const portfolioData = {
  products: [
    {
      id: 'crowncode-intelligence-suite',
      name: 'CrownCode Intelligence Suite',
      tagline: 'Federal-grade intelligence. Evidence-ready insight.',
      status: 'Stage 1 Beta',
      statusDetail: 'Stage 1 beta preparation with controlled testing underway',
      category: 'Intelligence',
      categoryLabel: 'Flagship Intelligence Platform',
      oneLiner:
        'A multimodal AI intelligence suite that documents, correlates, profiles, forecasts, and explains evidence-grade insights.',
      bullets: [
        'Multimodal intelligence extraction across text, image, audio, video, metadata',
        'Predictive behavioral modeling and psychological threat assessment',
        'Evidence-grade reporting with audit trails and chain-of-custody',
      ],
      whatItIs: [
        'CrownCode Intelligence Suite is a multimodal AI intelligence platform built for environments where decisions must be grounded in evidence, behavioral understanding, and accountability.',
        'It ingests and correlates text, images, audio, video, metadata, and environmental signals into structured intelligence that can be reviewed, audited, and defended.',
        'Every output is traceable, logged, and protected by strict chain-of-custody logic for investigative, legal, and intelligence-grade environments.',
      ],
      whoFor: [
        'Investigators and intelligence teams requiring evidence-grade outputs',
        'Security analysts responsible for proactive risk detection',
        'Organizations needing offline or air-gapped deployments',
      ],
      capabilities: [
        'Multimodal intelligence extraction (text, image, audio, video, metadata)',
        'Criminal behavioral profiling engines',
        'Predictive modeling of behavioral and threat trajectories',
        'Psychological and threat assessment frameworks',
        'AI-powered smart alerts for emerging risks',
        'Evidence-grade report generation (TXT, HTML, PDF)',
        'Chain-of-custody and audit trail enforcement',
        'Offline / air-gapped deployment capability',
        'Role-based access control and compartmentalization',
      ],
      not: [
        'Not speculative or dramatized intelligence',
        'Not a replacement for analyst judgment',
        'Not an automated law enforcement decision system',
      ],
      nextGate: 'Complete Stage 1 beta with validated evidence-ready reporting.',
      monetization: 'Enterprise licensing and secure deployments.',
      valuationCurrent: '$6,000,000 – $10,000,000',
      valuationProjected: '$22,000,000 – $38,000,000',
      completion: '~75%',
      timeToMarket: '3–6 months',
      projectedRevenue: {
        year1: '$1,200,000',
        year2: '$3,500,000',
        year3: '$7,500,000',
      },
      value: 'As-is: $6M–$10M',
      growthLabel: 'Projected: $22M–$38M',
      growth: [12, 28, 48, 65, 82],
      readiness: 75,
      metrics: [
        { label: 'Chain-of-custody', value: '100%', icon: 'lock' },
        { label: 'Signal scope', value: '5 modes', icon: 'eye' },
        { label: 'Alert latency', value: '<30s', icon: 'bolt' },
      ],
      keywords: ['intelligence', 'forensics', 'multimodal', 'audit', 'air-gapped'],
      priority: 5,
    },
    {
      id: 'crowncam',
      name: 'CrownCam',
      tagline: 'Rule Your View.',
      status: 'Beta',
      statusDetail: 'Functional beta with AI, interface, and resolution expansion in progress',
      category: 'Security',
      categoryLabel: 'Security & Situational Awareness',
      oneLiner:
        'A browser-based security camera platform that turns any device into an intelligent, real-time surveillance system.',
      bullets: [
        '100% browser-based camera deployment with QR or secure links',
        '4K+ resolution feeds and multi-monitor control-room layouts',
        'AI-powered motion detection with smart alerts',
      ],
      whatItIs: [
        'CrownCam is a browser-based security camera platform that transforms any device into an intelligent, real-time surveillance system without apps, proprietary hardware, or installation friction.',
        'It supports customizable dashboards, modern multi-monitor layouts, and ultra-high-resolution video feeds up to 4K and beyond.',
        'Smart alerts notify users when movement, behavioral anomalies, or environmental changes cross defined thresholds.',
      ],
      whoFor: [
        'Operators needing rapid, flexible surveillance deployments',
        'Security teams requiring multi-view monitoring environments',
        'Organizations wanting device-agnostic, encrypted camera access',
      ],
      capabilities: [
        '100% browser-based camera deployment',
        'Instant setup via QR codes or secure links',
        'End-to-end encrypted live video streams',
        '4K+ resolution video support',
        'Multi-monitor, control-room-ready layouts',
        'Customizable interfaces and dashboards',
        'AI-powered motion detection and anomaly recognition',
        'Smart alert system with configurable triggers',
        'Ultra-low latency real-time viewing',
      ],
      not: [
        'Not a hardware-locked surveillance system',
        'Not a stealth or covert tracking product',
        'Not a guarantee of long-term storage',
      ],
      nextGate: 'Finalize AI resolution upgrades and stabilize control-room workflows.',
      monetization: 'Subscription tiers for professional monitoring teams.',
      valuationCurrent: '$1,200,000 – $2,000,000',
      valuationProjected: '$5,000,000 – $8,000,000',
      completion: '~70%',
      timeToMarket: '2–4 months',
      projectedRevenue: {
        year1: '$650,000',
        year2: '$1,800,000',
        year3: '$3,600,000',
      },
      value: 'As-is: $1.2M–$2M',
      growthLabel: 'Projected: $5M–$8M',
      growth: [8, 20, 32, 46, 60],
      readiness: 70,
      metrics: [
        { label: 'Stream uptime', value: '99.1%', icon: 'shield' },
        { label: 'Avg latency', value: '120ms', icon: 'timer' },
        { label: 'Active cams', value: '240', icon: 'camera' },
      ],
      keywords: ['camera', 'security', '4k', 'alerts', 'surveillance'],
      priority: 4,
    },
    {
      id: 'crown-sos',
      name: 'Crown SOS',
      tagline: 'When chaos strikes, Crown SOS answers.',
      status: 'Beta',
      statusDetail: 'Prototype complete, beta testing active',
      category: 'Security',
      categoryLabel: 'Security & Emergency Response',
      oneLiner:
        'A real-time emergency response and proof-of-life platform with live location, audio, and evidence capture.',
      bullets: [
        'One-tap emergency activation with trusted contact routing',
        'Live location broadcasting with audio/video evidence capture',
        'Automated proof-of-life check-ins and session history',
      ],
      whatItIs: [
        'Crown SOS is a real-time emergency response and proof-of-life platform built for moments when silence becomes dangerous.',
        'With a single action, users can broadcast live location data, stream audio and video, capture visual evidence, and alert trusted contacts instantly.',
        'Automated check-ins provide ongoing confirmation of safety while session logs preserve critical context.',
      ],
      whoFor: [
        'Individuals or families needing rapid proof-of-life confirmation',
        'Field teams operating in high-risk environments',
        'Organizations focused on immediate situational clarity',
      ],
      capabilities: [
        'One-tap emergency activation',
        'Live location broadcasting',
        'Real-time audio and video streaming',
        'Evidence capture and logging',
        'Automated proof-of-life check-ins',
        'Trusted contact routing',
        'Privacy-first user controls',
      ],
      not: [
        'Not a replacement for emergency services',
        'Not a passive tracking tool for others',
        'Not a guarantee of response outcomes',
      ],
      nextGate: 'Validate beta response workflows and proof-of-life sequencing.',
      monetization: 'Consumer and enterprise safety subscriptions.',
      valuationCurrent: '$900,000 – $1,500,000',
      valuationProjected: '$3,000,000 – $5,000,000',
      completion: '~60%',
      timeToMarket: '4–6 months',
      projectedRevenue: {
        year1: '$400,000',
        year2: '$1,200,000',
        year3: '$2,800,000',
      },
      value: 'As-is: $900K–$1.5M',
      growthLabel: 'Projected: $3M–$5M',
      growth: [6, 16, 28, 40, 52],
      readiness: 60,
      metrics: [
        { label: 'Alert delivery', value: '97%', icon: 'alert' },
        { label: 'Avg response', value: '42s', icon: 'timer' },
        { label: 'Trusted nodes', value: '38', icon: 'network' },
      ],
      keywords: ['sos', 'emergency', 'proof-of-life', 'safety', 'alerts'],
      priority: 4,
    },
    {
      id: 'pic-detective',
      name: 'Pic Detective',
      tagline: 'Your photos have secrets. We decode them.',
      status: 'Beta',
      statusDetail: 'Core logic complete, reporting and interface polish underway',
      category: 'Forensics',
      categoryLabel: 'Forensic & Analytical Systems',
      oneLiner:
        'Transforms a single image into a structured intelligence artifact with forensic reporting.',
      bullets: [
        'Environmental inventory extraction and spatial mapping',
        'Behavioral indicator flagging with analyst overlays',
        'Structured forensic reporting with multi-format exports',
      ],
      whatItIs: [
        'Pic Detective transforms a single image into a structured intelligence artifact.',
        'It analyzes environments, objects, spatial relationships, and subtle behavioral indicators to generate detailed forensic-style reports.',
        'The focus is on what is present, what is implied, and what warrants attention—without speculation.',
      ],
      whoFor: [
        'Investigators and analysts requiring structured photo intelligence',
        'Security teams documenting evidence from static imagery',
        'Professionals needing exportable forensic reports',
      ],
      capabilities: [
        'Environmental inventory extraction',
        'Object and layout mapping',
        'Spatial reconstruction',
        'Behavioral indicator flagging',
        'OCR and text recognition',
        'Structured forensic reporting',
        'Multi-format exports',
        'Analyst review overlays',
      ],
      not: [
        'Not speculative storytelling',
        'Not facial recognition or identity matching',
        'Not a replacement for human review',
      ],
      nextGate: 'Finalize interface polish and reporting export workflows.',
      monetization: 'Per-report and professional licensing tiers.',
      valuationCurrent: '$1,800,000 – $3,000,000',
      valuationProjected: '$5,000,000 – $8,000,000',
      completion: '~80%',
      timeToMarket: '2–3 months',
      projectedRevenue: {
        year1: '$900,000',
        year2: '$2,400,000',
        year3: '$5,000,000',
      },
      value: 'As-is: $1.8M–$3M',
      growthLabel: 'Projected: $5M–$8M',
      growth: [10, 24, 42, 58, 72],
      readiness: 80,
      metrics: [
        { label: 'Report fidelity', value: '4.8/5', icon: 'eye' },
        { label: 'Export formats', value: '3', icon: 'book' },
        { label: 'Avg analysis', value: '40s', icon: 'timer' },
      ],
      keywords: ['forensics', 'image', 'reporting', 'analysis', 'evidence'],
      priority: 4,
    },
    {
      id: 'crown-watchtower',
      name: 'Crown WatchTower',
      tagline: 'Forensic-grade network visibility.',
      status: 'Prototype',
      statusDetail: 'Active development with functional analysis engines',
      category: 'Security',
      categoryLabel: 'Forensic & Analytical Systems',
      oneLiner:
        'Deep visibility into network traffic, wireless signals, and environmental indicators for real-time anomaly detection.',
      bullets: [
        'Network traffic inspection and wireless signal scanning',
        'Device fingerprinting and environment mapping',
        'Real-time anomaly detection with forensic logging',
      ],
      whatItIs: [
        'Crown WatchTower provides deep visibility into network traffic, wireless signals, and environmental indicators that conventional tools routinely overlook.',
        'It identifies anomalies, hidden behaviors, and risk surfaces in real time, bridging raw data and actionable understanding.',
      ],
      whoFor: [
        'Security teams needing real-time signal intelligence',
        'Operators responsible for network visibility',
        'Analysts mapping digital risk surfaces',
      ],
      capabilities: [
        'Network traffic inspection',
        'Wireless and signal scanning',
        'Device fingerprinting',
        'MAC and environment mapping',
        'Anomaly detection logic',
        'Threat surface visualization',
        'Forensic session logging',
        'Real-time monitoring',
      ],
      not: [
        'Not an offensive security toolkit',
        'Not a promise of full signal coverage',
        'Not designed for interception or exploitation',
      ],
      nextGate: 'Finalize initial prototype scope and monitoring dashboards.',
      monetization: 'Enterprise security licensing.',
      valuationCurrent: '$1,300,000 – $2,200,000',
      valuationProjected: '$4,000,000 – $6,000,000',
      completion: '~70%',
      timeToMarket: '3–5 months',
      projectedRevenue: {
        year1: '$500,000',
        year2: '$1,600,000',
        year3: '$3,800,000',
      },
      value: 'As-is: $1.3M–$2.2M',
      growthLabel: 'Projected: $4M–$6M',
      growth: [7, 18, 30, 42, 54],
      readiness: 70,
      metrics: [
        { label: 'Signal zones', value: '6', icon: 'network' },
        { label: 'Anomaly cues', value: '18', icon: 'alert' },
        { label: 'Scan latency', value: '2m', icon: 'timer' },
      ],
      keywords: ['network', 'signal', 'visibility', 'forensics', 'security'],
      priority: 3,
    },
    {
      id: 'lumilogix',
      name: 'LumiLogix',
      tagline: 'AI that feels.',
      status: 'Prototype',
      statusDetail: 'Core architecture finalized, modules in active development',
      category: 'Creative',
      categoryLabel: 'Creative, Communication & Behavioral Systems',
      oneLiner:
        'An emotionally intelligent marketing engine blending psychology, narrative structure, and data-driven insight.',
      bullets: [
        'Emotional intelligence modeling with archetype logic',
        'Narrative tone alignment across campaigns',
        'Ethical emotion safeguards with brand voice preservation',
      ],
      whatItIs: [
        'LumiLogix was created to solve a problem modern marketing refuses to admit: automation stripped emotion out of communication.',
        'It blends psychology, emotional intelligence modeling, narrative structure, and data-driven insight to ensure messaging feels intentional, human, and trustworthy.',
        'The system augments creativity without manipulation, helping brands scale communication without losing their voice.',
      ],
      whoFor: [
        'Brand teams seeking emotionally grounded messaging',
        'Marketing strategists needing narrative consistency',
        'Founders who want clarity without manipulation',
      ],
      capabilities: [
        'Emotional intelligence modeling',
        'Archetype-based messaging logic',
        'Narrative tone alignment',
        'Adaptive learning loops',
        'Sensory and emotionally grounded language generation',
        'Ethical emotion safeguards',
        'Multi-channel campaign output',
        'Brand voice preservation',
      ],
      not: [
        'Not a manipulative growth hack tool',
        'Not a replacement for brand strategy',
        'Not generic content automation',
      ],
      nextGate: 'Complete module integrations and validate ethical safeguards.',
      monetization: 'Subscription and enterprise marketing tiers.',
      valuationCurrent: '$2,500,000 – $4,000,000',
      valuationProjected: '$8,000,000 – $12,000,000',
      completion: '~65%',
      timeToMarket: '4–6 months',
      projectedRevenue: {
        year1: '$750,000',
        year2: '$2,200,000',
        year3: '$5,500,000',
      },
      value: 'As-is: $2.5M–$4M',
      growthLabel: 'Projected: $8M–$12M',
      growth: [9, 22, 40, 58, 74],
      readiness: 65,
      metrics: [
        { label: 'Archetypes', value: '12', icon: 'map' },
        { label: 'Voice fidelity', value: '96%', icon: 'check' },
        { label: 'Channel outputs', value: '8', icon: 'grid' },
      ],
      keywords: ['marketing', 'emotion', 'creative', 'psychology', 'ai'],
      priority: 3,
    },
    {
      id: 'crowncast',
      name: 'CrownCast',
      tagline: 'Not fate. Alignment.',
      status: 'Beta',
      statusDetail: 'Content engine complete, distribution and delivery finalization underway',
      category: 'Creative',
      categoryLabel: 'Creative, Communication & Behavioral Systems',
      oneLiner:
        'A daily generative insight engine grounded in psychology, emotional regulation, and agency.',
      bullets: [
        'Daily psychologically grounded insights with agency-first framing',
        'Emotion and decision-cycle modeling without superstition',
        'Mobile-first delivery with subscription-ready architecture',
      ],
      whatItIs: [
        'CrownCast is a daily generative insight engine designed to help people orient themselves in a world overloaded with noise.',
        'It avoids astrology or fate-based framing, instead using psychological cycles and emotional regulation patterns.',
        'Each entry encourages awareness and intentional action without making unverifiable claims.',
      ],
      whoFor: [
        'People seeking grounded daily insight without superstition',
        'Audiences who value agency and self-trust',
        'Subscribers wanting lightweight daily guidance',
      ],
      capabilities: [
        'Daily psychologically grounded insights',
        'Emotion and decision-cycle modeling',
        'Non-superstitious, agency-first framework',
        'Brand-voice consistency',
        'Subscription-ready architecture',
        'Mobile-first delivery',
      ],
      not: [
        'Not astrology or fate-based prediction',
        'Not therapy or mental health treatment',
        'Not superstition-driven forecasting',
      ],
      nextGate: 'Finalize distribution and delivery pipelines.',
      monetization: 'Subscription-based daily insight product.',
      valuationCurrent: '$600,000 – $1,000,000',
      valuationProjected: '$2,000,000 – $3,000,000',
      completion: '~85%',
      timeToMarket: '1–2 months',
      projectedRevenue: {
        year1: '$300,000',
        year2: '$900,000',
        year3: '$2,000,000',
      },
      value: 'As-is: $600K–$1M',
      growthLabel: 'Projected: $2M–$3M',
      growth: [5, 14, 26, 38, 50],
      readiness: 85,
      metrics: [
        { label: 'Daily prompts', value: '365', icon: 'calendar' },
        { label: 'Retention', value: '64%', icon: 'trend' },
        { label: 'Voice fidelity', value: '95%', icon: 'check' },
      ],
      keywords: ['daily', 'insight', 'psychology', 'agency', 'subscription'],
      priority: 3,
    },
    {
      id: 'presence-architect',
      name: 'Presence Architect',
      tagline: 'Signal, don’t announce.',
      status: 'Prototype',
      statusDetail: 'Prototype phase with framework and ruleset defined',
      category: 'Relationship',
      categoryLabel: 'Relationship & Cultural Products',
      oneLiner:
        'A strategic system for cultivating attraction, authority, and emotional gravity without chasing attention.',
      bullets: [
        'Social signaling frameworks with restraint and timing logic',
        'Emotional regulation and confidence projection models',
        'DM playbooks and platform-specific presence strategies',
      ],
      whatItIs: [
        'Presence Architect is a strategic system for cultivating attraction, authority, and emotional gravity without chasing attention or validation.',
        'It teaches users to project calm confidence through restraint, consistency, and emotional regulation rather than constant performance.',
        'Designed as a premium upsell within Game On, it converts visibility into leverage and attention into credibility.',
      ],
      whoFor: [
        'Creators seeking authority without noise',
        'Professionals who need composure-driven presence',
        'Game On audiences focused on confidence and restraint',
      ],
      capabilities: [
        'Social signaling frameworks',
        'Posting restraint and timing logic',
        'Emotional regulation and confidence projection models',
        'DM and interaction response playbooks',
        'Platform-specific presence strategies',
        'Consistency and tone enforcement',
        'Audit and refinement tools',
      ],
      not: [
        'Not an attention-chasing growth hack',
        'Not performative vulnerability training',
        'Not a guarantee of virality',
      ],
      nextGate: 'Move from prototype to pilot cohort validation.',
      monetization: 'Premium upsell within Game On ecosystem.',
      valuationCurrent: '$700,000 – $1,200,000',
      valuationProjected: '$3,000,000 – $5,000,000',
      completion: '~55%',
      timeToMarket: '4–6 months',
      projectedRevenue: {
        year1: '$250,000',
        year2: '$800,000',
        year3: '$1,800,000',
      },
      value: 'As-is: $700K–$1.2M',
      growthLabel: 'Projected: $3M–$5M',
      growth: [4, 12, 22, 34, 48],
      readiness: 55,
      metrics: [
        { label: 'Playbooks', value: '18', icon: 'guide' },
        { label: 'Signal lift', value: '+24%', icon: 'trend' },
        { label: 'Cohorts', value: '3', icon: 'users' },
      ],
      keywords: ['presence', 'relationship', 'confidence', 'signaling', 'game on'],
      priority: 2,
    },
    {
      id: 'ai-cherry-pie',
      name: 'AI Cherry Pie',
      tagline: 'Make AI writing sound human again.',
      status: 'Beta',
      statusDetail: 'Product-ready, packaging and distribution underway',
      category: 'Creative',
      categoryLabel: 'Creative, Communication & Behavioral Systems',
      oneLiner:
        'Analyzes rhythm, pacing, and emotional flow to remove AI residue while preserving the author’s voice.',
      bullets: [
        'AI writing fingerprint detection with cadence analysis',
        'Emotional flow restoration and human rhythm modeling',
        'Batch and single-text processing with publishing-ready outputs',
      ],
      whatItIs: [
        'AI Cherry Pie exists because people can feel artificial writing even when they can’t explain why.',
        'It analyzes rhythm, pacing, emotional flow, and structural fingerprints, then reconstructs writing to feel natural and believable.',
        'The system preserves the author’s voice while removing automation residue, restoring emotional realism and readability.',
      ],
      whoFor: [
        'Authors and creators who care about authenticity',
        'Marketing teams refining AI-assisted drafts',
        'Publishers needing human-sounding outputs at scale',
      ],
      capabilities: [
        'AI writing fingerprint detection',
        'Structural and cadence analysis',
        'Emotional flow restoration',
        'Human rhythm modeling',
        'Author voice preservation',
        'Batch and single-text processing',
        'Publishing-ready outputs',
        'CLI and GUI compatibility',
      ],
      not: [
        'Not a generic grammar checker',
        'Not a replacement for editorial judgment',
        'Not a tool to hide AI usage',
      ],
      nextGate: 'Finalize packaging, distribution, and launch channels.',
      monetization: 'Subscription and creator licensing tiers.',
      valuationCurrent: '$1,000,000 – $1,800,000',
      valuationProjected: '$4,000,000 – $6,000,000',
      completion: '~90%',
      timeToMarket: '1–2 months',
      projectedRevenue: {
        year1: '$1,100,000',
        year2: '$2,600,000',
        year3: '$4,200,000',
      },
      value: 'As-is: $1M–$1.8M',
      growthLabel: 'Projected: $4M–$6M',
      growth: [11, 24, 38, 52, 66],
      readiness: 90,
      metrics: [
        { label: 'Voice fidelity', value: '97%', icon: 'check' },
        { label: 'Processing', value: '1.2s', icon: 'timer' },
        { label: 'Output modes', value: '2', icon: 'grid' },
      ],
      keywords: ['writing', 'authenticity', 'cadence', 'ai', 'editing'],
      priority: 4,
    },
    {
      id: 'couples-connection-playground',
      name: 'Couples Connection Playground',
      tagline: 'Connection without pressure.',
      status: 'Concept',
      statusDetail: 'Concept finalized, content and interaction design in progress',
      category: 'Relationship',
      categoryLabel: 'Relationship & Cultural Products',
      oneLiner:
        'A playful, guided platform for couples to build connection without therapy language or pressure.',
      bullets: [
        'Interactive relationship games with emotional check-ins',
        'Guided conversation flows and conflict repair experiences',
        'Private shared couple spaces with mobile-first design',
      ],
      whatItIs: [
        'Couples Connection Playground was designed to help couples grow without turning their relationship into a problem to be fixed.',
        'It reframes communication and emotional growth as shared experiences—games, prompts, and guided interactions that feel safe, playful, and natural.',
        'Growth happens through participation rather than analysis, positioned as a paid upsell under the Game On brand.',
      ],
      whoFor: [
        'Couples seeking low-pressure connection tools',
        'Partners rebuilding communication habits',
        'Game On audiences wanting guided interaction experiences',
      ],
      capabilities: [
        'Interactive relationship games',
        'Emotional check-ins and prompts',
        'Conflict repair experiences',
        'Intimacy and bonding modes',
        'Guided conversation flows',
        'Private shared couple spaces',
        'Mobile-friendly interaction design',
        'Subscription monetization model',
      ],
      not: [
        'Not therapy or counseling',
        'Not a replacement for professional support',
        'Not confrontation-heavy exercises',
      ],
      nextGate: 'Finalize game loops and interaction design prototypes.',
      monetization: 'Paid upsell subscription within Game On.',
      valuationCurrent: '$500,000 – $900,000',
      valuationProjected: '$2,000,000 – $3,000,000',
      completion: '~50%',
      timeToMarket: '5–7 months',
      projectedRevenue: {
        year1: '$200,000',
        year2: '$750,000',
        year3: '$1,900,000',
      },
      value: 'As-is: $500K–$900K',
      growthLabel: 'Projected: $2M–$3M',
      growth: [3, 10, 20, 30, 44],
      readiness: 50,
      metrics: [
        { label: 'Session modes', value: '6', icon: 'heart' },
        { label: 'Exercises', value: '30', icon: 'spark' },
        { label: 'Completion', value: '74%', icon: 'check' },
      ],
      keywords: ['couples', 'relationship', 'connection', 'games', 'playground'],
      priority: 2,
    },
    {
      id: 'hotag',
      name: 'HoTag',
      tagline: 'Track the truth.',
      status: 'Concept',
      statusDetail: 'Early-stage concept with brand and device IP defined',
      category: 'Cultural',
      categoryLabel: 'Relationship & Cultural Products',
      oneLiner:
        'A culturally sharp consumer tech concept blending satire, behavioral insight, and tracking tech.',
      bullets: [
        'Location tracking product concept with branded device IP',
        'Companion mobile app framework and viral branding',
        'Merchandise and licensing extensions with cultural commentary',
      ],
      whatItIs: [
        'HoTag is a culturally sharp consumer tech concept that blends satire, behavioral insight, and modern tracking technology into a provocative product ecosystem.',
        'While playful on the surface, it explores transparency, trust, attachment, and accountability in modern relationships.',
        'It is designed to spark conversation while remaining scalable as a branded consumer product.',
      ],
      whoFor: [
        'Culture-forward consumers and brand collaborators',
        'Merchandise and licensing partners',
        'Teams exploring viral consumer tech narratives',
      ],
      capabilities: [
        'Location tracking product concept',
        'Branded consumer device IP',
        'Companion mobile app framework',
        'Viral and social-forward branding',
        'Merchandise and licensing extensions',
        'Cultural commentary positioning',
        'Scalable product ecosystem design',
      ],
      not: [
        'Not a shipping hardware product yet',
        'Not positioned as a safety tool',
        'Not intended for covert tracking',
      ],
      nextGate: 'Move from concept to prototype brand ecosystem.',
      monetization: 'Merchandise, licensing, and product ecosystem extensions.',
      valuationCurrent: '$250,000 – $500,000',
      valuationProjected: '$1,500,000 – $2,500,000',
      completion: '~40%',
      timeToMarket: '6–9 months',
      projectedRevenue: {
        year1: '$100,000',
        year2: '$400,000',
        year3: '$1,000,000',
      },
      value: 'As-is: $250K–$500K',
      growthLabel: 'Projected: $1.5M–$2.5M',
      growth: [2, 6, 12, 20, 30],
      readiness: 40,
      metrics: [
        { label: 'Brand drops', value: '12', icon: 'spark' },
        { label: 'Audience reach', value: '180k', icon: 'users' },
        { label: 'Launch kits', value: '3', icon: 'box' },
      ],
      keywords: ['satire', 'culture', 'tracking', 'brand', 'consumer'],
      priority: 1,
    },
  ],
  frameworks: [
    {
      name: 'Presence Architect',
      status: 'Prototype',
      description:
        'A strategic system for cultivating attraction, authority, and emotional gravity through restraint and consistency.',
      bullets: ['Social signaling frameworks', 'DM playbooks', 'Presence audits'],
    },
    {
      name: 'Emotional Intelligence Stack',
      status: 'Concept',
      description:
        'A behavioral framework integrating psychology, emotional regulation, and decision-cycle mapping across products.',
      bullets: ['Emotion modeling', 'Decision-cycle cues', 'Ethical influence guardrails'],
    },
  ],
  // Cover paths to drop in if needed:
  // assets/images/unshakeable-cover.png
  // assets/images/couples-connection-playground-cover.png
  books: [
    {
      name: 'Game On! Master the Conversation & Win Her Heart',
      status: 'Published',
      description: 'Published title anchored in Game On principles and conversational clarity.',
      cover: 'assets/images/game-on-main-cover.png',
      actionLabel: 'Buy book',
      actionHref: 'book.html',
    },
    {
      name: 'Unshakeable',
      status: 'In progress',
      description: 'In-progress manuscript focused on resilience and steadiness under pressure.',
      cover: '',
      actionLabel: 'Get updates',
      actionType: 'modal',
      actionTab: 'beta',
    },
  ],
  statuses: [
    {
      name: 'Concept',
      meaning: 'Defined asset with structure and intent, not yet built.',
      nextGate: 'Finalize scope, prototype requirements, and core validation plan.',
    },
    {
      name: 'Prototype',
      meaning: 'Functional build exists with scoped feature set.',
      nextGate: 'Validate with real-world users and harden the core workflows.',
    },
    {
      name: 'Beta',
      meaning: 'Product is usable by testers, not yet hardened for scale.',
      nextGate: 'Stabilize critical workflows and close priority feedback loops.',
    },
    {
      name: 'Stage 1 Beta',
      meaning: 'Structured beta preparation with controlled testing.',
      nextGate: 'Complete Stage 1 testing and confirm readiness criteria.',
    },
    {
      name: 'Live',
      meaning: 'Publicly available and maintained.',
      nextGate: 'Maintain reliability and scale responsibly.',
    },
  ],
}

const iconMap = {
  alert: 'warning-circle',
  audio: 'waveform',
  bolt: 'lightning',
  book: 'book',
  box: 'package',
  calendar: 'calendar',
  camera: 'camera',
  chat: 'chat-circle-text',
  check: 'check-circle',
  compass: 'compass',
  crown: 'crown-simple',
  eye: 'eye',
  filter: 'faders',
  framework: 'tree-structure',
  grid: 'squares-four',
  guide: 'map-trifold',
  heart: 'heart',
  lab: 'flask',
  lock: 'lock',
  map: 'map-trifold',
  network: 'network',
  shield: 'shield-check',
  signal: 'chart-line-up',
  spark: 'sparkle',
  status: 'activity',
  timer: 'timer',
  trend: 'trend-up',
  trendDown: 'trend-down',
  users: 'users',
}

const statusOrder = {
  Live: 5,
  'Stage 1 Beta': 4,
  Beta: 3,
  Prototype: 2,
  Concept: 1,
}

const categoryOptions = [
  'All',
  'Intelligence',
  'Security',
  'Forensics',
  'Creative',
  'Relationship',
  'Cultural',
  'Frameworks',
]
const statusOptions = ['All', 'Concept', 'Prototype', 'Beta', 'Stage 1 Beta', 'Live']

const dom = {
  productGrid: document.getElementById('product-grid'),
  statusFilter: document.getElementById('status-filter'),
  categoryFilter: document.getElementById('category-filter'),
  searchInput: document.getElementById('search-input'),
  sortFilter: document.getElementById('sort-filter'),
  statStrip: document.getElementById('stat-strip'),
  heroCard: document.getElementById('hero-card'),
  frameworkList: document.getElementById('framework-list'),
  booksGrid: document.getElementById('books-grid'),
  statusTable: document.getElementById('status-table'),
  modal: document.getElementById('beta-modal'),
  userAccessModal: document.getElementById('user-access-modal'),
  productModal: document.getElementById('product-modal'),
  productModalBody: document.getElementById('product-modal-body'),
  productModalTitle: document.getElementById('product-modal-title'),
  intakeForm: document.getElementById('intake-form'),
  formSuccess: document.getElementById('form-success'),
  formNote: document.getElementById('form-note'),
  accessForm: document.getElementById('access-form'),
  accessSuccess: document.getElementById('access-success'),
  accessNote: document.getElementById('access-note'),
  roleField: document.getElementById('role-field'),
  tabButtons: document.querySelectorAll('.tab-btn'),
  tabPanels: document.querySelectorAll('.tab-panel'),
  themeToggle: document.getElementById('theme-toggle'),
  megaMenu: document.getElementById('mega-menu'),
  megaToggles: document.querySelectorAll('[data-mega-toggle]'),
  filterToggle: document.getElementById('filter-toggle'),
  filterPanel: document.getElementById('filter-panel'),
  pagePreloader: document.getElementById('page-preloader'),
  signalChartTemplate: document.getElementById('signal-chart-template'),
  infographicBarsTemplate: document.getElementById('infographic-bars-template'),
}

const formatCount = (value, label, icon) => ({ value, label, icon })

const iconMarkup = (icon) => {
  const iconName = iconMap[icon]
  return iconName ? `<i class="ph ph-${iconName} icon-inline" aria-hidden="true"></i>` : ''
}

const getInitials = (name = '') =>
  name
    .split(' ')
    .map((word) => word[0])
    .join('')
    .slice(0, 3)
    .toUpperCase()

const animateCounts = (container = document) => {
  container.querySelectorAll('[data-count]').forEach((el) => {
    const target = Number(el.dataset.count)
    if (Number.isNaN(target)) {
      return
    }
    const suffix = el.dataset.suffix || ''
    const prefix = el.dataset.prefix || ''
    const duration = 1200
    let start = null

    const step = (timestamp) => {
      if (!start) start = timestamp
      const progress = Math.min((timestamp - start) / duration, 1)
      const value = Math.round(target * progress)
      el.textContent = `${prefix}${value}${suffix}`
      if (progress < 1) {
        requestAnimationFrame(step)
      } else {
        el.textContent = `${prefix}${target}${suffix}`
      }
    }

    requestAnimationFrame(step)
  })
}

const resetCounts = (container = document) => {
  container.querySelectorAll('[data-count]').forEach((el) => {
    const suffix = el.dataset.suffix || ''
    const prefix = el.dataset.prefix || ''
    el.textContent = `${prefix}0${suffix}`
  })
}

let revealObserver

const setupRevealAnimations = () => {
  const elements = document.querySelectorAll('.reveal')
  if (!elements.length) return
  if (!('IntersectionObserver' in window)) {
    elements.forEach((el) => el.classList.add('is-visible'))
    return
  }
  revealObserver = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add('is-visible')
          animateCounts(entry.target)
        } else {
          entry.target.classList.remove('is-visible')
          resetCounts(entry.target)
        }
      })
    },
    { threshold: 0.12 }
  )
  elements.forEach((el) => revealObserver.observe(el))
}

const registerRevealTargets = (root = document) => {
  if (!revealObserver) {
    setupRevealAnimations()
    return
  }
  root.querySelectorAll('.reveal').forEach((el) => {
    revealObserver.observe(el)
  })
}

const hidePagePreloader = () => {
  if (!dom.pagePreloader) return
  dom.pagePreloader.setAttribute('aria-hidden', 'true')
  dom.pagePreloader.classList.add('is-hidden')
  window.setTimeout(() => {
    dom.pagePreloader?.remove()
  }, 400)
}

const renderSignalChart = (values = []) => {
  const bars = values.length ? values : [18, 24, 30, 28, 36, 42, 38]
  const max = Math.max(...bars, 1)
  const min = Math.min(...bars)
  const avg = Math.round(bars.reduce((sum, val) => sum + val, 0) / bars.length)
  const gradientId = `signal-gradient-${Math.random().toString(36).slice(2, 8)}`
  const trendDelta = bars[bars.length - 1] - bars[0]
  const trendUp = trendDelta >= 0
  const trendLabel = trendUp ? 'Rising' : 'Cooling'
  const trendIcon = trendUp ? iconMarkup('trend') : iconMarkup('trendDown')
  const points = bars
    .map((val, index) => {
      const x = (index / (bars.length - 1)) * 100
      const y = 40 - (val / max) * 30 - 5
      return `${x.toFixed(2)},${y.toFixed(2)}`
    })
    .join(' ')
  const areaPoints = `0,40 ${points} 100,40`

  if (!dom.signalChartTemplate) {
    return ''
  }

  const chart = dom.signalChartTemplate.content.firstElementChild.cloneNode(true)
  const svg = chart.querySelector('.signal-chart__svg')
  const gradient = svg.querySelector('linearGradient')
  const area = chart.querySelector('.signal-area')
  const line = chart.querySelector('.signal-line')
  const pointsGroup = chart.querySelector('.signal-points')
  const trend = chart.querySelector('.signal-trend')
  const trendIconEl = chart.querySelector('.signal-trend-icon')
  const trendLabelEl = chart.querySelector('.signal-trend-label')
  const lowStat = chart.querySelector('.signal-stat--low strong')
  const avgStat = chart.querySelector('.signal-stat--avg strong')
  const highStat = chart.querySelector('.signal-stat--high strong')

  chart.setAttribute('aria-label', `Valuation signal trend with values ${bars.join(', ')}`)
  gradient.id = gradientId
  area.setAttribute('points', areaPoints)
  area.setAttribute('fill', `url(#${gradientId})`)
  line.setAttribute('points', points)
  pointsGroup.innerHTML = bars
    .map((val, index) => {
      const x = (index / (bars.length - 1)) * 100
      const y = 40 - (val / max) * 30 - 5
      return `<circle cx="${x.toFixed(2)}" cy="${y.toFixed(2)}" r="1.8" style="--point-index:${index};"></circle>`
    })
    .join('')

  trend.classList.toggle('signal-trend--up', trendUp)
  trend.classList.toggle('signal-trend--down', !trendUp)
  trendIconEl.innerHTML = trendIcon
  trendLabelEl.textContent = trendLabel
  lowStat.textContent = min
  avgStat.textContent = avg
  highStat.textContent = max

  return chart.outerHTML
}

const renderInfographicBars = (heights = [30, 48, 42, 66, 55, 70]) => {
  if (!dom.infographicBarsTemplate) {
    return ''
  }
  const container = dom.infographicBarsTemplate.content.firstElementChild.cloneNode(true)
  container.innerHTML = heights
    .map((height, index) => `<span style="height:${height}%; --bar-index:${index};"></span>`)
    .join('')
  return container.outerHTML
}

const renderHeroStats = () => {
  const total = portfolioData.products.length
  const beta = portfolioData.products.filter((item) =>
    ['Beta', 'Stage 1 Beta'].includes(item.status)
  ).length
  const concepts = portfolioData.products.filter((item) => item.status === 'Concept').length
  const heroProduct = portfolioData.products.find((item) => item.status === 'Stage 1 Beta')
  const stats = [
    formatCount(total, 'Total products', 'grid'),
    formatCount(beta, 'Active beta builds', 'bolt'),
    formatCount(concepts, 'Concepts in pipeline', 'spark'),
  ]

  dom.statStrip.innerHTML = stats
    .map(
      (stat) => `
        <div class="stat-card reveal">
          ${iconMarkup(stat.icon)}
          <div class="eyebrow">${stat.label}</div>
          <div class="stat-value" data-count="${stat.value}">0</div>
        </div>
      `
    )
    .join('')

  dom.heroCard.innerHTML = `
    <div class="hero-insight__header">
      <span class="eyebrow">Flagship intelligence</span>
      <span class="badge">Most ready</span>
    </div>
    <h3>${heroProduct?.name || 'CrownCode Intelligence Suite'}</h3>
    <p class="lede">The flagship system leading the portfolio’s readiness curve.</p>
    ${renderInfographicBars([28, 40, 55, 62, 48, 70])}
    <span class="infographic-caption">Readiness signal (portfolio-weighted)</span>
    <div class="hero-metrics">
      <span class="metric-chip">Stage: ${heroProduct?.status || 'Stage 1 Beta'}</span>
      <span class="metric-chip">Focus: ${heroProduct?.categoryLabel || 'Flagship Intelligence Platform'}</span>
      <span class="metric-chip">Next gate: ${heroProduct?.statusDetail || 'Stage 1 beta readiness'}</span>
    </div>
    <div class="hero-callout">
      <strong>Portfolio discipline</strong>
      <p>Every product lists the single milestone that advances its next phase.</p>
    </div>
  `
  dom.heroCard.classList.add('is-ready')
  dom.heroCard.closest('.hero-card')?.classList.add('hero-card--ready')

  animateCounts(dom.statStrip)
  registerRevealTargets(dom.statStrip)
}

const buildFilters = () => {
  dom.statusFilter.innerHTML = statusOptions
    .map((status) => `<option value="${status}">${status}</option>`)
    .join('')
  dom.categoryFilter.innerHTML = categoryOptions
    .map((cat) => `<option value="${cat}">${cat}</option>`)
    .join('')
}

const renderProducts = () => {
  const statusValue = dom.statusFilter.value
  const categoryValue = dom.categoryFilter.value
  const query = dom.searchInput.value.trim().toLowerCase()
  const sortValue = dom.sortFilter.value

  let filtered = [...portfolioData.products]

  if (statusValue !== 'All') {
    filtered = filtered.filter((item) => item.status === statusValue)
  }

  if (categoryValue !== 'All') {
    filtered = filtered.filter((item) => item.category === categoryValue)
  }

  if (query) {
    filtered = filtered.filter((item) => {
      const haystack = [
        item.name,
        item.tagline,
        item.oneLiner,
        item.categoryLabel,
        item.statusDetail,
        ...(item.keywords || []),
      ]
        .join(' ')
        .toLowerCase()
      return haystack.includes(query)
    })
  }

  if (sortValue === 'ready') {
    filtered.sort(
      (a, b) => statusOrder[b.status] - statusOrder[a.status] || b.priority - a.priority
    )
  } else if (sortValue === 'strategic') {
    filtered.sort(
      (a, b) => b.priority - a.priority || statusOrder[b.status] - statusOrder[a.status]
    )
  } else {
    filtered.sort((a, b) => a.name.localeCompare(b.name))
  }

  dom.productGrid.innerHTML = filtered
    .map((product) => {
      const metrics = (product.metrics || [])
        .map(
          (metric) => `
            <div class="metric">
              ${iconMarkup(metric.icon)}
              <div>
                <div class="metric-value">${metric.value}</div>
                <div class="metric-label">${metric.label}</div>
              </div>
            </div>
          `
        )
        .join('')
      const initials = getInitials(product.name)
      const mediaSrc = product.media || `assets/brand/products/${product.id}-hero.png`
      const categoryPills = Array.from(
        new Set([product.categoryLabel, product.category].filter(Boolean))
      )
      const readinessMarkup =
        typeof product.readiness === 'number'
          ? `
          <div class="readiness">
            <div class="readiness-header">
              <span>Readiness score</span>
              <strong class="count-up" data-count="${product.readiness}" data-suffix="%">0%</strong>
            </div>
            <div class="readiness-bar" role="progressbar" aria-valuenow="${product.readiness}" aria-valuemin="0" aria-valuemax="100">
              <span style="width:${product.readiness}%"></span>
            </div>
          </div>
        `
          : ''

      return `
        <article class="product-card reveal" data-status="${product.status}" data-category="${product.category}" data-product-id="${product.id}">
          <div class="product-header">
            <div class="product-icon" data-fallback="${product.name}">
              <img src="assets/brand/products/${product.id}.png" alt="${product.name} icon" loading="lazy">
              <span>${product.name
                .split(' ')
                .map((word) => word[0])
                .join('')
                .slice(0, 3)}</span>
            </div>
            <div>
              <h3>${product.name}</h3>
              <div class="product-tags">
                <span class="tag status-badge" data-status="${product.status}">${product.status}</span>
                ${categoryPills.map((pill) => `<span class="tag">${pill}</span>`).join('')}
              </div>
            </div>
          </div>
          <div class="card-media" data-fallback="${initials}">
            <img src="${mediaSrc}" alt="${product.name} preview" loading="lazy">
            <div class="media-placeholder">${initials}</div>
          </div>
          <p class="one-liner">${product.oneLiner}</p>
          <div class="signal-panel">
            <div class="signal-label">
              <span>Valuation signal</span>
              ${iconMarkup('signal')}
            </div>
            <div class="signal-meta">
              <strong>${product.value}</strong>
              <small>${product.growthLabel}</small>
            </div>
            ${renderSignalChart(product.growth || [])}
          </div>
          <div class="product-metrics">
            ${metrics}
          </div>
          ${readinessMarkup}
          <ul>
            ${product.bullets.map((item) => `<li>${item}</li>`).join('')}
          </ul>
          <div class="product-footer">
            <span class="muted">Next gate: ${product.nextGate}</span>
            <button class="ghost-btn ghost-btn--small" type="button" data-open-product="${product.id}">View brief</button>
          </div>
        </article>
      `
    })
    .join('')

  if (!filtered.length) {
    dom.productGrid.innerHTML = '<p>No products match the current filters.</p>'
  }

  animateCounts(dom.productGrid)
  registerRevealTargets(dom.productGrid)

  document.querySelectorAll('.product-icon img').forEach((img) => {
    img.addEventListener('error', () => {
      const parent = img.closest('.product-icon')
      parent.classList.add('is-fallback')
    })
  })

  document.querySelectorAll('.card-media img').forEach((img) => {
    img.addEventListener('error', () => {
      const parent = img.closest('.card-media')
      if (parent) {
        parent.classList.add('is-fallback')
      }
    })
  })

  document.querySelectorAll('.product-card').forEach((card) => {
    card.addEventListener('click', (event) => {
      const target = event.target
      if (target.closest('[data-open-product]')) {
        return
      }
      const productId = card.dataset.productId
      if (productId) {
        openProductModal(productId)
      }
    })
  })

  document.querySelectorAll('[data-open-product]').forEach((button) => {
    button.addEventListener('click', (event) => {
      event.stopPropagation()
      const productId = button.dataset.openProduct
      if (productId) {
        openProductModal(productId)
      }
    })
  })
}

const renderFrameworks = () => {
  dom.frameworkList.innerHTML = portfolioData.frameworks
    .map(
      (framework) => `
      <div class="framework-card reveal">
        <div class="card-header">
          ${iconMarkup('framework')}
          <div class="product-tags">
            <span class="tag status-badge" data-status="${framework.status}">${framework.status}</span>
          </div>
        </div>
        <h3>${framework.name}</h3>
        <p>${framework.description}</p>
        <ul>
          ${framework.bullets.map((item) => `<li>${item}</li>`).join('')}
        </ul>
      </div>
    `
    )
    .join('')

  registerRevealTargets(dom.frameworkList)
}

const renderBooks = () => {
  dom.booksGrid.innerHTML = portfolioData.books
    .map((book) => {
      const initials = getInitials(book.name)
      const coverMarkup = `
          ${book.cover ? `<img src="${book.cover}" alt="${book.name} cover" loading="lazy">` : ''}
          <div class="cover-placeholder"><strong>${initials}</strong><small>Cover pending</small></div>
        `
      const actionMarkup = book.actionLabel
        ? book.actionType === 'modal'
          ? `<button class="ghost-btn ghost-btn--small" type="button" data-open-modal data-modal-tab="${book.actionTab || 'beta'}" data-interest="${book.name}">${book.actionLabel}</button>`
          : `<a class="ghost-btn ghost-btn--small" href="${book.actionHref || '#'}">${book.actionLabel}</a>`
        : ''
      return `
      <div class="book-card reveal">
        <div class="book-cover ${book.cover ? 'has-cover' : 'is-fallback'}">
          ${coverMarkup}
        </div>
        <div class="book-meta">
          <div class="card-header">
            ${iconMarkup('book')}
            <div class="product-tags">
              <span class="tag status-badge" data-status="${book.status}">${book.status}</span>
            </div>
          </div>
          <h3>${book.name}</h3>
          <p>${book.description}</p>
          <div class="book-actions">${actionMarkup}</div>
        </div>
      </div>
    `
    })
    .join('')

  registerRevealTargets(dom.booksGrid)

  document.querySelectorAll('.book-cover img').forEach((img) => {
    img.addEventListener('error', () => {
      const parent = img.closest('.book-cover')
      if (parent) {
        parent.classList.remove('has-cover')
        parent.classList.add('is-fallback')
      }
    })
  })
}

const renderStatusTable = () => {
  dom.statusTable.innerHTML = portfolioData.statuses
    .map(
      (status) => `
        <tr>
          <th scope="row"><span class="status-badge status-badge--table" data-status="${status.name}">${status.name}</span></th>
          <td>${status.meaning}</td>
          <td>${status.nextGate}</td>
        </tr>
      `
    )
    .join('')
}

const tabLabels = {
  beta: 'Beta Tester',
  developer: 'Developer',
  partner: 'Partner / Investor',
}

const setActiveTab = (tabId = 'beta') => {
  dom.tabButtons.forEach((button) => {
    const isActive = button.dataset.tab === tabId
    button.classList.toggle('is-active', isActive)
    button.setAttribute('aria-selected', String(isActive))
  })
  dom.tabPanels.forEach((panel) => {
    panel.classList.toggle('is-active', panel.id === `tab-${tabId}`)
  })
  if (dom.roleField) {
    dom.roleField.value = tabLabels[tabId] || 'Beta Tester'
  }
}

const resetIntakeForm = () => {
  dom.intakeForm.reset()
  dom.intakeForm.hidden = false
  dom.formSuccess.hidden = true
  dom.formNote.textContent = ''
  setActiveTab('beta')
}

const resetAccessForm = () => {
  if (!dom.accessForm) return
  dom.accessForm.reset()
  dom.accessForm.hidden = false
  if (dom.accessSuccess) {
    dom.accessSuccess.hidden = true
  }
  if (dom.accessNote) {
    dom.accessNote.textContent = ''
  }
}

const openModal = (modal) => {
  if (!modal) return
  modal.classList.add('is-open')
  modal.setAttribute('aria-hidden', 'false')
  const firstInput = modal.querySelector('input, select, textarea, button')
  if (firstInput) {
    firstInput.focus()
  }
}

const closeModal = (modal) => {
  if (!modal) return
  modal.classList.remove('is-open')
  modal.setAttribute('aria-hidden', 'true')
  if (modal === dom.modal) {
    resetIntakeForm()
  }
  if (modal === dom.userAccessModal) {
    resetAccessForm()
  }
}

const openBetaModal = (tabId = 'beta', interest = '') => {
  resetIntakeForm()
  setActiveTab(tabId)
  if (interest) {
    const interestInputs = dom.intakeForm.querySelectorAll('input[name="interests"]')
    interestInputs.forEach((input) => {
      if (input.value.toLowerCase() === interest.toLowerCase()) {
        input.checked = true
      }
    })
  }
  openModal(dom.modal)
}

const renderProductModal = (product) => {
  const readinessMarkup =
    typeof product.readiness === 'number'
      ? `
        <div class="readiness">
          <div class="readiness-header">
            <span>Readiness score</span>
            <strong class="count-up" data-count="${product.readiness}" data-suffix="%">0%</strong>
          </div>
          <div class="readiness-bar" role="progressbar" aria-valuenow="${product.readiness}" aria-valuemin="0" aria-valuemax="100">
            <span style="width:${product.readiness}%"></span>
          </div>
        </div>
      `
      : ''

  return `
    <div class="product-modal__grid">
      <div class="product-modal__summary">
        <div class="product-tags">
          <span class="tag status-badge" data-status="${product.status}">${product.status}</span>
          <span class="tag">${product.categoryLabel}</span>
        </div>
        <p>${product.tagline}</p>
        <div class="signal-panel">
          <div class="signal-label">
            <span>Valuation signal</span>
            ${iconMarkup('signal')}
          </div>
          <div class="signal-meta">
            <strong>${product.value}</strong>
            <small>${product.growthLabel}</small>
          </div>
          ${renderSignalChart(product.growth || [])}
        </div>
        ${readinessMarkup}
      </div>
      <div class="detail-grid">
        <div>
          <h4>What it is</h4>
          ${product.whatItIs.map((paragraph) => `<p>${paragraph}</p>`).join('')}
        </div>
        <div>
          <h4>Who it’s for</h4>
          <ul>
            ${product.whoFor.map((item) => `<li>${item}</li>`).join('')}
          </ul>
        </div>
        <div>
          <h4>Core capabilities</h4>
          <ul>
            ${product.capabilities.map((item) => `<li>${item}</li>`).join('')}
          </ul>
        </div>
        <div class="detail-box">
          <h4>What it is NOT</h4>
          <ul>
            ${product.not.map((item) => `<li>${item}</li>`).join('')}
          </ul>
        </div>
        <div class="detail-box">
          <h4>Current status</h4>
          <p><strong>${product.status}</strong> — ${product.statusDetail}</p>
          <p><strong>Next gate:</strong> ${product.nextGate}</p>
          <p><strong>Monetization:</strong> ${product.monetization}</p>
          <p><strong>As-is valuation:</strong> ${product.valuationCurrent}</p>
          <p><strong>Projected valuation:</strong> ${product.valuationProjected}</p>
          <p><strong>Completion:</strong> ${product.completion}</p>
          <p><strong>Time to market:</strong> ${product.timeToMarket}</p>
          <p><strong>Projected annual revenue:</strong> ${product.projectedRevenue.year1} · ${product.projectedRevenue.year2} · ${product.projectedRevenue.year3}</p>
        </div>
      </div>
    </div>
  `
}

const openProductModal = (productId) => {
  const product = portfolioData.products.find((item) => item.id === productId)
  if (!product || !dom.productModal) return
  dom.productModalTitle.textContent = product.name
  dom.productModalBody.innerHTML = renderProductModal(product)
  animateCounts(dom.productModalBody)
  openModal(dom.productModal)
}

const attachFilters = () => {
  ;[dom.statusFilter, dom.categoryFilter, dom.searchInput, dom.sortFilter].forEach((el) => {
    el.addEventListener('input', renderProducts)
  })
}

const setupModal = () => {
  document.querySelectorAll('[data-open-modal]').forEach((button) => {
    button.addEventListener('click', () => {
      openBetaModal(button.dataset.modalTab || 'beta', button.dataset.interest || '')
    })
  })

  document.querySelectorAll('[data-open-user-access]').forEach((button) => {
    button.addEventListener('click', () => {
      resetAccessForm()
      openModal(dom.userAccessModal)
    })
  })

  document.querySelectorAll('[data-close-modal]').forEach((button) => {
    button.addEventListener('click', () => {
      const modal = button.closest('.modal')
      closeModal(modal)
    })
  })

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
      const openModalEl = document.querySelector('.modal.is-open')
      if (openModalEl) {
        closeModal(openModalEl)
      }
    }
  })

  dom.tabButtons.forEach((button) => {
    button.addEventListener('click', () => {
      setActiveTab(button.dataset.tab)
    })
  })

  dom.intakeForm.addEventListener('submit', (event) => {
    event.preventDefault()
    if (!dom.intakeForm.checkValidity()) {
      dom.formNote.textContent = 'Please complete all required fields with a valid email.'
      dom.intakeForm.reportValidity()
      return
    }
    dom.intakeForm.hidden = true
    dom.formSuccess.hidden = false
  })

  if (dom.accessForm) {
    dom.accessForm.addEventListener('submit', (event) => {
      event.preventDefault()
      if (!dom.accessForm.checkValidity()) {
        if (dom.accessNote) {
          dom.accessNote.textContent = 'Please complete all required fields with a valid email.'
        }
        dom.accessForm.reportValidity()
        return
      }
      dom.accessForm.hidden = true
      if (dom.accessSuccess) {
        dom.accessSuccess.hidden = false
      }
    })
  }

  setActiveTab('beta')
}

const setupThemeToggle = () => {
  const stored = localStorage.getItem('labs-theme')
  if (stored === 'light') {
    document.body.classList.add('theme-light')
    dom.themeToggle.setAttribute('aria-pressed', 'true')
  }

  dom.themeToggle.addEventListener('click', () => {
    const isLight = document.body.classList.toggle('theme-light')
    dom.themeToggle.setAttribute('aria-pressed', String(isLight))
    localStorage.setItem('labs-theme', isLight ? 'light' : 'dark')
  })
}

const setupNav = () => {
  if (!dom.megaMenu || dom.megaToggles.length === 0) return
  const toggleMenu = () => {
    const isOpen = dom.megaMenu.classList.toggle('is-open')
    dom.megaToggles.forEach((toggle) => toggle.setAttribute('aria-expanded', String(isOpen)))
  }

  dom.megaToggles.forEach((toggle) => {
    toggle.addEventListener('click', (event) => {
      event.stopPropagation()
      toggleMenu()
    })
  })

  document.addEventListener('click', (event) => {
    if (!dom.megaMenu.classList.contains('is-open')) return
    if (dom.megaMenu.contains(event.target)) return
    dom.megaMenu.classList.remove('is-open')
    dom.megaToggles.forEach((toggle) => toggle.setAttribute('aria-expanded', 'false'))
  })
}

const setupFiltersToggle = () => {
  if (!dom.filterToggle) return
  dom.filterToggle.addEventListener('click', () => {
    const isOpen = dom.filterPanel.classList.toggle('is-open')
    dom.filterToggle.setAttribute('aria-expanded', String(isOpen))
  })
}

document.addEventListener('DOMContentLoaded', () => {
  buildFilters()
  renderHeroStats()
  renderProducts()
  renderFrameworks()
  renderBooks()
  renderStatusTable()
  attachFilters()
  setupModal()
  setupThemeToggle()
  setupNav()
  setupFiltersToggle()
  setupRevealAnimations()
  hidePagePreloader()
})
