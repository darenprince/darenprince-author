;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i)
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === 'childList')
        for (const c of o.addedNodes) c.tagName === 'LINK' && c.rel === 'modulepreload' && r(c)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(i) {
    const o = {}
    return (
      i.integrity && (o.integrity = i.integrity),
      i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === 'use-credentials'
        ? (o.credentials = 'include')
        : i.crossOrigin === 'anonymous'
          ? (o.credentials = 'omit')
          : (o.credentials = 'same-origin'),
      o
    )
  }
  function r(i) {
    if (i.ep) return
    i.ep = !0
    const o = n(i)
    fetch(i.href, o)
  }
})()
;(function () {
  const e = document.createElement('link').relList
  if (e && e.supports && e.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r)
  new MutationObserver((r) => {
    for (const i of r)
      if (i.type === 'childList')
        for (const o of i.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && n(o)
  }).observe(document, { childList: !0, subtree: !0 })
  function t(r) {
    const i = {}
    return (
      r.integrity && (i.integrity = r.integrity),
      r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : r.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    )
  }
  function n(r) {
    if (r.ep) return
    r.ep = !0
    const i = t(r)
    fetch(r.href, i)
  }
})()
var jb = Object.defineProperty,
  Vb = (e, t, n) =>
    t in e ? jb(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n),
  ye = (e, t, n) => Vb(e, typeof t != 'symbol' ? t + '' : t, n)
function Zy(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n]
    if (typeof r != 'string' && !Array.isArray(r)) {
      for (const i in r)
        if (i !== 'default' && !(i in e)) {
          const o = Object.getOwnPropertyDescriptor(r, i)
          o && Object.defineProperty(e, i, o.get ? o : { enumerable: !0, get: () => r[i] })
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }))
}
;(function () {
  const e = document.createElement('link').relList
  if (e && e.supports && e.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r)
  new MutationObserver((r) => {
    for (const i of r)
      if (i.type === 'childList')
        for (const o of i.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && n(o)
  }).observe(document, { childList: !0, subtree: !0 })
  function t(r) {
    const i = {}
    return (
      r.integrity && (i.integrity = r.integrity),
      r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : r.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    )
  }
  function n(r) {
    if (r.ep) return
    r.ep = !0
    const i = t(r)
    fetch(r.href, i)
  }
})()
var ha =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
      ? window
      : typeof global < 'u'
        ? global
        : typeof self < 'u'
          ? self
          : {}
function Ky(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e
}
var qy = { exports: {} },
  Zu = {},
  Qy = { exports: {} },
  Ne = {}
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Rl = Symbol.for('react.element'),
  Ub = Symbol.for('react.portal'),
  Wb = Symbol.for('react.fragment'),
  zb = Symbol.for('react.strict_mode'),
  Hb = Symbol.for('react.profiler'),
  Xb = Symbol.for('react.provider'),
  Gb = Symbol.for('react.context'),
  Yb = Symbol.for('react.forward_ref'),
  Zb = Symbol.for('react.suspense'),
  Kb = Symbol.for('react.memo'),
  qb = Symbol.for('react.lazy'),
  Fp = Symbol.iterator
function Qb(e) {
  return e === null || typeof e != 'object'
    ? null
    : ((e = (Fp && e[Fp]) || e['@@iterator']), typeof e == 'function' ? e : null)
}
var $y = {
    isMounted: function () {
      return !1
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  Jy = Object.assign,
  e8 = {}
function Ho(e, t, n) {
  ;((this.props = e), (this.context = t), (this.refs = e8), (this.updater = n || $y))
}
Ho.prototype.isReactComponent = {}
Ho.prototype.setState = function (e, t) {
  if (typeof e != 'object' && typeof e != 'function' && e != null)
    throw Error(
      'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
    )
  this.updater.enqueueSetState(this, e, t, 'setState')
}
Ho.prototype.forceUpdate = function (e) {
  this.updater.enqueueForceUpdate(this, e, 'forceUpdate')
}
function t8() {}
t8.prototype = Ho.prototype
function Cf(e, t, n) {
  ;((this.props = e), (this.context = t), (this.refs = e8), (this.updater = n || $y))
}
var Sf = (Cf.prototype = new t8())
Sf.constructor = Cf
Jy(Sf, Ho.prototype)
Sf.isPureReactComponent = !0
var jp = Array.isArray,
  n8 = Object.prototype.hasOwnProperty,
  Af = { current: null },
  r8 = { key: !0, ref: !0, __self: !0, __source: !0 }
function i8(e, t, n) {
  var r,
    i = {},
    o = null,
    c = null
  if (t != null)
    for (r in (t.ref !== void 0 && (c = t.ref), t.key !== void 0 && (o = '' + t.key), t))
      n8.call(t, r) && !r8.hasOwnProperty(r) && (i[r] = t[r])
  var h = arguments.length - 2
  if (h === 1) i.children = n
  else if (1 < h) {
    for (var f = Array(h), p = 0; p < h; p++) f[p] = arguments[p + 2]
    i.children = f
  }
  if (e && e.defaultProps) for (r in ((h = e.defaultProps), h)) i[r] === void 0 && (i[r] = h[r])
  return { $$typeof: Rl, type: e, key: o, ref: c, props: i, _owner: Af.current }
}
function $b(e, t) {
  return { $$typeof: Rl, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner }
}
function kf(e) {
  return typeof e == 'object' && e !== null && e.$$typeof === Rl
}
function Jb(e) {
  var t = { '=': '=0', ':': '=2' }
  return (
    '$' +
    e.replace(/[=:]/g, function (n) {
      return t[n]
    })
  )
}
var Vp = /\/+/g
function Yh(e, t) {
  return typeof e == 'object' && e !== null && e.key != null ? Jb('' + e.key) : t.toString(36)
}
function Oc(e, t, n, r, i) {
  var o = typeof e
  ;(o === 'undefined' || o === 'boolean') && (e = null)
  var c = !1
  if (e === null) c = !0
  else
    switch (o) {
      case 'string':
      case 'number':
        c = !0
        break
      case 'object':
        switch (e.$$typeof) {
          case Rl:
          case Ub:
            c = !0
        }
    }
  if (c)
    return (
      (c = e),
      (i = i(c)),
      (e = r === '' ? '.' + Yh(c, 0) : r),
      jp(i)
        ? ((n = ''),
          e != null && (n = e.replace(Vp, '$&/') + '/'),
          Oc(i, t, n, '', function (p) {
            return p
          }))
        : i != null &&
          (kf(i) &&
            (i = $b(
              i,
              n +
                (!i.key || (c && c.key === i.key) ? '' : ('' + i.key).replace(Vp, '$&/') + '/') +
                e
            )),
          t.push(i)),
      1
    )
  if (((c = 0), (r = r === '' ? '.' : r + ':'), jp(e)))
    for (var h = 0; h < e.length; h++) {
      o = e[h]
      var f = r + Yh(o, h)
      c += Oc(o, t, n, f, i)
    }
  else if (((f = Qb(e)), typeof f == 'function'))
    for (e = f.call(e), h = 0; !(o = e.next()).done; )
      ((o = o.value), (f = r + Yh(o, h++)), (c += Oc(o, t, n, f, i)))
  else if (o === 'object')
    throw (
      (t = String(e)),
      Error(
        'Objects are not valid as a React child (found: ' +
          (t === '[object Object]' ? 'object with keys {' + Object.keys(e).join(', ') + '}' : t) +
          '). If you meant to render a collection of children, use an array instead.'
      )
    )
  return c
}
function nc(e, t, n) {
  if (e == null) return e
  var r = [],
    i = 0
  return (
    Oc(e, r, '', '', function (o) {
      return t.call(n, o, i++)
    }),
    r
  )
}
function ev(e) {
  if (e._status === -1) {
    var t = e._result
    ;((t = t()),
      t.then(
        function (n) {
          ;(e._status === 0 || e._status === -1) && ((e._status = 1), (e._result = n))
        },
        function (n) {
          ;(e._status === 0 || e._status === -1) && ((e._status = 2), (e._result = n))
        }
      ),
      e._status === -1 && ((e._status = 0), (e._result = t)))
  }
  if (e._status === 1) return e._result.default
  throw e._result
}
var an = { current: null },
  Bc = { transition: null },
  tv = { ReactCurrentDispatcher: an, ReactCurrentBatchConfig: Bc, ReactCurrentOwner: Af }
function s8() {
  throw Error('act(...) is not supported in production builds of React.')
}
Ne.Children = {
  map: nc,
  forEach: function (e, t, n) {
    nc(
      e,
      function () {
        t.apply(this, arguments)
      },
      n
    )
  },
  count: function (e) {
    var t = 0
    return (
      nc(e, function () {
        t++
      }),
      t
    )
  },
  toArray: function (e) {
    return (
      nc(e, function (t) {
        return t
      }) || []
    )
  },
  only: function (e) {
    if (!kf(e)) throw Error('React.Children.only expected to receive a single React element child.')
    return e
  },
}
Ne.Component = Ho
Ne.Fragment = Wb
Ne.Profiler = Hb
Ne.PureComponent = Cf
Ne.StrictMode = zb
Ne.Suspense = Zb
Ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tv
Ne.act = s8
Ne.cloneElement = function (e, t, n) {
  if (e == null)
    throw Error(
      'React.cloneElement(...): The argument must be a React element, but you passed ' + e + '.'
    )
  var r = Jy({}, e.props),
    i = e.key,
    o = e.ref,
    c = e._owner
  if (t != null) {
    if (
      (t.ref !== void 0 && ((o = t.ref), (c = Af.current)),
      t.key !== void 0 && (i = '' + t.key),
      e.type && e.type.defaultProps)
    )
      var h = e.type.defaultProps
    for (f in t)
      n8.call(t, f) &&
        !r8.hasOwnProperty(f) &&
        (r[f] = t[f] === void 0 && h !== void 0 ? h[f] : t[f])
  }
  var f = arguments.length - 2
  if (f === 1) r.children = n
  else if (1 < f) {
    h = Array(f)
    for (var p = 0; p < f; p++) h[p] = arguments[p + 2]
    r.children = h
  }
  return { $$typeof: Rl, type: e.type, key: i, ref: o, props: r, _owner: c }
}
Ne.createContext = function (e) {
  return (
    (e = {
      $$typeof: Gb,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (e.Provider = { $$typeof: Xb, _context: e }),
    (e.Consumer = e)
  )
}
Ne.createElement = i8
Ne.createFactory = function (e) {
  var t = i8.bind(null, e)
  return ((t.type = e), t)
}
Ne.createRef = function () {
  return { current: null }
}
Ne.forwardRef = function (e) {
  return { $$typeof: Yb, render: e }
}
Ne.isValidElement = kf
Ne.lazy = function (e) {
  return { $$typeof: qb, _payload: { _status: -1, _result: e }, _init: ev }
}
Ne.memo = function (e, t) {
  return { $$typeof: Kb, type: e, compare: t === void 0 ? null : t }
}
Ne.startTransition = function (e) {
  var t = Bc.transition
  Bc.transition = {}
  try {
    e()
  } finally {
    Bc.transition = t
  }
}
Ne.unstable_act = s8
Ne.useCallback = function (e, t) {
  return an.current.useCallback(e, t)
}
Ne.useContext = function (e) {
  return an.current.useContext(e)
}
Ne.useDebugValue = function () {}
Ne.useDeferredValue = function (e) {
  return an.current.useDeferredValue(e)
}
Ne.useEffect = function (e, t) {
  return an.current.useEffect(e, t)
}
Ne.useId = function () {
  return an.current.useId()
}
Ne.useImperativeHandle = function (e, t, n) {
  return an.current.useImperativeHandle(e, t, n)
}
Ne.useInsertionEffect = function (e, t) {
  return an.current.useInsertionEffect(e, t)
}
Ne.useLayoutEffect = function (e, t) {
  return an.current.useLayoutEffect(e, t)
}
Ne.useMemo = function (e, t) {
  return an.current.useMemo(e, t)
}
Ne.useReducer = function (e, t, n) {
  return an.current.useReducer(e, t, n)
}
Ne.useRef = function (e) {
  return an.current.useRef(e)
}
Ne.useState = function (e) {
  return an.current.useState(e)
}
Ne.useSyncExternalStore = function (e, t, n) {
  return an.current.useSyncExternalStore(e, t, n)
}
Ne.useTransition = function () {
  return an.current.useTransition()
}
Ne.version = '18.3.1'
Qy.exports = Ne
var X = Qy.exports
const A = Ky(X),
  nv = Zy({ __proto__: null, default: A }, [X])
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var rv = X,
  iv = Symbol.for('react.element'),
  sv = Symbol.for('react.fragment'),
  ov = Object.prototype.hasOwnProperty,
  av = rv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  lv = { key: !0, ref: !0, __self: !0, __source: !0 }
function o8(e, t, n) {
  var r,
    i = {},
    o = null,
    c = null
  ;(n !== void 0 && (o = '' + n),
    t.key !== void 0 && (o = '' + t.key),
    t.ref !== void 0 && (c = t.ref))
  for (r in t) ov.call(t, r) && !lv.hasOwnProperty(r) && (i[r] = t[r])
  if (e && e.defaultProps) for (r in ((t = e.defaultProps), t)) i[r] === void 0 && (i[r] = t[r])
  return { $$typeof: iv, type: e, key: o, ref: c, props: i, _owner: av.current }
}
Zu.Fragment = sv
Zu.jsx = o8
Zu.jsxs = o8
qy.exports = Zu
var N = qy.exports,
  a8 = { exports: {} },
  Fn = {},
  l8 = { exports: {} },
  c8 = {}
;(function (e) {
  function t(se, fe) {
    var pe = se.length
    se.push(fe)
    e: for (; 0 < pe; ) {
      var We = (pe - 1) >>> 1,
        Se = se[We]
      if (0 < i(Se, fe)) ((se[We] = fe), (se[pe] = Se), (pe = We))
      else break e
    }
  }
  function n(se) {
    return se.length === 0 ? null : se[0]
  }
  function r(se) {
    if (se.length === 0) return null
    var fe = se[0],
      pe = se.pop()
    if (pe !== fe) {
      se[0] = pe
      e: for (var We = 0, Se = se.length, Tt = Se >>> 1; We < Tt; ) {
        var Be = 2 * (We + 1) - 1,
          Sn = se[Be],
          ue = Be + 1,
          $r = se[ue]
        if (0 > i(Sn, pe))
          ue < Se && 0 > i($r, Sn)
            ? ((se[We] = $r), (se[ue] = pe), (We = ue))
            : ((se[We] = Sn), (se[Be] = pe), (We = Be))
        else if (ue < Se && 0 > i($r, pe)) ((se[We] = $r), (se[ue] = pe), (We = ue))
        else break e
      }
    }
    return fe
  }
  function i(se, fe) {
    var pe = se.sortIndex - fe.sortIndex
    return pe !== 0 ? pe : se.id - fe.id
  }
  if (typeof performance == 'object' && typeof performance.now == 'function') {
    var o = performance
    e.unstable_now = function () {
      return o.now()
    }
  } else {
    var c = Date,
      h = c.now()
    e.unstable_now = function () {
      return c.now() - h
    }
  }
  var f = [],
    p = [],
    y = 1,
    w = null,
    x = 3,
    E = !1,
    S = !1,
    k = !1,
    P = typeof setTimeout == 'function' ? setTimeout : null,
    I = typeof clearTimeout == 'function' ? clearTimeout : null,
    R = typeof setImmediate < 'u' ? setImmediate : null
  typeof navigator < 'u' &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling)
  function M(se) {
    for (var fe = n(p); fe !== null; ) {
      if (fe.callback === null) r(p)
      else if (fe.startTime <= se) (r(p), (fe.sortIndex = fe.expirationTime), t(f, fe))
      else break
      fe = n(p)
    }
  }
  function O(se) {
    if (((k = !1), M(se), !S))
      if (n(f) !== null) ((S = !0), xe(F))
      else {
        var fe = n(p)
        fe !== null && ge(O, fe.startTime - se)
      }
  }
  function F(se, fe) {
    ;((S = !1), k && ((k = !1), I(U), (U = -1)), (E = !0))
    var pe = x
    try {
      for (M(fe), w = n(f); w !== null && (!(w.expirationTime > fe) || (se && !oe())); ) {
        var We = w.callback
        if (typeof We == 'function') {
          ;((w.callback = null), (x = w.priorityLevel))
          var Se = We(w.expirationTime <= fe)
          ;((fe = e.unstable_now()),
            typeof Se == 'function' ? (w.callback = Se) : w === n(f) && r(f),
            M(fe))
        } else r(f)
        w = n(f)
      }
      if (w !== null) var Tt = !0
      else {
        var Be = n(p)
        ;(Be !== null && ge(O, Be.startTime - fe), (Tt = !1))
      }
      return Tt
    } finally {
      ;((w = null), (x = pe), (E = !1))
    }
  }
  var z = !1,
    V = null,
    U = -1,
    Z = 5,
    J = -1
  function oe() {
    return !(e.unstable_now() - J < Z)
  }
  function re() {
    if (V !== null) {
      var se = e.unstable_now()
      J = se
      var fe = !0
      try {
        fe = V(!0, se)
      } finally {
        fe ? ve() : ((z = !1), (V = null))
      }
    } else z = !1
  }
  var ve
  if (typeof R == 'function')
    ve = function () {
      R(re)
    }
  else if (typeof MessageChannel < 'u') {
    var Ie = new MessageChannel(),
      H = Ie.port2
    ;((Ie.port1.onmessage = re),
      (ve = function () {
        H.postMessage(null)
      }))
  } else
    ve = function () {
      P(re, 0)
    }
  function xe(se) {
    ;((V = se), z || ((z = !0), ve()))
  }
  function ge(se, fe) {
    U = P(function () {
      se(e.unstable_now())
    }, fe)
  }
  ;((e.unstable_IdlePriority = 5),
    (e.unstable_ImmediatePriority = 1),
    (e.unstable_LowPriority = 4),
    (e.unstable_NormalPriority = 3),
    (e.unstable_Profiling = null),
    (e.unstable_UserBlockingPriority = 2),
    (e.unstable_cancelCallback = function (se) {
      se.callback = null
    }),
    (e.unstable_continueExecution = function () {
      S || E || ((S = !0), xe(F))
    }),
    (e.unstable_forceFrameRate = function (se) {
      0 > se || 125 < se
        ? console.error(
            'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
          )
        : (Z = 0 < se ? Math.floor(1e3 / se) : 5)
    }),
    (e.unstable_getCurrentPriorityLevel = function () {
      return x
    }),
    (e.unstable_getFirstCallbackNode = function () {
      return n(f)
    }),
    (e.unstable_next = function (se) {
      switch (x) {
        case 1:
        case 2:
        case 3:
          var fe = 3
          break
        default:
          fe = x
      }
      var pe = x
      x = fe
      try {
        return se()
      } finally {
        x = pe
      }
    }),
    (e.unstable_pauseExecution = function () {}),
    (e.unstable_requestPaint = function () {}),
    (e.unstable_runWithPriority = function (se, fe) {
      switch (se) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          se = 3
      }
      var pe = x
      x = se
      try {
        return fe()
      } finally {
        x = pe
      }
    }),
    (e.unstable_scheduleCallback = function (se, fe, pe) {
      var We = e.unstable_now()
      switch (
        (typeof pe == 'object' && pe !== null
          ? ((pe = pe.delay), (pe = typeof pe == 'number' && 0 < pe ? We + pe : We))
          : (pe = We),
        se)
      ) {
        case 1:
          var Se = -1
          break
        case 2:
          Se = 250
          break
        case 5:
          Se = 1073741823
          break
        case 4:
          Se = 1e4
          break
        default:
          Se = 5e3
      }
      return (
        (Se = pe + Se),
        (se = {
          id: y++,
          callback: fe,
          priorityLevel: se,
          startTime: pe,
          expirationTime: Se,
          sortIndex: -1,
        }),
        pe > We
          ? ((se.sortIndex = pe),
            t(p, se),
            n(f) === null && se === n(p) && (k ? (I(U), (U = -1)) : (k = !0), ge(O, pe - We)))
          : ((se.sortIndex = Se), t(f, se), S || E || ((S = !0), xe(F))),
        se
      )
    }),
    (e.unstable_shouldYield = oe),
    (e.unstable_wrapCallback = function (se) {
      var fe = x
      return function () {
        var pe = x
        x = fe
        try {
          return se.apply(this, arguments)
        } finally {
          x = pe
        }
      }
    }))
})(c8)
l8.exports = c8
var cv = l8.exports
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var uv = X,
  On = cv
function ee(e) {
  for (
    var t = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, n = 1;
    n < arguments.length;
    n++
  )
    t += '&args[]=' + encodeURIComponent(arguments[n])
  return (
    'Minified React error #' +
    e +
    '; visit ' +
    t +
    ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
  )
}
var u8 = new Set(),
  tl = {}
function As(e, t) {
  ;(To(e, t), To(e + 'Capture', t))
}
function To(e, t) {
  for (tl[e] = t, e = 0; e < t.length; e++) u8.add(t[e])
}
var Xr = !(
    typeof window > 'u' ||
    typeof window.document > 'u' ||
    typeof window.document.createElement > 'u'
  ),
  Zd = Object.prototype.hasOwnProperty,
  hv =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Up = {},
  Wp = {}
function dv(e) {
  return Zd.call(Wp, e) ? !0 : Zd.call(Up, e) ? !1 : hv.test(e) ? (Wp[e] = !0) : ((Up[e] = !0), !1)
}
function fv(e, t, n, r) {
  if (n !== null && n.type === 0) return !1
  switch (typeof t) {
    case 'function':
    case 'symbol':
      return !0
    case 'boolean':
      return r
        ? !1
        : n !== null
          ? !n.acceptsBooleans
          : ((e = e.toLowerCase().slice(0, 5)), e !== 'data-' && e !== 'aria-')
    default:
      return !1
  }
}
function pv(e, t, n, r) {
  if (t === null || typeof t > 'u' || fv(e, t, n, r)) return !0
  if (r) return !1
  if (n !== null)
    switch (n.type) {
      case 3:
        return !t
      case 4:
        return t === !1
      case 5:
        return isNaN(t)
      case 6:
        return isNaN(t) || 1 > t
    }
  return !1
}
function ln(e, t, n, r, i, o, c) {
  ;((this.acceptsBooleans = t === 2 || t === 3 || t === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = e),
    (this.type = t),
    (this.sanitizeURL = o),
    (this.removeEmptyString = c))
}
var Gt = {}
'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
  .split(' ')
  .forEach(function (e) {
    Gt[e] = new ln(e, 0, !1, e, null, !1, !1)
  })
;[
  ['acceptCharset', 'accept-charset'],
  ['className', 'class'],
  ['htmlFor', 'for'],
  ['httpEquiv', 'http-equiv'],
].forEach(function (e) {
  var t = e[0]
  Gt[t] = new ln(t, 1, !1, e[1], null, !1, !1)
})
;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) {
  Gt[e] = new ln(e, 2, !1, e.toLowerCase(), null, !1, !1)
})
;['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (e) {
  Gt[e] = new ln(e, 2, !1, e, null, !1, !1)
})
'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
  .split(' ')
  .forEach(function (e) {
    Gt[e] = new ln(e, 3, !1, e.toLowerCase(), null, !1, !1)
  })
;['checked', 'multiple', 'muted', 'selected'].forEach(function (e) {
  Gt[e] = new ln(e, 3, !0, e, null, !1, !1)
})
;['capture', 'download'].forEach(function (e) {
  Gt[e] = new ln(e, 4, !1, e, null, !1, !1)
})
;['cols', 'rows', 'size', 'span'].forEach(function (e) {
  Gt[e] = new ln(e, 6, !1, e, null, !1, !1)
})
;['rowSpan', 'start'].forEach(function (e) {
  Gt[e] = new ln(e, 5, !1, e.toLowerCase(), null, !1, !1)
})
var _f = /[\-:]([a-z])/g
function If(e) {
  return e[1].toUpperCase()
}
'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
  .split(' ')
  .forEach(function (e) {
    var t = e.replace(_f, If)
    Gt[t] = new ln(t, 1, !1, e, null, !1, !1)
  })
'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
  .split(' ')
  .forEach(function (e) {
    var t = e.replace(_f, If)
    Gt[t] = new ln(t, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1)
  })
;['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) {
  var t = e.replace(_f, If)
  Gt[t] = new ln(t, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1)
})
;['tabIndex', 'crossOrigin'].forEach(function (e) {
  Gt[e] = new ln(e, 1, !1, e.toLowerCase(), null, !1, !1)
})
Gt.xlinkHref = new ln('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)
;['src', 'href', 'action', 'formAction'].forEach(function (e) {
  Gt[e] = new ln(e, 1, !1, e.toLowerCase(), null, !0, !0)
})
function Nf(e, t, n, r) {
  var i = Gt.hasOwnProperty(t) ? Gt[t] : null
  ;(i !== null
    ? i.type !== 0
    : r || !(2 < t.length) || (t[0] !== 'o' && t[0] !== 'O') || (t[1] !== 'n' && t[1] !== 'N')) &&
    (pv(t, n, i, r) && (n = null),
    r || i === null
      ? dv(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, '' + n))
      : i.mustUseProperty
        ? (e[i.propertyName] = n === null ? (i.type === 3 ? !1 : '') : n)
        : ((t = i.attributeName),
          (r = i.attributeNamespace),
          n === null
            ? e.removeAttribute(t)
            : ((i = i.type),
              (n = i === 3 || (i === 4 && n === !0) ? '' : '' + n),
              r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var qr = uv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  rc = Symbol.for('react.element'),
  ro = Symbol.for('react.portal'),
  io = Symbol.for('react.fragment'),
  Tf = Symbol.for('react.strict_mode'),
  Kd = Symbol.for('react.profiler'),
  h8 = Symbol.for('react.provider'),
  d8 = Symbol.for('react.context'),
  Rf = Symbol.for('react.forward_ref'),
  qd = Symbol.for('react.suspense'),
  Qd = Symbol.for('react.suspense_list'),
  Mf = Symbol.for('react.memo'),
  ci = Symbol.for('react.lazy'),
  f8 = Symbol.for('react.offscreen'),
  zp = Symbol.iterator
function da(e) {
  return e === null || typeof e != 'object'
    ? null
    : ((e = (zp && e[zp]) || e['@@iterator']), typeof e == 'function' ? e : null)
}
var dt = Object.assign,
  Zh
function ka(e) {
  if (Zh === void 0)
    try {
      throw Error()
    } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/)
      Zh = (t && t[1]) || ''
    }
  return (
    `
` +
    Zh +
    e
  )
}
var Kh = !1
function qh(e, t) {
  if (!e || Kh) return ''
  Kh = !0
  var n = Error.prepareStackTrace
  Error.prepareStackTrace = void 0
  try {
    if (t)
      if (
        ((t = function () {
          throw Error()
        }),
        Object.defineProperty(t.prototype, 'props', {
          set: function () {
            throw Error()
          },
        }),
        typeof Reflect == 'object' && Reflect.construct)
      ) {
        try {
          Reflect.construct(t, [])
        } catch (p) {
          var r = p
        }
        Reflect.construct(e, [], t)
      } else {
        try {
          t.call()
        } catch (p) {
          r = p
        }
        e.call(t.prototype)
      }
    else {
      try {
        throw Error()
      } catch (p) {
        r = p
      }
      e()
    }
  } catch (p) {
    if (p && r && typeof p.stack == 'string') {
      for (
        var i = p.stack.split(`
`),
          o = r.stack.split(`
`),
          c = i.length - 1,
          h = o.length - 1;
        1 <= c && 0 <= h && i[c] !== o[h];

      )
        h--
      for (; 1 <= c && 0 <= h; c--, h--)
        if (i[c] !== o[h]) {
          if (c !== 1 || h !== 1)
            do
              if ((c--, h--, 0 > h || i[c] !== o[h])) {
                var f =
                  `
` + i[c].replace(' at new ', ' at ')
                return (
                  e.displayName &&
                    f.includes('<anonymous>') &&
                    (f = f.replace('<anonymous>', e.displayName)),
                  f
                )
              }
            while (1 <= c && 0 <= h)
          break
        }
    }
  } finally {
    ;((Kh = !1), (Error.prepareStackTrace = n))
  }
  return (e = e ? e.displayName || e.name : '') ? ka(e) : ''
}
function gv(e) {
  switch (e.tag) {
    case 5:
      return ka(e.type)
    case 16:
      return ka('Lazy')
    case 13:
      return ka('Suspense')
    case 19:
      return ka('SuspenseList')
    case 0:
    case 2:
    case 15:
      return ((e = qh(e.type, !1)), e)
    case 11:
      return ((e = qh(e.type.render, !1)), e)
    case 1:
      return ((e = qh(e.type, !0)), e)
    default:
      return ''
  }
}
function $d(e) {
  if (e == null) return null
  if (typeof e == 'function') return e.displayName || e.name || null
  if (typeof e == 'string') return e
  switch (e) {
    case io:
      return 'Fragment'
    case ro:
      return 'Portal'
    case Kd:
      return 'Profiler'
    case Tf:
      return 'StrictMode'
    case qd:
      return 'Suspense'
    case Qd:
      return 'SuspenseList'
  }
  if (typeof e == 'object')
    switch (e.$$typeof) {
      case d8:
        return (e.displayName || 'Context') + '.Consumer'
      case h8:
        return (e._context.displayName || 'Context') + '.Provider'
      case Rf:
        var t = e.render
        return (
          (e = e.displayName),
          e ||
            ((e = t.displayName || t.name || ''),
            (e = e !== '' ? 'ForwardRef(' + e + ')' : 'ForwardRef')),
          e
        )
      case Mf:
        return ((t = e.displayName || null), t !== null ? t : $d(e.type) || 'Memo')
      case ci:
        ;((t = e._payload), (e = e._init))
        try {
          return $d(e(t))
        } catch {}
    }
  return null
}
function mv(e) {
  var t = e.type
  switch (e.tag) {
    case 24:
      return 'Cache'
    case 9:
      return (t.displayName || 'Context') + '.Consumer'
    case 10:
      return (t._context.displayName || 'Context') + '.Provider'
    case 18:
      return 'DehydratedFragment'
    case 11:
      return (
        (e = t.render),
        (e = e.displayName || e.name || ''),
        t.displayName || (e !== '' ? 'ForwardRef(' + e + ')' : 'ForwardRef')
      )
    case 7:
      return 'Fragment'
    case 5:
      return t
    case 4:
      return 'Portal'
    case 3:
      return 'Root'
    case 6:
      return 'Text'
    case 16:
      return $d(t)
    case 8:
      return t === Tf ? 'StrictMode' : 'Mode'
    case 22:
      return 'Offscreen'
    case 12:
      return 'Profiler'
    case 21:
      return 'Scope'
    case 13:
      return 'Suspense'
    case 19:
      return 'SuspenseList'
    case 25:
      return 'TracingMarker'
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == 'function') return t.displayName || t.name || null
      if (typeof t == 'string') return t
  }
  return null
}
function Mi(e) {
  switch (typeof e) {
    case 'boolean':
    case 'number':
    case 'string':
    case 'undefined':
      return e
    case 'object':
      return e
    default:
      return ''
  }
}
function p8(e) {
  var t = e.type
  return (e = e.nodeName) && e.toLowerCase() === 'input' && (t === 'checkbox' || t === 'radio')
}
function yv(e) {
  var t = p8(e) ? 'checked' : 'value',
    n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    r = '' + e[t]
  if (
    !e.hasOwnProperty(t) &&
    typeof n < 'u' &&
    typeof n.get == 'function' &&
    typeof n.set == 'function'
  ) {
    var i = n.get,
      o = n.set
    return (
      Object.defineProperty(e, t, {
        configurable: !0,
        get: function () {
          return i.call(this)
        },
        set: function (c) {
          ;((r = '' + c), o.call(this, c))
        },
      }),
      Object.defineProperty(e, t, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r
        },
        setValue: function (c) {
          r = '' + c
        },
        stopTracking: function () {
          ;((e._valueTracker = null), delete e[t])
        },
      }
    )
  }
}
function ic(e) {
  e._valueTracker || (e._valueTracker = yv(e))
}
function g8(e) {
  if (!e) return !1
  var t = e._valueTracker
  if (!t) return !0
  var n = t.getValue(),
    r = ''
  return (
    e && (r = p8(e) ? (e.checked ? 'true' : 'false') : e.value),
    (e = r),
    e !== n ? (t.setValue(e), !0) : !1
  )
}
function iu(e) {
  if (((e = e || (typeof document < 'u' ? document : void 0)), typeof e > 'u')) return null
  try {
    return e.activeElement || e.body
  } catch {
    return e.body
  }
}
function Jd(e, t) {
  var n = t.checked
  return dt({}, t, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? e._wrapperState.initialChecked,
  })
}
function Hp(e, t) {
  var n = t.defaultValue == null ? '' : t.defaultValue,
    r = t.checked != null ? t.checked : t.defaultChecked
  ;((n = Mi(t.value != null ? t.value : n)),
    (e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled: t.type === 'checkbox' || t.type === 'radio' ? t.checked != null : t.value != null,
    }))
}
function m8(e, t) {
  ;((t = t.checked), t != null && Nf(e, 'checked', t, !1))
}
function e1(e, t) {
  m8(e, t)
  var n = Mi(t.value),
    r = t.type
  if (n != null)
    r === 'number'
      ? ((n === 0 && e.value === '') || e.value != n) && (e.value = '' + n)
      : e.value !== '' + n && (e.value = '' + n)
  else if (r === 'submit' || r === 'reset') {
    e.removeAttribute('value')
    return
  }
  ;(t.hasOwnProperty('value')
    ? t1(e, t.type, n)
    : t.hasOwnProperty('defaultValue') && t1(e, t.type, Mi(t.defaultValue)),
    t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked))
}
function Xp(e, t, n) {
  if (t.hasOwnProperty('value') || t.hasOwnProperty('defaultValue')) {
    var r = t.type
    if (!((r !== 'submit' && r !== 'reset') || (t.value !== void 0 && t.value !== null))) return
    ;((t = '' + e._wrapperState.initialValue),
      n || t === e.value || (e.value = t),
      (e.defaultValue = t))
  }
  ;((n = e.name),
    n !== '' && (e.name = ''),
    (e.defaultChecked = !!e._wrapperState.initialChecked),
    n !== '' && (e.name = n))
}
function t1(e, t, n) {
  ;(t !== 'number' || iu(e.ownerDocument) !== e) &&
    (n == null
      ? (e.defaultValue = '' + e._wrapperState.initialValue)
      : e.defaultValue !== '' + n && (e.defaultValue = '' + n))
}
var _a = Array.isArray
function Co(e, t, n, r) {
  if (((e = e.options), t)) {
    t = {}
    for (var i = 0; i < n.length; i++) t['$' + n[i]] = !0
    for (n = 0; n < e.length; n++)
      ((i = t.hasOwnProperty('$' + e[n].value)),
        e[n].selected !== i && (e[n].selected = i),
        i && r && (e[n].defaultSelected = !0))
  } else {
    for (n = '' + Mi(n), t = null, i = 0; i < e.length; i++) {
      if (e[i].value === n) {
        ;((e[i].selected = !0), r && (e[i].defaultSelected = !0))
        return
      }
      t !== null || e[i].disabled || (t = e[i])
    }
    t !== null && (t.selected = !0)
  }
}
function n1(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(ee(91))
  return dt({}, t, {
    value: void 0,
    defaultValue: void 0,
    children: '' + e._wrapperState.initialValue,
  })
}
function Gp(e, t) {
  var n = t.value
  if (n == null) {
    if (((n = t.children), (t = t.defaultValue), n != null)) {
      if (t != null) throw Error(ee(92))
      if (_a(n)) {
        if (1 < n.length) throw Error(ee(93))
        n = n[0]
      }
      t = n
    }
    ;(t == null && (t = ''), (n = t))
  }
  e._wrapperState = { initialValue: Mi(n) }
}
function y8(e, t) {
  var n = Mi(t.value),
    r = Mi(t.defaultValue)
  ;(n != null &&
    ((n = '' + n),
    n !== e.value && (e.value = n),
    t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
    r != null && (e.defaultValue = '' + r))
}
function Yp(e) {
  var t = e.textContent
  t === e._wrapperState.initialValue && t !== '' && t !== null && (e.value = t)
}
function w8(e) {
  switch (e) {
    case 'svg':
      return 'http://www.w3.org/2000/svg'
    case 'math':
      return 'http://www.w3.org/1998/Math/MathML'
    default:
      return 'http://www.w3.org/1999/xhtml'
  }
}
function r1(e, t) {
  return e == null || e === 'http://www.w3.org/1999/xhtml'
    ? w8(t)
    : e === 'http://www.w3.org/2000/svg' && t === 'foreignObject'
      ? 'http://www.w3.org/1999/xhtml'
      : e
}
var sc,
  b8 = (function (e) {
    return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
      ? function (t, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return e(t, n, r, i)
          })
        }
      : e
  })(function (e, t) {
    if (e.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in e) e.innerHTML = t
    else {
      for (
        sc = sc || document.createElement('div'),
          sc.innerHTML = '<svg>' + t.valueOf().toString() + '</svg>',
          t = sc.firstChild;
        e.firstChild;

      )
        e.removeChild(e.firstChild)
      for (; t.firstChild; ) e.appendChild(t.firstChild)
    }
  })
function nl(e, t) {
  if (t) {
    var n = e.firstChild
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t
      return
    }
  }
  e.textContent = t
}
var Oa = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  wv = ['Webkit', 'ms', 'Moz', 'O']
Object.keys(Oa).forEach(function (e) {
  wv.forEach(function (t) {
    ;((t = t + e.charAt(0).toUpperCase() + e.substring(1)), (Oa[t] = Oa[e]))
  })
})
function v8(e, t, n) {
  return t == null || typeof t == 'boolean' || t === ''
    ? ''
    : n || typeof t != 'number' || t === 0 || (Oa.hasOwnProperty(e) && Oa[e])
      ? ('' + t).trim()
      : t + 'px'
}
function x8(e, t) {
  e = e.style
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var r = n.indexOf('--') === 0,
        i = v8(n, t[n], r)
      ;(n === 'float' && (n = 'cssFloat'), r ? e.setProperty(n, i) : (e[n] = i))
    }
}
var bv = dt(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
)
function i1(e, t) {
  if (t) {
    if (bv[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(ee(137, e))
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(ee(60))
      if (typeof t.dangerouslySetInnerHTML != 'object' || !('__html' in t.dangerouslySetInnerHTML))
        throw Error(ee(61))
    }
    if (t.style != null && typeof t.style != 'object') throw Error(ee(62))
  }
}
function s1(e, t) {
  if (e.indexOf('-') === -1) return typeof t.is == 'string'
  switch (e) {
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return !1
    default:
      return !0
  }
}
var o1 = null
function Pf(e) {
  return (
    (e = e.target || e.srcElement || window),
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
  )
}
var a1 = null,
  So = null,
  Ao = null
function Zp(e) {
  if ((e = Dl(e))) {
    if (typeof a1 != 'function') throw Error(ee(280))
    var t = e.stateNode
    t && ((t = Ju(t)), a1(e.stateNode, e.type, t))
  }
}
function E8(e) {
  So ? (Ao ? Ao.push(e) : (Ao = [e])) : (So = e)
}
function C8() {
  if (So) {
    var e = So,
      t = Ao
    if (((Ao = So = null), Zp(e), t)) for (e = 0; e < t.length; e++) Zp(t[e])
  }
}
function S8(e, t) {
  return e(t)
}
function A8() {}
var Qh = !1
function k8(e, t, n) {
  if (Qh) return e(t, n)
  Qh = !0
  try {
    return S8(e, t, n)
  } finally {
    ;((Qh = !1), (So !== null || Ao !== null) && (A8(), C8()))
  }
}
function rl(e, t) {
  var n = e.stateNode
  if (n === null) return null
  var r = Ju(n)
  if (r === null) return null
  n = r[t]
  e: switch (t) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      ;((r = !r.disabled) ||
        ((e = e.type),
        (r = !(e === 'button' || e === 'input' || e === 'select' || e === 'textarea'))),
        (e = !r))
      break e
    default:
      e = !1
  }
  if (e) return null
  if (n && typeof n != 'function') throw Error(ee(231, t, typeof n))
  return n
}
var l1 = !1
if (Xr)
  try {
    var fa = {}
    ;(Object.defineProperty(fa, 'passive', {
      get: function () {
        l1 = !0
      },
    }),
      window.addEventListener('test', fa, fa),
      window.removeEventListener('test', fa, fa))
  } catch {
    l1 = !1
  }
function vv(e, t, n, r, i, o, c, h, f) {
  var p = Array.prototype.slice.call(arguments, 3)
  try {
    t.apply(n, p)
  } catch (y) {
    this.onError(y)
  }
}
var Ba = !1,
  su = null,
  ou = !1,
  c1 = null,
  xv = {
    onError: function (e) {
      ;((Ba = !0), (su = e))
    },
  }
function Ev(e, t, n, r, i, o, c, h, f) {
  ;((Ba = !1), (su = null), vv.apply(xv, arguments))
}
function Cv(e, t, n, r, i, o, c, h, f) {
  if ((Ev.apply(this, arguments), Ba)) {
    if (Ba) {
      var p = su
      ;((Ba = !1), (su = null))
    } else throw Error(ee(198))
    ou || ((ou = !0), (c1 = p))
  }
}
function ks(e) {
  var t = e,
    n = e
  if (e.alternate) for (; t.return; ) t = t.return
  else {
    e = t
    do ((t = e), t.flags & 4098 && (n = t.return), (e = t.return))
    while (e)
  }
  return t.tag === 3 ? n : null
}
function _8(e) {
  if (e.tag === 13) {
    var t = e.memoizedState
    if ((t === null && ((e = e.alternate), e !== null && (t = e.memoizedState)), t !== null))
      return t.dehydrated
  }
  return null
}
function Kp(e) {
  if (ks(e) !== e) throw Error(ee(188))
}
function Sv(e) {
  var t = e.alternate
  if (!t) {
    if (((t = ks(e)), t === null)) throw Error(ee(188))
    return t !== e ? null : e
  }
  for (var n = e, r = t; ; ) {
    var i = n.return
    if (i === null) break
    var o = i.alternate
    if (o === null) {
      if (((r = i.return), r !== null)) {
        n = r
        continue
      }
      break
    }
    if (i.child === o.child) {
      for (o = i.child; o; ) {
        if (o === n) return (Kp(i), e)
        if (o === r) return (Kp(i), t)
        o = o.sibling
      }
      throw Error(ee(188))
    }
    if (n.return !== r.return) ((n = i), (r = o))
    else {
      for (var c = !1, h = i.child; h; ) {
        if (h === n) {
          ;((c = !0), (n = i), (r = o))
          break
        }
        if (h === r) {
          ;((c = !0), (r = i), (n = o))
          break
        }
        h = h.sibling
      }
      if (!c) {
        for (h = o.child; h; ) {
          if (h === n) {
            ;((c = !0), (n = o), (r = i))
            break
          }
          if (h === r) {
            ;((c = !0), (r = o), (n = i))
            break
          }
          h = h.sibling
        }
        if (!c) throw Error(ee(189))
      }
    }
    if (n.alternate !== r) throw Error(ee(190))
  }
  if (n.tag !== 3) throw Error(ee(188))
  return n.stateNode.current === n ? e : t
}
function I8(e) {
  return ((e = Sv(e)), e !== null ? N8(e) : null)
}
function N8(e) {
  if (e.tag === 5 || e.tag === 6) return e
  for (e = e.child; e !== null; ) {
    var t = N8(e)
    if (t !== null) return t
    e = e.sibling
  }
  return null
}
var T8 = On.unstable_scheduleCallback,
  qp = On.unstable_cancelCallback,
  Av = On.unstable_shouldYield,
  kv = On.unstable_requestPaint,
  Et = On.unstable_now,
  _v = On.unstable_getCurrentPriorityLevel,
  Df = On.unstable_ImmediatePriority,
  R8 = On.unstable_UserBlockingPriority,
  au = On.unstable_NormalPriority,
  Iv = On.unstable_LowPriority,
  M8 = On.unstable_IdlePriority,
  Ku = null,
  Ar = null
function Nv(e) {
  if (Ar && typeof Ar.onCommitFiberRoot == 'function')
    try {
      Ar.onCommitFiberRoot(Ku, e, void 0, (e.current.flags & 128) === 128)
    } catch {}
}
var cr = Math.clz32 ? Math.clz32 : Mv,
  Tv = Math.log,
  Rv = Math.LN2
function Mv(e) {
  return ((e >>>= 0), e === 0 ? 32 : (31 - ((Tv(e) / Rv) | 0)) | 0)
}
var oc = 64,
  ac = 4194304
function Ia(e) {
  switch (e & -e) {
    case 1:
      return 1
    case 2:
      return 2
    case 4:
      return 4
    case 8:
      return 8
    case 16:
      return 16
    case 32:
      return 32
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424
    case 134217728:
      return 134217728
    case 268435456:
      return 268435456
    case 536870912:
      return 536870912
    case 1073741824:
      return 1073741824
    default:
      return e
  }
}
function lu(e, t) {
  var n = e.pendingLanes
  if (n === 0) return 0
  var r = 0,
    i = e.suspendedLanes,
    o = e.pingedLanes,
    c = n & 268435455
  if (c !== 0) {
    var h = c & ~i
    h !== 0 ? (r = Ia(h)) : ((o &= c), o !== 0 && (r = Ia(o)))
  } else ((c = n & ~i), c !== 0 ? (r = Ia(c)) : o !== 0 && (r = Ia(o)))
  if (r === 0) return 0
  if (
    t !== 0 &&
    t !== r &&
    !(t & i) &&
    ((i = r & -r), (o = t & -t), i >= o || (i === 16 && (o & 4194240) !== 0))
  )
    return t
  if ((r & 4 && (r |= n & 16), (t = e.entangledLanes), t !== 0))
    for (e = e.entanglements, t &= r; 0 < t; )
      ((n = 31 - cr(t)), (i = 1 << n), (r |= e[n]), (t &= ~i))
  return r
}
function Pv(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1
    default:
      return -1
  }
}
function Dv(e, t) {
  for (
    var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes;
    0 < o;

  ) {
    var c = 31 - cr(o),
      h = 1 << c,
      f = i[c]
    ;(f === -1 ? (!(h & n) || h & r) && (i[c] = Pv(h, t)) : f <= t && (e.expiredLanes |= h),
      (o &= ~h))
  }
}
function u1(e) {
  return ((e = e.pendingLanes & -1073741825), e !== 0 ? e : e & 1073741824 ? 1073741824 : 0)
}
function P8() {
  var e = oc
  return ((oc <<= 1), !(oc & 4194240) && (oc = 64), e)
}
function $h(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e)
  return t
}
function Ml(e, t, n) {
  ;((e.pendingLanes |= t),
    t !== 536870912 && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
    (e = e.eventTimes),
    (t = 31 - cr(t)),
    (e[t] = n))
}
function Lv(e, t) {
  var n = e.pendingLanes & ~t
  ;((e.pendingLanes = t),
    (e.suspendedLanes = 0),
    (e.pingedLanes = 0),
    (e.expiredLanes &= t),
    (e.mutableReadLanes &= t),
    (e.entangledLanes &= t),
    (t = e.entanglements))
  var r = e.eventTimes
  for (e = e.expirationTimes; 0 < n; ) {
    var i = 31 - cr(n),
      o = 1 << i
    ;((t[i] = 0), (r[i] = -1), (e[i] = -1), (n &= ~o))
  }
}
function Lf(e, t) {
  var n = (e.entangledLanes |= t)
  for (e = e.entanglements; n; ) {
    var r = 31 - cr(n),
      i = 1 << r
    ;((i & t) | (e[r] & t) && (e[r] |= t), (n &= ~i))
  }
}
var He = 0
function D8(e) {
  return ((e &= -e), 1 < e ? (4 < e ? (e & 268435455 ? 16 : 536870912) : 4) : 1)
}
var L8,
  Of,
  O8,
  B8,
  F8,
  h1 = !1,
  lc = [],
  Ei = null,
  Ci = null,
  Si = null,
  il = new Map(),
  sl = new Map(),
  hi = [],
  Ov =
    'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
      ' '
    )
function Qp(e, t) {
  switch (e) {
    case 'focusin':
    case 'focusout':
      Ei = null
      break
    case 'dragenter':
    case 'dragleave':
      Ci = null
      break
    case 'mouseover':
    case 'mouseout':
      Si = null
      break
    case 'pointerover':
    case 'pointerout':
      il.delete(t.pointerId)
      break
    case 'gotpointercapture':
    case 'lostpointercapture':
      sl.delete(t.pointerId)
  }
}
function pa(e, t, n, r, i, o) {
  return e === null || e.nativeEvent !== o
    ? ((e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: o,
        targetContainers: [i],
      }),
      t !== null && ((t = Dl(t)), t !== null && Of(t)),
      e)
    : ((e.eventSystemFlags |= r),
      (t = e.targetContainers),
      i !== null && t.indexOf(i) === -1 && t.push(i),
      e)
}
function Bv(e, t, n, r, i) {
  switch (t) {
    case 'focusin':
      return ((Ei = pa(Ei, e, t, n, r, i)), !0)
    case 'dragenter':
      return ((Ci = pa(Ci, e, t, n, r, i)), !0)
    case 'mouseover':
      return ((Si = pa(Si, e, t, n, r, i)), !0)
    case 'pointerover':
      var o = i.pointerId
      return (il.set(o, pa(il.get(o) || null, e, t, n, r, i)), !0)
    case 'gotpointercapture':
      return ((o = i.pointerId), sl.set(o, pa(sl.get(o) || null, e, t, n, r, i)), !0)
  }
  return !1
}
function j8(e) {
  var t = ss(e.target)
  if (t !== null) {
    var n = ks(t)
    if (n !== null) {
      if (((t = n.tag), t === 13)) {
        if (((t = _8(n)), t !== null)) {
          ;((e.blockedOn = t),
            F8(e.priority, function () {
              O8(n)
            }))
          return
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null
        return
      }
    }
  }
  e.blockedOn = null
}
function Fc(e) {
  if (e.blockedOn !== null) return !1
  for (var t = e.targetContainers; 0 < t.length; ) {
    var n = d1(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent)
    if (n === null) {
      n = e.nativeEvent
      var r = new n.constructor(n.type, n)
      ;((o1 = r), n.target.dispatchEvent(r), (o1 = null))
    } else return ((t = Dl(n)), t !== null && Of(t), (e.blockedOn = n), !1)
    t.shift()
  }
  return !0
}
function $p(e, t, n) {
  Fc(e) && n.delete(t)
}
function Fv() {
  ;((h1 = !1),
    Ei !== null && Fc(Ei) && (Ei = null),
    Ci !== null && Fc(Ci) && (Ci = null),
    Si !== null && Fc(Si) && (Si = null),
    il.forEach($p),
    sl.forEach($p))
}
function ga(e, t) {
  e.blockedOn === t &&
    ((e.blockedOn = null),
    h1 || ((h1 = !0), On.unstable_scheduleCallback(On.unstable_NormalPriority, Fv)))
}
function ol(e) {
  function t(i) {
    return ga(i, e)
  }
  if (0 < lc.length) {
    ga(lc[0], e)
    for (var n = 1; n < lc.length; n++) {
      var r = lc[n]
      r.blockedOn === e && (r.blockedOn = null)
    }
  }
  for (
    Ei !== null && ga(Ei, e),
      Ci !== null && ga(Ci, e),
      Si !== null && ga(Si, e),
      il.forEach(t),
      sl.forEach(t),
      n = 0;
    n < hi.length;
    n++
  )
    ((r = hi[n]), r.blockedOn === e && (r.blockedOn = null))
  for (; 0 < hi.length && ((n = hi[0]), n.blockedOn === null); )
    (j8(n), n.blockedOn === null && hi.shift())
}
var ko = qr.ReactCurrentBatchConfig,
  cu = !0
function jv(e, t, n, r) {
  var i = He,
    o = ko.transition
  ko.transition = null
  try {
    ;((He = 1), Bf(e, t, n, r))
  } finally {
    ;((He = i), (ko.transition = o))
  }
}
function Vv(e, t, n, r) {
  var i = He,
    o = ko.transition
  ko.transition = null
  try {
    ;((He = 4), Bf(e, t, n, r))
  } finally {
    ;((He = i), (ko.transition = o))
  }
}
function Bf(e, t, n, r) {
  if (cu) {
    var i = d1(e, t, n, r)
    if (i === null) (ld(e, t, r, uu, n), Qp(e, r))
    else if (Bv(i, e, t, n, r)) r.stopPropagation()
    else if ((Qp(e, r), t & 4 && -1 < Ov.indexOf(e))) {
      for (; i !== null; ) {
        var o = Dl(i)
        if ((o !== null && L8(o), (o = d1(e, t, n, r)), o === null && ld(e, t, r, uu, n), o === i))
          break
        i = o
      }
      i !== null && r.stopPropagation()
    } else ld(e, t, r, null, n)
  }
}
var uu = null
function d1(e, t, n, r) {
  if (((uu = null), (e = Pf(r)), (e = ss(e)), e !== null))
    if (((t = ks(e)), t === null)) e = null
    else if (((n = t.tag), n === 13)) {
      if (((e = _8(t)), e !== null)) return e
      e = null
    } else if (n === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated)
        return t.tag === 3 ? t.stateNode.containerInfo : null
      e = null
    } else t !== e && (e = null)
  return ((uu = e), null)
}
function V8(e) {
  switch (e) {
    case 'cancel':
    case 'click':
    case 'close':
    case 'contextmenu':
    case 'copy':
    case 'cut':
    case 'auxclick':
    case 'dblclick':
    case 'dragend':
    case 'dragstart':
    case 'drop':
    case 'focusin':
    case 'focusout':
    case 'input':
    case 'invalid':
    case 'keydown':
    case 'keypress':
    case 'keyup':
    case 'mousedown':
    case 'mouseup':
    case 'paste':
    case 'pause':
    case 'play':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointerup':
    case 'ratechange':
    case 'reset':
    case 'resize':
    case 'seeked':
    case 'submit':
    case 'touchcancel':
    case 'touchend':
    case 'touchstart':
    case 'volumechange':
    case 'change':
    case 'selectionchange':
    case 'textInput':
    case 'compositionstart':
    case 'compositionend':
    case 'compositionupdate':
    case 'beforeblur':
    case 'afterblur':
    case 'beforeinput':
    case 'blur':
    case 'fullscreenchange':
    case 'focus':
    case 'hashchange':
    case 'popstate':
    case 'select':
    case 'selectstart':
      return 1
    case 'drag':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'mousemove':
    case 'mouseout':
    case 'mouseover':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'scroll':
    case 'toggle':
    case 'touchmove':
    case 'wheel':
    case 'mouseenter':
    case 'mouseleave':
    case 'pointerenter':
    case 'pointerleave':
      return 4
    case 'message':
      switch (_v()) {
        case Df:
          return 1
        case R8:
          return 4
        case au:
        case Iv:
          return 16
        case M8:
          return 536870912
        default:
          return 16
      }
    default:
      return 16
  }
}
var fi = null,
  Ff = null,
  jc = null
function U8() {
  if (jc) return jc
  var e,
    t = Ff,
    n = t.length,
    r,
    i = 'value' in fi ? fi.value : fi.textContent,
    o = i.length
  for (e = 0; e < n && t[e] === i[e]; e++);
  var c = n - e
  for (r = 1; r <= c && t[n - r] === i[o - r]; r++);
  return (jc = i.slice(e, 1 < r ? 1 - r : void 0))
}
function Vc(e) {
  var t = e.keyCode
  return (
    'charCode' in e ? ((e = e.charCode), e === 0 && t === 13 && (e = 13)) : (e = t),
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
  )
}
function cc() {
  return !0
}
function Jp() {
  return !1
}
function jn(e) {
  function t(n, r, i, o, c) {
    ;((this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = o),
      (this.target = c),
      (this.currentTarget = null))
    for (var h in e) e.hasOwnProperty(h) && ((n = e[h]), (this[h] = n ? n(o) : o[h]))
    return (
      (this.isDefaultPrevented = (
        o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1
      )
        ? cc
        : Jp),
      (this.isPropagationStopped = Jp),
      this
    )
  }
  return (
    dt(t.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0
        var n = this.nativeEvent
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != 'unknown' && (n.returnValue = !1),
          (this.isDefaultPrevented = cc))
      },
      stopPropagation: function () {
        var n = this.nativeEvent
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != 'unknown' && (n.cancelBubble = !0),
          (this.isPropagationStopped = cc))
      },
      persist: function () {},
      isPersistent: cc,
    }),
    t
  )
}
var Xo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
      return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  jf = jn(Xo),
  Pl = dt({}, Xo, { view: 0, detail: 0 }),
  Uv = jn(Pl),
  Jh,
  ed,
  ma,
  qu = dt({}, Pl, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Vf,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
      return e.relatedTarget === void 0
        ? e.fromElement === e.srcElement
          ? e.toElement
          : e.fromElement
        : e.relatedTarget
    },
    movementX: function (e) {
      return 'movementX' in e
        ? e.movementX
        : (e !== ma &&
            (ma && e.type === 'mousemove'
              ? ((Jh = e.screenX - ma.screenX), (ed = e.screenY - ma.screenY))
              : (ed = Jh = 0),
            (ma = e)),
          Jh)
    },
    movementY: function (e) {
      return 'movementY' in e ? e.movementY : ed
    },
  }),
  eg = jn(qu),
  Wv = dt({}, qu, { dataTransfer: 0 }),
  zv = jn(Wv),
  Hv = dt({}, Pl, { relatedTarget: 0 }),
  td = jn(Hv),
  Xv = dt({}, Xo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Gv = jn(Xv),
  Yv = dt({}, Xo, {
    clipboardData: function (e) {
      return 'clipboardData' in e ? e.clipboardData : window.clipboardData
    },
  }),
  Zv = jn(Yv),
  Kv = dt({}, Xo, { data: 0 }),
  tg = jn(Kv),
  qv = {
    Esc: 'Escape',
    Spacebar: ' ',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown',
    Del: 'Delete',
    Win: 'OS',
    Menu: 'ContextMenu',
    Apps: 'ContextMenu',
    Scroll: 'ScrollLock',
    MozPrintableKey: 'Unidentified',
  },
  Qv = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta',
  },
  $v = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
function Jv(e) {
  var t = this.nativeEvent
  return t.getModifierState ? t.getModifierState(e) : (e = $v[e]) ? !!t[e] : !1
}
function Vf() {
  return Jv
}
var ex = dt({}, Pl, {
    key: function (e) {
      if (e.key) {
        var t = qv[e.key] || e.key
        if (t !== 'Unidentified') return t
      }
      return e.type === 'keypress'
        ? ((e = Vc(e)), e === 13 ? 'Enter' : String.fromCharCode(e))
        : e.type === 'keydown' || e.type === 'keyup'
          ? Qv[e.keyCode] || 'Unidentified'
          : ''
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Vf,
    charCode: function (e) {
      return e.type === 'keypress' ? Vc(e) : 0
    },
    keyCode: function (e) {
      return e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0
    },
    which: function (e) {
      return e.type === 'keypress'
        ? Vc(e)
        : e.type === 'keydown' || e.type === 'keyup'
          ? e.keyCode
          : 0
    },
  }),
  tx = jn(ex),
  nx = dt({}, qu, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  ng = jn(nx),
  rx = dt({}, Pl, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Vf,
  }),
  ix = jn(rx),
  sx = dt({}, Xo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  ox = jn(sx),
  ax = dt({}, qu, {
    deltaX: function (e) {
      return 'deltaX' in e ? e.deltaX : 'wheelDeltaX' in e ? -e.wheelDeltaX : 0
    },
    deltaY: function (e) {
      return 'deltaY' in e
        ? e.deltaY
        : 'wheelDeltaY' in e
          ? -e.wheelDeltaY
          : 'wheelDelta' in e
            ? -e.wheelDelta
            : 0
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  lx = jn(ax),
  cx = [9, 13, 27, 32],
  Uf = Xr && 'CompositionEvent' in window,
  Fa = null
Xr && 'documentMode' in document && (Fa = document.documentMode)
var ux = Xr && 'TextEvent' in window && !Fa,
  W8 = Xr && (!Uf || (Fa && 8 < Fa && 11 >= Fa)),
  rg = ' ',
  ig = !1
function z8(e, t) {
  switch (e) {
    case 'keyup':
      return cx.indexOf(t.keyCode) !== -1
    case 'keydown':
      return t.keyCode !== 229
    case 'keypress':
    case 'mousedown':
    case 'focusout':
      return !0
    default:
      return !1
  }
}
function H8(e) {
  return ((e = e.detail), typeof e == 'object' && 'data' in e ? e.data : null)
}
var so = !1
function hx(e, t) {
  switch (e) {
    case 'compositionend':
      return H8(t)
    case 'keypress':
      return t.which !== 32 ? null : ((ig = !0), rg)
    case 'textInput':
      return ((e = t.data), e === rg && ig ? null : e)
    default:
      return null
  }
}
function dx(e, t) {
  if (so)
    return e === 'compositionend' || (!Uf && z8(e, t))
      ? ((e = U8()), (jc = Ff = fi = null), (so = !1), e)
      : null
  switch (e) {
    case 'paste':
      return null
    case 'keypress':
      if (!(t.ctrlKey || t.altKey || t.metaKey) || (t.ctrlKey && t.altKey)) {
        if (t.char && 1 < t.char.length) return t.char
        if (t.which) return String.fromCharCode(t.which)
      }
      return null
    case 'compositionend':
      return W8 && t.locale !== 'ko' ? null : t.data
    default:
      return null
  }
}
var fx = {
  color: !0,
  date: !0,
  datetime: !0,
  'datetime-local': !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
}
function sg(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return t === 'input' ? !!fx[e.type] : t === 'textarea'
}
function X8(e, t, n, r) {
  ;(E8(r),
    (t = hu(t, 'onChange')),
    0 < t.length &&
      ((n = new jf('onChange', 'change', null, n, r)), e.push({ event: n, listeners: t })))
}
var ja = null,
  al = null
function px(e) {
  n4(e, 0)
}
function Qu(e) {
  var t = lo(e)
  if (g8(t)) return e
}
function gx(e, t) {
  if (e === 'change') return t
}
var G8 = !1
if (Xr) {
  var nd
  if (Xr) {
    var rd = 'oninput' in document
    if (!rd) {
      var og = document.createElement('div')
      ;(og.setAttribute('oninput', 'return;'), (rd = typeof og.oninput == 'function'))
    }
    nd = rd
  } else nd = !1
  G8 = nd && (!document.documentMode || 9 < document.documentMode)
}
function ag() {
  ja && (ja.detachEvent('onpropertychange', Y8), (al = ja = null))
}
function Y8(e) {
  if (e.propertyName === 'value' && Qu(al)) {
    var t = []
    ;(X8(t, al, e, Pf(e)), k8(px, t))
  }
}
function mx(e, t, n) {
  e === 'focusin'
    ? (ag(), (ja = t), (al = n), ja.attachEvent('onpropertychange', Y8))
    : e === 'focusout' && ag()
}
function yx(e) {
  if (e === 'selectionchange' || e === 'keyup' || e === 'keydown') return Qu(al)
}
function wx(e, t) {
  if (e === 'click') return Qu(t)
}
function bx(e, t) {
  if (e === 'input' || e === 'change') return Qu(t)
}
function vx(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var hr = typeof Object.is == 'function' ? Object.is : vx
function ll(e, t) {
  if (hr(e, t)) return !0
  if (typeof e != 'object' || e === null || typeof t != 'object' || t === null) return !1
  var n = Object.keys(e),
    r = Object.keys(t)
  if (n.length !== r.length) return !1
  for (r = 0; r < n.length; r++) {
    var i = n[r]
    if (!Zd.call(t, i) || !hr(e[i], t[i])) return !1
  }
  return !0
}
function lg(e) {
  for (; e && e.firstChild; ) e = e.firstChild
  return e
}
function cg(e, t) {
  var n = lg(e)
  e = 0
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = e + n.textContent.length), e <= t && r >= t)) return { node: n, offset: t - e }
      e = r
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling
          break e
        }
        n = n.parentNode
      }
      n = void 0
    }
    n = lg(n)
  }
}
function Z8(e, t) {
  return e && t
    ? e === t
      ? !0
      : e && e.nodeType === 3
        ? !1
        : t && t.nodeType === 3
          ? Z8(e, t.parentNode)
          : 'contains' in e
            ? e.contains(t)
            : e.compareDocumentPosition
              ? !!(e.compareDocumentPosition(t) & 16)
              : !1
    : !1
}
function K8() {
  for (var e = window, t = iu(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var n = typeof t.contentWindow.location.href == 'string'
    } catch {
      n = !1
    }
    if (n) e = t.contentWindow
    else break
    t = iu(e.document)
  }
  return t
}
function Wf(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return (
    t &&
    ((t === 'input' &&
      (e.type === 'text' ||
        e.type === 'search' ||
        e.type === 'tel' ||
        e.type === 'url' ||
        e.type === 'password')) ||
      t === 'textarea' ||
      e.contentEditable === 'true')
  )
}
function xx(e) {
  var t = K8(),
    n = e.focusedElem,
    r = e.selectionRange
  if (t !== n && n && n.ownerDocument && Z8(n.ownerDocument.documentElement, n)) {
    if (r !== null && Wf(n)) {
      if (((t = r.start), (e = r.end), e === void 0 && (e = t), 'selectionStart' in n))
        ((n.selectionStart = t), (n.selectionEnd = Math.min(e, n.value.length)))
      else if (
        ((e = ((t = n.ownerDocument || document) && t.defaultView) || window), e.getSelection)
      ) {
        e = e.getSelection()
        var i = n.textContent.length,
          o = Math.min(r.start, i)
        ;((r = r.end === void 0 ? o : Math.min(r.end, i)),
          !e.extend && o > r && ((i = r), (r = o), (o = i)),
          (i = cg(n, o)))
        var c = cg(n, r)
        i &&
          c &&
          (e.rangeCount !== 1 ||
            e.anchorNode !== i.node ||
            e.anchorOffset !== i.offset ||
            e.focusNode !== c.node ||
            e.focusOffset !== c.offset) &&
          ((t = t.createRange()),
          t.setStart(i.node, i.offset),
          e.removeAllRanges(),
          o > r
            ? (e.addRange(t), e.extend(c.node, c.offset))
            : (t.setEnd(c.node, c.offset), e.addRange(t)))
      }
    }
    for (t = [], e = n; (e = e.parentNode); )
      e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop })
    for (typeof n.focus == 'function' && n.focus(), n = 0; n < t.length; n++)
      ((e = t[n]), (e.element.scrollLeft = e.left), (e.element.scrollTop = e.top))
  }
}
var Ex = Xr && 'documentMode' in document && 11 >= document.documentMode,
  oo = null,
  f1 = null,
  Va = null,
  p1 = !1
function ug(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument
  p1 ||
    oo == null ||
    oo !== iu(r) ||
    ((r = oo),
    'selectionStart' in r && Wf(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = ((r.ownerDocument && r.ownerDocument.defaultView) || window).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (Va && ll(Va, r)) ||
      ((Va = r),
      (r = hu(f1, 'onSelect')),
      0 < r.length &&
        ((t = new jf('onSelect', 'select', null, t, n)),
        e.push({ event: t, listeners: r }),
        (t.target = oo))))
}
function uc(e, t) {
  var n = {}
  return (
    (n[e.toLowerCase()] = t.toLowerCase()),
    (n['Webkit' + e] = 'webkit' + t),
    (n['Moz' + e] = 'moz' + t),
    n
  )
}
var ao = {
    animationend: uc('Animation', 'AnimationEnd'),
    animationiteration: uc('Animation', 'AnimationIteration'),
    animationstart: uc('Animation', 'AnimationStart'),
    transitionend: uc('Transition', 'TransitionEnd'),
  },
  id = {},
  q8 = {}
Xr &&
  ((q8 = document.createElement('div').style),
  'AnimationEvent' in window ||
    (delete ao.animationend.animation,
    delete ao.animationiteration.animation,
    delete ao.animationstart.animation),
  'TransitionEvent' in window || delete ao.transitionend.transition)
function $u(e) {
  if (id[e]) return id[e]
  if (!ao[e]) return e
  var t = ao[e],
    n
  for (n in t) if (t.hasOwnProperty(n) && n in q8) return (id[e] = t[n])
  return e
}
var Q8 = $u('animationend'),
  $8 = $u('animationiteration'),
  J8 = $u('animationstart'),
  e4 = $u('transitionend'),
  t4 = new Map(),
  hg =
    'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
      ' '
    )
function Bi(e, t) {
  ;(t4.set(e, t), As(t, [e]))
}
for (var sd = 0; sd < hg.length; sd++) {
  var od = hg[sd],
    Cx = od.toLowerCase(),
    Sx = od[0].toUpperCase() + od.slice(1)
  Bi(Cx, 'on' + Sx)
}
Bi(Q8, 'onAnimationEnd')
Bi($8, 'onAnimationIteration')
Bi(J8, 'onAnimationStart')
Bi('dblclick', 'onDoubleClick')
Bi('focusin', 'onFocus')
Bi('focusout', 'onBlur')
Bi(e4, 'onTransitionEnd')
To('onMouseEnter', ['mouseout', 'mouseover'])
To('onMouseLeave', ['mouseout', 'mouseover'])
To('onPointerEnter', ['pointerout', 'pointerover'])
To('onPointerLeave', ['pointerout', 'pointerover'])
As('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' '))
As(
  'onSelect',
  'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(' ')
)
As('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste'])
As('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' '))
As('onCompositionStart', 'compositionstart focusout keydown keypress keyup mousedown'.split(' '))
As('onCompositionUpdate', 'compositionupdate focusout keydown keypress keyup mousedown'.split(' '))
var Na =
    'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
      ' '
    ),
  Ax = new Set('cancel close invalid load scroll toggle'.split(' ').concat(Na))
function dg(e, t, n) {
  var r = e.type || 'unknown-event'
  ;((e.currentTarget = n), Cv(r, t, void 0, e), (e.currentTarget = null))
}
function n4(e, t) {
  t = (t & 4) !== 0
  for (var n = 0; n < e.length; n++) {
    var r = e[n],
      i = r.event
    r = r.listeners
    e: {
      var o = void 0
      if (t)
        for (var c = r.length - 1; 0 <= c; c--) {
          var h = r[c],
            f = h.instance,
            p = h.currentTarget
          if (((h = h.listener), f !== o && i.isPropagationStopped())) break e
          ;(dg(i, h, p), (o = f))
        }
      else
        for (c = 0; c < r.length; c++) {
          if (
            ((h = r[c]),
            (f = h.instance),
            (p = h.currentTarget),
            (h = h.listener),
            f !== o && i.isPropagationStopped())
          )
            break e
          ;(dg(i, h, p), (o = f))
        }
    }
  }
  if (ou) throw ((e = c1), (ou = !1), (c1 = null), e)
}
function et(e, t) {
  var n = t[b1]
  n === void 0 && (n = t[b1] = new Set())
  var r = e + '__bubble'
  n.has(r) || (r4(t, e, 2, !1), n.add(r))
}
function ad(e, t, n) {
  var r = 0
  ;(t && (r |= 4), r4(n, e, r, t))
}
var hc = '_reactListening' + Math.random().toString(36).slice(2)
function cl(e) {
  if (!e[hc]) {
    ;((e[hc] = !0),
      u8.forEach(function (n) {
        n !== 'selectionchange' && (Ax.has(n) || ad(n, !1, e), ad(n, !0, e))
      }))
    var t = e.nodeType === 9 ? e : e.ownerDocument
    t === null || t[hc] || ((t[hc] = !0), ad('selectionchange', !1, t))
  }
}
function r4(e, t, n, r) {
  switch (V8(t)) {
    case 1:
      var i = jv
      break
    case 4:
      i = Vv
      break
    default:
      i = Bf
  }
  ;((n = i.bind(null, t, n, e)),
    (i = void 0),
    !l1 || (t !== 'touchstart' && t !== 'touchmove' && t !== 'wheel') || (i = !0),
    r
      ? i !== void 0
        ? e.addEventListener(t, n, { capture: !0, passive: i })
        : e.addEventListener(t, n, !0)
      : i !== void 0
        ? e.addEventListener(t, n, { passive: i })
        : e.addEventListener(t, n, !1))
}
function ld(e, t, n, r, i) {
  var o = r
  if (!(t & 1) && !(t & 2) && r !== null)
    e: for (;;) {
      if (r === null) return
      var c = r.tag
      if (c === 3 || c === 4) {
        var h = r.stateNode.containerInfo
        if (h === i || (h.nodeType === 8 && h.parentNode === i)) break
        if (c === 4)
          for (c = r.return; c !== null; ) {
            var f = c.tag
            if (
              (f === 3 || f === 4) &&
              ((f = c.stateNode.containerInfo), f === i || (f.nodeType === 8 && f.parentNode === i))
            )
              return
            c = c.return
          }
        for (; h !== null; ) {
          if (((c = ss(h)), c === null)) return
          if (((f = c.tag), f === 5 || f === 6)) {
            r = o = c
            continue e
          }
          h = h.parentNode
        }
      }
      r = r.return
    }
  k8(function () {
    var p = o,
      y = Pf(n),
      w = []
    e: {
      var x = t4.get(e)
      if (x !== void 0) {
        var E = jf,
          S = e
        switch (e) {
          case 'keypress':
            if (Vc(n) === 0) break e
          case 'keydown':
          case 'keyup':
            E = tx
            break
          case 'focusin':
            ;((S = 'focus'), (E = td))
            break
          case 'focusout':
            ;((S = 'blur'), (E = td))
            break
          case 'beforeblur':
          case 'afterblur':
            E = td
            break
          case 'click':
            if (n.button === 2) break e
          case 'auxclick':
          case 'dblclick':
          case 'mousedown':
          case 'mousemove':
          case 'mouseup':
          case 'mouseout':
          case 'mouseover':
          case 'contextmenu':
            E = eg
            break
          case 'drag':
          case 'dragend':
          case 'dragenter':
          case 'dragexit':
          case 'dragleave':
          case 'dragover':
          case 'dragstart':
          case 'drop':
            E = zv
            break
          case 'touchcancel':
          case 'touchend':
          case 'touchmove':
          case 'touchstart':
            E = ix
            break
          case Q8:
          case $8:
          case J8:
            E = Gv
            break
          case e4:
            E = ox
            break
          case 'scroll':
            E = Uv
            break
          case 'wheel':
            E = lx
            break
          case 'copy':
          case 'cut':
          case 'paste':
            E = Zv
            break
          case 'gotpointercapture':
          case 'lostpointercapture':
          case 'pointercancel':
          case 'pointerdown':
          case 'pointermove':
          case 'pointerout':
          case 'pointerover':
          case 'pointerup':
            E = ng
        }
        var k = (t & 4) !== 0,
          P = !k && e === 'scroll',
          I = k ? (x !== null ? x + 'Capture' : null) : x
        k = []
        for (var R = p, M; R !== null; ) {
          M = R
          var O = M.stateNode
          if (
            (M.tag === 5 &&
              O !== null &&
              ((M = O), I !== null && ((O = rl(R, I)), O != null && k.push(ul(R, O, M)))),
            P)
          )
            break
          R = R.return
        }
        0 < k.length && ((x = new E(x, S, null, n, y)), w.push({ event: x, listeners: k }))
      }
    }
    if (!(t & 7)) {
      e: {
        if (
          ((x = e === 'mouseover' || e === 'pointerover'),
          (E = e === 'mouseout' || e === 'pointerout'),
          x && n !== o1 && (S = n.relatedTarget || n.fromElement) && (ss(S) || S[Gr]))
        )
          break e
        if (
          (E || x) &&
          ((x =
            y.window === y ? y : (x = y.ownerDocument) ? x.defaultView || x.parentWindow : window),
          E
            ? ((S = n.relatedTarget || n.toElement),
              (E = p),
              (S = S ? ss(S) : null),
              S !== null && ((P = ks(S)), S !== P || (S.tag !== 5 && S.tag !== 6)) && (S = null))
            : ((E = null), (S = p)),
          E !== S)
        ) {
          if (
            ((k = eg),
            (O = 'onMouseLeave'),
            (I = 'onMouseEnter'),
            (R = 'mouse'),
            (e === 'pointerout' || e === 'pointerover') &&
              ((k = ng), (O = 'onPointerLeave'), (I = 'onPointerEnter'), (R = 'pointer')),
            (P = E == null ? x : lo(E)),
            (M = S == null ? x : lo(S)),
            (x = new k(O, R + 'leave', E, n, y)),
            (x.target = P),
            (x.relatedTarget = M),
            (O = null),
            ss(y) === p &&
              ((k = new k(I, R + 'enter', S, n, y)),
              (k.target = M),
              (k.relatedTarget = P),
              (O = k)),
            (P = O),
            E && S)
          )
            t: {
              for (k = E, I = S, R = 0, M = k; M; M = eo(M)) R++
              for (M = 0, O = I; O; O = eo(O)) M++
              for (; 0 < R - M; ) ((k = eo(k)), R--)
              for (; 0 < M - R; ) ((I = eo(I)), M--)
              for (; R--; ) {
                if (k === I || (I !== null && k === I.alternate)) break t
                ;((k = eo(k)), (I = eo(I)))
              }
              k = null
            }
          else k = null
          ;(E !== null && fg(w, x, E, k, !1), S !== null && P !== null && fg(w, P, S, k, !0))
        }
      }
      e: {
        if (
          ((x = p ? lo(p) : window),
          (E = x.nodeName && x.nodeName.toLowerCase()),
          E === 'select' || (E === 'input' && x.type === 'file'))
        )
          var F = gx
        else if (sg(x))
          if (G8) F = bx
          else {
            F = yx
            var z = mx
          }
        else
          (E = x.nodeName) &&
            E.toLowerCase() === 'input' &&
            (x.type === 'checkbox' || x.type === 'radio') &&
            (F = wx)
        if (F && (F = F(e, p))) {
          X8(w, F, n, y)
          break e
        }
        ;(z && z(e, x, p),
          e === 'focusout' &&
            (z = x._wrapperState) &&
            z.controlled &&
            x.type === 'number' &&
            t1(x, 'number', x.value))
      }
      switch (((z = p ? lo(p) : window), e)) {
        case 'focusin':
          ;(sg(z) || z.contentEditable === 'true') && ((oo = z), (f1 = p), (Va = null))
          break
        case 'focusout':
          Va = f1 = oo = null
          break
        case 'mousedown':
          p1 = !0
          break
        case 'contextmenu':
        case 'mouseup':
        case 'dragend':
          ;((p1 = !1), ug(w, n, y))
          break
        case 'selectionchange':
          if (Ex) break
        case 'keydown':
        case 'keyup':
          ug(w, n, y)
      }
      var V
      if (Uf)
        e: {
          switch (e) {
            case 'compositionstart':
              var U = 'onCompositionStart'
              break e
            case 'compositionend':
              U = 'onCompositionEnd'
              break e
            case 'compositionupdate':
              U = 'onCompositionUpdate'
              break e
          }
          U = void 0
        }
      else
        so
          ? z8(e, n) && (U = 'onCompositionEnd')
          : e === 'keydown' && n.keyCode === 229 && (U = 'onCompositionStart')
      ;(U &&
        (W8 &&
          n.locale !== 'ko' &&
          (so || U !== 'onCompositionStart'
            ? U === 'onCompositionEnd' && so && (V = U8())
            : ((fi = y), (Ff = 'value' in fi ? fi.value : fi.textContent), (so = !0))),
        (z = hu(p, U)),
        0 < z.length &&
          ((U = new tg(U, e, null, n, y)),
          w.push({ event: U, listeners: z }),
          V ? (U.data = V) : ((V = H8(n)), V !== null && (U.data = V)))),
        (V = ux ? hx(e, n) : dx(e, n)) &&
          ((p = hu(p, 'onBeforeInput')),
          0 < p.length &&
            ((y = new tg('onBeforeInput', 'beforeinput', null, n, y)),
            w.push({ event: y, listeners: p }),
            (y.data = V))))
    }
    n4(w, t)
  })
}
function ul(e, t, n) {
  return { instance: e, listener: t, currentTarget: n }
}
function hu(e, t) {
  for (var n = t + 'Capture', r = []; e !== null; ) {
    var i = e,
      o = i.stateNode
    ;(i.tag === 5 &&
      o !== null &&
      ((i = o),
      (o = rl(e, n)),
      o != null && r.unshift(ul(e, o, i)),
      (o = rl(e, t)),
      o != null && r.push(ul(e, o, i))),
      (e = e.return))
  }
  return r
}
function eo(e) {
  if (e === null) return null
  do e = e.return
  while (e && e.tag !== 5)
  return e || null
}
function fg(e, t, n, r, i) {
  for (var o = t._reactName, c = []; n !== null && n !== r; ) {
    var h = n,
      f = h.alternate,
      p = h.stateNode
    if (f !== null && f === r) break
    ;(h.tag === 5 &&
      p !== null &&
      ((h = p),
      i
        ? ((f = rl(n, o)), f != null && c.unshift(ul(n, f, h)))
        : i || ((f = rl(n, o)), f != null && c.push(ul(n, f, h)))),
      (n = n.return))
  }
  c.length !== 0 && e.push({ event: t, listeners: c })
}
var kx = /\r\n?/g,
  _x = /\u0000|\uFFFD/g
function pg(e) {
  return (typeof e == 'string' ? e : '' + e)
    .replace(
      kx,
      `
`
    )
    .replace(_x, '')
}
function dc(e, t, n) {
  if (((t = pg(t)), pg(e) !== t && n)) throw Error(ee(425))
}
function du() {}
var g1 = null,
  m1 = null
function y1(e, t) {
  return (
    e === 'textarea' ||
    e === 'noscript' ||
    typeof t.children == 'string' ||
    typeof t.children == 'number' ||
    (typeof t.dangerouslySetInnerHTML == 'object' &&
      t.dangerouslySetInnerHTML !== null &&
      t.dangerouslySetInnerHTML.__html != null)
  )
}
var w1 = typeof setTimeout == 'function' ? setTimeout : void 0,
  Ix = typeof clearTimeout == 'function' ? clearTimeout : void 0,
  gg = typeof Promise == 'function' ? Promise : void 0,
  Nx =
    typeof queueMicrotask == 'function'
      ? queueMicrotask
      : typeof gg < 'u'
        ? function (e) {
            return gg.resolve(null).then(e).catch(Tx)
          }
        : w1
function Tx(e) {
  setTimeout(function () {
    throw e
  })
}
function cd(e, t) {
  var n = t,
    r = 0
  do {
    var i = n.nextSibling
    if ((e.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === '/$')) {
        if (r === 0) {
          ;(e.removeChild(i), ol(t))
          return
        }
        r--
      } else (n !== '$' && n !== '$?' && n !== '$!') || r++
    n = i
  } while (n)
  ol(t)
}
function Ai(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType
    if (t === 1 || t === 3) break
    if (t === 8) {
      if (((t = e.data), t === '$' || t === '$!' || t === '$?')) break
      if (t === '/$') return null
    }
  }
  return e
}
function mg(e) {
  e = e.previousSibling
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data
      if (n === '$' || n === '$!' || n === '$?') {
        if (t === 0) return e
        t--
      } else n === '/$' && t++
    }
    e = e.previousSibling
  }
  return null
}
var Go = Math.random().toString(36).slice(2),
  Sr = '__reactFiber$' + Go,
  hl = '__reactProps$' + Go,
  Gr = '__reactContainer$' + Go,
  b1 = '__reactEvents$' + Go,
  Rx = '__reactListeners$' + Go,
  Mx = '__reactHandles$' + Go
function ss(e) {
  var t = e[Sr]
  if (t) return t
  for (var n = e.parentNode; n; ) {
    if ((t = n[Gr] || n[Sr])) {
      if (((n = t.alternate), t.child !== null || (n !== null && n.child !== null)))
        for (e = mg(e); e !== null; ) {
          if ((n = e[Sr])) return n
          e = mg(e)
        }
      return t
    }
    ;((e = n), (n = e.parentNode))
  }
  return null
}
function Dl(e) {
  return (
    (e = e[Sr] || e[Gr]),
    !e || (e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3) ? null : e
  )
}
function lo(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode
  throw Error(ee(33))
}
function Ju(e) {
  return e[hl] || null
}
var v1 = [],
  co = -1
function Fi(e) {
  return { current: e }
}
function nt(e) {
  0 > co || ((e.current = v1[co]), (v1[co] = null), co--)
}
function $e(e, t) {
  ;(co++, (v1[co] = e.current), (e.current = t))
}
var Pi = {},
  en = Fi(Pi),
  vn = Fi(!1),
  ms = Pi
function Ro(e, t) {
  var n = e.type.contextTypes
  if (!n) return Pi
  var r = e.stateNode
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
    return r.__reactInternalMemoizedMaskedChildContext
  var i = {},
    o
  for (o in n) i[o] = t[o]
  return (
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = t),
      (e.__reactInternalMemoizedMaskedChildContext = i)),
    i
  )
}
function xn(e) {
  return ((e = e.childContextTypes), e != null)
}
function fu() {
  ;(nt(vn), nt(en))
}
function yg(e, t, n) {
  if (en.current !== Pi) throw Error(ee(168))
  ;($e(en, t), $e(vn, n))
}
function i4(e, t, n) {
  var r = e.stateNode
  if (((t = t.childContextTypes), typeof r.getChildContext != 'function')) return n
  r = r.getChildContext()
  for (var i in r) if (!(i in t)) throw Error(ee(108, mv(e) || 'Unknown', i))
  return dt({}, n, r)
}
function pu(e) {
  return (
    (e = ((e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext) || Pi),
    (ms = en.current),
    $e(en, e),
    $e(vn, vn.current),
    !0
  )
}
function wg(e, t, n) {
  var r = e.stateNode
  if (!r) throw Error(ee(169))
  ;(n
    ? ((e = i4(e, t, ms)),
      (r.__reactInternalMemoizedMergedChildContext = e),
      nt(vn),
      nt(en),
      $e(en, e))
    : nt(vn),
    $e(vn, n))
}
var Or = null,
  eh = !1,
  ud = !1
function s4(e) {
  Or === null ? (Or = [e]) : Or.push(e)
}
function Px(e) {
  ;((eh = !0), s4(e))
}
function ji() {
  if (!ud && Or !== null) {
    ud = !0
    var e = 0,
      t = He
    try {
      var n = Or
      for (He = 1; e < n.length; e++) {
        var r = n[e]
        do r = r(!0)
        while (r !== null)
      }
      ;((Or = null), (eh = !1))
    } catch (i) {
      throw (Or !== null && (Or = Or.slice(e + 1)), T8(Df, ji), i)
    } finally {
      ;((He = t), (ud = !1))
    }
  }
  return null
}
var uo = [],
  ho = 0,
  gu = null,
  mu = 0,
  Yn = [],
  Zn = 0,
  ys = null,
  Fr = 1,
  jr = ''
function Ji(e, t) {
  ;((uo[ho++] = mu), (uo[ho++] = gu), (gu = e), (mu = t))
}
function o4(e, t, n) {
  ;((Yn[Zn++] = Fr), (Yn[Zn++] = jr), (Yn[Zn++] = ys), (ys = e))
  var r = Fr
  e = jr
  var i = 32 - cr(r) - 1
  ;((r &= ~(1 << i)), (n += 1))
  var o = 32 - cr(t) + i
  if (30 < o) {
    var c = i - (i % 5)
    ;((o = (r & ((1 << c) - 1)).toString(32)),
      (r >>= c),
      (i -= c),
      (Fr = (1 << (32 - cr(t) + i)) | (n << i) | r),
      (jr = o + e))
  } else ((Fr = (1 << o) | (n << i) | r), (jr = e))
}
function zf(e) {
  e.return !== null && (Ji(e, 1), o4(e, 1, 0))
}
function Hf(e) {
  for (; e === gu; ) ((gu = uo[--ho]), (uo[ho] = null), (mu = uo[--ho]), (uo[ho] = null))
  for (; e === ys; )
    ((ys = Yn[--Zn]),
      (Yn[Zn] = null),
      (jr = Yn[--Zn]),
      (Yn[Zn] = null),
      (Fr = Yn[--Zn]),
      (Yn[Zn] = null))
}
var Pn = null,
  Tn = null,
  st = !1,
  lr = null
function a4(e, t) {
  var n = Kn(5, null, null, 0)
  ;((n.elementType = 'DELETED'),
    (n.stateNode = t),
    (n.return = e),
    (t = e.deletions),
    t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n))
}
function bg(e, t) {
  switch (e.tag) {
    case 5:
      var n = e.type
      return (
        (t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t),
        t !== null ? ((e.stateNode = t), (Pn = e), (Tn = Ai(t.firstChild)), !0) : !1
      )
    case 6:
      return (
        (t = e.pendingProps === '' || t.nodeType !== 3 ? null : t),
        t !== null ? ((e.stateNode = t), (Pn = e), (Tn = null), !0) : !1
      )
    case 13:
      return (
        (t = t.nodeType !== 8 ? null : t),
        t !== null
          ? ((n = ys !== null ? { id: Fr, overflow: jr } : null),
            (e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }),
            (n = Kn(18, null, null, 0)),
            (n.stateNode = t),
            (n.return = e),
            (e.child = n),
            (Pn = e),
            (Tn = null),
            !0)
          : !1
      )
    default:
      return !1
  }
}
function x1(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}
function E1(e) {
  if (st) {
    var t = Tn
    if (t) {
      var n = t
      if (!bg(e, t)) {
        if (x1(e)) throw Error(ee(418))
        t = Ai(n.nextSibling)
        var r = Pn
        t && bg(e, t) ? a4(r, n) : ((e.flags = (e.flags & -4097) | 2), (st = !1), (Pn = e))
      }
    } else {
      if (x1(e)) throw Error(ee(418))
      ;((e.flags = (e.flags & -4097) | 2), (st = !1), (Pn = e))
    }
  }
}
function vg(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; ) e = e.return
  Pn = e
}
function fc(e) {
  if (e !== Pn) return !1
  if (!st) return (vg(e), (st = !0), !1)
  var t
  if (
    ((t = e.tag !== 3) &&
      !(t = e.tag !== 5) &&
      ((t = e.type), (t = t !== 'head' && t !== 'body' && !y1(e.type, e.memoizedProps))),
    t && (t = Tn))
  ) {
    if (x1(e)) throw (l4(), Error(ee(418)))
    for (; t; ) (a4(e, t), (t = Ai(t.nextSibling)))
  }
  if ((vg(e), e.tag === 13)) {
    if (((e = e.memoizedState), (e = e !== null ? e.dehydrated : null), !e)) throw Error(ee(317))
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var n = e.data
          if (n === '/$') {
            if (t === 0) {
              Tn = Ai(e.nextSibling)
              break e
            }
            t--
          } else (n !== '$' && n !== '$!' && n !== '$?') || t++
        }
        e = e.nextSibling
      }
      Tn = null
    }
  } else Tn = Pn ? Ai(e.stateNode.nextSibling) : null
  return !0
}
function l4() {
  for (var e = Tn; e; ) e = Ai(e.nextSibling)
}
function Mo() {
  ;((Tn = Pn = null), (st = !1))
}
function Xf(e) {
  lr === null ? (lr = [e]) : lr.push(e)
}
var Dx = qr.ReactCurrentBatchConfig
function ya(e, t, n) {
  if (((e = n.ref), e !== null && typeof e != 'function' && typeof e != 'object')) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(ee(309))
        var r = n.stateNode
      }
      if (!r) throw Error(ee(147, e))
      var i = r,
        o = '' + e
      return t !== null && t.ref !== null && typeof t.ref == 'function' && t.ref._stringRef === o
        ? t.ref
        : ((t = function (c) {
            var h = i.refs
            c === null ? delete h[o] : (h[o] = c)
          }),
          (t._stringRef = o),
          t)
    }
    if (typeof e != 'string') throw Error(ee(284))
    if (!n._owner) throw Error(ee(290, e))
  }
  return e
}
function pc(e, t) {
  throw (
    (e = Object.prototype.toString.call(t)),
    Error(
      ee(31, e === '[object Object]' ? 'object with keys {' + Object.keys(t).join(', ') + '}' : e)
    )
  )
}
function xg(e) {
  var t = e._init
  return t(e._payload)
}
function c4(e) {
  function t(I, R) {
    if (e) {
      var M = I.deletions
      M === null ? ((I.deletions = [R]), (I.flags |= 16)) : M.push(R)
    }
  }
  function n(I, R) {
    if (!e) return null
    for (; R !== null; ) (t(I, R), (R = R.sibling))
    return null
  }
  function r(I, R) {
    for (I = new Map(); R !== null; )
      (R.key !== null ? I.set(R.key, R) : I.set(R.index, R), (R = R.sibling))
    return I
  }
  function i(I, R) {
    return ((I = Ni(I, R)), (I.index = 0), (I.sibling = null), I)
  }
  function o(I, R, M) {
    return (
      (I.index = M),
      e
        ? ((M = I.alternate),
          M !== null ? ((M = M.index), M < R ? ((I.flags |= 2), R) : M) : ((I.flags |= 2), R))
        : ((I.flags |= 1048576), R)
    )
  }
  function c(I) {
    return (e && I.alternate === null && (I.flags |= 2), I)
  }
  function h(I, R, M, O) {
    return R === null || R.tag !== 6
      ? ((R = yd(M, I.mode, O)), (R.return = I), R)
      : ((R = i(R, M)), (R.return = I), R)
  }
  function f(I, R, M, O) {
    var F = M.type
    return F === io
      ? y(I, R, M.props.children, O, M.key)
      : R !== null &&
          (R.elementType === F ||
            (typeof F == 'object' && F !== null && F.$$typeof === ci && xg(F) === R.type))
        ? ((O = i(R, M.props)), (O.ref = ya(I, R, M)), (O.return = I), O)
        : ((O = Yc(M.type, M.key, M.props, null, I.mode, O)),
          (O.ref = ya(I, R, M)),
          (O.return = I),
          O)
  }
  function p(I, R, M, O) {
    return R === null ||
      R.tag !== 4 ||
      R.stateNode.containerInfo !== M.containerInfo ||
      R.stateNode.implementation !== M.implementation
      ? ((R = wd(M, I.mode, O)), (R.return = I), R)
      : ((R = i(R, M.children || [])), (R.return = I), R)
  }
  function y(I, R, M, O, F) {
    return R === null || R.tag !== 7
      ? ((R = hs(M, I.mode, O, F)), (R.return = I), R)
      : ((R = i(R, M)), (R.return = I), R)
  }
  function w(I, R, M) {
    if ((typeof R == 'string' && R !== '') || typeof R == 'number')
      return ((R = yd('' + R, I.mode, M)), (R.return = I), R)
    if (typeof R == 'object' && R !== null) {
      switch (R.$$typeof) {
        case rc:
          return (
            (M = Yc(R.type, R.key, R.props, null, I.mode, M)),
            (M.ref = ya(I, null, R)),
            (M.return = I),
            M
          )
        case ro:
          return ((R = wd(R, I.mode, M)), (R.return = I), R)
        case ci:
          var O = R._init
          return w(I, O(R._payload), M)
      }
      if (_a(R) || da(R)) return ((R = hs(R, I.mode, M, null)), (R.return = I), R)
      pc(I, R)
    }
    return null
  }
  function x(I, R, M, O) {
    var F = R !== null ? R.key : null
    if ((typeof M == 'string' && M !== '') || typeof M == 'number')
      return F !== null ? null : h(I, R, '' + M, O)
    if (typeof M == 'object' && M !== null) {
      switch (M.$$typeof) {
        case rc:
          return M.key === F ? f(I, R, M, O) : null
        case ro:
          return M.key === F ? p(I, R, M, O) : null
        case ci:
          return ((F = M._init), x(I, R, F(M._payload), O))
      }
      if (_a(M) || da(M)) return F !== null ? null : y(I, R, M, O, null)
      pc(I, M)
    }
    return null
  }
  function E(I, R, M, O, F) {
    if ((typeof O == 'string' && O !== '') || typeof O == 'number')
      return ((I = I.get(M) || null), h(R, I, '' + O, F))
    if (typeof O == 'object' && O !== null) {
      switch (O.$$typeof) {
        case rc:
          return ((I = I.get(O.key === null ? M : O.key) || null), f(R, I, O, F))
        case ro:
          return ((I = I.get(O.key === null ? M : O.key) || null), p(R, I, O, F))
        case ci:
          var z = O._init
          return E(I, R, M, z(O._payload), F)
      }
      if (_a(O) || da(O)) return ((I = I.get(M) || null), y(R, I, O, F, null))
      pc(R, O)
    }
    return null
  }
  function S(I, R, M, O) {
    for (var F = null, z = null, V = R, U = (R = 0), Z = null; V !== null && U < M.length; U++) {
      V.index > U ? ((Z = V), (V = null)) : (Z = V.sibling)
      var J = x(I, V, M[U], O)
      if (J === null) {
        V === null && (V = Z)
        break
      }
      ;(e && V && J.alternate === null && t(I, V),
        (R = o(J, R, U)),
        z === null ? (F = J) : (z.sibling = J),
        (z = J),
        (V = Z))
    }
    if (U === M.length) return (n(I, V), st && Ji(I, U), F)
    if (V === null) {
      for (; U < M.length; U++)
        ((V = w(I, M[U], O)),
          V !== null && ((R = o(V, R, U)), z === null ? (F = V) : (z.sibling = V), (z = V)))
      return (st && Ji(I, U), F)
    }
    for (V = r(I, V); U < M.length; U++)
      ((Z = E(V, I, U, M[U], O)),
        Z !== null &&
          (e && Z.alternate !== null && V.delete(Z.key === null ? U : Z.key),
          (R = o(Z, R, U)),
          z === null ? (F = Z) : (z.sibling = Z),
          (z = Z)))
    return (
      e &&
        V.forEach(function (oe) {
          return t(I, oe)
        }),
      st && Ji(I, U),
      F
    )
  }
  function k(I, R, M, O) {
    var F = da(M)
    if (typeof F != 'function') throw Error(ee(150))
    if (((M = F.call(M)), M == null)) throw Error(ee(151))
    for (
      var z = (F = null), V = R, U = (R = 0), Z = null, J = M.next();
      V !== null && !J.done;
      U++, J = M.next()
    ) {
      V.index > U ? ((Z = V), (V = null)) : (Z = V.sibling)
      var oe = x(I, V, J.value, O)
      if (oe === null) {
        V === null && (V = Z)
        break
      }
      ;(e && V && oe.alternate === null && t(I, V),
        (R = o(oe, R, U)),
        z === null ? (F = oe) : (z.sibling = oe),
        (z = oe),
        (V = Z))
    }
    if (J.done) return (n(I, V), st && Ji(I, U), F)
    if (V === null) {
      for (; !J.done; U++, J = M.next())
        ((J = w(I, J.value, O)),
          J !== null && ((R = o(J, R, U)), z === null ? (F = J) : (z.sibling = J), (z = J)))
      return (st && Ji(I, U), F)
    }
    for (V = r(I, V); !J.done; U++, J = M.next())
      ((J = E(V, I, U, J.value, O)),
        J !== null &&
          (e && J.alternate !== null && V.delete(J.key === null ? U : J.key),
          (R = o(J, R, U)),
          z === null ? (F = J) : (z.sibling = J),
          (z = J)))
    return (
      e &&
        V.forEach(function (re) {
          return t(I, re)
        }),
      st && Ji(I, U),
      F
    )
  }
  function P(I, R, M, O) {
    if (
      (typeof M == 'object' &&
        M !== null &&
        M.type === io &&
        M.key === null &&
        (M = M.props.children),
      typeof M == 'object' && M !== null)
    ) {
      switch (M.$$typeof) {
        case rc:
          e: {
            for (var F = M.key, z = R; z !== null; ) {
              if (z.key === F) {
                if (((F = M.type), F === io)) {
                  if (z.tag === 7) {
                    ;(n(I, z.sibling), (R = i(z, M.props.children)), (R.return = I), (I = R))
                    break e
                  }
                } else if (
                  z.elementType === F ||
                  (typeof F == 'object' && F !== null && F.$$typeof === ci && xg(F) === z.type)
                ) {
                  ;(n(I, z.sibling),
                    (R = i(z, M.props)),
                    (R.ref = ya(I, z, M)),
                    (R.return = I),
                    (I = R))
                  break e
                }
                n(I, z)
                break
              } else t(I, z)
              z = z.sibling
            }
            M.type === io
              ? ((R = hs(M.props.children, I.mode, O, M.key)), (R.return = I), (I = R))
              : ((O = Yc(M.type, M.key, M.props, null, I.mode, O)),
                (O.ref = ya(I, R, M)),
                (O.return = I),
                (I = O))
          }
          return c(I)
        case ro:
          e: {
            for (z = M.key; R !== null; ) {
              if (R.key === z)
                if (
                  R.tag === 4 &&
                  R.stateNode.containerInfo === M.containerInfo &&
                  R.stateNode.implementation === M.implementation
                ) {
                  ;(n(I, R.sibling), (R = i(R, M.children || [])), (R.return = I), (I = R))
                  break e
                } else {
                  n(I, R)
                  break
                }
              else t(I, R)
              R = R.sibling
            }
            ;((R = wd(M, I.mode, O)), (R.return = I), (I = R))
          }
          return c(I)
        case ci:
          return ((z = M._init), P(I, R, z(M._payload), O))
      }
      if (_a(M)) return S(I, R, M, O)
      if (da(M)) return k(I, R, M, O)
      pc(I, M)
    }
    return (typeof M == 'string' && M !== '') || typeof M == 'number'
      ? ((M = '' + M),
        R !== null && R.tag === 6
          ? (n(I, R.sibling), (R = i(R, M)), (R.return = I), (I = R))
          : (n(I, R), (R = yd(M, I.mode, O)), (R.return = I), (I = R)),
        c(I))
      : n(I, R)
  }
  return P
}
var Po = c4(!0),
  u4 = c4(!1),
  yu = Fi(null),
  wu = null,
  fo = null,
  Gf = null
function Yf() {
  Gf = fo = wu = null
}
function Zf(e) {
  var t = yu.current
  ;(nt(yu), (e._currentValue = t))
}
function C1(e, t, n) {
  for (; e !== null; ) {
    var r = e.alternate
    if (
      ((e.childLanes & t) !== t
        ? ((e.childLanes |= t), r !== null && (r.childLanes |= t))
        : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t),
      e === n)
    )
      break
    e = e.return
  }
}
function _o(e, t) {
  ;((wu = e),
    (Gf = fo = null),
    (e = e.dependencies),
    e !== null && e.firstContext !== null && (e.lanes & t && (bn = !0), (e.firstContext = null)))
}
function $n(e) {
  var t = e._currentValue
  if (Gf !== e)
    if (((e = { context: e, memoizedValue: t, next: null }), fo === null)) {
      if (wu === null) throw Error(ee(308))
      ;((fo = e), (wu.dependencies = { lanes: 0, firstContext: e }))
    } else fo = fo.next = e
  return t
}
var os = null
function Kf(e) {
  os === null ? (os = [e]) : os.push(e)
}
function h4(e, t, n, r) {
  var i = t.interleaved
  return (
    i === null ? ((n.next = n), Kf(t)) : ((n.next = i.next), (i.next = n)),
    (t.interleaved = n),
    Yr(e, r)
  )
}
function Yr(e, t) {
  e.lanes |= t
  var n = e.alternate
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null; )
    ((e.childLanes |= t),
      (n = e.alternate),
      n !== null && (n.childLanes |= t),
      (n = e),
      (e = e.return))
  return n.tag === 3 ? n.stateNode : null
}
var ui = !1
function qf(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  }
}
function d4(e, t) {
  ;((e = e.updateQueue),
    t.updateQueue === e &&
      (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects,
      }))
}
function Wr(e, t) {
  return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null }
}
function ki(e, t, n) {
  var r = e.updateQueue
  if (r === null) return null
  if (((r = r.shared), Le & 2)) {
    var i = r.pending
    return (
      i === null ? (t.next = t) : ((t.next = i.next), (i.next = t)),
      (r.pending = t),
      Yr(e, n)
    )
  }
  return (
    (i = r.interleaved),
    i === null ? ((t.next = t), Kf(r)) : ((t.next = i.next), (i.next = t)),
    (r.interleaved = t),
    Yr(e, n)
  )
}
function Uc(e, t, n) {
  if (((t = t.updateQueue), t !== null && ((t = t.shared), (n & 4194240) !== 0))) {
    var r = t.lanes
    ;((r &= e.pendingLanes), (n |= r), (t.lanes = n), Lf(e, n))
  }
}
function Eg(e, t) {
  var n = e.updateQueue,
    r = e.alternate
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      o = null
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var c = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        }
        ;(o === null ? (i = o = c) : (o = o.next = c), (n = n.next))
      } while (n !== null)
      o === null ? (i = o = t) : (o = o.next = t)
    } else i = o = t
    ;((n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: o,
      shared: r.shared,
      effects: r.effects,
    }),
      (e.updateQueue = n))
    return
  }
  ;((e = n.lastBaseUpdate),
    e === null ? (n.firstBaseUpdate = t) : (e.next = t),
    (n.lastBaseUpdate = t))
}
function bu(e, t, n, r) {
  var i = e.updateQueue
  ui = !1
  var o = i.firstBaseUpdate,
    c = i.lastBaseUpdate,
    h = i.shared.pending
  if (h !== null) {
    i.shared.pending = null
    var f = h,
      p = f.next
    ;((f.next = null), c === null ? (o = p) : (c.next = p), (c = f))
    var y = e.alternate
    y !== null &&
      ((y = y.updateQueue),
      (h = y.lastBaseUpdate),
      h !== c && (h === null ? (y.firstBaseUpdate = p) : (h.next = p), (y.lastBaseUpdate = f)))
  }
  if (o !== null) {
    var w = i.baseState
    ;((c = 0), (y = p = f = null), (h = o))
    do {
      var x = h.lane,
        E = h.eventTime
      if ((r & x) === x) {
        y !== null &&
          (y = y.next =
            {
              eventTime: E,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null,
            })
        e: {
          var S = e,
            k = h
          switch (((x = t), (E = n), k.tag)) {
            case 1:
              if (((S = k.payload), typeof S == 'function')) {
                w = S.call(E, w, x)
                break e
              }
              w = S
              break e
            case 3:
              S.flags = (S.flags & -65537) | 128
            case 0:
              if (((S = k.payload), (x = typeof S == 'function' ? S.call(E, w, x) : S), x == null))
                break e
              w = dt({}, w, x)
              break e
            case 2:
              ui = !0
          }
        }
        h.callback !== null &&
          h.lane !== 0 &&
          ((e.flags |= 64), (x = i.effects), x === null ? (i.effects = [h]) : x.push(h))
      } else
        ((E = {
          eventTime: E,
          lane: x,
          tag: h.tag,
          payload: h.payload,
          callback: h.callback,
          next: null,
        }),
          y === null ? ((p = y = E), (f = w)) : (y = y.next = E),
          (c |= x))
      if (((h = h.next), h === null)) {
        if (((h = i.shared.pending), h === null)) break
        ;((x = h), (h = x.next), (x.next = null), (i.lastBaseUpdate = x), (i.shared.pending = null))
      }
    } while (!0)
    if (
      (y === null && (f = w),
      (i.baseState = f),
      (i.firstBaseUpdate = p),
      (i.lastBaseUpdate = y),
      (t = i.shared.interleaved),
      t !== null)
    ) {
      i = t
      do ((c |= i.lane), (i = i.next))
      while (i !== t)
    } else o === null && (i.shared.lanes = 0)
    ;((bs |= c), (e.lanes = c), (e.memoizedState = w))
  }
}
function Cg(e, t, n) {
  if (((e = t.effects), (t.effects = null), e !== null))
    for (t = 0; t < e.length; t++) {
      var r = e[t],
        i = r.callback
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != 'function')) throw Error(ee(191, i))
        i.call(r)
      }
    }
}
var Ll = {},
  kr = Fi(Ll),
  dl = Fi(Ll),
  fl = Fi(Ll)
function as(e) {
  if (e === Ll) throw Error(ee(174))
  return e
}
function Qf(e, t) {
  switch (($e(fl, t), $e(dl, e), $e(kr, Ll), (e = t.nodeType), e)) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : r1(null, '')
      break
    default:
      ;((e = e === 8 ? t.parentNode : t),
        (t = e.namespaceURI || null),
        (e = e.tagName),
        (t = r1(t, e)))
  }
  ;(nt(kr), $e(kr, t))
}
function Do() {
  ;(nt(kr), nt(dl), nt(fl))
}
function f4(e) {
  as(fl.current)
  var t = as(kr.current),
    n = r1(t, e.type)
  t !== n && ($e(dl, e), $e(kr, n))
}
function $f(e) {
  dl.current === e && (nt(kr), nt(dl))
}
var at = Fi(0)
function vu(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var n = t.memoizedState
      if (n !== null && ((n = n.dehydrated), n === null || n.data === '$?' || n.data === '$!'))
        return t
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t
    } else if (t.child !== null) {
      ;((t.child.return = t), (t = t.child))
      continue
    }
    if (t === e) break
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null
      t = t.return
    }
    ;((t.sibling.return = t.return), (t = t.sibling))
  }
  return null
}
var hd = []
function Jf() {
  for (var e = 0; e < hd.length; e++) hd[e]._workInProgressVersionPrimary = null
  hd.length = 0
}
var Wc = qr.ReactCurrentDispatcher,
  dd = qr.ReactCurrentBatchConfig,
  ws = 0,
  ut = null,
  It = null,
  Dt = null,
  xu = !1,
  Ua = !1,
  pl = 0,
  Lx = 0
function Kt() {
  throw Error(ee(321))
}
function e0(e, t) {
  if (t === null) return !1
  for (var n = 0; n < t.length && n < e.length; n++) if (!hr(e[n], t[n])) return !1
  return !0
}
function t0(e, t, n, r, i, o) {
  if (
    ((ws = o),
    (ut = t),
    (t.memoizedState = null),
    (t.updateQueue = null),
    (t.lanes = 0),
    (Wc.current = e === null || e.memoizedState === null ? jx : Vx),
    (e = n(r, i)),
    Ua)
  ) {
    o = 0
    do {
      if (((Ua = !1), (pl = 0), 25 <= o)) throw Error(ee(301))
      ;((o += 1), (Dt = It = null), (t.updateQueue = null), (Wc.current = Ux), (e = n(r, i)))
    } while (Ua)
  }
  if (
    ((Wc.current = Eu),
    (t = It !== null && It.next !== null),
    (ws = 0),
    (Dt = It = ut = null),
    (xu = !1),
    t)
  )
    throw Error(ee(300))
  return e
}
function n0() {
  var e = pl !== 0
  return ((pl = 0), e)
}
function Er() {
  var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
  return (Dt === null ? (ut.memoizedState = Dt = e) : (Dt = Dt.next = e), Dt)
}
function Jn() {
  if (It === null) {
    var e = ut.alternate
    e = e !== null ? e.memoizedState : null
  } else e = It.next
  var t = Dt === null ? ut.memoizedState : Dt.next
  if (t !== null) ((Dt = t), (It = e))
  else {
    if (e === null) throw Error(ee(310))
    ;((It = e),
      (e = {
        memoizedState: It.memoizedState,
        baseState: It.baseState,
        baseQueue: It.baseQueue,
        queue: It.queue,
        next: null,
      }),
      Dt === null ? (ut.memoizedState = Dt = e) : (Dt = Dt.next = e))
  }
  return Dt
}
function gl(e, t) {
  return typeof t == 'function' ? t(e) : t
}
function fd(e) {
  var t = Jn(),
    n = t.queue
  if (n === null) throw Error(ee(311))
  n.lastRenderedReducer = e
  var r = It,
    i = r.baseQueue,
    o = n.pending
  if (o !== null) {
    if (i !== null) {
      var c = i.next
      ;((i.next = o.next), (o.next = c))
    }
    ;((r.baseQueue = i = o), (n.pending = null))
  }
  if (i !== null) {
    ;((o = i.next), (r = r.baseState))
    var h = (c = null),
      f = null,
      p = o
    do {
      var y = p.lane
      if ((ws & y) === y)
        (f !== null &&
          (f = f.next =
            {
              lane: 0,
              action: p.action,
              hasEagerState: p.hasEagerState,
              eagerState: p.eagerState,
              next: null,
            }),
          (r = p.hasEagerState ? p.eagerState : e(r, p.action)))
      else {
        var w = {
          lane: y,
          action: p.action,
          hasEagerState: p.hasEagerState,
          eagerState: p.eagerState,
          next: null,
        }
        ;(f === null ? ((h = f = w), (c = r)) : (f = f.next = w), (ut.lanes |= y), (bs |= y))
      }
      p = p.next
    } while (p !== null && p !== o)
    ;(f === null ? (c = r) : (f.next = h),
      hr(r, t.memoizedState) || (bn = !0),
      (t.memoizedState = r),
      (t.baseState = c),
      (t.baseQueue = f),
      (n.lastRenderedState = r))
  }
  if (((e = n.interleaved), e !== null)) {
    i = e
    do ((o = i.lane), (ut.lanes |= o), (bs |= o), (i = i.next))
    while (i !== e)
  } else i === null && (n.lanes = 0)
  return [t.memoizedState, n.dispatch]
}
function pd(e) {
  var t = Jn(),
    n = t.queue
  if (n === null) throw Error(ee(311))
  n.lastRenderedReducer = e
  var r = n.dispatch,
    i = n.pending,
    o = t.memoizedState
  if (i !== null) {
    n.pending = null
    var c = (i = i.next)
    do ((o = e(o, c.action)), (c = c.next))
    while (c !== i)
    ;(hr(o, t.memoizedState) || (bn = !0),
      (t.memoizedState = o),
      t.baseQueue === null && (t.baseState = o),
      (n.lastRenderedState = o))
  }
  return [o, r]
}
function p4() {}
function g4(e, t) {
  var n = ut,
    r = Jn(),
    i = t(),
    o = !hr(r.memoizedState, i)
  if (
    (o && ((r.memoizedState = i), (bn = !0)),
    (r = r.queue),
    r0(w4.bind(null, n, r, e), [e]),
    r.getSnapshot !== t || o || (Dt !== null && Dt.memoizedState.tag & 1))
  ) {
    if (((n.flags |= 2048), ml(9, y4.bind(null, n, r, i, t), void 0, null), Lt === null))
      throw Error(ee(349))
    ws & 30 || m4(n, t, i)
  }
  return i
}
function m4(e, t, n) {
  ;((e.flags |= 16384),
    (e = { getSnapshot: t, value: n }),
    (t = ut.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }), (ut.updateQueue = t), (t.stores = [e]))
      : ((n = t.stores), n === null ? (t.stores = [e]) : n.push(e)))
}
function y4(e, t, n, r) {
  ;((t.value = n), (t.getSnapshot = r), b4(t) && v4(e))
}
function w4(e, t, n) {
  return n(function () {
    b4(t) && v4(e)
  })
}
function b4(e) {
  var t = e.getSnapshot
  e = e.value
  try {
    var n = t()
    return !hr(e, n)
  } catch {
    return !0
  }
}
function v4(e) {
  var t = Yr(e, 1)
  t !== null && ur(t, e, 1, -1)
}
function Sg(e) {
  var t = Er()
  return (
    typeof e == 'function' && (e = e()),
    (t.memoizedState = t.baseState = e),
    (e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: gl,
      lastRenderedState: e,
    }),
    (t.queue = e),
    (e = e.dispatch = Fx.bind(null, ut, e)),
    [t.memoizedState, e]
  )
}
function ml(e, t, n, r) {
  return (
    (e = { tag: e, create: t, destroy: n, deps: r, next: null }),
    (t = ut.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (ut.updateQueue = t),
        (t.lastEffect = e.next = e))
      : ((n = t.lastEffect),
        n === null
          ? (t.lastEffect = e.next = e)
          : ((r = n.next), (n.next = e), (e.next = r), (t.lastEffect = e))),
    e
  )
}
function x4() {
  return Jn().memoizedState
}
function zc(e, t, n, r) {
  var i = Er()
  ;((ut.flags |= e), (i.memoizedState = ml(1 | t, n, void 0, r === void 0 ? null : r)))
}
function th(e, t, n, r) {
  var i = Jn()
  r = r === void 0 ? null : r
  var o = void 0
  if (It !== null) {
    var c = It.memoizedState
    if (((o = c.destroy), r !== null && e0(r, c.deps))) {
      i.memoizedState = ml(t, n, o, r)
      return
    }
  }
  ;((ut.flags |= e), (i.memoizedState = ml(1 | t, n, o, r)))
}
function Ag(e, t) {
  return zc(8390656, 8, e, t)
}
function r0(e, t) {
  return th(2048, 8, e, t)
}
function E4(e, t) {
  return th(4, 2, e, t)
}
function C4(e, t) {
  return th(4, 4, e, t)
}
function S4(e, t) {
  if (typeof t == 'function')
    return (
      (e = e()),
      t(e),
      function () {
        t(null)
      }
    )
  if (t != null)
    return (
      (e = e()),
      (t.current = e),
      function () {
        t.current = null
      }
    )
}
function A4(e, t, n) {
  return ((n = n != null ? n.concat([e]) : null), th(4, 4, S4.bind(null, t, e), n))
}
function i0() {}
function k4(e, t) {
  var n = Jn()
  t = t === void 0 ? null : t
  var r = n.memoizedState
  return r !== null && t !== null && e0(t, r[1]) ? r[0] : ((n.memoizedState = [e, t]), e)
}
function _4(e, t) {
  var n = Jn()
  t = t === void 0 ? null : t
  var r = n.memoizedState
  return r !== null && t !== null && e0(t, r[1]) ? r[0] : ((e = e()), (n.memoizedState = [e, t]), e)
}
function I4(e, t, n) {
  return ws & 21
    ? (hr(n, t) || ((n = P8()), (ut.lanes |= n), (bs |= n), (e.baseState = !0)), t)
    : (e.baseState && ((e.baseState = !1), (bn = !0)), (e.memoizedState = n))
}
function Ox(e, t) {
  var n = He
  ;((He = n !== 0 && 4 > n ? n : 4), e(!0))
  var r = dd.transition
  dd.transition = {}
  try {
    ;(e(!1), t())
  } finally {
    ;((He = n), (dd.transition = r))
  }
}
function N4() {
  return Jn().memoizedState
}
function Bx(e, t, n) {
  var r = Ii(e)
  if (((n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }), T4(e)))
    R4(t, n)
  else if (((n = h4(e, t, n, r)), n !== null)) {
    var i = sn()
    ;(ur(n, e, r, i), M4(n, t, r))
  }
}
function Fx(e, t, n) {
  var r = Ii(e),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }
  if (T4(e)) R4(t, i)
  else {
    var o = e.alternate
    if (e.lanes === 0 && (o === null || o.lanes === 0) && ((o = t.lastRenderedReducer), o !== null))
      try {
        var c = t.lastRenderedState,
          h = o(c, n)
        if (((i.hasEagerState = !0), (i.eagerState = h), hr(h, c))) {
          var f = t.interleaved
          ;(f === null ? ((i.next = i), Kf(t)) : ((i.next = f.next), (f.next = i)),
            (t.interleaved = i))
          return
        }
      } catch {
      } finally {
      }
    ;((n = h4(e, t, i, r)), n !== null && ((i = sn()), ur(n, e, r, i), M4(n, t, r)))
  }
}
function T4(e) {
  var t = e.alternate
  return e === ut || (t !== null && t === ut)
}
function R4(e, t) {
  Ua = xu = !0
  var n = e.pending
  ;(n === null ? (t.next = t) : ((t.next = n.next), (n.next = t)), (e.pending = t))
}
function M4(e, t, n) {
  if (n & 4194240) {
    var r = t.lanes
    ;((r &= e.pendingLanes), (n |= r), (t.lanes = n), Lf(e, n))
  }
}
var Eu = {
    readContext: $n,
    useCallback: Kt,
    useContext: Kt,
    useEffect: Kt,
    useImperativeHandle: Kt,
    useInsertionEffect: Kt,
    useLayoutEffect: Kt,
    useMemo: Kt,
    useReducer: Kt,
    useRef: Kt,
    useState: Kt,
    useDebugValue: Kt,
    useDeferredValue: Kt,
    useTransition: Kt,
    useMutableSource: Kt,
    useSyncExternalStore: Kt,
    useId: Kt,
    unstable_isNewReconciler: !1,
  },
  jx = {
    readContext: $n,
    useCallback: function (e, t) {
      return ((Er().memoizedState = [e, t === void 0 ? null : t]), e)
    },
    useContext: $n,
    useEffect: Ag,
    useImperativeHandle: function (e, t, n) {
      return ((n = n != null ? n.concat([e]) : null), zc(4194308, 4, S4.bind(null, t, e), n))
    },
    useLayoutEffect: function (e, t) {
      return zc(4194308, 4, e, t)
    },
    useInsertionEffect: function (e, t) {
      return zc(4, 2, e, t)
    },
    useMemo: function (e, t) {
      var n = Er()
      return ((t = t === void 0 ? null : t), (e = e()), (n.memoizedState = [e, t]), e)
    },
    useReducer: function (e, t, n) {
      var r = Er()
      return (
        (t = n !== void 0 ? n(t) : t),
        (r.memoizedState = r.baseState = t),
        (e = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: e,
          lastRenderedState: t,
        }),
        (r.queue = e),
        (e = e.dispatch = Bx.bind(null, ut, e)),
        [r.memoizedState, e]
      )
    },
    useRef: function (e) {
      var t = Er()
      return ((e = { current: e }), (t.memoizedState = e))
    },
    useState: Sg,
    useDebugValue: i0,
    useDeferredValue: function (e) {
      return (Er().memoizedState = e)
    },
    useTransition: function () {
      var e = Sg(!1),
        t = e[0]
      return ((e = Ox.bind(null, e[1])), (Er().memoizedState = e), [t, e])
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (e, t, n) {
      var r = ut,
        i = Er()
      if (st) {
        if (n === void 0) throw Error(ee(407))
        n = n()
      } else {
        if (((n = t()), Lt === null)) throw Error(ee(349))
        ws & 30 || m4(r, t, n)
      }
      i.memoizedState = n
      var o = { value: n, getSnapshot: t }
      return (
        (i.queue = o),
        Ag(w4.bind(null, r, o, e), [e]),
        (r.flags |= 2048),
        ml(9, y4.bind(null, r, o, n, t), void 0, null),
        n
      )
    },
    useId: function () {
      var e = Er(),
        t = Lt.identifierPrefix
      if (st) {
        var n = jr,
          r = Fr
        ;((n = (r & ~(1 << (32 - cr(r) - 1))).toString(32) + n),
          (t = ':' + t + 'R' + n),
          (n = pl++),
          0 < n && (t += 'H' + n.toString(32)),
          (t += ':'))
      } else ((n = Lx++), (t = ':' + t + 'r' + n.toString(32) + ':'))
      return (e.memoizedState = t)
    },
    unstable_isNewReconciler: !1,
  },
  Vx = {
    readContext: $n,
    useCallback: k4,
    useContext: $n,
    useEffect: r0,
    useImperativeHandle: A4,
    useInsertionEffect: E4,
    useLayoutEffect: C4,
    useMemo: _4,
    useReducer: fd,
    useRef: x4,
    useState: function () {
      return fd(gl)
    },
    useDebugValue: i0,
    useDeferredValue: function (e) {
      var t = Jn()
      return I4(t, It.memoizedState, e)
    },
    useTransition: function () {
      var e = fd(gl)[0],
        t = Jn().memoizedState
      return [e, t]
    },
    useMutableSource: p4,
    useSyncExternalStore: g4,
    useId: N4,
    unstable_isNewReconciler: !1,
  },
  Ux = {
    readContext: $n,
    useCallback: k4,
    useContext: $n,
    useEffect: r0,
    useImperativeHandle: A4,
    useInsertionEffect: E4,
    useLayoutEffect: C4,
    useMemo: _4,
    useReducer: pd,
    useRef: x4,
    useState: function () {
      return pd(gl)
    },
    useDebugValue: i0,
    useDeferredValue: function (e) {
      var t = Jn()
      return It === null ? (t.memoizedState = e) : I4(t, It.memoizedState, e)
    },
    useTransition: function () {
      var e = pd(gl)[0],
        t = Jn().memoizedState
      return [e, t]
    },
    useMutableSource: p4,
    useSyncExternalStore: g4,
    useId: N4,
    unstable_isNewReconciler: !1,
  }
function or(e, t) {
  if (e && e.defaultProps) {
    ;((t = dt({}, t)), (e = e.defaultProps))
    for (var n in e) t[n] === void 0 && (t[n] = e[n])
    return t
  }
  return t
}
function S1(e, t, n, r) {
  ;((t = e.memoizedState),
    (n = n(r, t)),
    (n = n == null ? t : dt({}, t, n)),
    (e.memoizedState = n),
    e.lanes === 0 && (e.updateQueue.baseState = n))
}
var nh = {
  isMounted: function (e) {
    return (e = e._reactInternals) ? ks(e) === e : !1
  },
  enqueueSetState: function (e, t, n) {
    e = e._reactInternals
    var r = sn(),
      i = Ii(e),
      o = Wr(r, i)
    ;((o.payload = t),
      n != null && (o.callback = n),
      (t = ki(e, o, i)),
      t !== null && (ur(t, e, i, r), Uc(t, e, i)))
  },
  enqueueReplaceState: function (e, t, n) {
    e = e._reactInternals
    var r = sn(),
      i = Ii(e),
      o = Wr(r, i)
    ;((o.tag = 1),
      (o.payload = t),
      n != null && (o.callback = n),
      (t = ki(e, o, i)),
      t !== null && (ur(t, e, i, r), Uc(t, e, i)))
  },
  enqueueForceUpdate: function (e, t) {
    e = e._reactInternals
    var n = sn(),
      r = Ii(e),
      i = Wr(n, r)
    ;((i.tag = 2),
      t != null && (i.callback = t),
      (t = ki(e, i, r)),
      t !== null && (ur(t, e, r, n), Uc(t, e, r)))
  },
}
function kg(e, t, n, r, i, o, c) {
  return (
    (e = e.stateNode),
    typeof e.shouldComponentUpdate == 'function'
      ? e.shouldComponentUpdate(r, o, c)
      : t.prototype && t.prototype.isPureReactComponent
        ? !ll(n, r) || !ll(i, o)
        : !0
  )
}
function P4(e, t, n) {
  var r = !1,
    i = Pi,
    o = t.contextType
  return (
    typeof o == 'object' && o !== null
      ? (o = $n(o))
      : ((i = xn(t) ? ms : en.current),
        (r = t.contextTypes),
        (o = (r = r != null) ? Ro(e, i) : Pi)),
    (t = new t(n, o)),
    (e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null),
    (t.updater = nh),
    (e.stateNode = t),
    (t._reactInternals = e),
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = i),
      (e.__reactInternalMemoizedMaskedChildContext = o)),
    t
  )
}
function _g(e, t, n, r) {
  ;((e = t.state),
    typeof t.componentWillReceiveProps == 'function' && t.componentWillReceiveProps(n, r),
    typeof t.UNSAFE_componentWillReceiveProps == 'function' &&
      t.UNSAFE_componentWillReceiveProps(n, r),
    t.state !== e && nh.enqueueReplaceState(t, t.state, null))
}
function A1(e, t, n, r) {
  var i = e.stateNode
  ;((i.props = n), (i.state = e.memoizedState), (i.refs = {}), qf(e))
  var o = t.contextType
  ;(typeof o == 'object' && o !== null
    ? (i.context = $n(o))
    : ((o = xn(t) ? ms : en.current), (i.context = Ro(e, o))),
    (i.state = e.memoizedState),
    (o = t.getDerivedStateFromProps),
    typeof o == 'function' && (S1(e, t, o, n), (i.state = e.memoizedState)),
    typeof t.getDerivedStateFromProps == 'function' ||
      typeof i.getSnapshotBeforeUpdate == 'function' ||
      (typeof i.UNSAFE_componentWillMount != 'function' &&
        typeof i.componentWillMount != 'function') ||
      ((t = i.state),
      typeof i.componentWillMount == 'function' && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == 'function' && i.UNSAFE_componentWillMount(),
      t !== i.state && nh.enqueueReplaceState(i, i.state, null),
      bu(e, n, i, r),
      (i.state = e.memoizedState)),
    typeof i.componentDidMount == 'function' && (e.flags |= 4194308))
}
function Lo(e, t) {
  try {
    var n = '',
      r = t
    do ((n += gv(r)), (r = r.return))
    while (r)
    var i = n
  } catch (o) {
    i =
      `
Error generating stack: ` +
      o.message +
      `
` +
      o.stack
  }
  return { value: e, source: t, stack: i, digest: null }
}
function gd(e, t, n) {
  return { value: e, source: null, stack: n ?? null, digest: t ?? null }
}
function k1(e, t) {
  try {
    console.error(t.value)
  } catch (n) {
    setTimeout(function () {
      throw n
    })
  }
}
var Wx = typeof WeakMap == 'function' ? WeakMap : Map
function D4(e, t, n) {
  ;((n = Wr(-1, n)), (n.tag = 3), (n.payload = { element: null }))
  var r = t.value
  return (
    (n.callback = function () {
      ;(Su || ((Su = !0), (L1 = r)), k1(e, t))
    }),
    n
  )
}
function L4(e, t, n) {
  ;((n = Wr(-1, n)), (n.tag = 3))
  var r = e.type.getDerivedStateFromError
  if (typeof r == 'function') {
    var i = t.value
    ;((n.payload = function () {
      return r(i)
    }),
      (n.callback = function () {
        k1(e, t)
      }))
  }
  var o = e.stateNode
  return (
    o !== null &&
      typeof o.componentDidCatch == 'function' &&
      (n.callback = function () {
        ;(k1(e, t), typeof r != 'function' && (_i === null ? (_i = new Set([this])) : _i.add(this)))
        var c = t.stack
        this.componentDidCatch(t.value, { componentStack: c !== null ? c : '' })
      }),
    n
  )
}
function Ig(e, t, n) {
  var r = e.pingCache
  if (r === null) {
    r = e.pingCache = new Wx()
    var i = new Set()
    r.set(t, i)
  } else ((i = r.get(t)), i === void 0 && ((i = new Set()), r.set(t, i)))
  i.has(n) || (i.add(n), (e = nE.bind(null, e, t, n)), t.then(e, e))
}
function Ng(e) {
  do {
    var t
    if (
      ((t = e.tag === 13) && ((t = e.memoizedState), (t = t !== null ? t.dehydrated !== null : !0)),
      t)
    )
      return e
    e = e.return
  } while (e !== null)
  return null
}
function Tg(e, t, n, r, i) {
  return e.mode & 1
    ? ((e.flags |= 65536), (e.lanes = i), e)
    : (e === t
        ? (e.flags |= 65536)
        : ((e.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null ? (n.tag = 17) : ((t = Wr(-1, 1)), (t.tag = 2), ki(n, t, 1))),
          (n.lanes |= 1)),
      e)
}
var zx = qr.ReactCurrentOwner,
  bn = !1
function rn(e, t, n, r) {
  t.child = e === null ? u4(t, null, n, r) : Po(t, e.child, n, r)
}
function Rg(e, t, n, r, i) {
  n = n.render
  var o = t.ref
  return (
    _o(t, i),
    (r = t0(e, t, n, r, o, i)),
    (n = n0()),
    e !== null && !bn
      ? ((t.updateQueue = e.updateQueue), (t.flags &= -2053), (e.lanes &= ~i), Zr(e, t, i))
      : (st && n && zf(t), (t.flags |= 1), rn(e, t, r, i), t.child)
  )
}
function Mg(e, t, n, r, i) {
  if (e === null) {
    var o = n.type
    return typeof o == 'function' &&
      !d0(o) &&
      o.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((t.tag = 15), (t.type = o), O4(e, t, o, r, i))
      : ((e = Yc(n.type, null, r, t, t.mode, i)), (e.ref = t.ref), (e.return = t), (t.child = e))
  }
  if (((o = e.child), !(e.lanes & i))) {
    var c = o.memoizedProps
    if (((n = n.compare), (n = n !== null ? n : ll), n(c, r) && e.ref === t.ref)) return Zr(e, t, i)
  }
  return ((t.flags |= 1), (e = Ni(o, r)), (e.ref = t.ref), (e.return = t), (t.child = e))
}
function O4(e, t, n, r, i) {
  if (e !== null) {
    var o = e.memoizedProps
    if (ll(o, r) && e.ref === t.ref)
      if (((bn = !1), (t.pendingProps = r = o), (e.lanes & i) !== 0)) e.flags & 131072 && (bn = !0)
      else return ((t.lanes = e.lanes), Zr(e, t, i))
  }
  return _1(e, t, n, r, i)
}
function B4(e, t, n) {
  var r = t.pendingProps,
    i = r.children,
    o = e !== null ? e.memoizedState : null
  if (r.mode === 'hidden')
    if (!(t.mode & 1))
      ((t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        $e(go, In),
        (In |= n))
    else {
      if (!(n & 1073741824))
        return (
          (e = o !== null ? o.baseLanes | n : n),
          (t.lanes = t.childLanes = 1073741824),
          (t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }),
          (t.updateQueue = null),
          $e(go, In),
          (In |= e),
          null
        )
      ;((t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = o !== null ? o.baseLanes : n),
        $e(go, In),
        (In |= r))
    }
  else
    (o !== null ? ((r = o.baseLanes | n), (t.memoizedState = null)) : (r = n),
      $e(go, In),
      (In |= r))
  return (rn(e, t, i, n), t.child)
}
function F4(e, t) {
  var n = t.ref
  ;((e === null && n !== null) || (e !== null && e.ref !== n)) &&
    ((t.flags |= 512), (t.flags |= 2097152))
}
function _1(e, t, n, r, i) {
  var o = xn(n) ? ms : en.current
  return (
    (o = Ro(t, o)),
    _o(t, i),
    (n = t0(e, t, n, r, o, i)),
    (r = n0()),
    e !== null && !bn
      ? ((t.updateQueue = e.updateQueue), (t.flags &= -2053), (e.lanes &= ~i), Zr(e, t, i))
      : (st && r && zf(t), (t.flags |= 1), rn(e, t, n, i), t.child)
  )
}
function Pg(e, t, n, r, i) {
  if (xn(n)) {
    var o = !0
    pu(t)
  } else o = !1
  if ((_o(t, i), t.stateNode === null)) (Hc(e, t), P4(t, n, r), A1(t, n, r, i), (r = !0))
  else if (e === null) {
    var c = t.stateNode,
      h = t.memoizedProps
    c.props = h
    var f = c.context,
      p = n.contextType
    typeof p == 'object' && p !== null
      ? (p = $n(p))
      : ((p = xn(n) ? ms : en.current), (p = Ro(t, p)))
    var y = n.getDerivedStateFromProps,
      w = typeof y == 'function' || typeof c.getSnapshotBeforeUpdate == 'function'
    ;(w ||
      (typeof c.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof c.componentWillReceiveProps != 'function') ||
      ((h !== r || f !== p) && _g(t, c, r, p)),
      (ui = !1))
    var x = t.memoizedState
    ;((c.state = x),
      bu(t, r, c, i),
      (f = t.memoizedState),
      h !== r || x !== f || vn.current || ui
        ? (typeof y == 'function' && (S1(t, n, y, r), (f = t.memoizedState)),
          (h = ui || kg(t, n, h, r, x, f, p))
            ? (w ||
                (typeof c.UNSAFE_componentWillMount != 'function' &&
                  typeof c.componentWillMount != 'function') ||
                (typeof c.componentWillMount == 'function' && c.componentWillMount(),
                typeof c.UNSAFE_componentWillMount == 'function' && c.UNSAFE_componentWillMount()),
              typeof c.componentDidMount == 'function' && (t.flags |= 4194308))
            : (typeof c.componentDidMount == 'function' && (t.flags |= 4194308),
              (t.memoizedProps = r),
              (t.memoizedState = f)),
          (c.props = r),
          (c.state = f),
          (c.context = p),
          (r = h))
        : (typeof c.componentDidMount == 'function' && (t.flags |= 4194308), (r = !1)))
  } else {
    ;((c = t.stateNode),
      d4(e, t),
      (h = t.memoizedProps),
      (p = t.type === t.elementType ? h : or(t.type, h)),
      (c.props = p),
      (w = t.pendingProps),
      (x = c.context),
      (f = n.contextType),
      typeof f == 'object' && f !== null
        ? (f = $n(f))
        : ((f = xn(n) ? ms : en.current), (f = Ro(t, f))))
    var E = n.getDerivedStateFromProps
    ;((y = typeof E == 'function' || typeof c.getSnapshotBeforeUpdate == 'function') ||
      (typeof c.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof c.componentWillReceiveProps != 'function') ||
      ((h !== w || x !== f) && _g(t, c, r, f)),
      (ui = !1),
      (x = t.memoizedState),
      (c.state = x),
      bu(t, r, c, i))
    var S = t.memoizedState
    h !== w || x !== S || vn.current || ui
      ? (typeof E == 'function' && (S1(t, n, E, r), (S = t.memoizedState)),
        (p = ui || kg(t, n, p, r, x, S, f) || !1)
          ? (y ||
              (typeof c.UNSAFE_componentWillUpdate != 'function' &&
                typeof c.componentWillUpdate != 'function') ||
              (typeof c.componentWillUpdate == 'function' && c.componentWillUpdate(r, S, f),
              typeof c.UNSAFE_componentWillUpdate == 'function' &&
                c.UNSAFE_componentWillUpdate(r, S, f)),
            typeof c.componentDidUpdate == 'function' && (t.flags |= 4),
            typeof c.getSnapshotBeforeUpdate == 'function' && (t.flags |= 1024))
          : (typeof c.componentDidUpdate != 'function' ||
              (h === e.memoizedProps && x === e.memoizedState) ||
              (t.flags |= 4),
            typeof c.getSnapshotBeforeUpdate != 'function' ||
              (h === e.memoizedProps && x === e.memoizedState) ||
              (t.flags |= 1024),
            (t.memoizedProps = r),
            (t.memoizedState = S)),
        (c.props = r),
        (c.state = S),
        (c.context = f),
        (r = p))
      : (typeof c.componentDidUpdate != 'function' ||
          (h === e.memoizedProps && x === e.memoizedState) ||
          (t.flags |= 4),
        typeof c.getSnapshotBeforeUpdate != 'function' ||
          (h === e.memoizedProps && x === e.memoizedState) ||
          (t.flags |= 1024),
        (r = !1))
  }
  return I1(e, t, n, r, o, i)
}
function I1(e, t, n, r, i, o) {
  F4(e, t)
  var c = (t.flags & 128) !== 0
  if (!r && !c) return (i && wg(t, n, !1), Zr(e, t, o))
  ;((r = t.stateNode), (zx.current = t))
  var h = c && typeof n.getDerivedStateFromError != 'function' ? null : r.render()
  return (
    (t.flags |= 1),
    e !== null && c
      ? ((t.child = Po(t, e.child, null, o)), (t.child = Po(t, null, h, o)))
      : rn(e, t, h, o),
    (t.memoizedState = r.state),
    i && wg(t, n, !0),
    t.child
  )
}
function j4(e) {
  var t = e.stateNode
  ;(t.pendingContext
    ? yg(e, t.pendingContext, t.pendingContext !== t.context)
    : t.context && yg(e, t.context, !1),
    Qf(e, t.containerInfo))
}
function Dg(e, t, n, r, i) {
  return (Mo(), Xf(i), (t.flags |= 256), rn(e, t, n, r), t.child)
}
var N1 = { dehydrated: null, treeContext: null, retryLane: 0 }
function T1(e) {
  return { baseLanes: e, cachePool: null, transitions: null }
}
function V4(e, t, n) {
  var r = t.pendingProps,
    i = at.current,
    o = !1,
    c = (t.flags & 128) !== 0,
    h
  if (
    ((h = c) || (h = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0),
    h ? ((o = !0), (t.flags &= -129)) : (e === null || e.memoizedState !== null) && (i |= 1),
    $e(at, i & 1),
    e === null)
  )
    return (
      E1(t),
      (e = t.memoizedState),
      e !== null && ((e = e.dehydrated), e !== null)
        ? (t.mode & 1 ? (e.data === '$!' ? (t.lanes = 8) : (t.lanes = 1073741824)) : (t.lanes = 1),
          null)
        : ((c = r.children),
          (e = r.fallback),
          o
            ? ((r = t.mode),
              (o = t.child),
              (c = { mode: 'hidden', children: c }),
              !(r & 1) && o !== null
                ? ((o.childLanes = 0), (o.pendingProps = c))
                : (o = sh(c, r, 0, null)),
              (e = hs(e, r, n, null)),
              (o.return = t),
              (e.return = t),
              (o.sibling = e),
              (t.child = o),
              (t.child.memoizedState = T1(n)),
              (t.memoizedState = N1),
              e)
            : s0(t, c))
    )
  if (((i = e.memoizedState), i !== null && ((h = i.dehydrated), h !== null)))
    return Hx(e, t, c, r, h, i, n)
  if (o) {
    ;((o = r.fallback), (c = t.mode), (i = e.child), (h = i.sibling))
    var f = { mode: 'hidden', children: r.children }
    return (
      !(c & 1) && t.child !== i
        ? ((r = t.child), (r.childLanes = 0), (r.pendingProps = f), (t.deletions = null))
        : ((r = Ni(i, f)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      h !== null ? (o = Ni(h, o)) : ((o = hs(o, c, n, null)), (o.flags |= 2)),
      (o.return = t),
      (r.return = t),
      (r.sibling = o),
      (t.child = r),
      (r = o),
      (o = t.child),
      (c = e.child.memoizedState),
      (c =
        c === null
          ? T1(n)
          : { baseLanes: c.baseLanes | n, cachePool: null, transitions: c.transitions }),
      (o.memoizedState = c),
      (o.childLanes = e.childLanes & ~n),
      (t.memoizedState = N1),
      r
    )
  }
  return (
    (o = e.child),
    (e = o.sibling),
    (r = Ni(o, { mode: 'visible', children: r.children })),
    !(t.mode & 1) && (r.lanes = n),
    (r.return = t),
    (r.sibling = null),
    e !== null &&
      ((n = t.deletions), n === null ? ((t.deletions = [e]), (t.flags |= 16)) : n.push(e)),
    (t.child = r),
    (t.memoizedState = null),
    r
  )
}
function s0(e, t) {
  return (
    (t = sh({ mode: 'visible', children: t }, e.mode, 0, null)),
    (t.return = e),
    (e.child = t)
  )
}
function gc(e, t, n, r) {
  return (
    r !== null && Xf(r),
    Po(t, e.child, null, n),
    (e = s0(t, t.pendingProps.children)),
    (e.flags |= 2),
    (t.memoizedState = null),
    e
  )
}
function Hx(e, t, n, r, i, o, c) {
  if (n)
    return t.flags & 256
      ? ((t.flags &= -257), (r = gd(Error(ee(422)))), gc(e, t, c, r))
      : t.memoizedState !== null
        ? ((t.child = e.child), (t.flags |= 128), null)
        : ((o = r.fallback),
          (i = t.mode),
          (r = sh({ mode: 'visible', children: r.children }, i, 0, null)),
          (o = hs(o, i, c, null)),
          (o.flags |= 2),
          (r.return = t),
          (o.return = t),
          (r.sibling = o),
          (t.child = r),
          t.mode & 1 && Po(t, e.child, null, c),
          (t.child.memoizedState = T1(c)),
          (t.memoizedState = N1),
          o)
  if (!(t.mode & 1)) return gc(e, t, c, null)
  if (i.data === '$!') {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var h = r.dgst
    return ((r = h), (o = Error(ee(419))), (r = gd(o, r, void 0)), gc(e, t, c, r))
  }
  if (((h = (c & e.childLanes) !== 0), bn || h)) {
    if (((r = Lt), r !== null)) {
      switch (c & -c) {
        case 4:
          i = 2
          break
        case 16:
          i = 8
          break
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32
          break
        case 536870912:
          i = 268435456
          break
        default:
          i = 0
      }
      ;((i = i & (r.suspendedLanes | c) ? 0 : i),
        i !== 0 && i !== o.retryLane && ((o.retryLane = i), Yr(e, i), ur(r, e, i, -1)))
    }
    return (h0(), (r = gd(Error(ee(421)))), gc(e, t, c, r))
  }
  return i.data === '$?'
    ? ((t.flags |= 128), (t.child = e.child), (t = rE.bind(null, e)), (i._reactRetry = t), null)
    : ((e = o.treeContext),
      (Tn = Ai(i.nextSibling)),
      (Pn = t),
      (st = !0),
      (lr = null),
      e !== null &&
        ((Yn[Zn++] = Fr),
        (Yn[Zn++] = jr),
        (Yn[Zn++] = ys),
        (Fr = e.id),
        (jr = e.overflow),
        (ys = t)),
      (t = s0(t, r.children)),
      (t.flags |= 4096),
      t)
}
function Lg(e, t, n) {
  e.lanes |= t
  var r = e.alternate
  ;(r !== null && (r.lanes |= t), C1(e.return, t, n))
}
function md(e, t, n, r, i) {
  var o = e.memoizedState
  o === null
    ? (e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i,
      })
    : ((o.isBackwards = t),
      (o.rendering = null),
      (o.renderingStartTime = 0),
      (o.last = r),
      (o.tail = n),
      (o.tailMode = i))
}
function U4(e, t, n) {
  var r = t.pendingProps,
    i = r.revealOrder,
    o = r.tail
  if ((rn(e, t, r.children, n), (r = at.current), r & 2)) ((r = (r & 1) | 2), (t.flags |= 128))
  else {
    if (e !== null && e.flags & 128)
      e: for (e = t.child; e !== null; ) {
        if (e.tag === 13) e.memoizedState !== null && Lg(e, n, t)
        else if (e.tag === 19) Lg(e, n, t)
        else if (e.child !== null) {
          ;((e.child.return = e), (e = e.child))
          continue
        }
        if (e === t) break e
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) break e
          e = e.return
        }
        ;((e.sibling.return = e.return), (e = e.sibling))
      }
    r &= 1
  }
  if (($e(at, r), !(t.mode & 1))) t.memoizedState = null
  else
    switch (i) {
      case 'forwards':
        for (n = t.child, i = null; n !== null; )
          ((e = n.alternate), e !== null && vu(e) === null && (i = n), (n = n.sibling))
        ;((n = i),
          n === null ? ((i = t.child), (t.child = null)) : ((i = n.sibling), (n.sibling = null)),
          md(t, !1, i, n, o))
        break
      case 'backwards':
        for (n = null, i = t.child, t.child = null; i !== null; ) {
          if (((e = i.alternate), e !== null && vu(e) === null)) {
            t.child = i
            break
          }
          ;((e = i.sibling), (i.sibling = n), (n = i), (i = e))
        }
        md(t, !0, n, null, o)
        break
      case 'together':
        md(t, !1, null, null, void 0)
        break
      default:
        t.memoizedState = null
    }
  return t.child
}
function Hc(e, t) {
  !(t.mode & 1) && e !== null && ((e.alternate = null), (t.alternate = null), (t.flags |= 2))
}
function Zr(e, t, n) {
  if ((e !== null && (t.dependencies = e.dependencies), (bs |= t.lanes), !(n & t.childLanes)))
    return null
  if (e !== null && t.child !== e.child) throw Error(ee(153))
  if (t.child !== null) {
    for (e = t.child, n = Ni(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null; )
      ((e = e.sibling), (n = n.sibling = Ni(e, e.pendingProps)), (n.return = t))
    n.sibling = null
  }
  return t.child
}
function Xx(e, t, n) {
  switch (t.tag) {
    case 3:
      ;(j4(t), Mo())
      break
    case 5:
      f4(t)
      break
    case 1:
      xn(t.type) && pu(t)
      break
    case 4:
      Qf(t, t.stateNode.containerInfo)
      break
    case 10:
      var r = t.type._context,
        i = t.memoizedProps.value
      ;($e(yu, r._currentValue), (r._currentValue = i))
      break
    case 13:
      if (((r = t.memoizedState), r !== null))
        return r.dehydrated !== null
          ? ($e(at, at.current & 1), (t.flags |= 128), null)
          : n & t.child.childLanes
            ? V4(e, t, n)
            : ($e(at, at.current & 1), (e = Zr(e, t, n)), e !== null ? e.sibling : null)
      $e(at, at.current & 1)
      break
    case 19:
      if (((r = (n & t.childLanes) !== 0), e.flags & 128)) {
        if (r) return U4(e, t, n)
        t.flags |= 128
      }
      if (
        ((i = t.memoizedState),
        i !== null && ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        $e(at, at.current),
        r)
      )
        break
      return null
    case 22:
    case 23:
      return ((t.lanes = 0), B4(e, t, n))
  }
  return Zr(e, t, n)
}
var W4, R1, z4, H4
W4 = function (e, t) {
  for (var n = t.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode)
    else if (n.tag !== 4 && n.child !== null) {
      ;((n.child.return = n), (n = n.child))
      continue
    }
    if (n === t) break
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === t) return
      n = n.return
    }
    ;((n.sibling.return = n.return), (n = n.sibling))
  }
}
R1 = function () {}
z4 = function (e, t, n, r) {
  var i = e.memoizedProps
  if (i !== r) {
    ;((e = t.stateNode), as(kr.current))
    var o = null
    switch (n) {
      case 'input':
        ;((i = Jd(e, i)), (r = Jd(e, r)), (o = []))
        break
      case 'select':
        ;((i = dt({}, i, { value: void 0 })), (r = dt({}, r, { value: void 0 })), (o = []))
        break
      case 'textarea':
        ;((i = n1(e, i)), (r = n1(e, r)), (o = []))
        break
      default:
        typeof i.onClick != 'function' && typeof r.onClick == 'function' && (e.onclick = du)
    }
    i1(n, r)
    var c
    n = null
    for (p in i)
      if (!r.hasOwnProperty(p) && i.hasOwnProperty(p) && i[p] != null)
        if (p === 'style') {
          var h = i[p]
          for (c in h) h.hasOwnProperty(c) && (n || (n = {}), (n[c] = ''))
        } else
          p !== 'dangerouslySetInnerHTML' &&
            p !== 'children' &&
            p !== 'suppressContentEditableWarning' &&
            p !== 'suppressHydrationWarning' &&
            p !== 'autoFocus' &&
            (tl.hasOwnProperty(p) ? o || (o = []) : (o = o || []).push(p, null))
    for (p in r) {
      var f = r[p]
      if (
        ((h = i != null ? i[p] : void 0),
        r.hasOwnProperty(p) && f !== h && (f != null || h != null))
      )
        if (p === 'style')
          if (h) {
            for (c in h)
              !h.hasOwnProperty(c) || (f && f.hasOwnProperty(c)) || (n || (n = {}), (n[c] = ''))
            for (c in f) f.hasOwnProperty(c) && h[c] !== f[c] && (n || (n = {}), (n[c] = f[c]))
          } else (n || (o || (o = []), o.push(p, n)), (n = f))
        else
          p === 'dangerouslySetInnerHTML'
            ? ((f = f ? f.__html : void 0),
              (h = h ? h.__html : void 0),
              f != null && h !== f && (o = o || []).push(p, f))
            : p === 'children'
              ? (typeof f != 'string' && typeof f != 'number') || (o = o || []).push(p, '' + f)
              : p !== 'suppressContentEditableWarning' &&
                p !== 'suppressHydrationWarning' &&
                (tl.hasOwnProperty(p)
                  ? (f != null && p === 'onScroll' && et('scroll', e), o || h === f || (o = []))
                  : (o = o || []).push(p, f))
    }
    n && (o = o || []).push('style', n)
    var p = o
    ;(t.updateQueue = p) && (t.flags |= 4)
  }
}
H4 = function (e, t, n, r) {
  n !== r && (t.flags |= 4)
}
function wa(e, t) {
  if (!st)
    switch (e.tailMode) {
      case 'hidden':
        t = e.tail
        for (var n = null; t !== null; ) (t.alternate !== null && (n = t), (t = t.sibling))
        n === null ? (e.tail = null) : (n.sibling = null)
        break
      case 'collapsed':
        n = e.tail
        for (var r = null; n !== null; ) (n.alternate !== null && (r = n), (n = n.sibling))
        r === null
          ? t || e.tail === null
            ? (e.tail = null)
            : (e.tail.sibling = null)
          : (r.sibling = null)
    }
}
function qt(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
    n = 0,
    r = 0
  if (t)
    for (var i = e.child; i !== null; )
      ((n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = e),
        (i = i.sibling))
  else
    for (i = e.child; i !== null; )
      ((n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = e),
        (i = i.sibling))
  return ((e.subtreeFlags |= r), (e.childLanes = n), t)
}
function Gx(e, t, n) {
  var r = t.pendingProps
  switch ((Hf(t), t.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return (qt(t), null)
    case 1:
      return (xn(t.type) && fu(), qt(t), null)
    case 3:
      return (
        (r = t.stateNode),
        Do(),
        nt(vn),
        nt(en),
        Jf(),
        r.pendingContext && ((r.context = r.pendingContext), (r.pendingContext = null)),
        (e === null || e.child === null) &&
          (fc(t)
            ? (t.flags |= 4)
            : e === null ||
              (e.memoizedState.isDehydrated && !(t.flags & 256)) ||
              ((t.flags |= 1024), lr !== null && (F1(lr), (lr = null)))),
        R1(e, t),
        qt(t),
        null
      )
    case 5:
      $f(t)
      var i = as(fl.current)
      if (((n = t.type), e !== null && t.stateNode != null))
        (z4(e, t, n, r, i), e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152)))
      else {
        if (!r) {
          if (t.stateNode === null) throw Error(ee(166))
          return (qt(t), null)
        }
        if (((e = as(kr.current)), fc(t))) {
          ;((r = t.stateNode), (n = t.type))
          var o = t.memoizedProps
          switch (((r[Sr] = t), (r[hl] = o), (e = (t.mode & 1) !== 0), n)) {
            case 'dialog':
              ;(et('cancel', r), et('close', r))
              break
            case 'iframe':
            case 'object':
            case 'embed':
              et('load', r)
              break
            case 'video':
            case 'audio':
              for (i = 0; i < Na.length; i++) et(Na[i], r)
              break
            case 'source':
              et('error', r)
              break
            case 'img':
            case 'image':
            case 'link':
              ;(et('error', r), et('load', r))
              break
            case 'details':
              et('toggle', r)
              break
            case 'input':
              ;(Hp(r, o), et('invalid', r))
              break
            case 'select':
              ;((r._wrapperState = { wasMultiple: !!o.multiple }), et('invalid', r))
              break
            case 'textarea':
              ;(Gp(r, o), et('invalid', r))
          }
          ;(i1(n, o), (i = null))
          for (var c in o)
            if (o.hasOwnProperty(c)) {
              var h = o[c]
              c === 'children'
                ? typeof h == 'string'
                  ? r.textContent !== h &&
                    (o.suppressHydrationWarning !== !0 && dc(r.textContent, h, e),
                    (i = ['children', h]))
                  : typeof h == 'number' &&
                    r.textContent !== '' + h &&
                    (o.suppressHydrationWarning !== !0 && dc(r.textContent, h, e),
                    (i = ['children', '' + h]))
                : tl.hasOwnProperty(c) && h != null && c === 'onScroll' && et('scroll', r)
            }
          switch (n) {
            case 'input':
              ;(ic(r), Xp(r, o, !0))
              break
            case 'textarea':
              ;(ic(r), Yp(r))
              break
            case 'select':
            case 'option':
              break
            default:
              typeof o.onClick == 'function' && (r.onclick = du)
          }
          ;((r = i), (t.updateQueue = r), r !== null && (t.flags |= 4))
        } else {
          ;((c = i.nodeType === 9 ? i : i.ownerDocument),
            e === 'http://www.w3.org/1999/xhtml' && (e = w8(n)),
            e === 'http://www.w3.org/1999/xhtml'
              ? n === 'script'
                ? ((e = c.createElement('div')),
                  (e.innerHTML = '<script><\/script>'),
                  (e = e.removeChild(e.firstChild)))
                : typeof r.is == 'string'
                  ? (e = c.createElement(n, { is: r.is }))
                  : ((e = c.createElement(n)),
                    n === 'select' &&
                      ((c = e), r.multiple ? (c.multiple = !0) : r.size && (c.size = r.size)))
              : (e = c.createElementNS(e, n)),
            (e[Sr] = t),
            (e[hl] = r),
            W4(e, t, !1, !1),
            (t.stateNode = e))
          e: {
            switch (((c = s1(n, r)), n)) {
              case 'dialog':
                ;(et('cancel', e), et('close', e), (i = r))
                break
              case 'iframe':
              case 'object':
              case 'embed':
                ;(et('load', e), (i = r))
                break
              case 'video':
              case 'audio':
                for (i = 0; i < Na.length; i++) et(Na[i], e)
                i = r
                break
              case 'source':
                ;(et('error', e), (i = r))
                break
              case 'img':
              case 'image':
              case 'link':
                ;(et('error', e), et('load', e), (i = r))
                break
              case 'details':
                ;(et('toggle', e), (i = r))
                break
              case 'input':
                ;(Hp(e, r), (i = Jd(e, r)), et('invalid', e))
                break
              case 'option':
                i = r
                break
              case 'select':
                ;((e._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = dt({}, r, { value: void 0 })),
                  et('invalid', e))
                break
              case 'textarea':
                ;(Gp(e, r), (i = n1(e, r)), et('invalid', e))
                break
              default:
                i = r
            }
            ;(i1(n, i), (h = i))
            for (o in h)
              if (h.hasOwnProperty(o)) {
                var f = h[o]
                o === 'style'
                  ? x8(e, f)
                  : o === 'dangerouslySetInnerHTML'
                    ? ((f = f ? f.__html : void 0), f != null && b8(e, f))
                    : o === 'children'
                      ? typeof f == 'string'
                        ? (n !== 'textarea' || f !== '') && nl(e, f)
                        : typeof f == 'number' && nl(e, '' + f)
                      : o !== 'suppressContentEditableWarning' &&
                        o !== 'suppressHydrationWarning' &&
                        o !== 'autoFocus' &&
                        (tl.hasOwnProperty(o)
                          ? f != null && o === 'onScroll' && et('scroll', e)
                          : f != null && Nf(e, o, f, c))
              }
            switch (n) {
              case 'input':
                ;(ic(e), Xp(e, r, !1))
                break
              case 'textarea':
                ;(ic(e), Yp(e))
                break
              case 'option':
                r.value != null && e.setAttribute('value', '' + Mi(r.value))
                break
              case 'select':
                ;((e.multiple = !!r.multiple),
                  (o = r.value),
                  o != null
                    ? Co(e, !!r.multiple, o, !1)
                    : r.defaultValue != null && Co(e, !!r.multiple, r.defaultValue, !0))
                break
              default:
                typeof i.onClick == 'function' && (e.onclick = du)
            }
            switch (n) {
              case 'button':
              case 'input':
              case 'select':
              case 'textarea':
                r = !!r.autoFocus
                break e
              case 'img':
                r = !0
                break e
              default:
                r = !1
            }
          }
          r && (t.flags |= 4)
        }
        t.ref !== null && ((t.flags |= 512), (t.flags |= 2097152))
      }
      return (qt(t), null)
    case 6:
      if (e && t.stateNode != null) H4(e, t, e.memoizedProps, r)
      else {
        if (typeof r != 'string' && t.stateNode === null) throw Error(ee(166))
        if (((n = as(fl.current)), as(kr.current), fc(t))) {
          if (
            ((r = t.stateNode),
            (n = t.memoizedProps),
            (r[Sr] = t),
            (o = r.nodeValue !== n) && ((e = Pn), e !== null))
          )
            switch (e.tag) {
              case 3:
                dc(r.nodeValue, n, (e.mode & 1) !== 0)
                break
              case 5:
                e.memoizedProps.suppressHydrationWarning !== !0 &&
                  dc(r.nodeValue, n, (e.mode & 1) !== 0)
            }
          o && (t.flags |= 4)
        } else
          ((r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[Sr] = t),
            (t.stateNode = r))
      }
      return (qt(t), null)
    case 13:
      if (
        (nt(at),
        (r = t.memoizedState),
        e === null || (e.memoizedState !== null && e.memoizedState.dehydrated !== null))
      ) {
        if (st && Tn !== null && t.mode & 1 && !(t.flags & 128))
          (l4(), Mo(), (t.flags |= 98560), (o = !1))
        else if (((o = fc(t)), r !== null && r.dehydrated !== null)) {
          if (e === null) {
            if (!o) throw Error(ee(318))
            if (((o = t.memoizedState), (o = o !== null ? o.dehydrated : null), !o))
              throw Error(ee(317))
            o[Sr] = t
          } else (Mo(), !(t.flags & 128) && (t.memoizedState = null), (t.flags |= 4))
          ;(qt(t), (o = !1))
        } else (lr !== null && (F1(lr), (lr = null)), (o = !0))
        if (!o) return t.flags & 65536 ? t : null
      }
      return t.flags & 128
        ? ((t.lanes = n), t)
        : ((r = r !== null),
          r !== (e !== null && e.memoizedState !== null) &&
            r &&
            ((t.child.flags |= 8192),
            t.mode & 1 && (e === null || at.current & 1 ? Nt === 0 && (Nt = 3) : h0())),
          t.updateQueue !== null && (t.flags |= 4),
          qt(t),
          null)
    case 4:
      return (Do(), R1(e, t), e === null && cl(t.stateNode.containerInfo), qt(t), null)
    case 10:
      return (Zf(t.type._context), qt(t), null)
    case 17:
      return (xn(t.type) && fu(), qt(t), null)
    case 19:
      if ((nt(at), (o = t.memoizedState), o === null)) return (qt(t), null)
      if (((r = (t.flags & 128) !== 0), (c = o.rendering), c === null))
        if (r) wa(o, !1)
        else {
          if (Nt !== 0 || (e !== null && e.flags & 128))
            for (e = t.child; e !== null; ) {
              if (((c = vu(e)), c !== null)) {
                for (
                  t.flags |= 128,
                    wa(o, !1),
                    r = c.updateQueue,
                    r !== null && ((t.updateQueue = r), (t.flags |= 4)),
                    t.subtreeFlags = 0,
                    r = n,
                    n = t.child;
                  n !== null;

                )
                  ((o = n),
                    (e = r),
                    (o.flags &= 14680066),
                    (c = o.alternate),
                    c === null
                      ? ((o.childLanes = 0),
                        (o.lanes = e),
                        (o.child = null),
                        (o.subtreeFlags = 0),
                        (o.memoizedProps = null),
                        (o.memoizedState = null),
                        (o.updateQueue = null),
                        (o.dependencies = null),
                        (o.stateNode = null))
                      : ((o.childLanes = c.childLanes),
                        (o.lanes = c.lanes),
                        (o.child = c.child),
                        (o.subtreeFlags = 0),
                        (o.deletions = null),
                        (o.memoizedProps = c.memoizedProps),
                        (o.memoizedState = c.memoizedState),
                        (o.updateQueue = c.updateQueue),
                        (o.type = c.type),
                        (e = c.dependencies),
                        (o.dependencies =
                          e === null ? null : { lanes: e.lanes, firstContext: e.firstContext })),
                    (n = n.sibling))
                return ($e(at, (at.current & 1) | 2), t.child)
              }
              e = e.sibling
            }
          o.tail !== null &&
            Et() > Oo &&
            ((t.flags |= 128), (r = !0), wa(o, !1), (t.lanes = 4194304))
        }
      else {
        if (!r)
          if (((e = vu(c)), e !== null)) {
            if (
              ((t.flags |= 128),
              (r = !0),
              (n = e.updateQueue),
              n !== null && ((t.updateQueue = n), (t.flags |= 4)),
              wa(o, !0),
              o.tail === null && o.tailMode === 'hidden' && !c.alternate && !st)
            )
              return (qt(t), null)
          } else
            2 * Et() - o.renderingStartTime > Oo &&
              n !== 1073741824 &&
              ((t.flags |= 128), (r = !0), wa(o, !1), (t.lanes = 4194304))
        o.isBackwards
          ? ((c.sibling = t.child), (t.child = c))
          : ((n = o.last), n !== null ? (n.sibling = c) : (t.child = c), (o.last = c))
      }
      return o.tail !== null
        ? ((t = o.tail),
          (o.rendering = t),
          (o.tail = t.sibling),
          (o.renderingStartTime = Et()),
          (t.sibling = null),
          (n = at.current),
          $e(at, r ? (n & 1) | 2 : n & 1),
          t)
        : (qt(t), null)
    case 22:
    case 23:
      return (
        u0(),
        (r = t.memoizedState !== null),
        e !== null && (e.memoizedState !== null) !== r && (t.flags |= 8192),
        r && t.mode & 1
          ? In & 1073741824 && (qt(t), t.subtreeFlags & 6 && (t.flags |= 8192))
          : qt(t),
        null
      )
    case 24:
      return null
    case 25:
      return null
  }
  throw Error(ee(156, t.tag))
}
function Yx(e, t) {
  switch ((Hf(t), t.tag)) {
    case 1:
      return (
        xn(t.type) && fu(),
        (e = t.flags),
        e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 3:
      return (
        Do(),
        nt(vn),
        nt(en),
        Jf(),
        (e = t.flags),
        e & 65536 && !(e & 128) ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 5:
      return ($f(t), null)
    case 13:
      if ((nt(at), (e = t.memoizedState), e !== null && e.dehydrated !== null)) {
        if (t.alternate === null) throw Error(ee(340))
        Mo()
      }
      return ((e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null)
    case 19:
      return (nt(at), null)
    case 4:
      return (Do(), null)
    case 10:
      return (Zf(t.type._context), null)
    case 22:
    case 23:
      return (u0(), null)
    case 24:
      return null
    default:
      return null
  }
}
var mc = !1,
  $t = !1,
  Zx = typeof WeakSet == 'function' ? WeakSet : Set,
  ce = null
function po(e, t) {
  var n = e.ref
  if (n !== null)
    if (typeof n == 'function')
      try {
        n(null)
      } catch (r) {
        wt(e, t, r)
      }
    else n.current = null
}
function X4(e, t, n) {
  try {
    n()
  } catch (r) {
    wt(e, t, r)
  }
}
var Og = !1
function Kx(e, t) {
  if (((g1 = cu), (e = K8()), Wf(e))) {
    if ('selectionStart' in e) var n = { start: e.selectionStart, end: e.selectionEnd }
    else
      e: {
        n = ((n = e.ownerDocument) && n.defaultView) || window
        var r = n.getSelection && n.getSelection()
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode
          var i = r.anchorOffset,
            o = r.focusNode
          r = r.focusOffset
          try {
            ;(n.nodeType, o.nodeType)
          } catch {
            n = null
            break e
          }
          var c = 0,
            h = -1,
            f = -1,
            p = 0,
            y = 0,
            w = e,
            x = null
          t: for (;;) {
            for (
              var E;
              w !== n || (i !== 0 && w.nodeType !== 3) || (h = c + i),
                w !== o || (r !== 0 && w.nodeType !== 3) || (f = c + r),
                w.nodeType === 3 && (c += w.nodeValue.length),
                (E = w.firstChild) !== null;

            )
              ((x = w), (w = E))
            for (;;) {
              if (w === e) break t
              if (
                (x === n && ++p === i && (h = c),
                x === o && ++y === r && (f = c),
                (E = w.nextSibling) !== null)
              )
                break
              ;((w = x), (x = w.parentNode))
            }
            w = E
          }
          n = h === -1 || f === -1 ? null : { start: h, end: f }
        } else n = null
      }
    n = n || { start: 0, end: 0 }
  } else n = null
  for (m1 = { focusedElem: e, selectionRange: n }, cu = !1, ce = t; ce !== null; )
    if (((t = ce), (e = t.child), (t.subtreeFlags & 1028) !== 0 && e !== null))
      ((e.return = t), (ce = e))
    else
      for (; ce !== null; ) {
        t = ce
        try {
          var S = t.alternate
          if (t.flags & 1024)
            switch (t.tag) {
              case 0:
              case 11:
              case 15:
                break
              case 1:
                if (S !== null) {
                  var k = S.memoizedProps,
                    P = S.memoizedState,
                    I = t.stateNode,
                    R = I.getSnapshotBeforeUpdate(t.elementType === t.type ? k : or(t.type, k), P)
                  I.__reactInternalSnapshotBeforeUpdate = R
                }
                break
              case 3:
                var M = t.stateNode.containerInfo
                M.nodeType === 1
                  ? (M.textContent = '')
                  : M.nodeType === 9 && M.documentElement && M.removeChild(M.documentElement)
                break
              case 5:
              case 6:
              case 4:
              case 17:
                break
              default:
                throw Error(ee(163))
            }
        } catch (O) {
          wt(t, t.return, O)
        }
        if (((e = t.sibling), e !== null)) {
          ;((e.return = t.return), (ce = e))
          break
        }
        ce = t.return
      }
  return ((S = Og), (Og = !1), S)
}
function Wa(e, t, n) {
  var r = t.updateQueue
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next)
    do {
      if ((i.tag & e) === e) {
        var o = i.destroy
        ;((i.destroy = void 0), o !== void 0 && X4(t, n, o))
      }
      i = i.next
    } while (i !== r)
  }
}
function rh(e, t) {
  if (((t = t.updateQueue), (t = t !== null ? t.lastEffect : null), t !== null)) {
    var n = (t = t.next)
    do {
      if ((n.tag & e) === e) {
        var r = n.create
        n.destroy = r()
      }
      n = n.next
    } while (n !== t)
  }
}
function M1(e) {
  var t = e.ref
  if (t !== null) {
    var n = e.stateNode
    switch (e.tag) {
      case 5:
        e = n
        break
      default:
        e = n
    }
    typeof t == 'function' ? t(e) : (t.current = e)
  }
}
function G4(e) {
  var t = e.alternate
  ;(t !== null && ((e.alternate = null), G4(t)),
    (e.child = null),
    (e.deletions = null),
    (e.sibling = null),
    e.tag === 5 &&
      ((t = e.stateNode),
      t !== null && (delete t[Sr], delete t[hl], delete t[b1], delete t[Rx], delete t[Mx])),
    (e.stateNode = null),
    (e.return = null),
    (e.dependencies = null),
    (e.memoizedProps = null),
    (e.memoizedState = null),
    (e.pendingProps = null),
    (e.stateNode = null),
    (e.updateQueue = null))
}
function Y4(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function Bg(e) {
  e: for (;;) {
    for (; e.sibling === null; ) {
      if (e.return === null || Y4(e.return)) return null
      e = e.return
    }
    for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e
      ;((e.child.return = e), (e = e.child))
    }
    if (!(e.flags & 2)) return e.stateNode
  }
}
function P1(e, t, n) {
  var r = e.tag
  if (r === 5 || r === 6)
    ((e = e.stateNode),
      t
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(e, t)
          : n.insertBefore(e, t)
        : (n.nodeType === 8
            ? ((t = n.parentNode), t.insertBefore(e, n))
            : ((t = n), t.appendChild(e)),
          (n = n._reactRootContainer),
          n != null || t.onclick !== null || (t.onclick = du)))
  else if (r !== 4 && ((e = e.child), e !== null))
    for (P1(e, t, n), e = e.sibling; e !== null; ) (P1(e, t, n), (e = e.sibling))
}
function D1(e, t, n) {
  var r = e.tag
  if (r === 5 || r === 6) ((e = e.stateNode), t ? n.insertBefore(e, t) : n.appendChild(e))
  else if (r !== 4 && ((e = e.child), e !== null))
    for (D1(e, t, n), e = e.sibling; e !== null; ) (D1(e, t, n), (e = e.sibling))
}
var Wt = null,
  ar = !1
function oi(e, t, n) {
  for (n = n.child; n !== null; ) (Z4(e, t, n), (n = n.sibling))
}
function Z4(e, t, n) {
  if (Ar && typeof Ar.onCommitFiberUnmount == 'function')
    try {
      Ar.onCommitFiberUnmount(Ku, n)
    } catch {}
  switch (n.tag) {
    case 5:
      $t || po(n, t)
    case 6:
      var r = Wt,
        i = ar
      ;((Wt = null),
        oi(e, t, n),
        (Wt = r),
        (ar = i),
        Wt !== null &&
          (ar
            ? ((e = Wt),
              (n = n.stateNode),
              e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n))
            : Wt.removeChild(n.stateNode)))
      break
    case 18:
      Wt !== null &&
        (ar
          ? ((e = Wt),
            (n = n.stateNode),
            e.nodeType === 8 ? cd(e.parentNode, n) : e.nodeType === 1 && cd(e, n),
            ol(e))
          : cd(Wt, n.stateNode))
      break
    case 4:
      ;((r = Wt),
        (i = ar),
        (Wt = n.stateNode.containerInfo),
        (ar = !0),
        oi(e, t, n),
        (Wt = r),
        (ar = i))
      break
    case 0:
    case 11:
    case 14:
    case 15:
      if (!$t && ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))) {
        i = r = r.next
        do {
          var o = i,
            c = o.destroy
          ;((o = o.tag), c !== void 0 && (o & 2 || o & 4) && X4(n, t, c), (i = i.next))
        } while (i !== r)
      }
      oi(e, t, n)
      break
    case 1:
      if (!$t && (po(n, t), (r = n.stateNode), typeof r.componentWillUnmount == 'function'))
        try {
          ;((r.props = n.memoizedProps), (r.state = n.memoizedState), r.componentWillUnmount())
        } catch (h) {
          wt(n, t, h)
        }
      oi(e, t, n)
      break
    case 21:
      oi(e, t, n)
      break
    case 22:
      n.mode & 1
        ? (($t = (r = $t) || n.memoizedState !== null), oi(e, t, n), ($t = r))
        : oi(e, t, n)
      break
    default:
      oi(e, t, n)
  }
}
function Fg(e) {
  var t = e.updateQueue
  if (t !== null) {
    e.updateQueue = null
    var n = e.stateNode
    ;(n === null && (n = e.stateNode = new Zx()),
      t.forEach(function (r) {
        var i = iE.bind(null, e, r)
        n.has(r) || (n.add(r), r.then(i, i))
      }))
  }
}
function ir(e, t) {
  var n = t.deletions
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r]
      try {
        var o = e,
          c = t,
          h = c
        e: for (; h !== null; ) {
          switch (h.tag) {
            case 5:
              ;((Wt = h.stateNode), (ar = !1))
              break e
            case 3:
              ;((Wt = h.stateNode.containerInfo), (ar = !0))
              break e
            case 4:
              ;((Wt = h.stateNode.containerInfo), (ar = !0))
              break e
          }
          h = h.return
        }
        if (Wt === null) throw Error(ee(160))
        ;(Z4(o, c, i), (Wt = null), (ar = !1))
        var f = i.alternate
        ;(f !== null && (f.return = null), (i.return = null))
      } catch (p) {
        wt(i, t, p)
      }
    }
  if (t.subtreeFlags & 12854) for (t = t.child; t !== null; ) (K4(t, e), (t = t.sibling))
}
function K4(e, t) {
  var n = e.alternate,
    r = e.flags
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((ir(t, e), br(e), r & 4)) {
        try {
          ;(Wa(3, e, e.return), rh(3, e))
        } catch (k) {
          wt(e, e.return, k)
        }
        try {
          Wa(5, e, e.return)
        } catch (k) {
          wt(e, e.return, k)
        }
      }
      break
    case 1:
      ;(ir(t, e), br(e), r & 512 && n !== null && po(n, n.return))
      break
    case 5:
      if ((ir(t, e), br(e), r & 512 && n !== null && po(n, n.return), e.flags & 32)) {
        var i = e.stateNode
        try {
          nl(i, '')
        } catch (k) {
          wt(e, e.return, k)
        }
      }
      if (r & 4 && ((i = e.stateNode), i != null)) {
        var o = e.memoizedProps,
          c = n !== null ? n.memoizedProps : o,
          h = e.type,
          f = e.updateQueue
        if (((e.updateQueue = null), f !== null))
          try {
            ;(h === 'input' && o.type === 'radio' && o.name != null && m8(i, o), s1(h, c))
            var p = s1(h, o)
            for (c = 0; c < f.length; c += 2) {
              var y = f[c],
                w = f[c + 1]
              y === 'style'
                ? x8(i, w)
                : y === 'dangerouslySetInnerHTML'
                  ? b8(i, w)
                  : y === 'children'
                    ? nl(i, w)
                    : Nf(i, y, w, p)
            }
            switch (h) {
              case 'input':
                e1(i, o)
                break
              case 'textarea':
                y8(i, o)
                break
              case 'select':
                var x = i._wrapperState.wasMultiple
                i._wrapperState.wasMultiple = !!o.multiple
                var E = o.value
                E != null
                  ? Co(i, !!o.multiple, E, !1)
                  : x !== !!o.multiple &&
                    (o.defaultValue != null
                      ? Co(i, !!o.multiple, o.defaultValue, !0)
                      : Co(i, !!o.multiple, o.multiple ? [] : '', !1))
            }
            i[hl] = o
          } catch (k) {
            wt(e, e.return, k)
          }
      }
      break
    case 6:
      if ((ir(t, e), br(e), r & 4)) {
        if (e.stateNode === null) throw Error(ee(162))
        ;((i = e.stateNode), (o = e.memoizedProps))
        try {
          i.nodeValue = o
        } catch (k) {
          wt(e, e.return, k)
        }
      }
      break
    case 3:
      if ((ir(t, e), br(e), r & 4 && n !== null && n.memoizedState.isDehydrated))
        try {
          ol(t.containerInfo)
        } catch (k) {
          wt(e, e.return, k)
        }
      break
    case 4:
      ;(ir(t, e), br(e))
      break
    case 13:
      ;(ir(t, e),
        br(e),
        (i = e.child),
        i.flags & 8192 &&
          ((o = i.memoizedState !== null),
          (i.stateNode.isHidden = o),
          !o || (i.alternate !== null && i.alternate.memoizedState !== null) || (l0 = Et())),
        r & 4 && Fg(e))
      break
    case 22:
      if (
        ((y = n !== null && n.memoizedState !== null),
        e.mode & 1 ? (($t = (p = $t) || y), ir(t, e), ($t = p)) : ir(t, e),
        br(e),
        r & 8192)
      ) {
        if (((p = e.memoizedState !== null), (e.stateNode.isHidden = p) && !y && e.mode & 1))
          for (ce = e, y = e.child; y !== null; ) {
            for (w = ce = y; ce !== null; ) {
              switch (((x = ce), (E = x.child), x.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Wa(4, x, x.return)
                  break
                case 1:
                  po(x, x.return)
                  var S = x.stateNode
                  if (typeof S.componentWillUnmount == 'function') {
                    ;((r = x), (n = x.return))
                    try {
                      ;((t = r),
                        (S.props = t.memoizedProps),
                        (S.state = t.memoizedState),
                        S.componentWillUnmount())
                    } catch (k) {
                      wt(r, n, k)
                    }
                  }
                  break
                case 5:
                  po(x, x.return)
                  break
                case 22:
                  if (x.memoizedState !== null) {
                    Vg(w)
                    continue
                  }
              }
              E !== null ? ((E.return = x), (ce = E)) : Vg(w)
            }
            y = y.sibling
          }
        e: for (y = null, w = e; ; ) {
          if (w.tag === 5) {
            if (y === null) {
              y = w
              try {
                ;((i = w.stateNode),
                  p
                    ? ((o = i.style),
                      typeof o.setProperty == 'function'
                        ? o.setProperty('display', 'none', 'important')
                        : (o.display = 'none'))
                    : ((h = w.stateNode),
                      (f = w.memoizedProps.style),
                      (c = f != null && f.hasOwnProperty('display') ? f.display : null),
                      (h.style.display = v8('display', c))))
              } catch (k) {
                wt(e, e.return, k)
              }
            }
          } else if (w.tag === 6) {
            if (y === null)
              try {
                w.stateNode.nodeValue = p ? '' : w.memoizedProps
              } catch (k) {
                wt(e, e.return, k)
              }
          } else if (
            ((w.tag !== 22 && w.tag !== 23) || w.memoizedState === null || w === e) &&
            w.child !== null
          ) {
            ;((w.child.return = w), (w = w.child))
            continue
          }
          if (w === e) break e
          for (; w.sibling === null; ) {
            if (w.return === null || w.return === e) break e
            ;(y === w && (y = null), (w = w.return))
          }
          ;(y === w && (y = null), (w.sibling.return = w.return), (w = w.sibling))
        }
      }
      break
    case 19:
      ;(ir(t, e), br(e), r & 4 && Fg(e))
      break
    case 21:
      break
    default:
      ;(ir(t, e), br(e))
  }
}
function br(e) {
  var t = e.flags
  if (t & 2) {
    try {
      e: {
        for (var n = e.return; n !== null; ) {
          if (Y4(n)) {
            var r = n
            break e
          }
          n = n.return
        }
        throw Error(ee(160))
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode
          r.flags & 32 && (nl(i, ''), (r.flags &= -33))
          var o = Bg(e)
          D1(e, o, i)
          break
        case 3:
        case 4:
          var c = r.stateNode.containerInfo,
            h = Bg(e)
          P1(e, h, c)
          break
        default:
          throw Error(ee(161))
      }
    } catch (f) {
      wt(e, e.return, f)
    }
    e.flags &= -3
  }
  t & 4096 && (e.flags &= -4097)
}
function qx(e, t, n) {
  ;((ce = e), q4(e))
}
function q4(e, t, n) {
  for (var r = (e.mode & 1) !== 0; ce !== null; ) {
    var i = ce,
      o = i.child
    if (i.tag === 22 && r) {
      var c = i.memoizedState !== null || mc
      if (!c) {
        var h = i.alternate,
          f = (h !== null && h.memoizedState !== null) || $t
        h = mc
        var p = $t
        if (((mc = c), ($t = f) && !p))
          for (ce = i; ce !== null; )
            ((c = ce),
              (f = c.child),
              c.tag === 22 && c.memoizedState !== null
                ? Ug(i)
                : f !== null
                  ? ((f.return = c), (ce = f))
                  : Ug(i))
        for (; o !== null; ) ((ce = o), q4(o), (o = o.sibling))
        ;((ce = i), (mc = h), ($t = p))
      }
      jg(e)
    } else i.subtreeFlags & 8772 && o !== null ? ((o.return = i), (ce = o)) : jg(e)
  }
}
function jg(e) {
  for (; ce !== null; ) {
    var t = ce
    if (t.flags & 8772) {
      var n = t.alternate
      try {
        if (t.flags & 8772)
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              $t || rh(5, t)
              break
            case 1:
              var r = t.stateNode
              if (t.flags & 4 && !$t)
                if (n === null) r.componentDidMount()
                else {
                  var i = t.elementType === t.type ? n.memoizedProps : or(t.type, n.memoizedProps)
                  r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                }
              var o = t.updateQueue
              o !== null && Cg(t, o, r)
              break
            case 3:
              var c = t.updateQueue
              if (c !== null) {
                if (((n = null), t.child !== null))
                  switch (t.child.tag) {
                    case 5:
                      n = t.child.stateNode
                      break
                    case 1:
                      n = t.child.stateNode
                  }
                Cg(t, c, n)
              }
              break
            case 5:
              var h = t.stateNode
              if (n === null && t.flags & 4) {
                n = h
                var f = t.memoizedProps
                switch (t.type) {
                  case 'button':
                  case 'input':
                  case 'select':
                  case 'textarea':
                    f.autoFocus && n.focus()
                    break
                  case 'img':
                    f.src && (n.src = f.src)
                }
              }
              break
            case 6:
              break
            case 4:
              break
            case 12:
              break
            case 13:
              if (t.memoizedState === null) {
                var p = t.alternate
                if (p !== null) {
                  var y = p.memoizedState
                  if (y !== null) {
                    var w = y.dehydrated
                    w !== null && ol(w)
                  }
                }
              }
              break
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break
            default:
              throw Error(ee(163))
          }
        $t || (t.flags & 512 && M1(t))
      } catch (x) {
        wt(t, t.return, x)
      }
    }
    if (t === e) {
      ce = null
      break
    }
    if (((n = t.sibling), n !== null)) {
      ;((n.return = t.return), (ce = n))
      break
    }
    ce = t.return
  }
}
function Vg(e) {
  for (; ce !== null; ) {
    var t = ce
    if (t === e) {
      ce = null
      break
    }
    var n = t.sibling
    if (n !== null) {
      ;((n.return = t.return), (ce = n))
      break
    }
    ce = t.return
  }
}
function Ug(e) {
  for (; ce !== null; ) {
    var t = ce
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var n = t.return
          try {
            rh(4, t)
          } catch (f) {
            wt(t, n, f)
          }
          break
        case 1:
          var r = t.stateNode
          if (typeof r.componentDidMount == 'function') {
            var i = t.return
            try {
              r.componentDidMount()
            } catch (f) {
              wt(t, i, f)
            }
          }
          var o = t.return
          try {
            M1(t)
          } catch (f) {
            wt(t, o, f)
          }
          break
        case 5:
          var c = t.return
          try {
            M1(t)
          } catch (f) {
            wt(t, c, f)
          }
      }
    } catch (f) {
      wt(t, t.return, f)
    }
    if (t === e) {
      ce = null
      break
    }
    var h = t.sibling
    if (h !== null) {
      ;((h.return = t.return), (ce = h))
      break
    }
    ce = t.return
  }
}
var Qx = Math.ceil,
  Cu = qr.ReactCurrentDispatcher,
  o0 = qr.ReactCurrentOwner,
  Qn = qr.ReactCurrentBatchConfig,
  Le = 0,
  Lt = null,
  St = null,
  Xt = 0,
  In = 0,
  go = Fi(0),
  Nt = 0,
  yl = null,
  bs = 0,
  ih = 0,
  a0 = 0,
  za = null,
  yn = null,
  l0 = 0,
  Oo = 1 / 0,
  Lr = null,
  Su = !1,
  L1 = null,
  _i = null,
  yc = !1,
  pi = null,
  Au = 0,
  Ha = 0,
  O1 = null,
  Xc = -1,
  Gc = 0
function sn() {
  return Le & 6 ? Et() : Xc !== -1 ? Xc : (Xc = Et())
}
function Ii(e) {
  return e.mode & 1
    ? Le & 2 && Xt !== 0
      ? Xt & -Xt
      : Dx.transition !== null
        ? (Gc === 0 && (Gc = P8()), Gc)
        : ((e = He), e !== 0 || ((e = window.event), (e = e === void 0 ? 16 : V8(e.type))), e)
    : 1
}
function ur(e, t, n, r) {
  if (50 < Ha) throw ((Ha = 0), (O1 = null), Error(ee(185)))
  ;(Ml(e, n, r),
    (!(Le & 2) || e !== Lt) &&
      (e === Lt && (!(Le & 2) && (ih |= n), Nt === 4 && di(e, Xt)),
      En(e, r),
      n === 1 && Le === 0 && !(t.mode & 1) && ((Oo = Et() + 500), eh && ji())))
}
function En(e, t) {
  var n = e.callbackNode
  Dv(e, t)
  var r = lu(e, e === Lt ? Xt : 0)
  if (r === 0) (n !== null && qp(n), (e.callbackNode = null), (e.callbackPriority = 0))
  else if (((t = r & -r), e.callbackPriority !== t)) {
    if ((n != null && qp(n), t === 1))
      (e.tag === 0 ? Px(Wg.bind(null, e)) : s4(Wg.bind(null, e)),
        Nx(function () {
          !(Le & 6) && ji()
        }),
        (n = null))
    else {
      switch (D8(r)) {
        case 1:
          n = Df
          break
        case 4:
          n = R8
          break
        case 16:
          n = au
          break
        case 536870912:
          n = M8
          break
        default:
          n = au
      }
      n = iw(n, Q4.bind(null, e))
    }
    ;((e.callbackPriority = t), (e.callbackNode = n))
  }
}
function Q4(e, t) {
  if (((Xc = -1), (Gc = 0), Le & 6)) throw Error(ee(327))
  var n = e.callbackNode
  if (Io() && e.callbackNode !== n) return null
  var r = lu(e, e === Lt ? Xt : 0)
  if (r === 0) return null
  if (r & 30 || r & e.expiredLanes || t) t = ku(e, r)
  else {
    t = r
    var i = Le
    Le |= 2
    var o = J4()
    ;(Lt !== e || Xt !== t) && ((Lr = null), (Oo = Et() + 500), us(e, t))
    do
      try {
        eE()
        break
      } catch (h) {
        $4(e, h)
      }
    while (!0)
    ;(Yf(), (Cu.current = o), (Le = i), St !== null ? (t = 0) : ((Lt = null), (Xt = 0), (t = Nt)))
  }
  if (t !== 0) {
    if ((t === 2 && ((i = u1(e)), i !== 0 && ((r = i), (t = B1(e, i)))), t === 1))
      throw ((n = yl), us(e, 0), di(e, r), En(e, Et()), n)
    if (t === 6) di(e, r)
    else {
      if (
        ((i = e.current.alternate),
        !(r & 30) &&
          !$x(i) &&
          ((t = ku(e, r)), t === 2 && ((o = u1(e)), o !== 0 && ((r = o), (t = B1(e, o)))), t === 1))
      )
        throw ((n = yl), us(e, 0), di(e, r), En(e, Et()), n)
      switch (((e.finishedWork = i), (e.finishedLanes = r), t)) {
        case 0:
        case 1:
          throw Error(ee(345))
        case 2:
          es(e, yn, Lr)
          break
        case 3:
          if ((di(e, r), (r & 130023424) === r && ((t = l0 + 500 - Et()), 10 < t))) {
            if (lu(e, 0) !== 0) break
            if (((i = e.suspendedLanes), (i & r) !== r)) {
              ;(sn(), (e.pingedLanes |= e.suspendedLanes & i))
              break
            }
            e.timeoutHandle = w1(es.bind(null, e, yn, Lr), t)
            break
          }
          es(e, yn, Lr)
          break
        case 4:
          if ((di(e, r), (r & 4194240) === r)) break
          for (t = e.eventTimes, i = -1; 0 < r; ) {
            var c = 31 - cr(r)
            ;((o = 1 << c), (c = t[c]), c > i && (i = c), (r &= ~o))
          }
          if (
            ((r = i),
            (r = Et() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                  ? 480
                  : 1080 > r
                    ? 1080
                    : 1920 > r
                      ? 1920
                      : 3e3 > r
                        ? 3e3
                        : 4320 > r
                          ? 4320
                          : 1960 * Qx(r / 1960)) - r),
            10 < r)
          ) {
            e.timeoutHandle = w1(es.bind(null, e, yn, Lr), r)
            break
          }
          es(e, yn, Lr)
          break
        case 5:
          es(e, yn, Lr)
          break
        default:
          throw Error(ee(329))
      }
    }
  }
  return (En(e, Et()), e.callbackNode === n ? Q4.bind(null, e) : null)
}
function B1(e, t) {
  var n = za
  return (
    e.current.memoizedState.isDehydrated && (us(e, t).flags |= 256),
    (e = ku(e, t)),
    e !== 2 && ((t = yn), (yn = n), t !== null && F1(t)),
    e
  )
}
function F1(e) {
  yn === null ? (yn = e) : yn.push.apply(yn, e)
}
function $x(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var n = t.updateQueue
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            o = i.getSnapshot
          i = i.value
          try {
            if (!hr(o(), i)) return !1
          } catch {
            return !1
          }
        }
    }
    if (((n = t.child), t.subtreeFlags & 16384 && n !== null)) ((n.return = t), (t = n))
    else {
      if (t === e) break
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0
        t = t.return
      }
      ;((t.sibling.return = t.return), (t = t.sibling))
    }
  }
  return !0
}
function di(e, t) {
  for (
    t &= ~a0, t &= ~ih, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes;
    0 < t;

  ) {
    var n = 31 - cr(t),
      r = 1 << n
    ;((e[n] = -1), (t &= ~r))
  }
}
function Wg(e) {
  if (Le & 6) throw Error(ee(327))
  Io()
  var t = lu(e, 0)
  if (!(t & 1)) return (En(e, Et()), null)
  var n = ku(e, t)
  if (e.tag !== 0 && n === 2) {
    var r = u1(e)
    r !== 0 && ((t = r), (n = B1(e, r)))
  }
  if (n === 1) throw ((n = yl), us(e, 0), di(e, t), En(e, Et()), n)
  if (n === 6) throw Error(ee(345))
  return (
    (e.finishedWork = e.current.alternate),
    (e.finishedLanes = t),
    es(e, yn, Lr),
    En(e, Et()),
    null
  )
}
function c0(e, t) {
  var n = Le
  Le |= 1
  try {
    return e(t)
  } finally {
    ;((Le = n), Le === 0 && ((Oo = Et() + 500), eh && ji()))
  }
}
function vs(e) {
  pi !== null && pi.tag === 0 && !(Le & 6) && Io()
  var t = Le
  Le |= 1
  var n = Qn.transition,
    r = He
  try {
    if (((Qn.transition = null), (He = 1), e)) return e()
  } finally {
    ;((He = r), (Qn.transition = n), (Le = t), !(Le & 6) && ji())
  }
}
function u0() {
  ;((In = go.current), nt(go))
}
function us(e, t) {
  ;((e.finishedWork = null), (e.finishedLanes = 0))
  var n = e.timeoutHandle
  if ((n !== -1 && ((e.timeoutHandle = -1), Ix(n)), St !== null))
    for (n = St.return; n !== null; ) {
      var r = n
      switch ((Hf(r), r.tag)) {
        case 1:
          ;((r = r.type.childContextTypes), r != null && fu())
          break
        case 3:
          ;(Do(), nt(vn), nt(en), Jf())
          break
        case 5:
          $f(r)
          break
        case 4:
          Do()
          break
        case 13:
          nt(at)
          break
        case 19:
          nt(at)
          break
        case 10:
          Zf(r.type._context)
          break
        case 22:
        case 23:
          u0()
      }
      n = n.return
    }
  if (
    ((Lt = e),
    (St = e = Ni(e.current, null)),
    (Xt = In = t),
    (Nt = 0),
    (yl = null),
    (a0 = ih = bs = 0),
    (yn = za = null),
    os !== null)
  ) {
    for (t = 0; t < os.length; t++)
      if (((n = os[t]), (r = n.interleaved), r !== null)) {
        n.interleaved = null
        var i = r.next,
          o = n.pending
        if (o !== null) {
          var c = o.next
          ;((o.next = i), (r.next = c))
        }
        n.pending = r
      }
    os = null
  }
  return e
}
function $4(e, t) {
  do {
    var n = St
    try {
      if ((Yf(), (Wc.current = Eu), xu)) {
        for (var r = ut.memoizedState; r !== null; ) {
          var i = r.queue
          ;(i !== null && (i.pending = null), (r = r.next))
        }
        xu = !1
      }
      if (
        ((ws = 0),
        (Dt = It = ut = null),
        (Ua = !1),
        (pl = 0),
        (o0.current = null),
        n === null || n.return === null)
      ) {
        ;((Nt = 1), (yl = t), (St = null))
        break
      }
      e: {
        var o = e,
          c = n.return,
          h = n,
          f = t
        if (
          ((t = Xt),
          (h.flags |= 32768),
          f !== null && typeof f == 'object' && typeof f.then == 'function')
        ) {
          var p = f,
            y = h,
            w = y.tag
          if (!(y.mode & 1) && (w === 0 || w === 11 || w === 15)) {
            var x = y.alternate
            x
              ? ((y.updateQueue = x.updateQueue),
                (y.memoizedState = x.memoizedState),
                (y.lanes = x.lanes))
              : ((y.updateQueue = null), (y.memoizedState = null))
          }
          var E = Ng(c)
          if (E !== null) {
            ;((E.flags &= -257), Tg(E, c, h, o, t), E.mode & 1 && Ig(o, p, t), (t = E), (f = p))
            var S = t.updateQueue
            if (S === null) {
              var k = new Set()
              ;(k.add(f), (t.updateQueue = k))
            } else S.add(f)
            break e
          } else {
            if (!(t & 1)) {
              ;(Ig(o, p, t), h0())
              break e
            }
            f = Error(ee(426))
          }
        } else if (st && h.mode & 1) {
          var P = Ng(c)
          if (P !== null) {
            ;(!(P.flags & 65536) && (P.flags |= 256), Tg(P, c, h, o, t), Xf(Lo(f, h)))
            break e
          }
        }
        ;((o = f = Lo(f, h)), Nt !== 4 && (Nt = 2), za === null ? (za = [o]) : za.push(o), (o = c))
        do {
          switch (o.tag) {
            case 3:
              ;((o.flags |= 65536), (t &= -t), (o.lanes |= t))
              var I = D4(o, f, t)
              Eg(o, I)
              break e
            case 1:
              h = f
              var R = o.type,
                M = o.stateNode
              if (
                !(o.flags & 128) &&
                (typeof R.getDerivedStateFromError == 'function' ||
                  (M !== null &&
                    typeof M.componentDidCatch == 'function' &&
                    (_i === null || !_i.has(M))))
              ) {
                ;((o.flags |= 65536), (t &= -t), (o.lanes |= t))
                var O = L4(o, h, t)
                Eg(o, O)
                break e
              }
          }
          o = o.return
        } while (o !== null)
      }
      tw(n)
    } catch (F) {
      ;((t = F), St === n && n !== null && (St = n = n.return))
      continue
    }
    break
  } while (!0)
}
function J4() {
  var e = Cu.current
  return ((Cu.current = Eu), e === null ? Eu : e)
}
function h0() {
  ;((Nt === 0 || Nt === 3 || Nt === 2) && (Nt = 4),
    Lt === null || (!(bs & 268435455) && !(ih & 268435455)) || di(Lt, Xt))
}
function ku(e, t) {
  var n = Le
  Le |= 2
  var r = J4()
  ;(Lt !== e || Xt !== t) && ((Lr = null), us(e, t))
  do
    try {
      Jx()
      break
    } catch (i) {
      $4(e, i)
    }
  while (!0)
  if ((Yf(), (Le = n), (Cu.current = r), St !== null)) throw Error(ee(261))
  return ((Lt = null), (Xt = 0), Nt)
}
function Jx() {
  for (; St !== null; ) ew(St)
}
function eE() {
  for (; St !== null && !Av(); ) ew(St)
}
function ew(e) {
  var t = rw(e.alternate, e, In)
  ;((e.memoizedProps = e.pendingProps), t === null ? tw(e) : (St = t), (o0.current = null))
}
function tw(e) {
  var t = e
  do {
    var n = t.alternate
    if (((e = t.return), t.flags & 32768)) {
      if (((n = Yx(n, t)), n !== null)) {
        ;((n.flags &= 32767), (St = n))
        return
      }
      if (e !== null) ((e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null))
      else {
        ;((Nt = 6), (St = null))
        return
      }
    } else if (((n = Gx(n, t, In)), n !== null)) {
      St = n
      return
    }
    if (((t = t.sibling), t !== null)) {
      St = t
      return
    }
    St = t = e
  } while (t !== null)
  Nt === 0 && (Nt = 5)
}
function es(e, t, n) {
  var r = He,
    i = Qn.transition
  try {
    ;((Qn.transition = null), (He = 1), tE(e, t, n, r))
  } finally {
    ;((Qn.transition = i), (He = r))
  }
  return null
}
function tE(e, t, n, r) {
  do Io()
  while (pi !== null)
  if (Le & 6) throw Error(ee(327))
  n = e.finishedWork
  var i = e.finishedLanes
  if (n === null) return null
  if (((e.finishedWork = null), (e.finishedLanes = 0), n === e.current)) throw Error(ee(177))
  ;((e.callbackNode = null), (e.callbackPriority = 0))
  var o = n.lanes | n.childLanes
  if (
    (Lv(e, o),
    e === Lt && ((St = Lt = null), (Xt = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      yc ||
      ((yc = !0),
      iw(au, function () {
        return (Io(), null)
      })),
    (o = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || o)
  ) {
    ;((o = Qn.transition), (Qn.transition = null))
    var c = He
    He = 1
    var h = Le
    ;((Le |= 4),
      (o0.current = null),
      Kx(e, n),
      K4(n, e),
      xx(m1),
      (cu = !!g1),
      (m1 = g1 = null),
      (e.current = n),
      qx(n),
      kv(),
      (Le = h),
      (He = c),
      (Qn.transition = o))
  } else e.current = n
  if (
    (yc && ((yc = !1), (pi = e), (Au = i)),
    (o = e.pendingLanes),
    o === 0 && (_i = null),
    Nv(n.stateNode),
    En(e, Et()),
    t !== null)
  )
    for (r = e.onRecoverableError, n = 0; n < t.length; n++)
      ((i = t[n]), r(i.value, { componentStack: i.stack, digest: i.digest }))
  if (Su) throw ((Su = !1), (e = L1), (L1 = null), e)
  return (
    Au & 1 && e.tag !== 0 && Io(),
    (o = e.pendingLanes),
    o & 1 ? (e === O1 ? Ha++ : ((Ha = 0), (O1 = e))) : (Ha = 0),
    ji(),
    null
  )
}
function Io() {
  if (pi !== null) {
    var e = D8(Au),
      t = Qn.transition,
      n = He
    try {
      if (((Qn.transition = null), (He = 16 > e ? 16 : e), pi === null)) var r = !1
      else {
        if (((e = pi), (pi = null), (Au = 0), Le & 6)) throw Error(ee(331))
        var i = Le
        for (Le |= 4, ce = e.current; ce !== null; ) {
          var o = ce,
            c = o.child
          if (ce.flags & 16) {
            var h = o.deletions
            if (h !== null) {
              for (var f = 0; f < h.length; f++) {
                var p = h[f]
                for (ce = p; ce !== null; ) {
                  var y = ce
                  switch (y.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Wa(8, y, o)
                  }
                  var w = y.child
                  if (w !== null) ((w.return = y), (ce = w))
                  else
                    for (; ce !== null; ) {
                      y = ce
                      var x = y.sibling,
                        E = y.return
                      if ((G4(y), y === p)) {
                        ce = null
                        break
                      }
                      if (x !== null) {
                        ;((x.return = E), (ce = x))
                        break
                      }
                      ce = E
                    }
                }
              }
              var S = o.alternate
              if (S !== null) {
                var k = S.child
                if (k !== null) {
                  S.child = null
                  do {
                    var P = k.sibling
                    ;((k.sibling = null), (k = P))
                  } while (k !== null)
                }
              }
              ce = o
            }
          }
          if (o.subtreeFlags & 2064 && c !== null) ((c.return = o), (ce = c))
          else
            e: for (; ce !== null; ) {
              if (((o = ce), o.flags & 2048))
                switch (o.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Wa(9, o, o.return)
                }
              var I = o.sibling
              if (I !== null) {
                ;((I.return = o.return), (ce = I))
                break e
              }
              ce = o.return
            }
        }
        var R = e.current
        for (ce = R; ce !== null; ) {
          c = ce
          var M = c.child
          if (c.subtreeFlags & 2064 && M !== null) ((M.return = c), (ce = M))
          else
            e: for (c = R; ce !== null; ) {
              if (((h = ce), h.flags & 2048))
                try {
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      rh(9, h)
                  }
                } catch (F) {
                  wt(h, h.return, F)
                }
              if (h === c) {
                ce = null
                break e
              }
              var O = h.sibling
              if (O !== null) {
                ;((O.return = h.return), (ce = O))
                break e
              }
              ce = h.return
            }
        }
        if (((Le = i), ji(), Ar && typeof Ar.onPostCommitFiberRoot == 'function'))
          try {
            Ar.onPostCommitFiberRoot(Ku, e)
          } catch {}
        r = !0
      }
      return r
    } finally {
      ;((He = n), (Qn.transition = t))
    }
  }
  return !1
}
function zg(e, t, n) {
  ;((t = Lo(n, t)),
    (t = D4(e, t, 1)),
    (e = ki(e, t, 1)),
    (t = sn()),
    e !== null && (Ml(e, 1, t), En(e, t)))
}
function wt(e, t, n) {
  if (e.tag === 3) zg(e, e, n)
  else
    for (; t !== null; ) {
      if (t.tag === 3) {
        zg(t, e, n)
        break
      } else if (t.tag === 1) {
        var r = t.stateNode
        if (
          typeof t.type.getDerivedStateFromError == 'function' ||
          (typeof r.componentDidCatch == 'function' && (_i === null || !_i.has(r)))
        ) {
          ;((e = Lo(n, e)),
            (e = L4(t, e, 1)),
            (t = ki(t, e, 1)),
            (e = sn()),
            t !== null && (Ml(t, 1, e), En(t, e)))
          break
        }
      }
      t = t.return
    }
}
function nE(e, t, n) {
  var r = e.pingCache
  ;(r !== null && r.delete(t),
    (t = sn()),
    (e.pingedLanes |= e.suspendedLanes & n),
    Lt === e &&
      (Xt & n) === n &&
      (Nt === 4 || (Nt === 3 && (Xt & 130023424) === Xt && 500 > Et() - l0) ? us(e, 0) : (a0 |= n)),
    En(e, t))
}
function nw(e, t) {
  t === 0 && (e.mode & 1 ? ((t = ac), (ac <<= 1), !(ac & 130023424) && (ac = 4194304)) : (t = 1))
  var n = sn()
  ;((e = Yr(e, t)), e !== null && (Ml(e, t, n), En(e, n)))
}
function rE(e) {
  var t = e.memoizedState,
    n = 0
  ;(t !== null && (n = t.retryLane), nw(e, n))
}
function iE(e, t) {
  var n = 0
  switch (e.tag) {
    case 13:
      var r = e.stateNode,
        i = e.memoizedState
      i !== null && (n = i.retryLane)
      break
    case 19:
      r = e.stateNode
      break
    default:
      throw Error(ee(314))
  }
  ;(r !== null && r.delete(t), nw(e, n))
}
var rw
rw = function (e, t, n) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps || vn.current) bn = !0
    else {
      if (!(e.lanes & n) && !(t.flags & 128)) return ((bn = !1), Xx(e, t, n))
      bn = !!(e.flags & 131072)
    }
  else ((bn = !1), st && t.flags & 1048576 && o4(t, mu, t.index))
  switch (((t.lanes = 0), t.tag)) {
    case 2:
      var r = t.type
      ;(Hc(e, t), (e = t.pendingProps))
      var i = Ro(t, en.current)
      ;(_o(t, n), (i = t0(null, t, r, e, i, n)))
      var o = n0()
      return (
        (t.flags |= 1),
        typeof i == 'object' && i !== null && typeof i.render == 'function' && i.$$typeof === void 0
          ? ((t.tag = 1),
            (t.memoizedState = null),
            (t.updateQueue = null),
            xn(r) ? ((o = !0), pu(t)) : (o = !1),
            (t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null),
            qf(t),
            (i.updater = nh),
            (t.stateNode = i),
            (i._reactInternals = t),
            A1(t, r, e, n),
            (t = I1(null, t, r, !0, o, n)))
          : ((t.tag = 0), st && o && zf(t), rn(null, t, i, n), (t = t.child)),
        t
      )
    case 16:
      r = t.elementType
      e: {
        switch (
          (Hc(e, t),
          (e = t.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (t.type = r),
          (i = t.tag = oE(r)),
          (e = or(r, e)),
          i)
        ) {
          case 0:
            t = _1(null, t, r, e, n)
            break e
          case 1:
            t = Pg(null, t, r, e, n)
            break e
          case 11:
            t = Rg(null, t, r, e, n)
            break e
          case 14:
            t = Mg(null, t, r, or(r.type, e), n)
            break e
        }
        throw Error(ee(306, r, ''))
      }
      return t
    case 0:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : or(r, i)),
        _1(e, t, r, i, n)
      )
    case 1:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : or(r, i)),
        Pg(e, t, r, i, n)
      )
    case 3:
      e: {
        if ((j4(t), e === null)) throw Error(ee(387))
        ;((r = t.pendingProps), (o = t.memoizedState), (i = o.element), d4(e, t), bu(t, r, null, n))
        var c = t.memoizedState
        if (((r = c.element), o.isDehydrated))
          if (
            ((o = {
              element: r,
              isDehydrated: !1,
              cache: c.cache,
              pendingSuspenseBoundaries: c.pendingSuspenseBoundaries,
              transitions: c.transitions,
            }),
            (t.updateQueue.baseState = o),
            (t.memoizedState = o),
            t.flags & 256)
          ) {
            ;((i = Lo(Error(ee(423)), t)), (t = Dg(e, t, r, n, i)))
            break e
          } else if (r !== i) {
            ;((i = Lo(Error(ee(424)), t)), (t = Dg(e, t, r, n, i)))
            break e
          } else
            for (
              Tn = Ai(t.stateNode.containerInfo.firstChild),
                Pn = t,
                st = !0,
                lr = null,
                n = u4(t, null, r, n),
                t.child = n;
              n;

            )
              ((n.flags = (n.flags & -3) | 4096), (n = n.sibling))
        else {
          if ((Mo(), r === i)) {
            t = Zr(e, t, n)
            break e
          }
          rn(e, t, r, n)
        }
        t = t.child
      }
      return t
    case 5:
      return (
        f4(t),
        e === null && E1(t),
        (r = t.type),
        (i = t.pendingProps),
        (o = e !== null ? e.memoizedProps : null),
        (c = i.children),
        y1(r, i) ? (c = null) : o !== null && y1(r, o) && (t.flags |= 32),
        F4(e, t),
        rn(e, t, c, n),
        t.child
      )
    case 6:
      return (e === null && E1(t), null)
    case 13:
      return V4(e, t, n)
    case 4:
      return (
        Qf(t, t.stateNode.containerInfo),
        (r = t.pendingProps),
        e === null ? (t.child = Po(t, null, r, n)) : rn(e, t, r, n),
        t.child
      )
    case 11:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : or(r, i)),
        Rg(e, t, r, i, n)
      )
    case 7:
      return (rn(e, t, t.pendingProps, n), t.child)
    case 8:
      return (rn(e, t, t.pendingProps.children, n), t.child)
    case 12:
      return (rn(e, t, t.pendingProps.children, n), t.child)
    case 10:
      e: {
        if (
          ((r = t.type._context),
          (i = t.pendingProps),
          (o = t.memoizedProps),
          (c = i.value),
          $e(yu, r._currentValue),
          (r._currentValue = c),
          o !== null)
        )
          if (hr(o.value, c)) {
            if (o.children === i.children && !vn.current) {
              t = Zr(e, t, n)
              break e
            }
          } else
            for (o = t.child, o !== null && (o.return = t); o !== null; ) {
              var h = o.dependencies
              if (h !== null) {
                c = o.child
                for (var f = h.firstContext; f !== null; ) {
                  if (f.context === r) {
                    if (o.tag === 1) {
                      ;((f = Wr(-1, n & -n)), (f.tag = 2))
                      var p = o.updateQueue
                      if (p !== null) {
                        p = p.shared
                        var y = p.pending
                        ;(y === null ? (f.next = f) : ((f.next = y.next), (y.next = f)),
                          (p.pending = f))
                      }
                    }
                    ;((o.lanes |= n),
                      (f = o.alternate),
                      f !== null && (f.lanes |= n),
                      C1(o.return, n, t),
                      (h.lanes |= n))
                    break
                  }
                  f = f.next
                }
              } else if (o.tag === 10) c = o.type === t.type ? null : o.child
              else if (o.tag === 18) {
                if (((c = o.return), c === null)) throw Error(ee(341))
                ;((c.lanes |= n),
                  (h = c.alternate),
                  h !== null && (h.lanes |= n),
                  C1(c, n, t),
                  (c = o.sibling))
              } else c = o.child
              if (c !== null) c.return = o
              else
                for (c = o; c !== null; ) {
                  if (c === t) {
                    c = null
                    break
                  }
                  if (((o = c.sibling), o !== null)) {
                    ;((o.return = c.return), (c = o))
                    break
                  }
                  c = c.return
                }
              o = c
            }
        ;(rn(e, t, i.children, n), (t = t.child))
      }
      return t
    case 9:
      return (
        (i = t.type),
        (r = t.pendingProps.children),
        _o(t, n),
        (i = $n(i)),
        (r = r(i)),
        (t.flags |= 1),
        rn(e, t, r, n),
        t.child
      )
    case 14:
      return ((r = t.type), (i = or(r, t.pendingProps)), (i = or(r.type, i)), Mg(e, t, r, i, n))
    case 15:
      return O4(e, t, t.type, t.pendingProps, n)
    case 17:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : or(r, i)),
        Hc(e, t),
        (t.tag = 1),
        xn(r) ? ((e = !0), pu(t)) : (e = !1),
        _o(t, n),
        P4(t, r, i),
        A1(t, r, i, n),
        I1(null, t, r, !0, e, n)
      )
    case 19:
      return U4(e, t, n)
    case 22:
      return B4(e, t, n)
  }
  throw Error(ee(156, t.tag))
}
function iw(e, t) {
  return T8(e, t)
}
function sE(e, t, n, r) {
  ;((this.tag = e),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = t),
    (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null))
}
function Kn(e, t, n, r) {
  return new sE(e, t, n, r)
}
function d0(e) {
  return ((e = e.prototype), !(!e || !e.isReactComponent))
}
function oE(e) {
  if (typeof e == 'function') return d0(e) ? 1 : 0
  if (e != null) {
    if (((e = e.$$typeof), e === Rf)) return 11
    if (e === Mf) return 14
  }
  return 2
}
function Ni(e, t) {
  var n = e.alternate
  return (
    n === null
      ? ((n = Kn(e.tag, t, e.key, e.mode)),
        (n.elementType = e.elementType),
        (n.type = e.type),
        (n.stateNode = e.stateNode),
        (n.alternate = e),
        (e.alternate = n))
      : ((n.pendingProps = t),
        (n.type = e.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = e.flags & 14680064),
    (n.childLanes = e.childLanes),
    (n.lanes = e.lanes),
    (n.child = e.child),
    (n.memoizedProps = e.memoizedProps),
    (n.memoizedState = e.memoizedState),
    (n.updateQueue = e.updateQueue),
    (t = e.dependencies),
    (n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }),
    (n.sibling = e.sibling),
    (n.index = e.index),
    (n.ref = e.ref),
    n
  )
}
function Yc(e, t, n, r, i, o) {
  var c = 2
  if (((r = e), typeof e == 'function')) d0(e) && (c = 1)
  else if (typeof e == 'string') c = 5
  else
    e: switch (e) {
      case io:
        return hs(n.children, i, o, t)
      case Tf:
        ;((c = 8), (i |= 8))
        break
      case Kd:
        return ((e = Kn(12, n, t, i | 2)), (e.elementType = Kd), (e.lanes = o), e)
      case qd:
        return ((e = Kn(13, n, t, i)), (e.elementType = qd), (e.lanes = o), e)
      case Qd:
        return ((e = Kn(19, n, t, i)), (e.elementType = Qd), (e.lanes = o), e)
      case f8:
        return sh(n, i, o, t)
      default:
        if (typeof e == 'object' && e !== null)
          switch (e.$$typeof) {
            case h8:
              c = 10
              break e
            case d8:
              c = 9
              break e
            case Rf:
              c = 11
              break e
            case Mf:
              c = 14
              break e
            case ci:
              ;((c = 16), (r = null))
              break e
          }
        throw Error(ee(130, e == null ? e : typeof e, ''))
    }
  return ((t = Kn(c, n, t, i)), (t.elementType = e), (t.type = r), (t.lanes = o), t)
}
function hs(e, t, n, r) {
  return ((e = Kn(7, e, r, t)), (e.lanes = n), e)
}
function sh(e, t, n, r) {
  return (
    (e = Kn(22, e, r, t)),
    (e.elementType = f8),
    (e.lanes = n),
    (e.stateNode = { isHidden: !1 }),
    e
  )
}
function yd(e, t, n) {
  return ((e = Kn(6, e, null, t)), (e.lanes = n), e)
}
function wd(e, t, n) {
  return (
    (t = Kn(4, e.children !== null ? e.children : [], e.key, t)),
    (t.lanes = n),
    (t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation,
    }),
    t
  )
}
function aE(e, t, n, r, i) {
  ;((this.tag = t),
    (this.containerInfo = e),
    (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = $h(0)),
    (this.expirationTimes = $h(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = $h(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null))
}
function f0(e, t, n, r, i, o, c, h, f) {
  return (
    (e = new aE(e, t, n, h, f)),
    t === 1 ? ((t = 1), o === !0 && (t |= 8)) : (t = 0),
    (o = Kn(3, null, null, t)),
    (e.current = o),
    (o.stateNode = e),
    (o.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    qf(o),
    e
  )
}
function lE(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
  return {
    $$typeof: ro,
    key: r == null ? null : '' + r,
    children: e,
    containerInfo: t,
    implementation: n,
  }
}
function sw(e) {
  if (!e) return Pi
  e = e._reactInternals
  e: {
    if (ks(e) !== e || e.tag !== 1) throw Error(ee(170))
    var t = e
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context
          break e
        case 1:
          if (xn(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext
            break e
          }
      }
      t = t.return
    } while (t !== null)
    throw Error(ee(171))
  }
  if (e.tag === 1) {
    var n = e.type
    if (xn(n)) return i4(e, n, t)
  }
  return t
}
function ow(e, t, n, r, i, o, c, h, f) {
  return (
    (e = f0(n, r, !0, e, i, o, c, h, f)),
    (e.context = sw(null)),
    (n = e.current),
    (r = sn()),
    (i = Ii(n)),
    (o = Wr(r, i)),
    (o.callback = t ?? null),
    ki(n, o, i),
    (e.current.lanes = i),
    Ml(e, i, r),
    En(e, r),
    e
  )
}
function oh(e, t, n, r) {
  var i = t.current,
    o = sn(),
    c = Ii(i)
  return (
    (n = sw(n)),
    t.context === null ? (t.context = n) : (t.pendingContext = n),
    (t = Wr(o, c)),
    (t.payload = { element: e }),
    (r = r === void 0 ? null : r),
    r !== null && (t.callback = r),
    (e = ki(i, t, c)),
    e !== null && (ur(e, i, c, o), Uc(e, i, c)),
    c
  )
}
function _u(e) {
  if (((e = e.current), !e.child)) return null
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode
    default:
      return e.child.stateNode
  }
}
function Hg(e, t) {
  if (((e = e.memoizedState), e !== null && e.dehydrated !== null)) {
    var n = e.retryLane
    e.retryLane = n !== 0 && n < t ? n : t
  }
}
function p0(e, t) {
  ;(Hg(e, t), (e = e.alternate) && Hg(e, t))
}
function cE() {
  return null
}
var aw =
  typeof reportError == 'function'
    ? reportError
    : function (e) {
        console.error(e)
      }
function g0(e) {
  this._internalRoot = e
}
ah.prototype.render = g0.prototype.render = function (e) {
  var t = this._internalRoot
  if (t === null) throw Error(ee(409))
  oh(e, t, null, null)
}
ah.prototype.unmount = g0.prototype.unmount = function () {
  var e = this._internalRoot
  if (e !== null) {
    this._internalRoot = null
    var t = e.containerInfo
    ;(vs(function () {
      oh(null, e, null, null)
    }),
      (t[Gr] = null))
  }
}
function ah(e) {
  this._internalRoot = e
}
ah.prototype.unstable_scheduleHydration = function (e) {
  if (e) {
    var t = B8()
    e = { blockedOn: null, target: e, priority: t }
    for (var n = 0; n < hi.length && t !== 0 && t < hi[n].priority; n++);
    ;(hi.splice(n, 0, e), n === 0 && j8(e))
  }
}
function m0(e) {
  return !(!e || (e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11))
}
function lh(e) {
  return !(
    !e ||
    (e.nodeType !== 1 &&
      e.nodeType !== 9 &&
      e.nodeType !== 11 &&
      (e.nodeType !== 8 || e.nodeValue !== ' react-mount-point-unstable '))
  )
}
function Xg() {}
function uE(e, t, n, r, i) {
  if (i) {
    if (typeof r == 'function') {
      var o = r
      r = function () {
        var p = _u(c)
        o.call(p)
      }
    }
    var c = ow(t, r, e, 0, null, !1, !1, '', Xg)
    return (
      (e._reactRootContainer = c),
      (e[Gr] = c.current),
      cl(e.nodeType === 8 ? e.parentNode : e),
      vs(),
      c
    )
  }
  for (; (i = e.lastChild); ) e.removeChild(i)
  if (typeof r == 'function') {
    var h = r
    r = function () {
      var p = _u(f)
      h.call(p)
    }
  }
  var f = f0(e, 0, !1, null, null, !1, !1, '', Xg)
  return (
    (e._reactRootContainer = f),
    (e[Gr] = f.current),
    cl(e.nodeType === 8 ? e.parentNode : e),
    vs(function () {
      oh(t, f, n, r)
    }),
    f
  )
}
function ch(e, t, n, r, i) {
  var o = n._reactRootContainer
  if (o) {
    var c = o
    if (typeof i == 'function') {
      var h = i
      i = function () {
        var f = _u(c)
        h.call(f)
      }
    }
    oh(t, c, e, i)
  } else c = uE(n, t, e, i, r)
  return _u(c)
}
L8 = function (e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode
      if (t.current.memoizedState.isDehydrated) {
        var n = Ia(t.pendingLanes)
        n !== 0 && (Lf(t, n | 1), En(t, Et()), !(Le & 6) && ((Oo = Et() + 500), ji()))
      }
      break
    case 13:
      ;(vs(function () {
        var r = Yr(e, 1)
        if (r !== null) {
          var i = sn()
          ur(r, e, 1, i)
        }
      }),
        p0(e, 1))
  }
}
Of = function (e) {
  if (e.tag === 13) {
    var t = Yr(e, 134217728)
    if (t !== null) {
      var n = sn()
      ur(t, e, 134217728, n)
    }
    p0(e, 134217728)
  }
}
O8 = function (e) {
  if (e.tag === 13) {
    var t = Ii(e),
      n = Yr(e, t)
    if (n !== null) {
      var r = sn()
      ur(n, e, t, r)
    }
    p0(e, t)
  }
}
B8 = function () {
  return He
}
F8 = function (e, t) {
  var n = He
  try {
    return ((He = e), t())
  } finally {
    He = n
  }
}
a1 = function (e, t, n) {
  switch (t) {
    case 'input':
      if ((e1(e, n), (t = n.name), n.type === 'radio' && t != null)) {
        for (n = e; n.parentNode; ) n = n.parentNode
        for (
          n = n.querySelectorAll('input[name=' + JSON.stringify('' + t) + '][type="radio"]'), t = 0;
          t < n.length;
          t++
        ) {
          var r = n[t]
          if (r !== e && r.form === e.form) {
            var i = Ju(r)
            if (!i) throw Error(ee(90))
            ;(g8(r), e1(r, i))
          }
        }
      }
      break
    case 'textarea':
      y8(e, n)
      break
    case 'select':
      ;((t = n.value), t != null && Co(e, !!n.multiple, t, !1))
  }
}
S8 = c0
A8 = vs
var hE = { usingClientEntryPoint: !1, Events: [Dl, lo, Ju, E8, C8, c0] },
  ba = {
    findFiberByHostInstance: ss,
    bundleType: 0,
    version: '18.3.1',
    rendererPackageName: 'react-dom',
  },
  dE = {
    bundleType: ba.bundleType,
    version: ba.version,
    rendererPackageName: ba.rendererPackageName,
    rendererConfig: ba.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: qr.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (e) {
      return ((e = I8(e)), e === null ? null : e.stateNode)
    },
    findFiberByHostInstance: ba.findFiberByHostInstance || cE,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: '18.3.1-next-f1338f8080-20240426',
  }
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
  var wc = __REACT_DEVTOOLS_GLOBAL_HOOK__
  if (!wc.isDisabled && wc.supportsFiber)
    try {
      ;((Ku = wc.inject(dE)), (Ar = wc))
    } catch {}
}
Fn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hE
Fn.createPortal = function (e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
  if (!m0(t)) throw Error(ee(200))
  return lE(e, t, null, n)
}
Fn.createRoot = function (e, t) {
  if (!m0(e)) throw Error(ee(299))
  var n = !1,
    r = '',
    i = aw
  return (
    t != null &&
      (t.unstable_strictMode === !0 && (n = !0),
      t.identifierPrefix !== void 0 && (r = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (i = t.onRecoverableError)),
    (t = f0(e, 1, !1, null, null, n, !1, r, i)),
    (e[Gr] = t.current),
    cl(e.nodeType === 8 ? e.parentNode : e),
    new g0(t)
  )
}
Fn.findDOMNode = function (e) {
  if (e == null) return null
  if (e.nodeType === 1) return e
  var t = e._reactInternals
  if (t === void 0)
    throw typeof e.render == 'function'
      ? Error(ee(188))
      : ((e = Object.keys(e).join(',')), Error(ee(268, e)))
  return ((e = I8(t)), (e = e === null ? null : e.stateNode), e)
}
Fn.flushSync = function (e) {
  return vs(e)
}
Fn.hydrate = function (e, t, n) {
  if (!lh(t)) throw Error(ee(200))
  return ch(null, e, t, !0, n)
}
Fn.hydrateRoot = function (e, t, n) {
  if (!m0(e)) throw Error(ee(405))
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    o = '',
    c = aw
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (o = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (c = n.onRecoverableError)),
    (t = ow(t, null, e, 1, n ?? null, i, !1, o, c)),
    (e[Gr] = t.current),
    cl(e),
    r)
  )
    for (e = 0; e < r.length; e++)
      ((n = r[e]),
        (i = n._getVersion),
        (i = i(n._source)),
        t.mutableSourceEagerHydrationData == null
          ? (t.mutableSourceEagerHydrationData = [n, i])
          : t.mutableSourceEagerHydrationData.push(n, i))
  return new ah(t)
}
Fn.render = function (e, t, n) {
  if (!lh(t)) throw Error(ee(200))
  return ch(null, e, t, !1, n)
}
Fn.unmountComponentAtNode = function (e) {
  if (!lh(e)) throw Error(ee(40))
  return e._reactRootContainer
    ? (vs(function () {
        ch(null, null, e, !1, function () {
          ;((e._reactRootContainer = null), (e[Gr] = null))
        })
      }),
      !0)
    : !1
}
Fn.unstable_batchedUpdates = c0
Fn.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
  if (!lh(n)) throw Error(ee(200))
  if (e == null || e._reactInternals === void 0) throw Error(ee(38))
  return ch(e, t, n, !1, r)
}
Fn.version = '18.3.1-next-f1338f8080-20240426'
function lw() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(lw)
    } catch (e) {
      console.error(e)
    }
}
;(lw(), (a8.exports = Fn))
var fE = a8.exports,
  cw,
  Gg = fE
;((cw = Gg.createRoot), Gg.hydrateRoot)
/**
 * @remix-run/router v1.23.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function wl() {
  return (
    (wl = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    wl.apply(this, arguments)
  )
}
var gi
;(function (e) {
  ;((e.Pop = 'POP'), (e.Push = 'PUSH'), (e.Replace = 'REPLACE'))
})(gi || (gi = {}))
const Yg = 'popstate'
function pE(e) {
  e === void 0 && (e = {})
  function t(i, o) {
    let { pathname: c = '/', search: h = '', hash: f = '' } = _s(i.location.hash.substr(1))
    return (
      !c.startsWith('/') && !c.startsWith('.') && (c = '/' + c),
      j1(
        '',
        { pathname: c, search: h, hash: f },
        (o.state && o.state.usr) || null,
        (o.state && o.state.key) || 'default'
      )
    )
  }
  function n(i, o) {
    let c = i.document.querySelector('base'),
      h = ''
    if (c && c.getAttribute('href')) {
      let f = i.location.href,
        p = f.indexOf('#')
      h = p === -1 ? f : f.slice(0, p)
    }
    return h + '#' + (typeof o == 'string' ? o : Iu(o))
  }
  function r(i, o) {
    uh(
      i.pathname.charAt(0) === '/',
      'relative pathnames are not supported in hash history.push(' + JSON.stringify(o) + ')'
    )
  }
  return mE(t, n, r, e)
}
function ht(e, t) {
  if (e === !1 || e === null || typeof e > 'u') throw new Error(t)
}
function uh(e, t) {
  if (!e) {
    typeof console < 'u' && console.warn(t)
    try {
      throw new Error(t)
    } catch {}
  }
}
function gE() {
  return Math.random().toString(36).substr(2, 8)
}
function Zg(e, t) {
  return { usr: e.state, key: e.key, idx: t }
}
function j1(e, t, n, r) {
  return (
    n === void 0 && (n = null),
    wl(
      { pathname: typeof e == 'string' ? e : e.pathname, search: '', hash: '' },
      typeof t == 'string' ? _s(t) : t,
      { state: n, key: (t && t.key) || r || gE() }
    )
  )
}
function Iu(e) {
  let { pathname: t = '/', search: n = '', hash: r = '' } = e
  return (
    n && n !== '?' && (t += n.charAt(0) === '?' ? n : '?' + n),
    r && r !== '#' && (t += r.charAt(0) === '#' ? r : '#' + r),
    t
  )
}
function _s(e) {
  let t = {}
  if (e) {
    let n = e.indexOf('#')
    n >= 0 && ((t.hash = e.substr(n)), (e = e.substr(0, n)))
    let r = e.indexOf('?')
    ;(r >= 0 && ((t.search = e.substr(r)), (e = e.substr(0, r))), e && (t.pathname = e))
  }
  return t
}
function mE(e, t, n, r) {
  r === void 0 && (r = {})
  let { window: i = document.defaultView, v5Compat: o = !1 } = r,
    c = i.history,
    h = gi.Pop,
    f = null,
    p = y()
  p == null && ((p = 0), c.replaceState(wl({}, c.state, { idx: p }), ''))
  function y() {
    return (c.state || { idx: null }).idx
  }
  function w() {
    h = gi.Pop
    let P = y(),
      I = P == null ? null : P - p
    ;((p = P), f && f({ action: h, location: k.location, delta: I }))
  }
  function x(P, I) {
    h = gi.Push
    let R = j1(k.location, P, I)
    ;(n && n(R, P), (p = y() + 1))
    let M = Zg(R, p),
      O = k.createHref(R)
    try {
      c.pushState(M, '', O)
    } catch (F) {
      if (F instanceof DOMException && F.name === 'DataCloneError') throw F
      i.location.assign(O)
    }
    o && f && f({ action: h, location: k.location, delta: 1 })
  }
  function E(P, I) {
    h = gi.Replace
    let R = j1(k.location, P, I)
    ;(n && n(R, P), (p = y()))
    let M = Zg(R, p),
      O = k.createHref(R)
    ;(c.replaceState(M, '', O), o && f && f({ action: h, location: k.location, delta: 0 }))
  }
  function S(P) {
    let I = i.location.origin !== 'null' ? i.location.origin : i.location.href,
      R = typeof P == 'string' ? P : Iu(P)
    return (
      (R = R.replace(/ $/, '%20')),
      ht(I, 'No window.location.(origin|href) available to create URL for href: ' + R),
      new URL(R, I)
    )
  }
  let k = {
    get action() {
      return h
    },
    get location() {
      return e(i, c)
    },
    listen(P) {
      if (f) throw new Error('A history only accepts one active listener')
      return (
        i.addEventListener(Yg, w),
        (f = P),
        () => {
          ;(i.removeEventListener(Yg, w), (f = null))
        }
      )
    },
    createHref(P) {
      return t(i, P)
    },
    createURL: S,
    encodeLocation(P) {
      let I = S(P)
      return { pathname: I.pathname, search: I.search, hash: I.hash }
    },
    push: x,
    replace: E,
    go(P) {
      return c.go(P)
    },
  }
  return k
}
var Kg
;(function (e) {
  ;((e.data = 'data'), (e.deferred = 'deferred'), (e.redirect = 'redirect'), (e.error = 'error'))
})(Kg || (Kg = {}))
function yE(e, t, n) {
  return (n === void 0 && (n = '/'), wE(e, t, n))
}
function wE(e, t, n, r) {
  let i = typeof t == 'string' ? _s(t) : t,
    o = Bo(i.pathname || '/', n)
  if (o == null) return null
  let c = uw(e)
  bE(c)
  let h = null
  for (let f = 0; h == null && f < c.length; ++f) {
    let p = TE(o)
    h = IE(c[f], p)
  }
  return h
}
function uw(e, t, n, r) {
  ;(t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = ''))
  let i = (o, c, h) => {
    let f = {
      relativePath: h === void 0 ? o.path || '' : h,
      caseSensitive: o.caseSensitive === !0,
      childrenIndex: c,
      route: o,
    }
    f.relativePath.startsWith('/') &&
      (ht(
        f.relativePath.startsWith(r),
        'Absolute route path "' +
          f.relativePath +
          '" nested under path ' +
          ('"' + r + '" is not valid. An absolute child route path ') +
          'must start with the combined path of all its parent routes.'
      ),
      (f.relativePath = f.relativePath.slice(r.length)))
    let p = Ti([r, f.relativePath]),
      y = n.concat(f)
    ;(o.children &&
      o.children.length > 0 &&
      (ht(
        o.index !== !0,
        'Index routes must not have child routes. Please remove ' +
          ('all child routes from route path "' + p + '".')
      ),
      uw(o.children, t, y, p)),
      !(o.path == null && !o.index) && t.push({ path: p, score: kE(p, o.index), routesMeta: y }))
  }
  return (
    e.forEach((o, c) => {
      var h
      if (o.path === '' || !((h = o.path) != null && h.includes('?'))) i(o, c)
      else for (let f of hw(o.path)) i(o, c, f)
    }),
    t
  )
}
function hw(e) {
  let t = e.split('/')
  if (t.length === 0) return []
  let [n, ...r] = t,
    i = n.endsWith('?'),
    o = n.replace(/\?$/, '')
  if (r.length === 0) return i ? [o, ''] : [o]
  let c = hw(r.join('/')),
    h = []
  return (
    h.push(...c.map((f) => (f === '' ? o : [o, f].join('/')))),
    i && h.push(...c),
    h.map((f) => (e.startsWith('/') && f === '' ? '/' : f))
  )
}
function bE(e) {
  e.sort((t, n) =>
    t.score !== n.score
      ? n.score - t.score
      : _E(
          t.routesMeta.map((r) => r.childrenIndex),
          n.routesMeta.map((r) => r.childrenIndex)
        )
  )
}
const vE = /^:[\w-]+$/,
  xE = 3,
  EE = 2,
  CE = 1,
  SE = 10,
  AE = -2,
  qg = (e) => e === '*'
function kE(e, t) {
  let n = e.split('/'),
    r = n.length
  return (
    n.some(qg) && (r += AE),
    t && (r += EE),
    n.filter((i) => !qg(i)).reduce((i, o) => i + (vE.test(o) ? xE : o === '' ? CE : SE), r)
  )
}
function _E(e, t) {
  return e.length === t.length && e.slice(0, -1).every((n, r) => n === t[r])
    ? e[e.length - 1] - t[t.length - 1]
    : 0
}
function IE(e, t, n) {
  let { routesMeta: r } = e,
    i = {},
    o = '/',
    c = []
  for (let h = 0; h < r.length; ++h) {
    let f = r[h],
      p = h === r.length - 1,
      y = o === '/' ? t : t.slice(o.length) || '/',
      w = V1({ path: f.relativePath, caseSensitive: f.caseSensitive, end: p }, y),
      x = f.route
    if (!w) return null
    ;(Object.assign(i, w.params),
      c.push({
        params: i,
        pathname: Ti([o, w.pathname]),
        pathnameBase: LE(Ti([o, w.pathnameBase])),
        route: x,
      }),
      w.pathnameBase !== '/' && (o = Ti([o, w.pathnameBase])))
  }
  return c
}
function V1(e, t) {
  typeof e == 'string' && (e = { path: e, caseSensitive: !1, end: !0 })
  let [n, r] = NE(e.path, e.caseSensitive, e.end),
    i = t.match(n)
  if (!i) return null
  let o = i[0],
    c = o.replace(/(.)\/+$/, '$1'),
    h = i.slice(1)
  return {
    params: r.reduce((f, p, y) => {
      let { paramName: w, isOptional: x } = p
      if (w === '*') {
        let S = h[y] || ''
        c = o.slice(0, o.length - S.length).replace(/(.)\/+$/, '$1')
      }
      const E = h[y]
      return (x && !E ? (f[w] = void 0) : (f[w] = (E || '').replace(/%2F/g, '/')), f)
    }, {}),
    pathname: o,
    pathnameBase: c,
    pattern: e,
  }
}
function NE(e, t, n) {
  ;(t === void 0 && (t = !1),
    n === void 0 && (n = !0),
    uh(
      e === '*' || !e.endsWith('*') || e.endsWith('/*'),
      'Route path "' +
        e +
        '" will be treated as if it were ' +
        ('"' + e.replace(/\*$/, '/*') + '" because the `*` character must ') +
        'always follow a `/` in the pattern. To get rid of this warning, ' +
        ('please change the route path to "' + e.replace(/\*$/, '/*') + '".')
    ))
  let r = [],
    i =
      '^' +
      e
        .replace(/\/*\*?$/, '')
        .replace(/^\/*/, '/')
        .replace(/[\\.*+^${}|()[\]]/g, '\\$&')
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (o, c, h) => (
            r.push({ paramName: c, isOptional: h != null }),
            h ? '/?([^\\/]+)?' : '/([^\\/]+)'
          )
        )
  return (
    e.endsWith('*')
      ? (r.push({ paramName: '*' }), (i += e === '*' || e === '/*' ? '(.*)$' : '(?:\\/(.+)|\\/*)$'))
      : n
        ? (i += '\\/*$')
        : e !== '' && e !== '/' && (i += '(?:(?=\\/|$))'),
    [new RegExp(i, t ? void 0 : 'i'), r]
  )
}
function TE(e) {
  try {
    return e
      .split('/')
      .map((t) => decodeURIComponent(t).replace(/\//g, '%2F'))
      .join('/')
  } catch (t) {
    return (
      uh(
        !1,
        'The URL path "' +
          e +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ('encoding (' + t + ').')
      ),
      e
    )
  }
}
function Bo(e, t) {
  if (t === '/') return e
  if (!e.toLowerCase().startsWith(t.toLowerCase())) return null
  let n = t.endsWith('/') ? t.length - 1 : t.length,
    r = e.charAt(n)
  return r && r !== '/' ? null : e.slice(n) || '/'
}
const RE = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  ME = (e) => RE.test(e)
function PE(e, t) {
  t === void 0 && (t = '/')
  let { pathname: n, search: r = '', hash: i = '' } = typeof e == 'string' ? _s(e) : e,
    o
  if (n)
    if (ME(n)) o = n
    else {
      if (n.includes('//')) {
        let c = n
        ;((n = n.replace(/\/\/+/g, '/')),
          uh(!1, 'Pathnames cannot have embedded double slashes - normalizing ' + (c + ' -> ' + n)))
      }
      n.startsWith('/') ? (o = Qg(n.substring(1), '/')) : (o = Qg(n, t))
    }
  else o = t
  return { pathname: o, search: OE(r), hash: BE(i) }
}
function Qg(e, t) {
  let n = t.replace(/\/+$/, '').split('/')
  return (
    e.split('/').forEach((r) => {
      r === '..' ? n.length > 1 && n.pop() : r !== '.' && n.push(r)
    }),
    n.length > 1 ? n.join('/') : '/'
  )
}
function bd(e, t, n, r) {
  return (
    "Cannot include a '" +
    e +
    "' character in a manually specified " +
    ('`to.' + t + '` field [' + JSON.stringify(r) + '].  Please separate it out to the ') +
    ('`to.' + n + '` field. Alternatively you may provide the full path as ') +
    'a string in <Link to="..."> and the router will parse it for you.'
  )
}
function DE(e) {
  return e.filter((t, n) => n === 0 || (t.route.path && t.route.path.length > 0))
}
function y0(e, t) {
  let n = DE(e)
  return t
    ? n.map((r, i) => (i === n.length - 1 ? r.pathname : r.pathnameBase))
    : n.map((r) => r.pathnameBase)
}
function w0(e, t, n, r) {
  r === void 0 && (r = !1)
  let i
  typeof e == 'string'
    ? (i = _s(e))
    : ((i = wl({}, e)),
      ht(!i.pathname || !i.pathname.includes('?'), bd('?', 'pathname', 'search', i)),
      ht(!i.pathname || !i.pathname.includes('#'), bd('#', 'pathname', 'hash', i)),
      ht(!i.search || !i.search.includes('#'), bd('#', 'search', 'hash', i)))
  let o = e === '' || i.pathname === '',
    c = o ? '/' : i.pathname,
    h
  if (c == null) h = n
  else {
    let w = t.length - 1
    if (!r && c.startsWith('..')) {
      let x = c.split('/')
      for (; x[0] === '..'; ) (x.shift(), (w -= 1))
      i.pathname = x.join('/')
    }
    h = w >= 0 ? t[w] : '/'
  }
  let f = PE(i, h),
    p = c && c !== '/' && c.endsWith('/'),
    y = (o || c === '.') && n.endsWith('/')
  return (!f.pathname.endsWith('/') && (p || y) && (f.pathname += '/'), f)
}
const Ti = (e) => e.join('/').replace(/\/\/+/g, '/'),
  LE = (e) => e.replace(/\/+$/, '').replace(/^\/*/, '/'),
  OE = (e) => (!e || e === '?' ? '' : e.startsWith('?') ? e : '?' + e),
  BE = (e) => (!e || e === '#' ? '' : e.startsWith('#') ? e : '#' + e)
function FE(e) {
  return (
    e != null &&
    typeof e.status == 'number' &&
    typeof e.statusText == 'string' &&
    typeof e.internal == 'boolean' &&
    'data' in e
  )
}
const dw = ['post', 'put', 'patch', 'delete']
new Set(dw)
const jE = ['get', ...dw]
new Set(jE)
/**
 * React Router v6.30.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function bl() {
  return (
    (bl = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    bl.apply(this, arguments)
  )
}
const hh = X.createContext(null),
  fw = X.createContext(null),
  Qr = X.createContext(null),
  dh = X.createContext(null),
  Vi = X.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
  pw = X.createContext(null)
function VE(e, t) {
  let { relative: n } = t === void 0 ? {} : t
  Yo() || ht(!1)
  let { basename: r, navigator: i } = X.useContext(Qr),
    { hash: o, pathname: c, search: h } = fh(e, { relative: n }),
    f = c
  return (
    r !== '/' && (f = c === '/' ? r : Ti([r, c])),
    i.createHref({ pathname: f, search: h, hash: o })
  )
}
function Yo() {
  return X.useContext(dh) != null
}
function Zo() {
  return (Yo() || ht(!1), X.useContext(dh).location)
}
function gw(e) {
  X.useContext(Qr).static || X.useLayoutEffect(e)
}
function b0() {
  let { isDataRoute: e } = X.useContext(Vi)
  return e ? JE() : UE()
}
function UE() {
  Yo() || ht(!1)
  let e = X.useContext(hh),
    { basename: t, future: n, navigator: r } = X.useContext(Qr),
    { matches: i } = X.useContext(Vi),
    { pathname: o } = Zo(),
    c = JSON.stringify(y0(i, n.v7_relativeSplatPath)),
    h = X.useRef(!1)
  return (
    gw(() => {
      h.current = !0
    }),
    X.useCallback(
      function (f, p) {
        if ((p === void 0 && (p = {}), !h.current)) return
        if (typeof f == 'number') {
          r.go(f)
          return
        }
        let y = w0(f, JSON.parse(c), o, p.relative === 'path')
        ;(e == null && t !== '/' && (y.pathname = y.pathname === '/' ? t : Ti([t, y.pathname])),
          (p.replace ? r.replace : r.push)(y, p.state, p))
      },
      [t, r, c, o, e]
    )
  )
}
function fh(e, t) {
  let { relative: n } = t === void 0 ? {} : t,
    { future: r } = X.useContext(Qr),
    { matches: i } = X.useContext(Vi),
    { pathname: o } = Zo(),
    c = JSON.stringify(y0(i, r.v7_relativeSplatPath))
  return X.useMemo(() => w0(e, JSON.parse(c), o, n === 'path'), [e, c, o, n])
}
function WE(e, t) {
  return zE(e, t)
}
function zE(e, t, n, r) {
  Yo() || ht(!1)
  let { navigator: i } = X.useContext(Qr),
    { matches: o } = X.useContext(Vi),
    c = o[o.length - 1],
    h = c ? c.params : {}
  c && c.pathname
  let f = c ? c.pathnameBase : '/'
  c && c.route
  let p = Zo(),
    y
  if (t) {
    var w
    let P = typeof t == 'string' ? _s(t) : t
    ;(f === '/' || ((w = P.pathname) != null && w.startsWith(f)) || ht(!1), (y = P))
  } else y = p
  let x = y.pathname || '/',
    E = x
  if (f !== '/') {
    let P = f.replace(/^\//, '').split('/')
    E = '/' + x.replace(/^\//, '').split('/').slice(P.length).join('/')
  }
  let S = yE(e, { pathname: E }),
    k = ZE(
      S &&
        S.map((P) =>
          Object.assign({}, P, {
            params: Object.assign({}, h, P.params),
            pathname: Ti([
              f,
              i.encodeLocation ? i.encodeLocation(P.pathname).pathname : P.pathname,
            ]),
            pathnameBase:
              P.pathnameBase === '/'
                ? f
                : Ti([
                    f,
                    i.encodeLocation ? i.encodeLocation(P.pathnameBase).pathname : P.pathnameBase,
                  ]),
          })
        ),
      o,
      n,
      r
    )
  return t && k
    ? X.createElement(
        dh.Provider,
        {
          value: {
            location: bl({ pathname: '/', search: '', hash: '', state: null, key: 'default' }, y),
            navigationType: gi.Pop,
          },
        },
        k
      )
    : k
}
function HE() {
  let e = $E(),
    t = FE(e) ? e.status + ' ' + e.statusText : e instanceof Error ? e.message : JSON.stringify(e),
    n = e instanceof Error ? e.stack : null,
    r = { padding: '0.5rem', backgroundColor: 'rgba(200,200,200, 0.5)' }
  return X.createElement(
    X.Fragment,
    null,
    X.createElement('h2', null, 'Unexpected Application Error!'),
    X.createElement('h3', { style: { fontStyle: 'italic' } }, t),
    n ? X.createElement('pre', { style: r }, n) : null,
    null
  )
}
const XE = X.createElement(HE, null)
class GE extends X.Component {
  constructor(t) {
    ;(super(t),
      (this.state = { location: t.location, revalidation: t.revalidation, error: t.error }))
  }
  static getDerivedStateFromError(t) {
    return { error: t }
  }
  static getDerivedStateFromProps(t, n) {
    return n.location !== t.location || (n.revalidation !== 'idle' && t.revalidation === 'idle')
      ? { error: t.error, location: t.location, revalidation: t.revalidation }
      : {
          error: t.error !== void 0 ? t.error : n.error,
          location: n.location,
          revalidation: t.revalidation || n.revalidation,
        }
  }
  componentDidCatch(t, n) {
    console.error('React Router caught the following error during render', t, n)
  }
  render() {
    return this.state.error !== void 0
      ? X.createElement(
          Vi.Provider,
          { value: this.props.routeContext },
          X.createElement(pw.Provider, { value: this.state.error, children: this.props.component })
        )
      : this.props.children
  }
}
function YE(e) {
  let { routeContext: t, match: n, children: r } = e,
    i = X.useContext(hh)
  return (
    i &&
      i.static &&
      i.staticContext &&
      (n.route.errorElement || n.route.ErrorBoundary) &&
      (i.staticContext._deepestRenderedBoundaryId = n.route.id),
    X.createElement(Vi.Provider, { value: t }, r)
  )
}
function ZE(e, t, n, r) {
  var i
  if (
    (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null)
  ) {
    var o
    if (!n) return null
    if (n.errors) e = n.matches
    else if (
      (o = r) != null &&
      o.v7_partialHydration &&
      t.length === 0 &&
      !n.initialized &&
      n.matches.length > 0
    )
      e = n.matches
    else return null
  }
  let c = e,
    h = (i = n) == null ? void 0 : i.errors
  if (h != null) {
    let y = c.findIndex((w) => w.route.id && (h == null ? void 0 : h[w.route.id]) !== void 0)
    ;(y >= 0 || ht(!1), (c = c.slice(0, Math.min(c.length, y + 1))))
  }
  let f = !1,
    p = -1
  if (n && r && r.v7_partialHydration)
    for (let y = 0; y < c.length; y++) {
      let w = c[y]
      if (((w.route.HydrateFallback || w.route.hydrateFallbackElement) && (p = y), w.route.id)) {
        let { loaderData: x, errors: E } = n,
          S = w.route.loader && x[w.route.id] === void 0 && (!E || E[w.route.id] === void 0)
        if (w.route.lazy || S) {
          ;((f = !0), p >= 0 ? (c = c.slice(0, p + 1)) : (c = [c[0]]))
          break
        }
      }
    }
  return c.reduceRight((y, w, x) => {
    let E,
      S = !1,
      k = null,
      P = null
    n &&
      ((E = h && w.route.id ? h[w.route.id] : void 0),
      (k = w.route.errorElement || XE),
      f &&
        (p < 0 && x === 0
          ? (eC('route-fallback'), (S = !0), (P = null))
          : p === x && ((S = !0), (P = w.route.hydrateFallbackElement || null))))
    let I = t.concat(c.slice(0, x + 1)),
      R = () => {
        let M
        return (
          E
            ? (M = k)
            : S
              ? (M = P)
              : w.route.Component
                ? (M = X.createElement(w.route.Component, null))
                : w.route.element
                  ? (M = w.route.element)
                  : (M = y),
          X.createElement(YE, {
            match: w,
            routeContext: { outlet: y, matches: I, isDataRoute: n != null },
            children: M,
          })
        )
      }
    return n && (w.route.ErrorBoundary || w.route.errorElement || x === 0)
      ? X.createElement(GE, {
          location: n.location,
          revalidation: n.revalidation,
          component: k,
          error: E,
          children: R(),
          routeContext: { outlet: null, matches: I, isDataRoute: !0 },
        })
      : R()
  }, null)
}
var mw = (function (e) {
    return (
      (e.UseBlocker = 'useBlocker'),
      (e.UseRevalidator = 'useRevalidator'),
      (e.UseNavigateStable = 'useNavigate'),
      e
    )
  })(mw || {}),
  yw = (function (e) {
    return (
      (e.UseBlocker = 'useBlocker'),
      (e.UseLoaderData = 'useLoaderData'),
      (e.UseActionData = 'useActionData'),
      (e.UseRouteError = 'useRouteError'),
      (e.UseNavigation = 'useNavigation'),
      (e.UseRouteLoaderData = 'useRouteLoaderData'),
      (e.UseMatches = 'useMatches'),
      (e.UseRevalidator = 'useRevalidator'),
      (e.UseNavigateStable = 'useNavigate'),
      (e.UseRouteId = 'useRouteId'),
      e
    )
  })(yw || {})
function KE(e) {
  let t = X.useContext(hh)
  return (t || ht(!1), t)
}
function qE(e) {
  let t = X.useContext(fw)
  return (t || ht(!1), t)
}
function QE(e) {
  let t = X.useContext(Vi)
  return (t || ht(!1), t)
}
function ww(e) {
  let t = QE(),
    n = t.matches[t.matches.length - 1]
  return (n.route.id || ht(!1), n.route.id)
}
function $E() {
  var e
  let t = X.useContext(pw),
    n = qE(),
    r = ww()
  return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r]
}
function JE() {
  let { router: e } = KE(mw.UseNavigateStable),
    t = ww(yw.UseNavigateStable),
    n = X.useRef(!1)
  return (
    gw(() => {
      n.current = !0
    }),
    X.useCallback(
      function (r, i) {
        ;(i === void 0 && (i = {}),
          n.current &&
            (typeof r == 'number' ? e.navigate(r) : e.navigate(r, bl({ fromRouteId: t }, i))))
      },
      [e, t]
    )
  )
}
const $g = {}
function eC(e, t, n) {
  $g[e] || ($g[e] = !0)
}
function tC(e, t) {
  ;(e == null || e.v7_startTransition, e == null || e.v7_relativeSplatPath)
}
function nC(e) {
  let { to: t, replace: n, state: r, relative: i } = e
  Yo() || ht(!1)
  let { future: o, static: c } = X.useContext(Qr),
    { matches: h } = X.useContext(Vi),
    { pathname: f } = Zo(),
    p = b0(),
    y = w0(t, y0(h, o.v7_relativeSplatPath), f, i === 'path'),
    w = JSON.stringify(y)
  return (
    X.useEffect(() => p(JSON.parse(w), { replace: n, state: r, relative: i }), [p, w, i, n, r]),
    null
  )
}
function no(e) {
  ht(!1)
}
function rC(e) {
  let {
    basename: t = '/',
    children: n = null,
    location: r,
    navigationType: i = gi.Pop,
    navigator: o,
    static: c = !1,
    future: h,
  } = e
  Yo() && ht(!1)
  let f = t.replace(/^\/*/, '/'),
    p = X.useMemo(
      () => ({ basename: f, navigator: o, static: c, future: bl({ v7_relativeSplatPath: !1 }, h) }),
      [f, h, o, c]
    )
  typeof r == 'string' && (r = _s(r))
  let { pathname: y = '/', search: w = '', hash: x = '', state: E = null, key: S = 'default' } = r,
    k = X.useMemo(() => {
      let P = Bo(y, f)
      return P == null
        ? null
        : { location: { pathname: P, search: w, hash: x, state: E, key: S }, navigationType: i }
    }, [f, y, w, x, E, S, i])
  return k == null
    ? null
    : X.createElement(
        Qr.Provider,
        { value: p },
        X.createElement(dh.Provider, { children: n, value: k })
      )
}
function iC(e) {
  let { children: t, location: n } = e
  return WE(U1(t), n)
}
new Promise(() => {})
function U1(e, t) {
  t === void 0 && (t = [])
  let n = []
  return (
    X.Children.forEach(e, (r, i) => {
      if (!X.isValidElement(r)) return
      let o = [...t, i]
      if (r.type === X.Fragment) {
        n.push.apply(n, U1(r.props.children, o))
        return
      }
      ;(r.type !== no && ht(!1), !r.props.index || !r.props.children || ht(!1))
      let c = {
        id: r.props.id || o.join('-'),
        caseSensitive: r.props.caseSensitive,
        element: r.props.element,
        Component: r.props.Component,
        index: r.props.index,
        path: r.props.path,
        loader: r.props.loader,
        action: r.props.action,
        errorElement: r.props.errorElement,
        ErrorBoundary: r.props.ErrorBoundary,
        hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
        shouldRevalidate: r.props.shouldRevalidate,
        handle: r.props.handle,
        lazy: r.props.lazy,
      }
      ;(r.props.children && (c.children = U1(r.props.children, o)), n.push(c))
    }),
    n
  )
}
/**
 * React Router DOM v6.30.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Nu() {
  return (
    (Nu = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Nu.apply(this, arguments)
  )
}
function bw(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++) ((i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i]))
  return n
}
function sC(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}
function oC(e, t) {
  return e.button === 0 && (!t || t === '_self') && !sC(e)
}
const aC = [
    'onClick',
    'relative',
    'reloadDocument',
    'replace',
    'state',
    'target',
    'to',
    'preventScrollReset',
    'viewTransition',
  ],
  lC = [
    'aria-current',
    'caseSensitive',
    'className',
    'end',
    'style',
    'to',
    'viewTransition',
    'children',
  ],
  cC = '6'
try {
  window.__reactRouterVersion = cC
} catch {}
const uC = X.createContext({ isTransitioning: !1 }),
  hC = 'startTransition',
  Jg = nv[hC]
function dC(e) {
  let { basename: t, children: n, future: r, window: i } = e,
    o = X.useRef()
  o.current == null && (o.current = pE({ window: i, v5Compat: !0 }))
  let c = o.current,
    [h, f] = X.useState({ action: c.action, location: c.location }),
    { v7_startTransition: p } = r || {},
    y = X.useCallback(
      (w) => {
        p && Jg ? Jg(() => f(w)) : f(w)
      },
      [f, p]
    )
  return (
    X.useLayoutEffect(() => c.listen(y), [c, y]),
    X.useEffect(() => tC(r), [r]),
    X.createElement(rC, {
      basename: t,
      children: n,
      location: h.location,
      navigationType: h.action,
      navigator: c,
      future: r,
    })
  )
}
const fC =
    typeof window < 'u' &&
    typeof window.document < 'u' &&
    typeof window.document.createElement < 'u',
  pC = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  er = X.forwardRef(function (e, t) {
    let {
        onClick: n,
        relative: r,
        reloadDocument: i,
        replace: o,
        state: c,
        target: h,
        to: f,
        preventScrollReset: p,
        viewTransition: y,
      } = e,
      w = bw(e, aC),
      { basename: x } = X.useContext(Qr),
      E,
      S = !1
    if (typeof f == 'string' && pC.test(f) && ((E = f), fC))
      try {
        let R = new URL(window.location.href),
          M = f.startsWith('//') ? new URL(R.protocol + f) : new URL(f),
          O = Bo(M.pathname, x)
        M.origin === R.origin && O != null ? (f = O + M.search + M.hash) : (S = !0)
      } catch {}
    let k = VE(f, { relative: r }),
      P = yC(f, {
        replace: o,
        state: c,
        target: h,
        preventScrollReset: p,
        relative: r,
        viewTransition: y,
      })
    function I(R) {
      ;(n && n(R), R.defaultPrevented || P(R))
    }
    return X.createElement(
      'a',
      Nu({}, w, { href: E || k, onClick: S || i ? n : I, ref: t, target: h })
    )
  }),
  gC = X.forwardRef(function (e, t) {
    let {
        'aria-current': n = 'page',
        caseSensitive: r = !1,
        className: i = '',
        end: o = !1,
        style: c,
        to: h,
        viewTransition: f,
        children: p,
      } = e,
      y = bw(e, lC),
      w = fh(h, { relative: y.relative }),
      x = Zo(),
      E = X.useContext(fw),
      { navigator: S, basename: k } = X.useContext(Qr),
      P = E != null && wC(w) && f === !0,
      I = S.encodeLocation ? S.encodeLocation(w).pathname : w.pathname,
      R = x.pathname,
      M = E && E.navigation && E.navigation.location ? E.navigation.location.pathname : null
    ;(r || ((R = R.toLowerCase()), (M = M ? M.toLowerCase() : null), (I = I.toLowerCase())),
      M && k && (M = Bo(M, k) || M))
    const O = I !== '/' && I.endsWith('/') ? I.length - 1 : I.length
    let F = R === I || (!o && R.startsWith(I) && R.charAt(O) === '/'),
      z = M != null && (M === I || (!o && M.startsWith(I) && M.charAt(I.length) === '/')),
      V = { isActive: F, isPending: z, isTransitioning: P },
      U = F ? n : void 0,
      Z
    typeof i == 'function'
      ? (Z = i(V))
      : (Z = [i, F ? 'active' : null, z ? 'pending' : null, P ? 'transitioning' : null]
          .filter(Boolean)
          .join(' '))
    let J = typeof c == 'function' ? c(V) : c
    return X.createElement(
      er,
      Nu({}, y, { 'aria-current': U, className: Z, ref: t, style: J, to: h, viewTransition: f }),
      typeof p == 'function' ? p(V) : p
    )
  })
var W1
;(function (e) {
  ;((e.UseScrollRestoration = 'useScrollRestoration'),
    (e.UseSubmit = 'useSubmit'),
    (e.UseSubmitFetcher = 'useSubmitFetcher'),
    (e.UseFetcher = 'useFetcher'),
    (e.useViewTransitionState = 'useViewTransitionState'))
})(W1 || (W1 = {}))
var e2
;(function (e) {
  ;((e.UseFetcher = 'useFetcher'),
    (e.UseFetchers = 'useFetchers'),
    (e.UseScrollRestoration = 'useScrollRestoration'))
})(e2 || (e2 = {}))
function mC(e) {
  let t = X.useContext(hh)
  return (t || ht(!1), t)
}
function yC(e, t) {
  let {
      target: n,
      replace: r,
      state: i,
      preventScrollReset: o,
      relative: c,
      viewTransition: h,
    } = t === void 0 ? {} : t,
    f = b0(),
    p = Zo(),
    y = fh(e, { relative: c })
  return X.useCallback(
    (w) => {
      if (oC(w, n)) {
        w.preventDefault()
        let x = r !== void 0 ? r : Iu(p) === Iu(y)
        f(e, { replace: x, state: i, preventScrollReset: o, relative: c, viewTransition: h })
      }
    },
    [p, f, y, r, i, n, e, o, c, h]
  )
}
function wC(e, t) {
  t === void 0 && (t = {})
  let n = X.useContext(uC)
  n == null && ht(!1)
  let { basename: r } = mC(W1.useViewTransitionState),
    i = fh(e, { relative: t.relative })
  if (!n.isTransitioning) return !1
  let o = Bo(n.currentLocation.pathname, r) || n.currentLocation.pathname,
    c = Bo(n.nextLocation.pathname, r) || n.nextLocation.pathname
  return V1(i.pathname, c) != null || V1(i.pathname, o) != null
}
const vw = X.createContext({})
function bC(e) {
  const t = X.useRef(null)
  return (t.current === null && (t.current = e()), t.current)
}
const v0 = X.createContext(null),
  xw = X.createContext({ transformPagePoint: (e) => e, isStatic: !1, reducedMotion: 'never' })
function vC(e = !0) {
  const t = X.useContext(v0)
  if (t === null) return [!0, null]
  const { isPresent: n, onExitComplete: r, register: i } = t,
    o = X.useId()
  X.useEffect(() => {
    e && i(o)
  }, [e])
  const c = X.useCallback(() => e && r && r(o), [o, r, e])
  return !n && r ? [!1, c] : [!0]
}
const x0 = typeof window < 'u',
  xC = x0 ? X.useLayoutEffect : X.useEffect,
  Dn = (e) => e
let Ew = Dn
function E0(e) {
  let t
  return () => (t === void 0 && (t = e()), t)
}
const Fo = (e, t, n) => {
    const r = t - e
    return r === 0 ? 1 : (n - e) / r
  },
  zr = (e) => e * 1e3,
  Hr = (e) => e / 1e3,
  EC = { useManualTiming: !1 }
function CC(e) {
  let t = new Set(),
    n = new Set(),
    r = !1,
    i = !1
  const o = new WeakSet()
  let c = { delta: 0, timestamp: 0, isProcessing: !1 }
  function h(p) {
    ;(o.has(p) && (f.schedule(p), e()), p(c))
  }
  const f = {
    schedule: (p, y = !1, w = !1) => {
      const x = w && r ? t : n
      return (y && o.add(p), x.has(p) || x.add(p), p)
    },
    cancel: (p) => {
      ;(n.delete(p), o.delete(p))
    },
    process: (p) => {
      if (((c = p), r)) {
        i = !0
        return
      }
      ;((r = !0),
        ([t, n] = [n, t]),
        t.forEach(h),
        t.clear(),
        (r = !1),
        i && ((i = !1), f.process(p)))
    },
  }
  return f
}
const bc = ['read', 'resolveKeyframes', 'update', 'preRender', 'render', 'postRender'],
  SC = 40
function Cw(e, t) {
  let n = !1,
    r = !0
  const i = { delta: 0, timestamp: 0, isProcessing: !1 },
    o = () => (n = !0),
    c = bc.reduce((k, P) => ((k[P] = CC(o)), k), {}),
    { read: h, resolveKeyframes: f, update: p, preRender: y, render: w, postRender: x } = c,
    E = () => {
      const k = performance.now()
      ;((n = !1),
        (i.delta = r ? 1e3 / 60 : Math.max(Math.min(k - i.timestamp, SC), 1)),
        (i.timestamp = k),
        (i.isProcessing = !0),
        h.process(i),
        f.process(i),
        p.process(i),
        y.process(i),
        w.process(i),
        x.process(i),
        (i.isProcessing = !1),
        n && t && ((r = !1), e(E)))
    },
    S = () => {
      ;((n = !0), (r = !0), i.isProcessing || e(E))
    }
  return {
    schedule: bc.reduce((k, P) => {
      const I = c[P]
      return ((k[P] = (R, M = !1, O = !1) => (n || S(), I.schedule(R, M, O))), k)
    }, {}),
    cancel: (k) => {
      for (let P = 0; P < bc.length; P++) c[bc[P]].cancel(k)
    },
    state: i,
    steps: c,
  }
}
const {
    schedule: rt,
    cancel: Di,
    state: zt,
    steps: vd,
  } = Cw(typeof requestAnimationFrame < 'u' ? requestAnimationFrame : Dn, !0),
  Sw = X.createContext({ strict: !1 }),
  t2 = {
    animation: [
      'animate',
      'variants',
      'whileHover',
      'whileTap',
      'exit',
      'whileInView',
      'whileFocus',
      'whileDrag',
    ],
    exit: ['exit'],
    drag: ['drag', 'dragControls'],
    focus: ['whileFocus'],
    hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
    tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
    pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
    inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
    layout: ['layout', 'layoutId'],
  },
  jo = {}
for (const e in t2) jo[e] = { isEnabled: (t) => t2[e].some((n) => !!t[n]) }
function AC(e) {
  for (const t in e) jo[t] = { ...jo[t], ...e[t] }
}
const kC = new Set([
  'animate',
  'exit',
  'variants',
  'initial',
  'style',
  'values',
  'variants',
  'transition',
  'transformTemplate',
  'custom',
  'inherit',
  'onBeforeLayoutMeasure',
  'onAnimationStart',
  'onAnimationComplete',
  'onUpdate',
  'onDragStart',
  'onDrag',
  'onDragEnd',
  'onMeasureDragConstraints',
  'onDirectionLock',
  'onDragTransitionEnd',
  '_dragX',
  '_dragY',
  'onHoverStart',
  'onHoverEnd',
  'onViewportEnter',
  'onViewportLeave',
  'globalTapTarget',
  'ignoreStrict',
  'viewport',
])
function Tu(e) {
  return (
    e.startsWith('while') ||
    (e.startsWith('drag') && e !== 'draggable') ||
    e.startsWith('layout') ||
    e.startsWith('onTap') ||
    e.startsWith('onPan') ||
    e.startsWith('onLayout') ||
    kC.has(e)
  )
}
let Aw = (e) => !Tu(e)
function _C(e) {
  e && (Aw = (t) => (t.startsWith('on') ? !Tu(t) : e(t)))
}
try {
  _C(require('@emotion/is-prop-valid').default)
} catch {}
function IC(e, t, n) {
  const r = {}
  for (const i in e)
    (i === 'values' && typeof e.values == 'object') ||
      ((Aw(i) ||
        (n === !0 && Tu(i)) ||
        (!t && !Tu(i)) ||
        (e.draggable && i.startsWith('onDrag'))) &&
        (r[i] = e[i]))
  return r
}
function NC(e) {
  if (typeof Proxy > 'u') return e
  const t = new Map(),
    n = (...r) => e(...r)
  return new Proxy(n, {
    get: (r, i) => (i === 'create' ? e : (t.has(i) || t.set(i, e(i)), t.get(i))),
  })
}
const ph = X.createContext({})
function vl(e) {
  return typeof e == 'string' || Array.isArray(e)
}
function gh(e) {
  return e !== null && typeof e == 'object' && typeof e.start == 'function'
}
const C0 = ['animate', 'whileInView', 'whileFocus', 'whileHover', 'whileTap', 'whileDrag', 'exit'],
  S0 = ['initial', ...C0]
function mh(e) {
  return gh(e.animate) || S0.some((t) => vl(e[t]))
}
function kw(e) {
  return !!(mh(e) || e.variants)
}
function TC(e, t) {
  if (mh(e)) {
    const { initial: n, animate: r } = e
    return { initial: n === !1 || vl(n) ? n : void 0, animate: vl(r) ? r : void 0 }
  }
  return e.inherit !== !1 ? t : {}
}
function RC(e) {
  const { initial: t, animate: n } = TC(e, X.useContext(ph))
  return X.useMemo(() => ({ initial: t, animate: n }), [n2(t), n2(n)])
}
function n2(e) {
  return Array.isArray(e) ? e.join(' ') : e
}
const MC = Symbol.for('motionComponentSymbol')
function mo(e) {
  return e && typeof e == 'object' && Object.prototype.hasOwnProperty.call(e, 'current')
}
function PC(e, t, n) {
  return X.useCallback(
    (r) => {
      ;(r && e.onMount && e.onMount(r),
        t && (r ? t.mount(r) : t.unmount()),
        n && (typeof n == 'function' ? n(r) : mo(n) && (n.current = r)))
    },
    [t]
  )
}
const A0 = (e) => e.replace(/([a-z])([A-Z])/gu, '$1-$2').toLowerCase(),
  DC = 'framerAppearId',
  _w = 'data-' + A0(DC),
  { schedule: k0 } = Cw(queueMicrotask, !1),
  Iw = X.createContext({})
function LC(e, t, n, r, i) {
  var o, c
  const { visualElement: h } = X.useContext(ph),
    f = X.useContext(Sw),
    p = X.useContext(v0),
    y = X.useContext(xw).reducedMotion,
    w = X.useRef(null)
  ;((r = r || f.renderer),
    !w.current &&
      r &&
      (w.current = r(e, {
        visualState: t,
        parent: h,
        props: n,
        presenceContext: p,
        blockInitialAnimation: p ? p.initial === !1 : !1,
        reducedMotionConfig: y,
      })))
  const x = w.current,
    E = X.useContext(Iw)
  x && !x.projection && i && (x.type === 'html' || x.type === 'svg') && OC(w.current, n, i, E)
  const S = X.useRef(!1)
  X.useInsertionEffect(() => {
    x && S.current && x.update(n, p)
  })
  const k = n[_w],
    P = X.useRef(
      !!k &&
        !(!((o = window.MotionHandoffIsComplete) === null || o === void 0) && o.call(window, k)) &&
        ((c = window.MotionHasOptimisedAnimation) === null || c === void 0
          ? void 0
          : c.call(window, k))
    )
  return (
    xC(() => {
      x &&
        ((S.current = !0),
        (window.MotionIsMounted = !0),
        x.updateFeatures(),
        k0.render(x.render),
        P.current && x.animationState && x.animationState.animateChanges())
    }),
    X.useEffect(() => {
      x &&
        (!P.current && x.animationState && x.animationState.animateChanges(),
        P.current &&
          (queueMicrotask(() => {
            var I
            ;(I = window.MotionHandoffMarkAsComplete) === null || I === void 0 || I.call(window, k)
          }),
          (P.current = !1)))
    }),
    x
  )
}
function OC(e, t, n, r) {
  const { layoutId: i, layout: o, drag: c, dragConstraints: h, layoutScroll: f, layoutRoot: p } = t
  ;((e.projection = new n(e.latestValues, t['data-framer-portal-id'] ? void 0 : Nw(e.parent))),
    e.projection.setOptions({
      layoutId: i,
      layout: o,
      alwaysMeasureLayout: !!c || (h && mo(h)),
      visualElement: e,
      animationType: typeof o == 'string' ? o : 'both',
      initialPromotionConfig: r,
      layoutScroll: f,
      layoutRoot: p,
    }))
}
function Nw(e) {
  if (e) return e.options.allowProjection !== !1 ? e.projection : Nw(e.parent)
}
function BC({
  preloadedFeatures: e,
  createVisualElement: t,
  useRender: n,
  useVisualState: r,
  Component: i,
}) {
  var o, c
  e && AC(e)
  function h(p, y) {
    let w
    const x = { ...X.useContext(xw), ...p, layoutId: FC(p) },
      { isStatic: E } = x,
      S = RC(p),
      k = r(p, E)
    if (!E && x0) {
      jC()
      const P = VC(x)
      ;((w = P.MeasureLayout), (S.visualElement = LC(i, k, x, t, P.ProjectionNode)))
    }
    return N.jsxs(ph.Provider, {
      value: S,
      children: [
        w && S.visualElement ? N.jsx(w, { visualElement: S.visualElement, ...x }) : null,
        n(i, p, PC(k, S.visualElement, y), k, E, S.visualElement),
      ],
    })
  }
  h.displayName = `motion.${typeof i == 'string' ? i : `create(${(c = (o = i.displayName) !== null && o !== void 0 ? o : i.name) !== null && c !== void 0 ? c : ''})`}`
  const f = X.forwardRef(h)
  return ((f[MC] = i), f)
}
function FC({ layoutId: e }) {
  const t = X.useContext(vw).id
  return t && e !== void 0 ? t + '-' + e : e
}
function jC(e, t) {
  X.useContext(Sw).strict
}
function VC(e) {
  const { drag: t, layout: n } = jo
  if (!t && !n) return {}
  const r = { ...t, ...n }
  return {
    MeasureLayout:
      (t != null && t.isEnabled(e)) || (n != null && n.isEnabled(e)) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode,
  }
}
const UC = [
  'animate',
  'circle',
  'defs',
  'desc',
  'ellipse',
  'g',
  'image',
  'line',
  'filter',
  'marker',
  'mask',
  'metadata',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'rect',
  'stop',
  'switch',
  'symbol',
  'svg',
  'text',
  'tspan',
  'use',
  'view',
]
function _0(e) {
  return typeof e != 'string' || e.includes('-') ? !1 : !!(UC.indexOf(e) > -1 || /[A-Z]/u.test(e))
}
function r2(e) {
  const t = [{}, {}]
  return (
    e == null ||
      e.values.forEach((n, r) => {
        ;((t[0][r] = n.get()), (t[1][r] = n.getVelocity()))
      }),
    t
  )
}
function I0(e, t, n, r) {
  if (typeof t == 'function') {
    const [i, o] = r2(r)
    t = t(n !== void 0 ? n : e.custom, i, o)
  }
  if ((typeof t == 'string' && (t = e.variants && e.variants[t]), typeof t == 'function')) {
    const [i, o] = r2(r)
    t = t(n !== void 0 ? n : e.custom, i, o)
  }
  return t
}
const z1 = (e) => Array.isArray(e),
  WC = (e) => !!(e && typeof e == 'object' && e.mix && e.toValue),
  zC = (e) => (z1(e) ? e[e.length - 1] || 0 : e),
  Jt = (e) => !!(e && e.getVelocity)
function Zc(e) {
  const t = Jt(e) ? e.get() : e
  return WC(t) ? t.toValue() : t
}
function HC({ scrapeMotionValuesFromProps: e, createRenderState: t, onUpdate: n }, r, i, o) {
  const c = { latestValues: XC(r, i, o, e), renderState: t() }
  return (
    n && ((c.onMount = (h) => n({ props: r, current: h, ...c })), (c.onUpdate = (h) => n(h))),
    c
  )
}
const Tw = (e) => (t, n) => {
  const r = X.useContext(ph),
    i = X.useContext(v0),
    o = () => HC(e, t, r, i)
  return n ? o() : bC(o)
}
function XC(e, t, n, r) {
  const i = {},
    o = r(e, {})
  for (const x in o) i[x] = Zc(o[x])
  let { initial: c, animate: h } = e
  const f = mh(e),
    p = kw(e)
  t &&
    p &&
    !f &&
    e.inherit !== !1 &&
    (c === void 0 && (c = t.initial), h === void 0 && (h = t.animate))
  let y = n ? n.initial === !1 : !1
  y = y || c === !1
  const w = y ? h : c
  if (w && typeof w != 'boolean' && !gh(w)) {
    const x = Array.isArray(w) ? w : [w]
    for (let E = 0; E < x.length; E++) {
      const S = I0(e, x[E])
      if (S) {
        const { transitionEnd: k, transition: P, ...I } = S
        for (const R in I) {
          let M = I[R]
          if (Array.isArray(M)) {
            const O = y ? M.length - 1 : 0
            M = M[O]
          }
          M !== null && (i[R] = M)
        }
        for (const R in k) i[R] = k[R]
      }
    }
  }
  return i
}
const Ko = [
    'transformPerspective',
    'x',
    'y',
    'z',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY',
  ],
  Is = new Set(Ko),
  Rw = (e) => (t) => typeof t == 'string' && t.startsWith(e),
  Mw = Rw('--'),
  GC = Rw('var(--'),
  N0 = (e) => (GC(e) ? YC.test(e.split('/*')[0].trim()) : !1),
  YC = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  Pw = (e, t) => (t && typeof e == 'number' ? t.transform(e) : e),
  Kr = (e, t, n) => (n > t ? t : n < e ? e : n),
  qo = { test: (e) => typeof e == 'number', parse: parseFloat, transform: (e) => e },
  xl = { ...qo, transform: (e) => Kr(0, 1, e) },
  vc = { ...qo, default: 1 },
  Ol = (e) => ({
    test: (t) => typeof t == 'string' && t.endsWith(e) && t.split(' ').length === 1,
    parse: parseFloat,
    transform: (t) => `${t}${e}`,
  }),
  li = Ol('deg'),
  _r = Ol('%'),
  be = Ol('px'),
  ZC = Ol('vh'),
  KC = Ol('vw'),
  i2 = { ..._r, parse: (e) => _r.parse(e) / 100, transform: (e) => _r.transform(e * 100) },
  qC = {
    borderWidth: be,
    borderTopWidth: be,
    borderRightWidth: be,
    borderBottomWidth: be,
    borderLeftWidth: be,
    borderRadius: be,
    radius: be,
    borderTopLeftRadius: be,
    borderTopRightRadius: be,
    borderBottomRightRadius: be,
    borderBottomLeftRadius: be,
    width: be,
    maxWidth: be,
    height: be,
    maxHeight: be,
    top: be,
    right: be,
    bottom: be,
    left: be,
    padding: be,
    paddingTop: be,
    paddingRight: be,
    paddingBottom: be,
    paddingLeft: be,
    margin: be,
    marginTop: be,
    marginRight: be,
    marginBottom: be,
    marginLeft: be,
    backgroundPositionX: be,
    backgroundPositionY: be,
  },
  QC = {
    rotate: li,
    rotateX: li,
    rotateY: li,
    rotateZ: li,
    scale: vc,
    scaleX: vc,
    scaleY: vc,
    scaleZ: vc,
    skew: li,
    skewX: li,
    skewY: li,
    distance: be,
    translateX: be,
    translateY: be,
    translateZ: be,
    x: be,
    y: be,
    z: be,
    perspective: be,
    transformPerspective: be,
    opacity: xl,
    originX: i2,
    originY: i2,
    originZ: be,
  },
  s2 = { ...qo, transform: Math.round },
  T0 = { ...qC, ...QC, zIndex: s2, size: be, fillOpacity: xl, strokeOpacity: xl, numOctaves: s2 },
  $C = { x: 'translateX', y: 'translateY', z: 'translateZ', transformPerspective: 'perspective' },
  JC = Ko.length
function e5(e, t, n) {
  let r = '',
    i = !0
  for (let o = 0; o < JC; o++) {
    const c = Ko[o],
      h = e[c]
    if (h === void 0) continue
    let f = !0
    if (
      (typeof h == 'number'
        ? (f = h === (c.startsWith('scale') ? 1 : 0))
        : (f = parseFloat(h) === 0),
      !f || n)
    ) {
      const p = Pw(h, T0[c])
      if (!f) {
        i = !1
        const y = $C[c] || c
        r += `${y}(${p}) `
      }
      n && (t[c] = p)
    }
  }
  return ((r = r.trim()), n ? (r = n(t, i ? '' : r)) : i && (r = 'none'), r)
}
function R0(e, t, n) {
  const { style: r, vars: i, transformOrigin: o } = e
  let c = !1,
    h = !1
  for (const f in t) {
    const p = t[f]
    if (Is.has(f)) {
      c = !0
      continue
    } else if (Mw(f)) {
      i[f] = p
      continue
    } else {
      const y = Pw(p, T0[f])
      f.startsWith('origin') ? ((h = !0), (o[f] = y)) : (r[f] = y)
    }
  }
  if (
    (t.transform ||
      (c || n ? (r.transform = e5(t, e.transform, n)) : r.transform && (r.transform = 'none')),
    h)
  ) {
    const { originX: f = '50%', originY: p = '50%', originZ: y = 0 } = o
    r.transformOrigin = `${f} ${p} ${y}`
  }
}
const t5 = { offset: 'stroke-dashoffset', array: 'stroke-dasharray' },
  n5 = { offset: 'strokeDashoffset', array: 'strokeDasharray' }
function r5(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1
  const o = i ? t5 : n5
  e[o.offset] = be.transform(-r)
  const c = be.transform(t),
    h = be.transform(n)
  e[o.array] = `${c} ${h}`
}
function o2(e, t, n) {
  return typeof e == 'string' ? e : be.transform(t + n * e)
}
function i5(e, t, n) {
  const r = o2(t, e.x, e.width),
    i = o2(n, e.y, e.height)
  return `${r} ${i}`
}
function M0(
  e,
  {
    attrX: t,
    attrY: n,
    attrScale: r,
    originX: i,
    originY: o,
    pathLength: c,
    pathSpacing: h = 1,
    pathOffset: f = 0,
    ...p
  },
  y,
  w
) {
  if ((R0(e, p, w), y)) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox)
    return
  }
  ;((e.attrs = e.style), (e.style = {}))
  const { attrs: x, style: E, dimensions: S } = e
  ;(x.transform && (S && (E.transform = x.transform), delete x.transform),
    S &&
      (i !== void 0 || o !== void 0 || E.transform) &&
      (E.transformOrigin = i5(S, i !== void 0 ? i : 0.5, o !== void 0 ? o : 0.5)),
    t !== void 0 && (x.x = t),
    n !== void 0 && (x.y = n),
    r !== void 0 && (x.scale = r),
    c !== void 0 && r5(x, c, h, f, !1))
}
const P0 = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }),
  Dw = () => ({ ...P0(), attrs: {} }),
  D0 = (e) => typeof e == 'string' && e.toLowerCase() === 'svg'
function Lw(e, { style: t, vars: n }, r, i) {
  Object.assign(e.style, t, i && i.getProjectionStyles(r))
  for (const o in n) e.style.setProperty(o, n[o])
}
const Ow = new Set([
  'baseFrequency',
  'diffuseConstant',
  'kernelMatrix',
  'kernelUnitLength',
  'keySplines',
  'keyTimes',
  'limitingConeAngle',
  'markerHeight',
  'markerWidth',
  'numOctaves',
  'targetX',
  'targetY',
  'surfaceScale',
  'specularConstant',
  'specularExponent',
  'stdDeviation',
  'tableValues',
  'viewBox',
  'gradientTransform',
  'pathLength',
  'startOffset',
  'textLength',
  'lengthAdjust',
])
function Bw(e, t, n, r) {
  Lw(e, t, void 0, r)
  for (const i in t.attrs) e.setAttribute(Ow.has(i) ? i : A0(i), t.attrs[i])
}
const Ru = {}
function s5(e) {
  Object.assign(Ru, e)
}
function Fw(e, { layout: t, layoutId: n }) {
  return (
    Is.has(e) || e.startsWith('origin') || ((t || n !== void 0) && (!!Ru[e] || e === 'opacity'))
  )
}
function L0(e, t, n) {
  var r
  const { style: i } = e,
    o = {}
  for (const c in i)
    (Jt(i[c]) ||
      (t.style && Jt(t.style[c])) ||
      Fw(c, e) ||
      ((r = n == null ? void 0 : n.getValue(c)) === null || r === void 0 ? void 0 : r.liveStyle) !==
        void 0) &&
      (o[c] = i[c])
  return o
}
function jw(e, t, n) {
  const r = L0(e, t, n)
  for (const i in e)
    if (Jt(e[i]) || Jt(t[i])) {
      const o = Ko.indexOf(i) !== -1 ? 'attr' + i.charAt(0).toUpperCase() + i.substring(1) : i
      r[o] = e[i]
    }
  return r
}
function o5(e, t) {
  try {
    t.dimensions = typeof e.getBBox == 'function' ? e.getBBox() : e.getBoundingClientRect()
  } catch {
    t.dimensions = { x: 0, y: 0, width: 0, height: 0 }
  }
}
const a2 = ['x', 'y', 'width', 'height', 'cx', 'cy', 'r'],
  a5 = {
    useVisualState: Tw({
      scrapeMotionValuesFromProps: jw,
      createRenderState: Dw,
      onUpdate: ({ props: e, prevProps: t, current: n, renderState: r, latestValues: i }) => {
        if (!n) return
        let o = !!e.drag
        if (!o) {
          for (const h in i)
            if (Is.has(h)) {
              o = !0
              break
            }
        }
        if (!o) return
        let c = !t
        if (t)
          for (let h = 0; h < a2.length; h++) {
            const f = a2[h]
            e[f] !== t[f] && (c = !0)
          }
        c &&
          rt.read(() => {
            ;(o5(n, r),
              rt.render(() => {
                ;(M0(r, i, D0(n.tagName), e.transformTemplate), Bw(n, r))
              }))
          })
      },
    }),
  },
  l5 = { useVisualState: Tw({ scrapeMotionValuesFromProps: L0, createRenderState: P0 }) }
function Vw(e, t, n) {
  for (const r in t) !Jt(t[r]) && !Fw(r, n) && (e[r] = t[r])
}
function c5({ transformTemplate: e }, t) {
  return X.useMemo(() => {
    const n = P0()
    return (R0(n, t, e), Object.assign({}, n.vars, n.style))
  }, [t])
}
function u5(e, t) {
  const n = e.style || {},
    r = {}
  return (Vw(r, n, e), Object.assign(r, c5(e, t)), r)
}
function h5(e, t) {
  const n = {},
    r = u5(e, t)
  return (
    e.drag &&
      e.dragListener !== !1 &&
      ((n.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = 'none'),
      (r.touchAction = e.drag === !0 ? 'none' : `pan-${e.drag === 'x' ? 'y' : 'x'}`)),
    e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0),
    (n.style = r),
    n
  )
}
function d5(e, t, n, r) {
  const i = X.useMemo(() => {
    const o = Dw()
    return (M0(o, t, D0(r), e.transformTemplate), { ...o.attrs, style: { ...o.style } })
  }, [t])
  if (e.style) {
    const o = {}
    ;(Vw(o, e.style, e), (i.style = { ...o, ...i.style }))
  }
  return i
}
function f5(e = !1) {
  return (t, n, r, { latestValues: i }, o) => {
    const c = (_0(t) ? d5 : h5)(n, i, o, t),
      h = IC(n, typeof t == 'string', e),
      f = t !== X.Fragment ? { ...h, ...c, ref: r } : {},
      { children: p } = n,
      y = X.useMemo(() => (Jt(p) ? p.get() : p), [p])
    return X.createElement(t, { ...f, children: y })
  }
}
function p5(e, t) {
  return function (n, { forwardMotionProps: r } = { forwardMotionProps: !1 }) {
    const i = {
      ...(_0(n) ? a5 : l5),
      preloadedFeatures: e,
      useRender: f5(r),
      createVisualElement: t,
      Component: n,
    }
    return BC(i)
  }
}
function Uw(e, t) {
  if (!Array.isArray(t)) return !1
  const n = t.length
  if (n !== e.length) return !1
  for (let r = 0; r < n; r++) if (t[r] !== e[r]) return !1
  return !0
}
function yh(e, t, n) {
  const r = e.getProps()
  return I0(r, t, n !== void 0 ? n : r.custom, e)
}
const g5 = E0(() => window.ScrollTimeline !== void 0)
class m5 {
  constructor(t) {
    ;((this.stop = () => this.runAll('stop')), (this.animations = t.filter(Boolean)))
  }
  get finished() {
    return Promise.all(this.animations.map((t) => ('finished' in t ? t.finished : t)))
  }
  getAll(t) {
    return this.animations[0][t]
  }
  setAll(t, n) {
    for (let r = 0; r < this.animations.length; r++) this.animations[r][t] = n
  }
  attachTimeline(t, n) {
    const r = this.animations.map((i) => {
      if (g5() && i.attachTimeline) return i.attachTimeline(t)
      if (typeof n == 'function') return n(i)
    })
    return () => {
      r.forEach((i, o) => {
        ;(i && i(), this.animations[o].stop())
      })
    }
  }
  get time() {
    return this.getAll('time')
  }
  set time(t) {
    this.setAll('time', t)
  }
  get speed() {
    return this.getAll('speed')
  }
  set speed(t) {
    this.setAll('speed', t)
  }
  get startTime() {
    return this.getAll('startTime')
  }
  get duration() {
    let t = 0
    for (let n = 0; n < this.animations.length; n++) t = Math.max(t, this.animations[n].duration)
    return t
  }
  runAll(t) {
    this.animations.forEach((n) => n[t]())
  }
  flatten() {
    this.runAll('flatten')
  }
  play() {
    this.runAll('play')
  }
  pause() {
    this.runAll('pause')
  }
  cancel() {
    this.runAll('cancel')
  }
  complete() {
    this.runAll('complete')
  }
}
class y5 extends m5 {
  then(t, n) {
    return Promise.all(this.animations).then(t).catch(n)
  }
}
function O0(e, t) {
  return e ? e[t] || e.default || e : void 0
}
const H1 = 2e4
function Ww(e) {
  let t = 0
  const n = 50
  let r = e.next(t)
  for (; !r.done && t < H1; ) ((t += n), (r = e.next(t)))
  return t >= H1 ? 1 / 0 : t
}
function B0(e) {
  return typeof e == 'function'
}
function l2(e, t) {
  ;((e.timeline = t), (e.onfinish = null))
}
const F0 = (e) => Array.isArray(e) && typeof e[0] == 'number',
  w5 = { linearEasing: void 0 }
function b5(e, t) {
  const n = E0(e)
  return () => {
    var r
    return (r = w5[t]) !== null && r !== void 0 ? r : n()
  }
}
const Mu = b5(() => {
    try {
      document.createElement('div').animate({ opacity: 0 }, { easing: 'linear(0, 1)' })
    } catch {
      return !1
    }
    return !0
  }, 'linearEasing'),
  zw = (e, t, n = 10) => {
    let r = ''
    const i = Math.max(Math.round(t / n), 2)
    for (let o = 0; o < i; o++) r += e(Fo(0, i - 1, o)) + ', '
    return `linear(${r.substring(0, r.length - 2)})`
  }
function Hw(e) {
  return !!(
    (typeof e == 'function' && Mu()) ||
    !e ||
    (typeof e == 'string' && (e in X1 || Mu())) ||
    F0(e) ||
    (Array.isArray(e) && e.every(Hw))
  )
}
const Ta = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`,
  X1 = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'ease-in',
    easeOut: 'ease-out',
    easeInOut: 'ease-in-out',
    circIn: Ta([0, 0.65, 0.55, 1]),
    circOut: Ta([0.55, 0, 1, 0.45]),
    backIn: Ta([0.31, 0.01, 0.66, -0.59]),
    backOut: Ta([0.33, 1.53, 0.69, 0.99]),
  }
function Xw(e, t) {
  if (e)
    return typeof e == 'function' && Mu()
      ? zw(e, t)
      : F0(e)
        ? Ta(e)
        : Array.isArray(e)
          ? e.map((n) => Xw(n, t) || X1.easeOut)
          : X1[e]
}
const sr = { x: !1, y: !1 }
function Gw() {
  return sr.x || sr.y
}
function v5(e, t, n) {
  var r
  if (e instanceof Element) return [e]
  if (typeof e == 'string') {
    let i = document
    const o = (r = void 0) !== null && r !== void 0 ? r : i.querySelectorAll(e)
    return o ? Array.from(o) : []
  }
  return Array.from(e)
}
function Yw(e, t) {
  const n = v5(e),
    r = new AbortController(),
    i = { passive: !0, ...t, signal: r.signal }
  return [n, i, () => r.abort()]
}
function c2(e) {
  return (t) => {
    t.pointerType === 'touch' || Gw() || e(t)
  }
}
function x5(e, t, n = {}) {
  const [r, i, o] = Yw(e, n),
    c = c2((h) => {
      const { target: f } = h,
        p = t(h)
      if (typeof p != 'function' || !f) return
      const y = c2((w) => {
        ;(p(w), f.removeEventListener('pointerleave', y))
      })
      f.addEventListener('pointerleave', y, i)
    })
  return (
    r.forEach((h) => {
      h.addEventListener('pointerenter', c, i)
    }),
    o
  )
}
const Zw = (e, t) => (t ? (e === t ? !0 : Zw(e, t.parentElement)) : !1),
  j0 = (e) =>
    e.pointerType === 'mouse' ? typeof e.button != 'number' || e.button <= 0 : e.isPrimary !== !1,
  E5 = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'])
function C5(e) {
  return E5.has(e.tagName) || e.tabIndex !== -1
}
const Ra = new WeakSet()
function u2(e) {
  return (t) => {
    t.key === 'Enter' && e(t)
  }
}
function xd(e, t) {
  e.dispatchEvent(new PointerEvent('pointer' + t, { isPrimary: !0, bubbles: !0 }))
}
const S5 = (e, t) => {
  const n = e.currentTarget
  if (!n) return
  const r = u2(() => {
    if (Ra.has(n)) return
    xd(n, 'down')
    const i = u2(() => {
        xd(n, 'up')
      }),
      o = () => xd(n, 'cancel')
    ;(n.addEventListener('keyup', i, t), n.addEventListener('blur', o, t))
  })
  ;(n.addEventListener('keydown', r, t),
    n.addEventListener('blur', () => n.removeEventListener('keydown', r), t))
}
function h2(e) {
  return j0(e) && !Gw()
}
function A5(e, t, n = {}) {
  const [r, i, o] = Yw(e, n),
    c = (h) => {
      const f = h.currentTarget
      if (!h2(h) || Ra.has(f)) return
      Ra.add(f)
      const p = t(h),
        y = (E, S) => {
          ;(window.removeEventListener('pointerup', w),
            window.removeEventListener('pointercancel', x),
            !(!h2(E) || !Ra.has(f)) &&
              (Ra.delete(f), typeof p == 'function' && p(E, { success: S })))
        },
        w = (E) => {
          y(E, n.useGlobalTarget || Zw(f, E.target))
        },
        x = (E) => {
          y(E, !1)
        }
      ;(window.addEventListener('pointerup', w, i), window.addEventListener('pointercancel', x, i))
    }
  return (
    r.forEach((h) => {
      ;(!C5(h) && h.getAttribute('tabindex') === null && (h.tabIndex = 0),
        (n.useGlobalTarget ? window : h).addEventListener('pointerdown', c, i),
        h.addEventListener('focus', (f) => S5(f, i), i))
    }),
    o
  )
}
function k5(e) {
  return e === 'x' || e === 'y'
    ? sr[e]
      ? null
      : ((sr[e] = !0),
        () => {
          sr[e] = !1
        })
    : sr.x || sr.y
      ? null
      : ((sr.x = sr.y = !0),
        () => {
          sr.x = sr.y = !1
        })
}
const Kw = new Set(['width', 'height', 'top', 'left', 'right', 'bottom', ...Ko])
let Kc
function _5() {
  Kc = void 0
}
const Ir = {
  now: () => (
    Kc === void 0 &&
      Ir.set(zt.isProcessing || EC.useManualTiming ? zt.timestamp : performance.now()),
    Kc
  ),
  set: (e) => {
    ;((Kc = e), queueMicrotask(_5))
  },
}
function V0(e, t) {
  e.indexOf(t) === -1 && e.push(t)
}
function U0(e, t) {
  const n = e.indexOf(t)
  n > -1 && e.splice(n, 1)
}
class W0 {
  constructor() {
    this.subscriptions = []
  }
  add(t) {
    return (V0(this.subscriptions, t), () => U0(this.subscriptions, t))
  }
  notify(t, n, r) {
    const i = this.subscriptions.length
    if (i)
      if (i === 1) this.subscriptions[0](t, n, r)
      else
        for (let o = 0; o < i; o++) {
          const c = this.subscriptions[o]
          c && c(t, n, r)
        }
  }
  getSize() {
    return this.subscriptions.length
  }
  clear() {
    this.subscriptions.length = 0
  }
}
function qw(e, t) {
  return t ? e * (1e3 / t) : 0
}
const d2 = 30,
  I5 = (e) => !isNaN(parseFloat(e))
class N5 {
  constructor(t, n = {}) {
    ;((this.version = '11.18.2'),
      (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (r, i = !0) => {
        const o = Ir.now()
        ;(this.updatedAt !== o && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(r),
          this.current !== this.prev &&
            this.events.change &&
            this.events.change.notify(this.current),
          i && this.events.renderRequest && this.events.renderRequest.notify(this.current))
      }),
      (this.hasAnimated = !1),
      this.setCurrent(t),
      (this.owner = n.owner))
  }
  setCurrent(t) {
    ;((this.current = t),
      (this.updatedAt = Ir.now()),
      this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = I5(this.current)))
  }
  setPrevFrameValue(t = this.current) {
    ;((this.prevFrameValue = t), (this.prevUpdatedAt = this.updatedAt))
  }
  onChange(t) {
    return this.on('change', t)
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new W0())
    const r = this.events[t].add(n)
    return t === 'change'
      ? () => {
          ;(r(),
            rt.read(() => {
              this.events.change.getSize() || this.stop()
            }))
        }
      : r
  }
  clearListeners() {
    for (const t in this.events) this.events[t].clear()
  }
  attach(t, n) {
    ;((this.passiveEffect = t), (this.stopPassiveEffect = n))
  }
  set(t, n = !0) {
    !n || !this.passiveEffect
      ? this.updateAndNotify(t, n)
      : this.passiveEffect(t, this.updateAndNotify)
  }
  setWithVelocity(t, n, r) {
    ;(this.set(n),
      (this.prev = void 0),
      (this.prevFrameValue = t),
      (this.prevUpdatedAt = this.updatedAt - r))
  }
  jump(t, n = !0) {
    ;(this.updateAndNotify(t),
      (this.prev = t),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      n && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect())
  }
  get() {
    return this.current
  }
  getPrevious() {
    return this.prev
  }
  getVelocity() {
    const t = Ir.now()
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > d2)
      return 0
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, d2)
    return qw(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
  }
  start(t) {
    return (
      this.stop(),
      new Promise((n) => {
        ;((this.hasAnimated = !0),
          (this.animation = t(n)),
          this.events.animationStart && this.events.animationStart.notify())
      }).then(() => {
        ;(this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation())
      })
    )
  }
  stop() {
    ;(this.animation &&
      (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation())
  }
  isAnimating() {
    return !!this.animation
  }
  clearAnimation() {
    delete this.animation
  }
  destroy() {
    ;(this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect())
  }
}
function El(e, t) {
  return new N5(e, t)
}
function T5(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, El(n))
}
function R5(e, t) {
  const n = yh(e, t)
  let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {}
  o = { ...o, ...r }
  for (const c in o) {
    const h = zC(o[c])
    T5(e, c, h)
  }
}
function M5(e) {
  return !!(Jt(e) && e.add)
}
function G1(e, t) {
  const n = e.getValue('willChange')
  if (M5(n)) return n.add(t)
}
function Qw(e) {
  return e.props[_w]
}
const $w = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e,
  P5 = 1e-7,
  D5 = 12
function L5(e, t, n, r, i) {
  let o,
    c,
    h = 0
  do ((c = t + (n - t) / 2), (o = $w(c, r, i) - e), o > 0 ? (n = c) : (t = c))
  while (Math.abs(o) > P5 && ++h < D5)
  return c
}
function Bl(e, t, n, r) {
  if (e === t && n === r) return Dn
  const i = (o) => L5(o, 0, 1, e, n)
  return (o) => (o === 0 || o === 1 ? o : $w(i(o), t, r))
}
const Jw = (e) => (t) => (t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2),
  e6 = (e) => (t) => 1 - e(1 - t),
  t6 = Bl(0.33, 1.53, 0.69, 0.99),
  z0 = e6(t6),
  n6 = Jw(z0),
  r6 = (e) => ((e *= 2) < 1 ? 0.5 * z0(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1)))),
  H0 = (e) => 1 - Math.sin(Math.acos(e)),
  i6 = e6(H0),
  s6 = Jw(H0),
  o6 = (e) => /^0[^.\s]+$/u.test(e)
function O5(e) {
  return typeof e == 'number' ? e === 0 : e !== null ? e === 'none' || e === '0' || o6(e) : !0
}
const Xa = (e) => Math.round(e * 1e5) / 1e5,
  X0 = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu
function B5(e) {
  return e == null
}
const F5 =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  G0 = (e, t) => (n) =>
    !!(
      (typeof n == 'string' && F5.test(n) && n.startsWith(e)) ||
      (t && !B5(n) && Object.prototype.hasOwnProperty.call(n, t))
    ),
  a6 = (e, t, n) => (r) => {
    if (typeof r != 'string') return r
    const [i, o, c, h] = r.match(X0)
    return {
      [e]: parseFloat(i),
      [t]: parseFloat(o),
      [n]: parseFloat(c),
      alpha: h !== void 0 ? parseFloat(h) : 1,
    }
  },
  j5 = (e) => Kr(0, 255, e),
  Ed = { ...qo, transform: (e) => Math.round(j5(e)) },
  ls = {
    test: G0('rgb', 'red'),
    parse: a6('red', 'green', 'blue'),
    transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) =>
      'rgba(' +
      Ed.transform(e) +
      ', ' +
      Ed.transform(t) +
      ', ' +
      Ed.transform(n) +
      ', ' +
      Xa(xl.transform(r)) +
      ')',
  }
function V5(e) {
  let t = '',
    n = '',
    r = '',
    i = ''
  return (
    e.length > 5
      ? ((t = e.substring(1, 3)),
        (n = e.substring(3, 5)),
        (r = e.substring(5, 7)),
        (i = e.substring(7, 9)))
      : ((t = e.substring(1, 2)),
        (n = e.substring(2, 3)),
        (r = e.substring(3, 4)),
        (i = e.substring(4, 5)),
        (t += t),
        (n += n),
        (r += r),
        (i += i)),
    {
      red: parseInt(t, 16),
      green: parseInt(n, 16),
      blue: parseInt(r, 16),
      alpha: i ? parseInt(i, 16) / 255 : 1,
    }
  )
}
const Y1 = { test: G0('#'), parse: V5, transform: ls.transform },
  yo = {
    test: G0('hsl', 'hue'),
    parse: a6('hue', 'saturation', 'lightness'),
    transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) =>
      'hsla(' +
      Math.round(e) +
      ', ' +
      _r.transform(Xa(t)) +
      ', ' +
      _r.transform(Xa(n)) +
      ', ' +
      Xa(xl.transform(r)) +
      ')',
  },
  Qt = {
    test: (e) => ls.test(e) || Y1.test(e) || yo.test(e),
    parse: (e) => (ls.test(e) ? ls.parse(e) : yo.test(e) ? yo.parse(e) : Y1.parse(e)),
    transform: (e) =>
      typeof e == 'string' ? e : e.hasOwnProperty('red') ? ls.transform(e) : yo.transform(e),
  },
  U5 =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu
function W5(e) {
  var t, n
  return (
    isNaN(e) &&
    typeof e == 'string' &&
    (((t = e.match(X0)) === null || t === void 0 ? void 0 : t.length) || 0) +
      (((n = e.match(U5)) === null || n === void 0 ? void 0 : n.length) || 0) >
      0
  )
}
const l6 = 'number',
  c6 = 'color',
  z5 = 'var',
  H5 = 'var(',
  f2 = '${}',
  X5 =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu
function Cl(e) {
  const t = e.toString(),
    n = [],
    r = { color: [], number: [], var: [] },
    i = []
  let o = 0
  const c = t
    .replace(
      X5,
      (h) => (
        Qt.test(h)
          ? (r.color.push(o), i.push(c6), n.push(Qt.parse(h)))
          : h.startsWith(H5)
            ? (r.var.push(o), i.push(z5), n.push(h))
            : (r.number.push(o), i.push(l6), n.push(parseFloat(h))),
        ++o,
        f2
      )
    )
    .split(f2)
  return { values: n, split: c, indexes: r, types: i }
}
function u6(e) {
  return Cl(e).values
}
function h6(e) {
  const { split: t, types: n } = Cl(e),
    r = t.length
  return (i) => {
    let o = ''
    for (let c = 0; c < r; c++)
      if (((o += t[c]), i[c] !== void 0)) {
        const h = n[c]
        h === l6 ? (o += Xa(i[c])) : h === c6 ? (o += Qt.transform(i[c])) : (o += i[c])
      }
    return o
  }
}
const G5 = (e) => (typeof e == 'number' ? 0 : e)
function Y5(e) {
  const t = u6(e)
  return h6(e)(t.map(G5))
}
const Li = { test: W5, parse: u6, createTransformer: h6, getAnimatableNone: Y5 },
  Z5 = new Set(['brightness', 'contrast', 'saturate', 'opacity'])
function K5(e) {
  const [t, n] = e.slice(0, -1).split('(')
  if (t === 'drop-shadow') return e
  const [r] = n.match(X0) || []
  if (!r) return e
  const i = n.replace(r, '')
  let o = Z5.has(t) ? 1 : 0
  return (r !== n && (o *= 100), t + '(' + o + i + ')')
}
const q5 = /\b([a-z-]*)\(.*?\)/gu,
  Z1 = {
    ...Li,
    getAnimatableNone: (e) => {
      const t = e.match(q5)
      return t ? t.map(K5).join(' ') : e
    },
  },
  Q5 = {
    ...T0,
    color: Qt,
    backgroundColor: Qt,
    outlineColor: Qt,
    fill: Qt,
    stroke: Qt,
    borderColor: Qt,
    borderTopColor: Qt,
    borderRightColor: Qt,
    borderBottomColor: Qt,
    borderLeftColor: Qt,
    filter: Z1,
    WebkitFilter: Z1,
  },
  Y0 = (e) => Q5[e]
function d6(e, t) {
  let n = Y0(e)
  return (n !== Z1 && (n = Li), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0)
}
const $5 = new Set(['auto', 'none', '0'])
function J5(e, t, n) {
  let r = 0,
    i
  for (; r < e.length && !i; ) {
    const o = e[r]
    ;(typeof o == 'string' && !$5.has(o) && Cl(o).values.length && (i = e[r]), r++)
  }
  if (i && n) for (const o of t) e[o] = d6(n, i)
}
const p2 = (e) => e === qo || e === be,
  g2 = (e, t) => parseFloat(e.split(', ')[t]),
  m2 =
    (e, t) =>
    (n, { transform: r }) => {
      if (r === 'none' || !r) return 0
      const i = r.match(/^matrix3d\((.+)\)$/u)
      if (i) return g2(i[1], t)
      {
        const o = r.match(/^matrix\((.+)\)$/u)
        return o ? g2(o[1], e) : 0
      }
    },
  eS = new Set(['x', 'y', 'z']),
  tS = Ko.filter((e) => !eS.has(e))
function nS(e) {
  const t = []
  return (
    tS.forEach((n) => {
      const r = e.getValue(n)
      r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith('scale') ? 1 : 0))
    }),
    t
  )
}
const Vo = {
  width: ({ x: e }, { paddingLeft: t = '0', paddingRight: n = '0' }) =>
    e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = '0', paddingBottom: n = '0' }) =>
    e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  x: m2(4, 13),
  y: m2(5, 14),
}
Vo.translateX = Vo.x
Vo.translateY = Vo.y
const ds = new Set()
let K1 = !1,
  q1 = !1
function f6() {
  if (q1) {
    const e = Array.from(ds).filter((r) => r.needsMeasurement),
      t = new Set(e.map((r) => r.element)),
      n = new Map()
    ;(t.forEach((r) => {
      const i = nS(r)
      i.length && (n.set(r, i), r.render())
    }),
      e.forEach((r) => r.measureInitialState()),
      t.forEach((r) => {
        r.render()
        const i = n.get(r)
        i &&
          i.forEach(([o, c]) => {
            var h
            ;(h = r.getValue(o)) === null || h === void 0 || h.set(c)
          })
      }),
      e.forEach((r) => r.measureEndState()),
      e.forEach((r) => {
        r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY)
      }))
  }
  ;((q1 = !1), (K1 = !1), ds.forEach((e) => e.complete()), ds.clear())
}
function p6() {
  ds.forEach((e) => {
    ;(e.readKeyframes(), e.needsMeasurement && (q1 = !0))
  })
}
function rS() {
  ;(p6(), f6())
}
class Z0 {
  constructor(t, n, r, i, o, c = !1) {
    ;((this.isComplete = !1),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.isScheduled = !1),
      (this.unresolvedKeyframes = [...t]),
      (this.onComplete = n),
      (this.name = r),
      (this.motionValue = i),
      (this.element = o),
      (this.isAsync = c))
  }
  scheduleResolve() {
    ;((this.isScheduled = !0),
      this.isAsync
        ? (ds.add(this), K1 || ((K1 = !0), rt.read(p6), rt.resolveKeyframes(f6)))
        : (this.readKeyframes(), this.complete()))
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this
    for (let o = 0; o < t.length; o++)
      if (t[o] === null)
        if (o === 0) {
          const c = i == null ? void 0 : i.get(),
            h = t[t.length - 1]
          if (c !== void 0) t[0] = c
          else if (r && n) {
            const f = r.readValue(n, h)
            f != null && (t[0] = f)
          }
          ;(t[0] === void 0 && (t[0] = h), i && c === void 0 && i.set(t[0]))
        } else t[o] = t[o - 1]
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    ;((this.isComplete = !0),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
      ds.delete(this))
  }
  cancel() {
    this.isComplete || ((this.isScheduled = !1), ds.delete(this))
  }
  resume() {
    this.isComplete || this.scheduleResolve()
  }
}
const g6 = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e),
  iS = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
function sS(e) {
  const t = iS.exec(e)
  if (!t) return [,]
  const [, n, r, i] = t
  return [`--${n ?? r}`, i]
}
function m6(e, t, n = 1) {
  const [r, i] = sS(e)
  if (!r) return
  const o = window.getComputedStyle(t).getPropertyValue(r)
  if (o) {
    const c = o.trim()
    return g6(c) ? parseFloat(c) : c
  }
  return N0(i) ? m6(i, t, n + 1) : i
}
const y6 = (e) => (t) => t.test(e),
  oS = { test: (e) => e === 'auto', parse: (e) => e },
  w6 = [qo, be, _r, li, KC, ZC, oS],
  y2 = (e) => w6.find(y6(e))
class b6 extends Z0 {
  constructor(t, n, r, i, o) {
    super(t, n, r, i, o, !0)
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this
    if (!n || !n.current) return
    super.readKeyframes()
    for (let f = 0; f < t.length; f++) {
      let p = t[f]
      if (typeof p == 'string' && ((p = p.trim()), N0(p))) {
        const y = m6(p, n.current)
        ;(y !== void 0 && (t[f] = y), f === t.length - 1 && (this.finalKeyframe = p))
      }
    }
    if ((this.resolveNoneKeyframes(), !Kw.has(r) || t.length !== 2)) return
    const [i, o] = t,
      c = y2(i),
      h = y2(o)
    if (c !== h)
      if (p2(c) && p2(h))
        for (let f = 0; f < t.length; f++) {
          const p = t[f]
          typeof p == 'string' && (t[f] = parseFloat(p))
        }
      else this.needsMeasurement = !0
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this,
      r = []
    for (let i = 0; i < t.length; i++) O5(t[i]) && r.push(i)
    r.length && J5(t, r, n)
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this
    if (!t || !t.current) return
    ;(r === 'height' && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = Vo[r](t.measureViewportBox(), window.getComputedStyle(t.current))),
      (n[0] = this.measuredOrigin))
    const i = n[n.length - 1]
    i !== void 0 && t.getValue(r, i).jump(i, !1)
  }
  measureEndState() {
    var t
    const { element: n, name: r, unresolvedKeyframes: i } = this
    if (!n || !n.current) return
    const o = n.getValue(r)
    o && o.jump(this.measuredOrigin, !1)
    const c = i.length - 1,
      h = i[c]
    ;((i[c] = Vo[r](n.measureViewportBox(), window.getComputedStyle(n.current))),
      h !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = h),
      !((t = this.removedTransforms) === null || t === void 0) &&
        t.length &&
        this.removedTransforms.forEach(([f, p]) => {
          n.getValue(f).set(p)
        }),
      this.resolveNoneKeyframes())
  }
}
const w2 = (e, t) =>
  t === 'zIndex'
    ? !1
    : !!(
        typeof e == 'number' ||
        Array.isArray(e) ||
        (typeof e == 'string' && (Li.test(e) || e === '0') && !e.startsWith('url('))
      )
function aS(e) {
  const t = e[0]
  if (e.length === 1) return !0
  for (let n = 0; n < e.length; n++) if (e[n] !== t) return !0
}
function lS(e, t, n, r) {
  const i = e[0]
  if (i === null) return !1
  if (t === 'display' || t === 'visibility') return !0
  const o = e[e.length - 1],
    c = w2(i, t),
    h = w2(o, t)
  return !c || !h ? !1 : aS(e) || ((n === 'spring' || B0(n)) && r)
}
const cS = (e) => e !== null
function wh(e, { repeat: t, repeatType: n = 'loop' }, r) {
  const i = e.filter(cS),
    o = t && n !== 'loop' && t % 2 === 1 ? 0 : i.length - 1
  return !o || r === void 0 ? i[o] : r
}
const uS = 40
class v6 {
  constructor({
    autoplay: t = !0,
    delay: n = 0,
    type: r = 'keyframes',
    repeat: i = 0,
    repeatDelay: o = 0,
    repeatType: c = 'loop',
    ...h
  }) {
    ;((this.isStopped = !1),
      (this.hasAttemptedResolve = !1),
      (this.createdAt = Ir.now()),
      (this.options = {
        autoplay: t,
        delay: n,
        type: r,
        repeat: i,
        repeatDelay: o,
        repeatType: c,
        ...h,
      }),
      this.updateFinishedPromise())
  }
  calcStartTime() {
    return this.resolvedAt
      ? this.resolvedAt - this.createdAt > uS
        ? this.resolvedAt
        : this.createdAt
      : this.createdAt
  }
  get resolved() {
    return (!this._resolved && !this.hasAttemptedResolve && rS(), this._resolved)
  }
  onKeyframesResolved(t, n) {
    ;((this.resolvedAt = Ir.now()), (this.hasAttemptedResolve = !0))
    const {
      name: r,
      type: i,
      velocity: o,
      delay: c,
      onComplete: h,
      onUpdate: f,
      isGenerator: p,
    } = this.options
    if (!p && !lS(t, r, i, o))
      if (c) this.options.duration = 0
      else {
        ;(f && f(wh(t, this.options, n)), h && h(), this.resolveFinishedPromise())
        return
      }
    const y = this.initPlayback(t, n)
    y !== !1 && ((this._resolved = { keyframes: t, finalKeyframe: n, ...y }), this.onPostResolved())
  }
  onPostResolved() {}
  then(t, n) {
    return this.currentFinishedPromise.then(t, n)
  }
  flatten() {
    ;((this.options.type = 'keyframes'), (this.options.ease = 'linear'))
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((t) => {
      this.resolveFinishedPromise = t
    })
  }
}
const lt = (e, t, n) => e + (t - e) * n
function Cd(e, t, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
  )
}
function hS({ hue: e, saturation: t, lightness: n, alpha: r }) {
  ;((e /= 360), (t /= 100), (n /= 100))
  let i = 0,
    o = 0,
    c = 0
  if (!t) i = o = c = n
  else {
    const h = n < 0.5 ? n * (1 + t) : n + t - n * t,
      f = 2 * n - h
    ;((i = Cd(f, h, e + 1 / 3)), (o = Cd(f, h, e)), (c = Cd(f, h, e - 1 / 3)))
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(o * 255),
    blue: Math.round(c * 255),
    alpha: r,
  }
}
function Pu(e, t) {
  return (n) => (n > 0 ? t : e)
}
const Sd = (e, t, n) => {
    const r = e * e,
      i = n * (t * t - r) + r
    return i < 0 ? 0 : Math.sqrt(i)
  },
  dS = [Y1, ls, yo],
  fS = (e) => dS.find((t) => t.test(e))
function b2(e) {
  const t = fS(e)
  if (!t) return !1
  let n = t.parse(e)
  return (t === yo && (n = hS(n)), n)
}
const v2 = (e, t) => {
    const n = b2(e),
      r = b2(t)
    if (!n || !r) return Pu(e, t)
    const i = { ...n }
    return (o) => (
      (i.red = Sd(n.red, r.red, o)),
      (i.green = Sd(n.green, r.green, o)),
      (i.blue = Sd(n.blue, r.blue, o)),
      (i.alpha = lt(n.alpha, r.alpha, o)),
      ls.transform(i)
    )
  },
  pS = (e, t) => (n) => t(e(n)),
  Fl = (...e) => e.reduce(pS),
  Q1 = new Set(['none', 'hidden'])
function gS(e, t) {
  return Q1.has(e) ? (n) => (n <= 0 ? e : t) : (n) => (n >= 1 ? t : e)
}
function mS(e, t) {
  return (n) => lt(e, t, n)
}
function K0(e) {
  return typeof e == 'number'
    ? mS
    : typeof e == 'string'
      ? N0(e)
        ? Pu
        : Qt.test(e)
          ? v2
          : bS
      : Array.isArray(e)
        ? x6
        : typeof e == 'object'
          ? Qt.test(e)
            ? v2
            : yS
          : Pu
}
function x6(e, t) {
  const n = [...e],
    r = n.length,
    i = e.map((o, c) => K0(o)(o, t[c]))
  return (o) => {
    for (let c = 0; c < r; c++) n[c] = i[c](o)
    return n
  }
}
function yS(e, t) {
  const n = { ...e, ...t },
    r = {}
  for (const i in n) e[i] !== void 0 && t[i] !== void 0 && (r[i] = K0(e[i])(e[i], t[i]))
  return (i) => {
    for (const o in r) n[o] = r[o](i)
    return n
  }
}
function wS(e, t) {
  var n
  const r = [],
    i = { color: 0, var: 0, number: 0 }
  for (let o = 0; o < t.values.length; o++) {
    const c = t.types[o],
      h = e.indexes[c][i[c]],
      f = (n = e.values[h]) !== null && n !== void 0 ? n : 0
    ;((r[o] = f), i[c]++)
  }
  return r
}
const bS = (e, t) => {
  const n = Li.createTransformer(t),
    r = Cl(e),
    i = Cl(t)
  return r.indexes.var.length === i.indexes.var.length &&
    r.indexes.color.length === i.indexes.color.length &&
    r.indexes.number.length >= i.indexes.number.length
    ? (Q1.has(e) && !i.values.length) || (Q1.has(t) && !r.values.length)
      ? gS(e, t)
      : Fl(x6(wS(r, i), i.values), n)
    : Pu(e, t)
}
function E6(e, t, n) {
  return typeof e == 'number' && typeof t == 'number' && typeof n == 'number'
    ? lt(e, t, n)
    : K0(e)(e, t)
}
const vS = 5
function C6(e, t, n) {
  const r = Math.max(t - vS, 0)
  return qw(n - e(r), t - r)
}
const yt = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  Ad = 0.001
function xS({
  duration: e = yt.duration,
  bounce: t = yt.bounce,
  velocity: n = yt.velocity,
  mass: r = yt.mass,
}) {
  let i,
    o,
    c = 1 - t
  ;((c = Kr(yt.minDamping, yt.maxDamping, c)),
    (e = Kr(yt.minDuration, yt.maxDuration, Hr(e))),
    c < 1
      ? ((i = (p) => {
          const y = p * c,
            w = y * e,
            x = y - n,
            E = $1(p, c),
            S = Math.exp(-w)
          return Ad - (x / E) * S
        }),
        (o = (p) => {
          const y = p * c * e,
            w = y * n + n,
            x = Math.pow(c, 2) * Math.pow(p, 2) * e,
            E = Math.exp(-y),
            S = $1(Math.pow(p, 2), c)
          return ((-i(p) + Ad > 0 ? -1 : 1) * ((w - x) * E)) / S
        }))
      : ((i = (p) => {
          const y = Math.exp(-p * e),
            w = (p - n) * e + 1
          return -Ad + y * w
        }),
        (o = (p) => {
          const y = Math.exp(-p * e),
            w = (n - p) * (e * e)
          return y * w
        })))
  const h = 5 / e,
    f = CS(i, o, h)
  if (((e = zr(e)), isNaN(f))) return { stiffness: yt.stiffness, damping: yt.damping, duration: e }
  {
    const p = Math.pow(f, 2) * r
    return { stiffness: p, damping: c * 2 * Math.sqrt(r * p), duration: e }
  }
}
const ES = 12
function CS(e, t, n) {
  let r = n
  for (let i = 1; i < ES; i++) r = r - e(r) / t(r)
  return r
}
function $1(e, t) {
  return e * Math.sqrt(1 - t * t)
}
const SS = ['duration', 'bounce'],
  AS = ['stiffness', 'damping', 'mass']
function x2(e, t) {
  return t.some((n) => e[n] !== void 0)
}
function kS(e) {
  let t = {
    velocity: yt.velocity,
    stiffness: yt.stiffness,
    damping: yt.damping,
    mass: yt.mass,
    isResolvedFromDuration: !1,
    ...e,
  }
  if (!x2(e, AS) && x2(e, SS))
    if (e.visualDuration) {
      const n = e.visualDuration,
        r = (2 * Math.PI) / (n * 1.2),
        i = r * r,
        o = 2 * Kr(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i)
      t = { ...t, mass: yt.mass, stiffness: i, damping: o }
    } else {
      const n = xS(e)
      ;((t = { ...t, ...n, mass: yt.mass }), (t.isResolvedFromDuration = !0))
    }
  return t
}
function S6(e = yt.visualDuration, t = yt.bounce) {
  const n = typeof e != 'object' ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e
  let { restSpeed: r, restDelta: i } = n
  const o = n.keyframes[0],
    c = n.keyframes[n.keyframes.length - 1],
    h = { done: !1, value: o },
    {
      stiffness: f,
      damping: p,
      mass: y,
      duration: w,
      velocity: x,
      isResolvedFromDuration: E,
    } = kS({ ...n, velocity: -Hr(n.velocity || 0) }),
    S = x || 0,
    k = p / (2 * Math.sqrt(f * y)),
    P = c - o,
    I = Hr(Math.sqrt(f / y)),
    R = Math.abs(P) < 5
  ;(r || (r = R ? yt.restSpeed.granular : yt.restSpeed.default),
    i || (i = R ? yt.restDelta.granular : yt.restDelta.default))
  let M
  if (k < 1) {
    const F = $1(I, k)
    M = (z) => {
      const V = Math.exp(-k * I * z)
      return c - V * (((S + k * I * P) / F) * Math.sin(F * z) + P * Math.cos(F * z))
    }
  } else if (k === 1) M = (F) => c - Math.exp(-I * F) * (P + (S + I * P) * F)
  else {
    const F = I * Math.sqrt(k * k - 1)
    M = (z) => {
      const V = Math.exp(-k * I * z),
        U = Math.min(F * z, 300)
      return c - (V * ((S + k * I * P) * Math.sinh(U) + F * P * Math.cosh(U))) / F
    }
  }
  const O = {
    calculatedDuration: (E && w) || null,
    next: (F) => {
      const z = M(F)
      if (E) h.done = F >= w
      else {
        let V = 0
        k < 1 && (V = F === 0 ? zr(S) : C6(M, F, z))
        const U = Math.abs(V) <= r,
          Z = Math.abs(c - z) <= i
        h.done = U && Z
      }
      return ((h.value = h.done ? c : z), h)
    },
    toString: () => {
      const F = Math.min(Ww(O), H1),
        z = zw((V) => O.next(F * V).value, F, 30)
      return F + 'ms ' + z
    },
  }
  return O
}
function E2({
  keyframes: e,
  velocity: t = 0,
  power: n = 0.8,
  timeConstant: r = 325,
  bounceDamping: i = 10,
  bounceStiffness: o = 500,
  modifyTarget: c,
  min: h,
  max: f,
  restDelta: p = 0.5,
  restSpeed: y,
}) {
  const w = e[0],
    x = { done: !1, value: w },
    E = (U) => (h !== void 0 && U < h) || (f !== void 0 && U > f),
    S = (U) => (h === void 0 ? f : f === void 0 || Math.abs(h - U) < Math.abs(f - U) ? h : f)
  let k = n * t
  const P = w + k,
    I = c === void 0 ? P : c(P)
  I !== P && (k = I - w)
  const R = (U) => -k * Math.exp(-U / r),
    M = (U) => I + R(U),
    O = (U) => {
      const Z = R(U),
        J = M(U)
      ;((x.done = Math.abs(Z) <= p), (x.value = x.done ? I : J))
    }
  let F, z
  const V = (U) => {
    E(x.value) &&
      ((F = U),
      (z = S6({
        keyframes: [x.value, S(x.value)],
        velocity: C6(M, U, x.value),
        damping: i,
        stiffness: o,
        restDelta: p,
        restSpeed: y,
      })))
  }
  return (
    V(0),
    {
      calculatedDuration: null,
      next: (U) => {
        let Z = !1
        return (
          !z && F === void 0 && ((Z = !0), O(U), V(U)),
          F !== void 0 && U >= F ? z.next(U - F) : (!Z && O(U), x)
        )
      },
    }
  )
}
const _S = Bl(0.42, 0, 1, 1),
  IS = Bl(0, 0, 0.58, 1),
  A6 = Bl(0.42, 0, 0.58, 1),
  NS = (e) => Array.isArray(e) && typeof e[0] != 'number',
  TS = {
    linear: Dn,
    easeIn: _S,
    easeInOut: A6,
    easeOut: IS,
    circIn: H0,
    circInOut: s6,
    circOut: i6,
    backIn: z0,
    backInOut: n6,
    backOut: t6,
    anticipate: r6,
  },
  C2 = (e) => {
    if (F0(e)) {
      Ew(e.length === 4)
      const [t, n, r, i] = e
      return Bl(t, n, r, i)
    } else if (typeof e == 'string') return TS[e]
    return e
  }
function RS(e, t, n) {
  const r = [],
    i = n || E6,
    o = e.length - 1
  for (let c = 0; c < o; c++) {
    let h = i(e[c], e[c + 1])
    if (t) {
      const f = Array.isArray(t) ? t[c] || Dn : t
      h = Fl(f, h)
    }
    r.push(h)
  }
  return r
}
function MS(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const o = e.length
  if ((Ew(o === t.length), o === 1)) return () => t[0]
  if (o === 2 && t[0] === t[1]) return () => t[1]
  const c = e[0] === e[1]
  e[0] > e[o - 1] && ((e = [...e].reverse()), (t = [...t].reverse()))
  const h = RS(t, r, i),
    f = h.length,
    p = (y) => {
      if (c && y < e[0]) return t[0]
      let w = 0
      if (f > 1) for (; w < e.length - 2 && !(y < e[w + 1]); w++);
      const x = Fo(e[w], e[w + 1], y)
      return h[w](x)
    }
  return n ? (y) => p(Kr(e[0], e[o - 1], y)) : p
}
function PS(e, t) {
  const n = e[e.length - 1]
  for (let r = 1; r <= t; r++) {
    const i = Fo(0, t, r)
    e.push(lt(n, 1, i))
  }
}
function DS(e) {
  const t = [0]
  return (PS(t, e.length - 1), t)
}
function LS(e, t) {
  return e.map((n) => n * t)
}
function OS(e, t) {
  return e.map(() => t || A6).splice(0, e.length - 1)
}
function Du({ duration: e = 300, keyframes: t, times: n, ease: r = 'easeInOut' }) {
  const i = NS(r) ? r.map(C2) : C2(r),
    o = { done: !1, value: t[0] },
    c = LS(n && n.length === t.length ? n : DS(t), e),
    h = MS(c, t, { ease: Array.isArray(i) ? i : OS(t, i) })
  return { calculatedDuration: e, next: (f) => ((o.value = h(f)), (o.done = f >= e), o) }
}
const BS = (e) => {
    const t = ({ timestamp: n }) => e(n)
    return {
      start: () => rt.update(t, !0),
      stop: () => Di(t),
      now: () => (zt.isProcessing ? zt.timestamp : Ir.now()),
    }
  },
  FS = { decay: E2, inertia: E2, tween: Du, keyframes: Du, spring: S6 },
  jS = (e) => e / 100
class q0 extends v6 {
  constructor(t) {
    ;(super(t),
      (this.holdTime = null),
      (this.cancelTime = null),
      (this.currentTime = 0),
      (this.playbackSpeed = 1),
      (this.pendingPlayState = 'running'),
      (this.startTime = null),
      (this.state = 'idle'),
      (this.stop = () => {
        if ((this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle')) return
        this.teardown()
        const { onStop: f } = this.options
        f && f()
      }))
    const { name: n, motionValue: r, element: i, keyframes: o } = this.options,
      c = (i == null ? void 0 : i.KeyframeResolver) || Z0,
      h = (f, p) => this.onKeyframesResolved(f, p)
    ;((this.resolver = new c(o, h, n, r, i)), this.resolver.scheduleResolve())
  }
  flatten() {
    ;(super.flatten(),
      this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)))
  }
  initPlayback(t) {
    const {
        type: n = 'keyframes',
        repeat: r = 0,
        repeatDelay: i = 0,
        repeatType: o,
        velocity: c = 0,
      } = this.options,
      h = B0(n) ? n : FS[n] || Du
    let f, p
    h !== Du && typeof t[0] != 'number' && ((f = Fl(jS, E6(t[0], t[1]))), (t = [0, 100]))
    const y = h({ ...this.options, keyframes: t })
    ;(o === 'mirror' && (p = h({ ...this.options, keyframes: [...t].reverse(), velocity: -c })),
      y.calculatedDuration === null && (y.calculatedDuration = Ww(y)))
    const { calculatedDuration: w } = y,
      x = w + i,
      E = x * (r + 1) - i
    return {
      generator: y,
      mirroredGenerator: p,
      mapPercentToKeyframes: f,
      calculatedDuration: w,
      resolvedDuration: x,
      totalDuration: E,
    }
  }
  onPostResolved() {
    const { autoplay: t = !0 } = this.options
    ;(this.play(),
      this.pendingPlayState === 'paused' || !t
        ? this.pause()
        : (this.state = this.pendingPlayState))
  }
  tick(t, n = !1) {
    const { resolved: r } = this
    if (!r) {
      const { keyframes: U } = this.options
      return { done: !0, value: U[U.length - 1] }
    }
    const {
      finalKeyframe: i,
      generator: o,
      mirroredGenerator: c,
      mapPercentToKeyframes: h,
      keyframes: f,
      calculatedDuration: p,
      totalDuration: y,
      resolvedDuration: w,
    } = r
    if (this.startTime === null) return o.next(0)
    const { delay: x, repeat: E, repeatType: S, repeatDelay: k, onUpdate: P } = this.options
    ;(this.speed > 0
      ? (this.startTime = Math.min(this.startTime, t))
      : this.speed < 0 && (this.startTime = Math.min(t - y / this.speed, this.startTime)),
      n
        ? (this.currentTime = t)
        : this.holdTime !== null
          ? (this.currentTime = this.holdTime)
          : (this.currentTime = Math.round(t - this.startTime) * this.speed))
    const I = this.currentTime - x * (this.speed >= 0 ? 1 : -1),
      R = this.speed >= 0 ? I < 0 : I > y
    ;((this.currentTime = Math.max(I, 0)),
      this.state === 'finished' && this.holdTime === null && (this.currentTime = y))
    let M = this.currentTime,
      O = o
    if (E) {
      const U = Math.min(this.currentTime, y) / w
      let Z = Math.floor(U),
        J = U % 1
      ;(!J && U >= 1 && (J = 1),
        J === 1 && Z--,
        (Z = Math.min(Z, E + 1)),
        Z % 2 && (S === 'reverse' ? ((J = 1 - J), k && (J -= k / w)) : S === 'mirror' && (O = c)),
        (M = Kr(0, 1, J) * w))
    }
    const F = R ? { done: !1, value: f[0] } : O.next(M)
    h && (F.value = h(F.value))
    let { done: z } = F
    !R && p !== null && (z = this.speed >= 0 ? this.currentTime >= y : this.currentTime <= 0)
    const V =
      this.holdTime === null && (this.state === 'finished' || (this.state === 'running' && z))
    return (
      V && i !== void 0 && (F.value = wh(f, this.options, i)),
      P && P(F.value),
      V && this.finish(),
      F
    )
  }
  get duration() {
    const { resolved: t } = this
    return t ? Hr(t.calculatedDuration) : 0
  }
  get time() {
    return Hr(this.currentTime)
  }
  set time(t) {
    ;((t = zr(t)),
      (this.currentTime = t),
      this.holdTime !== null || this.speed === 0
        ? (this.holdTime = t)
        : this.driver && (this.startTime = this.driver.now() - t / this.speed))
  }
  get speed() {
    return this.playbackSpeed
  }
  set speed(t) {
    const n = this.playbackSpeed !== t
    ;((this.playbackSpeed = t), n && (this.time = Hr(this.currentTime)))
  }
  play() {
    if ((this.resolver.isScheduled || this.resolver.resume(), !this._resolved)) {
      this.pendingPlayState = 'running'
      return
    }
    if (this.isStopped) return
    const { driver: t = BS, onPlay: n, startTime: r } = this.options
    ;(this.driver || (this.driver = t((o) => this.tick(o))), n && n())
    const i = this.driver.now()
    ;(this.holdTime !== null
      ? (this.startTime = i - this.holdTime)
      : this.startTime
        ? this.state === 'finished' && (this.startTime = i)
        : (this.startTime = r ?? this.calcStartTime()),
      this.state === 'finished' && this.updateFinishedPromise(),
      (this.cancelTime = this.startTime),
      (this.holdTime = null),
      (this.state = 'running'),
      this.driver.start())
  }
  pause() {
    var t
    if (!this._resolved) {
      this.pendingPlayState = 'paused'
      return
    }
    ;((this.state = 'paused'),
      (this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0))
  }
  complete() {
    ;(this.state !== 'running' && this.play(),
      (this.pendingPlayState = this.state = 'finished'),
      (this.holdTime = null))
  }
  finish() {
    ;(this.teardown(), (this.state = 'finished'))
    const { onComplete: t } = this.options
    t && t()
  }
  cancel() {
    ;(this.cancelTime !== null && this.tick(this.cancelTime),
      this.teardown(),
      this.updateFinishedPromise())
  }
  teardown() {
    ;((this.state = 'idle'),
      this.stopDriver(),
      this.resolveFinishedPromise(),
      this.updateFinishedPromise(),
      (this.startTime = this.cancelTime = null),
      this.resolver.cancel())
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0))
  }
  sample(t) {
    return ((this.startTime = 0), this.tick(t, !0))
  }
}
const VS = new Set(['opacity', 'clipPath', 'filter', 'transform'])
function US(
  e,
  t,
  n,
  {
    delay: r = 0,
    duration: i = 300,
    repeat: o = 0,
    repeatType: c = 'loop',
    ease: h = 'easeInOut',
    times: f,
  } = {}
) {
  const p = { [t]: n }
  f && (p.offset = f)
  const y = Xw(h, i)
  return (
    Array.isArray(y) && (p.easing = y),
    e.animate(p, {
      delay: r,
      duration: i,
      easing: Array.isArray(y) ? 'linear' : y,
      fill: 'both',
      iterations: o + 1,
      direction: c === 'reverse' ? 'alternate' : 'normal',
    })
  )
}
const WS = E0(() => Object.hasOwnProperty.call(Element.prototype, 'animate')),
  Lu = 10,
  zS = 2e4
function HS(e) {
  return B0(e.type) || e.type === 'spring' || !Hw(e.ease)
}
function XS(e, t) {
  const n = new q0({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 })
  let r = { done: !1, value: e[0] }
  const i = []
  let o = 0
  for (; !r.done && o < zS; ) ((r = n.sample(o)), i.push(r.value), (o += Lu))
  return { times: void 0, keyframes: i, duration: o - Lu, ease: 'linear' }
}
const k6 = { anticipate: r6, backInOut: n6, circInOut: s6 }
function GS(e) {
  return e in k6
}
class S2 extends v6 {
  constructor(t) {
    super(t)
    const { name: n, motionValue: r, element: i, keyframes: o } = this.options
    ;((this.resolver = new b6(o, (c, h) => this.onKeyframesResolved(c, h), n, r, i)),
      this.resolver.scheduleResolve())
  }
  initPlayback(t, n) {
    let {
      duration: r = 300,
      times: i,
      ease: o,
      type: c,
      motionValue: h,
      name: f,
      startTime: p,
    } = this.options
    if (!h.owner || !h.owner.current) return !1
    if ((typeof o == 'string' && Mu() && GS(o) && (o = k6[o]), HS(this.options))) {
      const { onComplete: w, onUpdate: x, motionValue: E, element: S, ...k } = this.options,
        P = XS(t, k)
      ;((t = P.keyframes),
        t.length === 1 && (t[1] = t[0]),
        (r = P.duration),
        (i = P.times),
        (o = P.ease),
        (c = 'keyframes'))
    }
    const y = US(h.owner.current, f, t, { ...this.options, duration: r, times: i, ease: o })
    return (
      (y.startTime = p ?? this.calcStartTime()),
      this.pendingTimeline
        ? (l2(y, this.pendingTimeline), (this.pendingTimeline = void 0))
        : (y.onfinish = () => {
            const { onComplete: w } = this.options
            ;(h.set(wh(t, this.options, n)), w && w(), this.cancel(), this.resolveFinishedPromise())
          }),
      { animation: y, duration: r, times: i, type: c, ease: o, keyframes: t }
    )
  }
  get duration() {
    const { resolved: t } = this
    if (!t) return 0
    const { duration: n } = t
    return Hr(n)
  }
  get time() {
    const { resolved: t } = this
    if (!t) return 0
    const { animation: n } = t
    return Hr(n.currentTime || 0)
  }
  set time(t) {
    const { resolved: n } = this
    if (!n) return
    const { animation: r } = n
    r.currentTime = zr(t)
  }
  get speed() {
    const { resolved: t } = this
    if (!t) return 1
    const { animation: n } = t
    return n.playbackRate
  }
  set speed(t) {
    const { resolved: n } = this
    if (!n) return
    const { animation: r } = n
    r.playbackRate = t
  }
  get state() {
    const { resolved: t } = this
    if (!t) return 'idle'
    const { animation: n } = t
    return n.playState
  }
  get startTime() {
    const { resolved: t } = this
    if (!t) return null
    const { animation: n } = t
    return n.startTime
  }
  attachTimeline(t) {
    if (!this._resolved) this.pendingTimeline = t
    else {
      const { resolved: n } = this
      if (!n) return Dn
      const { animation: r } = n
      l2(r, t)
    }
    return Dn
  }
  play() {
    if (this.isStopped) return
    const { resolved: t } = this
    if (!t) return
    const { animation: n } = t
    ;(n.playState === 'finished' && this.updateFinishedPromise(), n.play())
  }
  pause() {
    const { resolved: t } = this
    if (!t) return
    const { animation: n } = t
    n.pause()
  }
  stop() {
    if ((this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle')) return
    ;(this.resolveFinishedPromise(), this.updateFinishedPromise())
    const { resolved: t } = this
    if (!t) return
    const { animation: n, keyframes: r, duration: i, type: o, ease: c, times: h } = t
    if (n.playState === 'idle' || n.playState === 'finished') return
    if (this.time) {
      const { motionValue: p, onUpdate: y, onComplete: w, element: x, ...E } = this.options,
        S = new q0({
          ...E,
          keyframes: r,
          duration: i,
          type: o,
          ease: c,
          times: h,
          isGenerator: !0,
        }),
        k = zr(this.time)
      p.setWithVelocity(S.sample(k - Lu).value, S.sample(k).value, Lu)
    }
    const { onStop: f } = this.options
    ;(f && f(), this.cancel())
  }
  complete() {
    const { resolved: t } = this
    t && t.animation.finish()
  }
  cancel() {
    const { resolved: t } = this
    t && t.animation.cancel()
  }
  static supports(t) {
    const { motionValue: n, name: r, repeatDelay: i, repeatType: o, damping: c, type: h } = t
    if (!n || !n.owner || !(n.owner.current instanceof HTMLElement)) return !1
    const { onUpdate: f, transformTemplate: p } = n.owner.getProps()
    return WS() && r && VS.has(r) && !f && !p && !i && o !== 'mirror' && c !== 0 && h !== 'inertia'
  }
}
const YS = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10 },
  ZS = (e) => ({
    type: 'spring',
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  KS = { type: 'keyframes', duration: 0.8 },
  qS = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  QS = (e, { keyframes: t }) =>
    t.length > 2 ? KS : Is.has(e) ? (e.startsWith('scale') ? ZS(t[1]) : YS) : qS
function $S({
  when: e,
  delay: t,
  delayChildren: n,
  staggerChildren: r,
  staggerDirection: i,
  repeat: o,
  repeatType: c,
  repeatDelay: h,
  from: f,
  elapsed: p,
  ...y
}) {
  return !!Object.keys(y).length
}
const Q0 =
  (e, t, n, r = {}, i, o) =>
  (c) => {
    const h = O0(r, e) || {},
      f = h.delay || r.delay || 0
    let { elapsed: p = 0 } = r
    p = p - zr(f)
    let y = {
      keyframes: Array.isArray(n) ? n : [null, n],
      ease: 'easeOut',
      velocity: t.getVelocity(),
      ...h,
      delay: -p,
      onUpdate: (x) => {
        ;(t.set(x), h.onUpdate && h.onUpdate(x))
      },
      onComplete: () => {
        ;(c(), h.onComplete && h.onComplete())
      },
      name: e,
      motionValue: t,
      element: o ? void 0 : i,
    }
    ;($S(h) || (y = { ...y, ...QS(e, y) }),
      y.duration && (y.duration = zr(y.duration)),
      y.repeatDelay && (y.repeatDelay = zr(y.repeatDelay)),
      y.from !== void 0 && (y.keyframes[0] = y.from))
    let w = !1
    if (
      ((y.type === !1 || (y.duration === 0 && !y.repeatDelay)) &&
        ((y.duration = 0), y.delay === 0 && (w = !0)),
      w && !o && t.get() !== void 0)
    ) {
      const x = wh(y.keyframes, h)
      if (x !== void 0)
        return (
          rt.update(() => {
            ;(y.onUpdate(x), y.onComplete())
          }),
          new y5([])
        )
    }
    return !o && S2.supports(y) ? new S2(y) : new q0(y)
  }
function JS({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0
  return ((t[n] = !1), r)
}
function _6(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  var o
  let { transition: c = e.getDefaultTransition(), transitionEnd: h, ...f } = t
  r && (c = r)
  const p = [],
    y = i && e.animationState && e.animationState.getState()[i]
  for (const w in f) {
    const x = e.getValue(w, (o = e.latestValues[w]) !== null && o !== void 0 ? o : null),
      E = f[w]
    if (E === void 0 || (y && JS(y, w))) continue
    const S = { delay: n, ...O0(c || {}, w) }
    let k = !1
    if (window.MotionHandoffAnimation) {
      const I = Qw(e)
      if (I) {
        const R = window.MotionHandoffAnimation(I, w, rt)
        R !== null && ((S.startTime = R), (k = !0))
      }
    }
    ;(G1(e, w), x.start(Q0(w, x, E, e.shouldReduceMotion && Kw.has(w) ? { type: !1 } : S, e, k)))
    const P = x.animation
    P && p.push(P)
  }
  return (
    h &&
      Promise.all(p).then(() => {
        rt.update(() => {
          h && R5(e, h)
        })
      }),
    p
  )
}
function J1(e, t, n = {}) {
  var r
  const i = yh(
    e,
    t,
    n.type === 'exit'
      ? (r = e.presenceContext) === null || r === void 0
        ? void 0
        : r.custom
      : void 0
  )
  let { transition: o = e.getDefaultTransition() || {} } = i || {}
  n.transitionOverride && (o = n.transitionOverride)
  const c = i ? () => Promise.all(_6(e, i, n)) : () => Promise.resolve(),
    h =
      e.variantChildren && e.variantChildren.size
        ? (p = 0) => {
            const { delayChildren: y = 0, staggerChildren: w, staggerDirection: x } = o
            return eA(e, t, y + p, w, x, n)
          }
        : () => Promise.resolve(),
    { when: f } = o
  if (f) {
    const [p, y] = f === 'beforeChildren' ? [c, h] : [h, c]
    return p().then(() => y())
  } else return Promise.all([c(), h(n.delay)])
}
function eA(e, t, n = 0, r = 0, i = 1, o) {
  const c = [],
    h = (e.variantChildren.size - 1) * r,
    f = i === 1 ? (p = 0) => p * r : (p = 0) => h - p * r
  return (
    Array.from(e.variantChildren)
      .sort(tA)
      .forEach((p, y) => {
        ;(p.notify('AnimationStart', t),
          c.push(J1(p, t, { ...o, delay: n + f(y) }).then(() => p.notify('AnimationComplete', t))))
      }),
    Promise.all(c)
  )
}
function tA(e, t) {
  return e.sortNodePosition(t)
}
function nA(e, t, n = {}) {
  e.notify('AnimationStart', t)
  let r
  if (Array.isArray(t)) {
    const i = t.map((o) => J1(e, o, n))
    r = Promise.all(i)
  } else if (typeof t == 'string') r = J1(e, t, n)
  else {
    const i = typeof t == 'function' ? yh(e, t, n.custom) : t
    r = Promise.all(_6(e, i, n))
  }
  return r.then(() => {
    e.notify('AnimationComplete', t)
  })
}
const rA = S0.length
function I6(e) {
  if (!e) return
  if (!e.isControllingVariants) {
    const n = e.parent ? I6(e.parent) || {} : {}
    return (e.props.initial !== void 0 && (n.initial = e.props.initial), n)
  }
  const t = {}
  for (let n = 0; n < rA; n++) {
    const r = S0[n],
      i = e.props[r]
    ;(vl(i) || i === !1) && (t[r] = i)
  }
  return t
}
const iA = [...C0].reverse(),
  sA = C0.length
function oA(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => nA(e, n, r)))
}
function aA(e) {
  let t = oA(e),
    n = A2(),
    r = !0
  const i = (f) => (p, y) => {
    var w
    const x = yh(
      e,
      y,
      f === 'exit' ? ((w = e.presenceContext) === null || w === void 0 ? void 0 : w.custom) : void 0
    )
    if (x) {
      const { transition: E, transitionEnd: S, ...k } = x
      p = { ...p, ...k, ...S }
    }
    return p
  }
  function o(f) {
    t = f(e)
  }
  function c(f) {
    const { props: p } = e,
      y = I6(e.parent) || {},
      w = [],
      x = new Set()
    let E = {},
      S = 1 / 0
    for (let P = 0; P < sA; P++) {
      const I = iA[P],
        R = n[I],
        M = p[I] !== void 0 ? p[I] : y[I],
        O = vl(M),
        F = I === f ? R.isActive : null
      F === !1 && (S = P)
      let z = M === y[I] && M !== p[I] && O
      if (
        (z && r && e.manuallyAnimateOnMount && (z = !1),
        (R.protectedKeys = { ...E }),
        (!R.isActive && F === null) || (!M && !R.prevProp) || gh(M) || typeof M == 'boolean')
      )
        continue
      const V = lA(R.prevProp, M)
      let U = V || (I === f && R.isActive && !z && O) || (P > S && O),
        Z = !1
      const J = Array.isArray(M) ? M : [M]
      let oe = J.reduce(i(I), {})
      F === !1 && (oe = {})
      const { prevResolvedValues: re = {} } = R,
        ve = { ...re, ...oe },
        Ie = (H) => {
          ;((U = !0), x.has(H) && ((Z = !0), x.delete(H)), (R.needsAnimating[H] = !0))
          const xe = e.getValue(H)
          xe && (xe.liveStyle = !1)
        }
      for (const H in ve) {
        const xe = oe[H],
          ge = re[H]
        if (E.hasOwnProperty(H)) continue
        let se = !1
        ;(z1(xe) && z1(ge) ? (se = !Uw(xe, ge)) : (se = xe !== ge),
          se
            ? xe != null
              ? Ie(H)
              : x.add(H)
            : xe !== void 0 && x.has(H)
              ? Ie(H)
              : (R.protectedKeys[H] = !0))
      }
      ;((R.prevProp = M),
        (R.prevResolvedValues = oe),
        R.isActive && (E = { ...E, ...oe }),
        r && e.blockInitialAnimation && (U = !1),
        U && (!(z && V) || Z) && w.push(...J.map((H) => ({ animation: H, options: { type: I } }))))
    }
    if (x.size) {
      const P = {}
      ;(x.forEach((I) => {
        const R = e.getBaseTarget(I),
          M = e.getValue(I)
        ;(M && (M.liveStyle = !0), (P[I] = R ?? null))
      }),
        w.push({ animation: P }))
    }
    let k = !!w.length
    return (
      r && (p.initial === !1 || p.initial === p.animate) && !e.manuallyAnimateOnMount && (k = !1),
      (r = !1),
      k ? t(w) : Promise.resolve()
    )
  }
  function h(f, p) {
    var y
    if (n[f].isActive === p) return Promise.resolve()
    ;((y = e.variantChildren) === null ||
      y === void 0 ||
      y.forEach((x) => {
        var E
        return (E = x.animationState) === null || E === void 0 ? void 0 : E.setActive(f, p)
      }),
      (n[f].isActive = p))
    const w = c(f)
    for (const x in n) n[x].protectedKeys = {}
    return w
  }
  return {
    animateChanges: c,
    setActive: h,
    setAnimateFunction: o,
    getState: () => n,
    reset: () => {
      ;((n = A2()), (r = !0))
    },
  }
}
function lA(e, t) {
  return typeof t == 'string' ? t !== e : Array.isArray(t) ? !Uw(t, e) : !1
}
function Ki(e = !1) {
  return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} }
}
function A2() {
  return {
    animate: Ki(!0),
    whileInView: Ki(),
    whileHover: Ki(),
    whileTap: Ki(),
    whileDrag: Ki(),
    whileFocus: Ki(),
    exit: Ki(),
  }
}
class Ui {
  constructor(t) {
    ;((this.isMounted = !1), (this.node = t))
  }
  update() {}
}
class cA extends Ui {
  constructor(t) {
    ;(super(t), t.animationState || (t.animationState = aA(t)))
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps()
    gh(t) && (this.unmountControls = t.subscribe(this.node))
  }
  mount() {
    this.updateAnimationControlsSubscription()
  }
  update() {
    const { animate: t } = this.node.getProps(),
      { animate: n } = this.node.prevProps || {}
    t !== n && this.updateAnimationControlsSubscription()
  }
  unmount() {
    var t
    ;(this.node.animationState.reset(),
      (t = this.unmountControls) === null || t === void 0 || t.call(this))
  }
}
let uA = 0
class hA extends Ui {
  constructor() {
    ;(super(...arguments), (this.id = uA++))
  }
  update() {
    if (!this.node.presenceContext) return
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {}
    if (!this.node.animationState || t === r) return
    const i = this.node.animationState.setActive('exit', !t)
    n && !t && i.then(() => n(this.id))
  }
  mount() {
    const { register: t } = this.node.presenceContext || {}
    t && (this.unmount = t(this.id))
  }
  unmount() {}
}
const dA = { animation: { Feature: cA }, exit: { Feature: hA } }
function Sl(e, t, n, r = { passive: !0 }) {
  return (e.addEventListener(t, n, r), () => e.removeEventListener(t, n))
}
function jl(e) {
  return { point: { x: e.pageX, y: e.pageY } }
}
const fA = (e) => (t) => j0(t) && e(t, jl(t))
function Ga(e, t, n, r) {
  return Sl(e, t, fA(n), r)
}
const k2 = (e, t) => Math.abs(e - t)
function pA(e, t) {
  const n = k2(e.x, t.x),
    r = k2(e.y, t.y)
  return Math.sqrt(n ** 2 + r ** 2)
}
class N6 {
  constructor(t, n, { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: o = !1 } = {}) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return
        const w = _d(this.lastMoveEventInfo, this.history),
          x = this.startEvent !== null,
          E = pA(w.offset, { x: 0, y: 0 }) >= 3
        if (!x && !E) return
        const { point: S } = w,
          { timestamp: k } = zt
        this.history.push({ ...S, timestamp: k })
        const { onStart: P, onMove: I } = this.handlers
        ;(x || (P && P(this.lastMoveEvent, w), (this.startEvent = this.lastMoveEvent)),
          I && I(this.lastMoveEvent, w))
      }),
      (this.handlePointerMove = (w, x) => {
        ;((this.lastMoveEvent = w),
          (this.lastMoveEventInfo = kd(x, this.transformPagePoint)),
          rt.update(this.updatePoint, !0))
      }),
      (this.handlePointerUp = (w, x) => {
        this.end()
        const { onEnd: E, onSessionEnd: S, resumeAnimation: k } = this.handlers
        if ((this.dragSnapToOrigin && k && k(), !(this.lastMoveEvent && this.lastMoveEventInfo)))
          return
        const P = _d(
          w.type === 'pointercancel' ? this.lastMoveEventInfo : kd(x, this.transformPagePoint),
          this.history
        )
        ;(this.startEvent && E && E(w, P), S && S(w, P))
      }),
      !j0(t))
    )
      return
    ;((this.dragSnapToOrigin = o),
      (this.handlers = n),
      (this.transformPagePoint = r),
      (this.contextWindow = i || window))
    const c = jl(t),
      h = kd(c, this.transformPagePoint),
      { point: f } = h,
      { timestamp: p } = zt
    this.history = [{ ...f, timestamp: p }]
    const { onSessionStart: y } = n
    ;(y && y(t, _d(h, this.history)),
      (this.removeListeners = Fl(
        Ga(this.contextWindow, 'pointermove', this.handlePointerMove),
        Ga(this.contextWindow, 'pointerup', this.handlePointerUp),
        Ga(this.contextWindow, 'pointercancel', this.handlePointerUp)
      )))
  }
  updateHandlers(t) {
    this.handlers = t
  }
  end() {
    ;(this.removeListeners && this.removeListeners(), Di(this.updatePoint))
  }
}
function kd(e, t) {
  return t ? { point: t(e.point) } : e
}
function _2(e, t) {
  return { x: e.x - t.x, y: e.y - t.y }
}
function _d({ point: e }, t) {
  return { point: e, delta: _2(e, T6(t)), offset: _2(e, gA(t)), velocity: mA(t, 0.1) }
}
function gA(e) {
  return e[0]
}
function T6(e) {
  return e[e.length - 1]
}
function mA(e, t) {
  if (e.length < 2) return { x: 0, y: 0 }
  let n = e.length - 1,
    r = null
  const i = T6(e)
  for (; n >= 0 && ((r = e[n]), !(i.timestamp - r.timestamp > zr(t))); ) n--
  if (!r) return { x: 0, y: 0 }
  const o = Hr(i.timestamp - r.timestamp)
  if (o === 0) return { x: 0, y: 0 }
  const c = { x: (i.x - r.x) / o, y: (i.y - r.y) / o }
  return (c.x === 1 / 0 && (c.x = 0), c.y === 1 / 0 && (c.y = 0), c)
}
const R6 = 1e-4,
  yA = 1 - R6,
  wA = 1 + R6,
  M6 = 0.01,
  bA = 0 - M6,
  vA = 0 + M6
function Bn(e) {
  return e.max - e.min
}
function xA(e, t, n) {
  return Math.abs(e - t) <= n
}
function I2(e, t, n, r = 0.5) {
  ;((e.origin = r),
    (e.originPoint = lt(t.min, t.max, e.origin)),
    (e.scale = Bn(n) / Bn(t)),
    (e.translate = lt(n.min, n.max, e.origin) - e.originPoint),
    ((e.scale >= yA && e.scale <= wA) || isNaN(e.scale)) && (e.scale = 1),
    ((e.translate >= bA && e.translate <= vA) || isNaN(e.translate)) && (e.translate = 0))
}
function Ya(e, t, n, r) {
  ;(I2(e.x, t.x, n.x, r ? r.originX : void 0), I2(e.y, t.y, n.y, r ? r.originY : void 0))
}
function N2(e, t, n) {
  ;((e.min = n.min + t.min), (e.max = e.min + Bn(t)))
}
function EA(e, t, n) {
  ;(N2(e.x, t.x, n.x), N2(e.y, t.y, n.y))
}
function T2(e, t, n) {
  ;((e.min = t.min - n.min), (e.max = e.min + Bn(t)))
}
function Za(e, t, n) {
  ;(T2(e.x, t.x, n.x), T2(e.y, t.y, n.y))
}
function CA(e, { min: t, max: n }, r) {
  return (
    t !== void 0 && e < t
      ? (e = r ? lt(t, e, r.min) : Math.max(e, t))
      : n !== void 0 && e > n && (e = r ? lt(n, e, r.max) : Math.min(e, n)),
    e
  )
}
function R2(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0,
  }
}
function SA(e, { top: t, left: n, bottom: r, right: i }) {
  return { x: R2(e.x, n, i), y: R2(e.y, t, r) }
}
function M2(e, t) {
  let n = t.min - e.min,
    r = t.max - e.max
  return (t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r })
}
function AA(e, t) {
  return { x: M2(e.x, t.x), y: M2(e.y, t.y) }
}
function kA(e, t) {
  let n = 0.5
  const r = Bn(e),
    i = Bn(t)
  return (
    i > r ? (n = Fo(t.min, t.max - r, e.min)) : r > i && (n = Fo(e.min, e.max - i, t.min)),
    Kr(0, 1, n)
  )
}
function _A(e, t) {
  const n = {}
  return (
    t.min !== void 0 && (n.min = t.min - e.min),
    t.max !== void 0 && (n.max = t.max - e.min),
    n
  )
}
const ef = 0.35
function IA(e = ef) {
  return (
    e === !1 ? (e = 0) : e === !0 && (e = ef),
    { x: P2(e, 'left', 'right'), y: P2(e, 'top', 'bottom') }
  )
}
function P2(e, t, n) {
  return { min: D2(e, t), max: D2(e, n) }
}
function D2(e, t) {
  return typeof e == 'number' ? e : e[t] || 0
}
const L2 = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  wo = () => ({ x: L2(), y: L2() }),
  O2 = () => ({ min: 0, max: 0 }),
  xt = () => ({ x: O2(), y: O2() })
function Gn(e) {
  return [e('x'), e('y')]
}
function P6({ top: e, left: t, right: n, bottom: r }) {
  return { x: { min: t, max: n }, y: { min: e, max: r } }
}
function NA({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min }
}
function TA(e, t) {
  if (!t) return e
  const n = t({ x: e.left, y: e.top }),
    r = t({ x: e.right, y: e.bottom })
  return { top: n.y, left: n.x, bottom: r.y, right: r.x }
}
function Id(e) {
  return e === void 0 || e === 1
}
function tf({ scale: e, scaleX: t, scaleY: n }) {
  return !Id(e) || !Id(t) || !Id(n)
}
function ts(e) {
  return tf(e) || D6(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
}
function D6(e) {
  return B2(e.x) || B2(e.y)
}
function B2(e) {
  return e && e !== '0%'
}
function Ou(e, t, n) {
  const r = e - n,
    i = t * r
  return n + i
}
function F2(e, t, n, r, i) {
  return (i !== void 0 && (e = Ou(e, i, r)), Ou(e, n, r) + t)
}
function nf(e, t = 0, n = 1, r, i) {
  ;((e.min = F2(e.min, t, n, r, i)), (e.max = F2(e.max, t, n, r, i)))
}
function L6(e, { x: t, y: n }) {
  ;(nf(e.x, t.translate, t.scale, t.originPoint), nf(e.y, n.translate, n.scale, n.originPoint))
}
const j2 = 0.999999999999,
  V2 = 1.0000000000001
function RA(e, t, n, r = !1) {
  const i = n.length
  if (!i) return
  t.x = t.y = 1
  let o, c
  for (let h = 0; h < i; h++) {
    ;((o = n[h]), (c = o.projectionDelta))
    const { visualElement: f } = o.options
    ;(f && f.props.style && f.props.style.display === 'contents') ||
      (r &&
        o.options.layoutScroll &&
        o.scroll &&
        o !== o.root &&
        vo(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }),
      c && ((t.x *= c.x.scale), (t.y *= c.y.scale), L6(e, c)),
      r && ts(o.latestValues) && vo(e, o.latestValues))
  }
  ;(t.x < V2 && t.x > j2 && (t.x = 1), t.y < V2 && t.y > j2 && (t.y = 1))
}
function bo(e, t) {
  ;((e.min = e.min + t), (e.max = e.max + t))
}
function U2(e, t, n, r, i = 0.5) {
  const o = lt(e.min, e.max, i)
  nf(e, t, n, o, r)
}
function vo(e, t) {
  ;(U2(e.x, t.x, t.scaleX, t.scale, t.originX), U2(e.y, t.y, t.scaleY, t.scale, t.originY))
}
function O6(e, t) {
  return P6(TA(e.getBoundingClientRect(), t))
}
function MA(e, t, n) {
  const r = O6(e, n),
    { scroll: i } = t
  return (i && (bo(r.x, i.offset.x), bo(r.y, i.offset.y)), r)
}
const B6 = ({ current: e }) => (e ? e.ownerDocument.defaultView : null),
  PA = new WeakMap()
class DA {
  constructor(t) {
    ;((this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = xt()),
      (this.visualElement = t))
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: r } = this.visualElement
    if (r && r.isPresent === !1) return
    const i = (y) => {
        const { dragSnapToOrigin: w } = this.getProps()
        ;(w ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(jl(y).point))
      },
      o = (y, w) => {
        const { drag: x, dragPropagation: E, onDragStart: S } = this.getProps()
        if (
          x &&
          !E &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = k5(x)),
          !this.openDragLock)
        )
          return
        ;((this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          Gn((P) => {
            let I = this.getAxisMotionValue(P).get() || 0
            if (_r.test(I)) {
              const { projection: R } = this.visualElement
              if (R && R.layout) {
                const M = R.layout.layoutBox[P]
                M && (I = Bn(M) * (parseFloat(I) / 100))
              }
            }
            this.originPoint[P] = I
          }),
          S && rt.postRender(() => S(y, w)),
          G1(this.visualElement, 'transform'))
        const { animationState: k } = this.visualElement
        k && k.setActive('whileDrag', !0)
      },
      c = (y, w) => {
        const {
          dragPropagation: x,
          dragDirectionLock: E,
          onDirectionLock: S,
          onDrag: k,
        } = this.getProps()
        if (!x && !this.openDragLock) return
        const { offset: P } = w
        if (E && this.currentDirection === null) {
          ;((this.currentDirection = LA(P)),
            this.currentDirection !== null && S && S(this.currentDirection))
          return
        }
        ;(this.updateAxis('x', w.point, P),
          this.updateAxis('y', w.point, P),
          this.visualElement.render(),
          k && k(y, w))
      },
      h = (y, w) => this.stop(y, w),
      f = () =>
        Gn((y) => {
          var w
          return (
            this.getAnimationState(y) === 'paused' &&
            ((w = this.getAxisMotionValue(y).animation) === null || w === void 0
              ? void 0
              : w.play())
          )
        }),
      { dragSnapToOrigin: p } = this.getProps()
    this.panSession = new N6(
      t,
      { onSessionStart: i, onStart: o, onMove: c, onSessionEnd: h, resumeAnimation: f },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: p,
        contextWindow: B6(this.visualElement),
      }
    )
  }
  stop(t, n) {
    const r = this.isDragging
    if ((this.cancel(), !r)) return
    const { velocity: i } = n
    this.startAnimation(i)
    const { onDragEnd: o } = this.getProps()
    o && rt.postRender(() => o(t, n))
  }
  cancel() {
    this.isDragging = !1
    const { projection: t, animationState: n } = this.visualElement
    ;(t && (t.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0))
    const { dragPropagation: r } = this.getProps()
    ;(!r && this.openDragLock && (this.openDragLock(), (this.openDragLock = null)),
      n && n.setActive('whileDrag', !1))
  }
  updateAxis(t, n, r) {
    const { drag: i } = this.getProps()
    if (!r || !xc(t, i, this.currentDirection)) return
    const o = this.getAxisMotionValue(t)
    let c = this.originPoint[t] + r[t]
    ;(this.constraints && this.constraints[t] && (c = CA(c, this.constraints[t], this.elastic[t])),
      o.set(c))
  }
  resolveConstraints() {
    var t
    const { dragConstraints: n, dragElastic: r } = this.getProps(),
      i =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (t = this.visualElement.projection) === null || t === void 0
            ? void 0
            : t.layout,
      o = this.constraints
    ;(n && mo(n)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : n && i
        ? (this.constraints = SA(i.layoutBox, n))
        : (this.constraints = !1),
      (this.elastic = IA(r)),
      o !== this.constraints &&
        i &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        Gn((c) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(c) &&
            (this.constraints[c] = _A(i.layoutBox[c], this.constraints[c]))
        }))
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps()
    if (!t || !mo(t)) return !1
    const r = t.current,
      { projection: i } = this.visualElement
    if (!i || !i.layout) return !1
    const o = MA(r, i.root, this.visualElement.getTransformPagePoint())
    let c = AA(i.layout.layoutBox, o)
    if (n) {
      const h = n(NA(c))
      ;((this.hasMutatedConstraints = !!h), h && (c = P6(h)))
    }
    return c
  }
  startAnimation(t) {
    const {
        drag: n,
        dragMomentum: r,
        dragElastic: i,
        dragTransition: o,
        dragSnapToOrigin: c,
        onDragTransitionEnd: h,
      } = this.getProps(),
      f = this.constraints || {},
      p = Gn((y) => {
        if (!xc(y, n, this.currentDirection)) return
        let w = (f && f[y]) || {}
        c && (w = { min: 0, max: 0 })
        const x = i ? 200 : 1e6,
          E = i ? 40 : 1e7,
          S = {
            type: 'inertia',
            velocity: r ? t[y] : 0,
            bounceStiffness: x,
            bounceDamping: E,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...o,
            ...w,
          }
        return this.startAxisValueAnimation(y, S)
      })
    return Promise.all(p).then(h)
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t)
    return (G1(this.visualElement, t), r.start(Q0(t, r, 0, n, this.visualElement, !1)))
  }
  stopAnimation() {
    Gn((t) => this.getAxisMotionValue(t).stop())
  }
  pauseAnimation() {
    Gn((t) => {
      var n
      return (n = this.getAxisMotionValue(t).animation) === null || n === void 0
        ? void 0
        : n.pause()
    })
  }
  getAnimationState(t) {
    var n
    return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state
  }
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`,
      r = this.visualElement.getProps()
    return r[n] || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0)
  }
  snapToCursor(t) {
    Gn((n) => {
      const { drag: r } = this.getProps()
      if (!xc(n, r, this.currentDirection)) return
      const { projection: i } = this.visualElement,
        o = this.getAxisMotionValue(n)
      if (i && i.layout) {
        const { min: c, max: h } = i.layout.layoutBox[n]
        o.set(t[n] - lt(c, h, 0.5))
      }
    })
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return
    const { drag: t, dragConstraints: n } = this.getProps(),
      { projection: r } = this.visualElement
    if (!mo(n) || !r || !this.constraints) return
    this.stopAnimation()
    const i = { x: 0, y: 0 }
    Gn((c) => {
      const h = this.getAxisMotionValue(c)
      if (h && this.constraints !== !1) {
        const f = h.get()
        i[c] = kA({ min: f, max: f }, this.constraints[c])
      }
    })
    const { transformTemplate: o } = this.visualElement.getProps()
    ;((this.visualElement.current.style.transform = o ? o({}, '') : 'none'),
      r.root && r.root.updateScroll(),
      r.updateLayout(),
      this.resolveConstraints(),
      Gn((c) => {
        if (!xc(c, t, null)) return
        const h = this.getAxisMotionValue(c),
          { min: f, max: p } = this.constraints[c]
        h.set(lt(f, p, i[c]))
      }))
  }
  addListeners() {
    if (!this.visualElement.current) return
    PA.set(this.visualElement, this)
    const t = this.visualElement.current,
      n = Ga(t, 'pointerdown', (f) => {
        const { drag: p, dragListener: y = !0 } = this.getProps()
        p && y && this.start(f)
      }),
      r = () => {
        const { dragConstraints: f } = this.getProps()
        mo(f) && f.current && (this.constraints = this.resolveRefConstraints())
      },
      { projection: i } = this.visualElement,
      o = i.addEventListener('measure', r)
    ;(i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), rt.read(r))
    const c = Sl(window, 'resize', () => this.scalePositionWithinConstraints()),
      h = i.addEventListener('didUpdate', ({ delta: f, hasLayoutChanged: p }) => {
        this.isDragging &&
          p &&
          (Gn((y) => {
            const w = this.getAxisMotionValue(y)
            w && ((this.originPoint[y] += f[y].translate), w.set(w.get() + f[y].translate))
          }),
          this.visualElement.render())
      })
    return () => {
      ;(c(), n(), o(), h && h())
    }
  }
  getProps() {
    const t = this.visualElement.getProps(),
      {
        drag: n = !1,
        dragDirectionLock: r = !1,
        dragPropagation: i = !1,
        dragConstraints: o = !1,
        dragElastic: c = ef,
        dragMomentum: h = !0,
      } = t
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: c,
      dragMomentum: h,
    }
  }
}
function xc(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e)
}
function LA(e, t = 10) {
  let n = null
  return (Math.abs(e.y) > t ? (n = 'y') : Math.abs(e.x) > t && (n = 'x'), n)
}
class OA extends Ui {
  constructor(t) {
    ;(super(t),
      (this.removeGroupControls = Dn),
      (this.removeListeners = Dn),
      (this.controls = new DA(t)))
  }
  mount() {
    const { dragControls: t } = this.node.getProps()
    ;(t && (this.removeGroupControls = t.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Dn))
  }
  unmount() {
    ;(this.removeGroupControls(), this.removeListeners())
  }
}
const W2 = (e) => (t, n) => {
  e && rt.postRender(() => e(t, n))
}
class BA extends Ui {
  constructor() {
    ;(super(...arguments), (this.removePointerDownListener = Dn))
  }
  onPointerDown(t) {
    this.session = new N6(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: B6(this.node),
    })
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps()
    return {
      onSessionStart: W2(t),
      onStart: W2(n),
      onMove: r,
      onEnd: (o, c) => {
        ;(delete this.session, i && rt.postRender(() => i(o, c)))
      },
    }
  }
  mount() {
    this.removePointerDownListener = Ga(this.node.current, 'pointerdown', (t) =>
      this.onPointerDown(t)
    )
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
    ;(this.removePointerDownListener(), this.session && this.session.end())
  }
}
const qc = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }
function z2(e, t) {
  return t.max === t.min ? 0 : (e / (t.max - t.min)) * 100
}
const va = {
    correct: (e, t) => {
      if (!t.target) return e
      if (typeof e == 'string')
        if (be.test(e)) e = parseFloat(e)
        else return e
      const n = z2(e, t.target.x),
        r = z2(e, t.target.y)
      return `${n}% ${r}%`
    },
  },
  FA = {
    correct: (e, { treeScale: t, projectionDelta: n }) => {
      const r = e,
        i = Li.parse(e)
      if (i.length > 5) return r
      const o = Li.createTransformer(e),
        c = typeof i[0] != 'number' ? 1 : 0,
        h = n.x.scale * t.x,
        f = n.y.scale * t.y
      ;((i[0 + c] /= h), (i[1 + c] /= f))
      const p = lt(h, f, 0.5)
      return (
        typeof i[2 + c] == 'number' && (i[2 + c] /= p),
        typeof i[3 + c] == 'number' && (i[3 + c] /= p),
        o(i)
      )
    },
  }
class jA extends X.Component {
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props,
      { projection: o } = t
    ;(s5(VA),
      o &&
        (n.group && n.group.add(o),
        r && r.register && i && r.register(o),
        o.root.didUpdate(),
        o.addEventListener('animationComplete', () => {
          this.safeToRemove()
        }),
        o.setOptions({ ...o.options, onExitComplete: () => this.safeToRemove() })),
      (qc.hasEverUpdated = !0))
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: i, isPresent: o } = this.props,
      c = r.projection
    return (
      c &&
        ((c.isPresent = o),
        i || t.layoutDependency !== n || n === void 0 ? c.willUpdate() : this.safeToRemove(),
        t.isPresent !== o &&
          (o
            ? c.promote()
            : c.relegate() ||
              rt.postRender(() => {
                const h = c.getStack()
                ;(!h || !h.members.length) && this.safeToRemove()
              }))),
      null
    )
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement
    t &&
      (t.root.didUpdate(),
      k0.postRender(() => {
        !t.currentAnimation && t.isLead() && this.safeToRemove()
      }))
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props,
      { projection: i } = t
    i &&
      (i.scheduleCheckAfterUnmount(),
      n && n.group && n.group.remove(i),
      r && r.deregister && r.deregister(i))
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props
    t && t()
  }
  render() {
    return null
  }
}
function F6(e) {
  const [t, n] = vC(),
    r = X.useContext(vw)
  return N.jsx(jA, {
    ...e,
    layoutGroup: r,
    switchLayoutGroup: X.useContext(Iw),
    isPresent: t,
    safeToRemove: n,
  })
}
const VA = {
  borderRadius: {
    ...va,
    applyTo: [
      'borderTopLeftRadius',
      'borderTopRightRadius',
      'borderBottomLeftRadius',
      'borderBottomRightRadius',
    ],
  },
  borderTopLeftRadius: va,
  borderTopRightRadius: va,
  borderBottomLeftRadius: va,
  borderBottomRightRadius: va,
  boxShadow: FA,
}
function UA(e, t, n) {
  const r = Jt(e) ? e : El(e)
  return (r.start(Q0('', r, t, n)), r.animation)
}
function WA(e) {
  return e instanceof SVGElement && e.tagName !== 'svg'
}
const zA = (e, t) => e.depth - t.depth
class HA {
  constructor() {
    ;((this.children = []), (this.isDirty = !1))
  }
  add(t) {
    ;(V0(this.children, t), (this.isDirty = !0))
  }
  remove(t) {
    ;(U0(this.children, t), (this.isDirty = !0))
  }
  forEach(t) {
    ;(this.isDirty && this.children.sort(zA), (this.isDirty = !1), this.children.forEach(t))
  }
}
function XA(e, t) {
  const n = Ir.now(),
    r = ({ timestamp: i }) => {
      const o = i - n
      o >= t && (Di(r), e(o - t))
    }
  return (rt.read(r, !0), () => Di(r))
}
const j6 = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'],
  GA = j6.length,
  H2 = (e) => (typeof e == 'string' ? parseFloat(e) : e),
  X2 = (e) => typeof e == 'number' || be.test(e)
function YA(e, t, n, r, i, o) {
  i
    ? ((e.opacity = lt(0, n.opacity !== void 0 ? n.opacity : 1, ZA(r))),
      (e.opacityExit = lt(t.opacity !== void 0 ? t.opacity : 1, 0, KA(r))))
    : o &&
      (e.opacity = lt(
        t.opacity !== void 0 ? t.opacity : 1,
        n.opacity !== void 0 ? n.opacity : 1,
        r
      ))
  for (let c = 0; c < GA; c++) {
    const h = `border${j6[c]}Radius`
    let f = G2(t, h),
      p = G2(n, h)
    ;(f === void 0 && p === void 0) ||
      (f || (f = 0),
      p || (p = 0),
      f === 0 || p === 0 || X2(f) === X2(p)
        ? ((e[h] = Math.max(lt(H2(f), H2(p), r), 0)), (_r.test(p) || _r.test(f)) && (e[h] += '%'))
        : (e[h] = p))
  }
  ;(t.rotate || n.rotate) && (e.rotate = lt(t.rotate || 0, n.rotate || 0, r))
}
function G2(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius
}
const ZA = V6(0, 0.5, i6),
  KA = V6(0.5, 0.95, Dn)
function V6(e, t, n) {
  return (r) => (r < e ? 0 : r > t ? 1 : n(Fo(e, t, r)))
}
function Y2(e, t) {
  ;((e.min = t.min), (e.max = t.max))
}
function Hn(e, t) {
  ;(Y2(e.x, t.x), Y2(e.y, t.y))
}
function Z2(e, t) {
  ;((e.translate = t.translate),
    (e.scale = t.scale),
    (e.originPoint = t.originPoint),
    (e.origin = t.origin))
}
function K2(e, t, n, r, i) {
  return ((e -= t), (e = Ou(e, 1 / n, r)), i !== void 0 && (e = Ou(e, 1 / i, r)), e)
}
function qA(e, t = 0, n = 1, r = 0.5, i, o = e, c = e) {
  if (
    (_r.test(t) && ((t = parseFloat(t)), (t = lt(c.min, c.max, t / 100) - c.min)),
    typeof t != 'number')
  )
    return
  let h = lt(o.min, o.max, r)
  ;(e === o && (h -= t), (e.min = K2(e.min, t, n, h, i)), (e.max = K2(e.max, t, n, h, i)))
}
function q2(e, t, [n, r, i], o, c) {
  qA(e, t[n], t[r], t[i], t.scale, o, c)
}
const QA = ['x', 'scaleX', 'originX'],
  $A = ['y', 'scaleY', 'originY']
function Q2(e, t, n, r) {
  ;(q2(e.x, t, QA, n ? n.x : void 0, r ? r.x : void 0),
    q2(e.y, t, $A, n ? n.y : void 0, r ? r.y : void 0))
}
function $2(e) {
  return e.translate === 0 && e.scale === 1
}
function U6(e) {
  return $2(e.x) && $2(e.y)
}
function J2(e, t) {
  return e.min === t.min && e.max === t.max
}
function JA(e, t) {
  return J2(e.x, t.x) && J2(e.y, t.y)
}
function em(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max)
}
function W6(e, t) {
  return em(e.x, t.x) && em(e.y, t.y)
}
function tm(e) {
  return Bn(e.x) / Bn(e.y)
}
function nm(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint
}
class e7 {
  constructor() {
    this.members = []
  }
  add(t) {
    ;(V0(this.members, t), t.scheduleRender())
  }
  remove(t) {
    if ((U0(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead)) {
      const n = this.members[this.members.length - 1]
      n && this.promote(n)
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i)
    if (n === 0) return !1
    let r
    for (let i = n; i >= 0; i--) {
      const o = this.members[i]
      if (o.isPresent !== !1) {
        r = o
        break
      }
    }
    return r ? (this.promote(r), !0) : !1
  }
  promote(t, n) {
    const r = this.lead
    if (t !== r && ((this.prevLead = r), (this.lead = t), t.show(), r)) {
      ;(r.instance && r.scheduleRender(),
        t.scheduleRender(),
        (t.resumeFrom = r),
        n && (t.resumeFrom.preserveOpacity = !0),
        r.snapshot &&
          ((t.snapshot = r.snapshot),
          (t.snapshot.latestValues = r.animationValues || r.latestValues)),
        t.root && t.root.isUpdating && (t.isLayoutDirty = !0))
      const { crossfade: i } = t.options
      i === !1 && r.hide()
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t
      ;(n.onExitComplete && n.onExitComplete(),
        r && r.options.onExitComplete && r.options.onExitComplete())
    })
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1)
    })
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}
function t7(e, t, n) {
  let r = ''
  const i = e.x.translate / t.x,
    o = e.y.translate / t.y,
    c = (n == null ? void 0 : n.z) || 0
  if (
    ((i || o || c) && (r = `translate3d(${i}px, ${o}px, ${c}px) `),
    (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `),
    n)
  ) {
    const { transformPerspective: p, rotate: y, rotateX: w, rotateY: x, skewX: E, skewY: S } = n
    ;(p && (r = `perspective(${p}px) ${r}`),
      y && (r += `rotate(${y}deg) `),
      w && (r += `rotateX(${w}deg) `),
      x && (r += `rotateY(${x}deg) `),
      E && (r += `skewX(${E}deg) `),
      S && (r += `skewY(${S}deg) `))
  }
  const h = e.x.scale * t.x,
    f = e.y.scale * t.y
  return ((h !== 1 || f !== 1) && (r += `scale(${h}, ${f})`), r || 'none')
}
const ns = {
    type: 'projectionFrame',
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0,
  },
  Ma = typeof window < 'u' && window.MotionDebug !== void 0,
  Nd = ['', 'X', 'Y', 'Z'],
  n7 = { visibility: 'hidden' },
  rm = 1e3
let r7 = 0
function Td(e, t, n, r) {
  const { latestValues: i } = t
  i[e] && ((n[e] = i[e]), t.setStaticValue(e, 0), r && (r[e] = 0))
}
function z6(e) {
  if (((e.hasCheckedOptimisedAppear = !0), e.root === e)) return
  const { visualElement: t } = e.options
  if (!t) return
  const n = Qw(t)
  if (window.MotionHasOptimisedAnimation(n, 'transform')) {
    const { layout: i, layoutId: o } = e.options
    window.MotionCancelOptimisedAnimation(n, 'transform', rt, !(i || o))
  }
  const { parent: r } = e
  r && !r.hasCheckedOptimisedAppear && z6(r)
}
function H6({
  attachResizeListener: e,
  defaultParent: t,
  measureScroll: n,
  checkIsScrollRoot: r,
  resetTransform: i,
}) {
  return class {
    constructor(o = {}, c = t == null ? void 0 : t()) {
      ;((this.id = r7++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots())
        }),
        (this.updateProjection = () => {
          ;((this.projectionUpdateScheduled = !1),
            Ma && (ns.totalNodes = ns.resolvedTargetDeltas = ns.recalculatedProjection = 0),
            this.nodes.forEach(o7),
            this.nodes.forEach(h7),
            this.nodes.forEach(d7),
            this.nodes.forEach(a7),
            Ma && window.MotionDebug.record(ns))
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = o),
        (this.root = c ? c.root || c : this),
        (this.path = c ? [...c.path, c] : []),
        (this.parent = c),
        (this.depth = c ? c.depth + 1 : 0))
      for (let h = 0; h < this.path.length; h++) this.path[h].shouldResetTransform = !0
      this.root === this && (this.nodes = new HA())
    }
    addEventListener(o, c) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new W0()),
        this.eventHandlers.get(o).add(c)
      )
    }
    notifyListeners(o, ...c) {
      const h = this.eventHandlers.get(o)
      h && h.notify(...c)
    }
    hasListeners(o) {
      return this.eventHandlers.has(o)
    }
    mount(o, c = this.root.hasTreeAnimated) {
      if (this.instance) return
      ;((this.isSVG = WA(o)), (this.instance = o))
      const { layoutId: h, layout: f, visualElement: p } = this.options
      if (
        (p && !p.current && p.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        c && (f || h) && (this.isLayoutDirty = !0),
        e)
      ) {
        let y
        const w = () => (this.root.updateBlockedByResize = !1)
        e(o, () => {
          ;((this.root.updateBlockedByResize = !0),
            y && y(),
            (y = XA(w, 250)),
            qc.hasAnimatedSinceResize && ((qc.hasAnimatedSinceResize = !1), this.nodes.forEach(sm)))
        })
      }
      ;(h && this.root.registerSharedNode(h, this),
        this.options.animate !== !1 &&
          p &&
          (h || f) &&
          this.addEventListener(
            'didUpdate',
            ({ delta: y, hasLayoutChanged: w, hasRelativeTargetChanged: x, layout: E }) => {
              if (this.isTreeAnimationBlocked()) {
                ;((this.target = void 0), (this.relativeTarget = void 0))
                return
              }
              const S = this.options.transition || p.getDefaultTransition() || y7,
                { onLayoutAnimationStart: k, onLayoutAnimationComplete: P } = p.getProps(),
                I = !this.targetLayout || !W6(this.targetLayout, E) || x,
                R = !w && x
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                R ||
                (w && (I || !this.currentAnimation))
              ) {
                ;(this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(y, R))
                const M = { ...O0(S, 'layout'), onPlay: k, onComplete: P }
                ;((p.shouldReduceMotion || this.options.layoutRoot) &&
                  ((M.delay = 0), (M.type = !1)),
                  this.startAnimation(M))
              } else
                (w || sm(this),
                  this.isLead() && this.options.onExitComplete && this.options.onExitComplete())
              this.targetLayout = E
            }
          ))
    }
    unmount() {
      ;(this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this))
      const o = this.getStack()
      ;(o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Di(this.updateProjection))
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || (this.parent && this.parent.isTreeAnimationBlocked()) || !1
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0), this.nodes && this.nodes.forEach(f7), this.animationId++)
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options
      return o && o.getProps().transformTemplate
    }
    willUpdate(o = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete()
        return
      }
      if (
        (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && z6(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return
      this.isLayoutDirty = !0
      for (let p = 0; p < this.path.length; p++) {
        const y = this.path[p]
        ;((y.shouldResetTransform = !0),
          y.updateScroll('snapshot'),
          y.options.layoutRoot && y.willUpdate(!1))
      }
      const { layoutId: c, layout: h } = this.options
      if (c === void 0 && !h) return
      const f = this.getTransformTemplate()
      ;((this.prevTransformTemplateValue = f ? f(this.latestValues, '') : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners('willUpdate'))
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        ;(this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(im))
        return
      }
      ;(this.isUpdating || this.nodes.forEach(c7),
        (this.isUpdating = !1),
        this.nodes.forEach(u7),
        this.nodes.forEach(i7),
        this.nodes.forEach(s7),
        this.clearAllSnapshots())
      const o = Ir.now()
      ;((zt.delta = Kr(0, 1e3 / 60, o - zt.timestamp)),
        (zt.timestamp = o),
        (zt.isProcessing = !0),
        vd.update.process(zt),
        vd.preRender.process(zt),
        vd.render.process(zt),
        (zt.isProcessing = !1))
    }
    didUpdate() {
      this.updateScheduled || ((this.updateScheduled = !0), k0.read(this.scheduleUpdate))
    }
    clearAllSnapshots() {
      ;(this.nodes.forEach(l7), this.sharedNodes.forEach(p7))
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0), rt.preRender(this.updateProjection, !1, !0))
    }
    scheduleCheckAfterUnmount() {
      rt.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
      })
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure())
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)
      )
        return
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let h = 0; h < this.path.length; h++) this.path[h].updateScroll()
      const o = this.layout
      ;((this.layout = this.measure(!1)),
        (this.layoutCorrected = xt()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners('measure', this.layout.layoutBox))
      const { visualElement: c } = this.options
      c && c.notify('LayoutMeasure', this.layout.layoutBox, o ? o.layoutBox : void 0)
    }
    updateScroll(o = 'measure') {
      let c = !!(this.options.layoutScroll && this.instance)
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === o &&
          (c = !1),
        c)
      ) {
        const h = r(this.instance)
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: h,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : h,
        }
      }
    }
    resetTransform() {
      if (!i) return
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
        c = this.projectionDelta && !U6(this.projectionDelta),
        h = this.getTransformTemplate(),
        f = h ? h(this.latestValues, '') : void 0,
        p = f !== this.prevTransformTemplateValue
      o &&
        (c || ts(this.latestValues) || p) &&
        (i(this.instance, f), (this.shouldResetTransform = !1), this.scheduleRender())
    }
    measure(o = !0) {
      const c = this.measurePageBox()
      let h = this.removeElementScroll(c)
      return (
        o && (h = this.removeTransform(h)),
        w7(h),
        {
          animationId: this.root.animationId,
          measuredBox: c,
          layoutBox: h,
          latestValues: {},
          source: this.id,
        }
      )
    }
    measurePageBox() {
      var o
      const { visualElement: c } = this.options
      if (!c) return xt()
      const h = c.measureViewportBox()
      if (!((!((o = this.scroll) === null || o === void 0) && o.wasRoot) || this.path.some(b7))) {
        const { scroll: f } = this.root
        f && (bo(h.x, f.offset.x), bo(h.y, f.offset.y))
      }
      return h
    }
    removeElementScroll(o) {
      var c
      const h = xt()
      if ((Hn(h, o), !((c = this.scroll) === null || c === void 0) && c.wasRoot)) return h
      for (let f = 0; f < this.path.length; f++) {
        const p = this.path[f],
          { scroll: y, options: w } = p
        p !== this.root &&
          y &&
          w.layoutScroll &&
          (y.wasRoot && Hn(h, o), bo(h.x, y.offset.x), bo(h.y, y.offset.y))
      }
      return h
    }
    applyTransform(o, c = !1) {
      const h = xt()
      Hn(h, o)
      for (let f = 0; f < this.path.length; f++) {
        const p = this.path[f]
        ;(!c &&
          p.options.layoutScroll &&
          p.scroll &&
          p !== p.root &&
          vo(h, { x: -p.scroll.offset.x, y: -p.scroll.offset.y }),
          ts(p.latestValues) && vo(h, p.latestValues))
      }
      return (ts(this.latestValues) && vo(h, this.latestValues), h)
    }
    removeTransform(o) {
      const c = xt()
      Hn(c, o)
      for (let h = 0; h < this.path.length; h++) {
        const f = this.path[h]
        if (!f.instance || !ts(f.latestValues)) continue
        tf(f.latestValues) && f.updateSnapshot()
        const p = xt(),
          y = f.measurePageBox()
        ;(Hn(p, y), Q2(c, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, p))
      }
      return (ts(this.latestValues) && Q2(c, this.latestValues), c)
    }
    setTargetDelta(o) {
      ;((this.targetDelta = o), this.root.scheduleUpdateProjection(), (this.isProjectionDirty = !0))
    }
    setOptions(o) {
      this.options = { ...this.options, ...o, crossfade: o.crossfade !== void 0 ? o.crossfade : !0 }
    }
    clearMeasurements() {
      ;((this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1))
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== zt.timestamp &&
        this.relativeParent.resolveTargetDelta(!0)
    }
    resolveTargetDelta(o = !1) {
      var c
      const h = this.getLead()
      ;(this.isProjectionDirty || (this.isProjectionDirty = h.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = h.isTransformDirty),
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = h.isSharedProjectionDirty))
      const f = !!this.resumingFrom || this !== h
      if (
        !(
          o ||
          (f && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((c = this.parent) === null || c === void 0) && c.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return
      const { layout: p, layoutId: y } = this.options
      if (!(!this.layout || !(p || y))) {
        if (
          ((this.resolvedRelativeTargetAt = zt.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const w = this.getClosestProjectingParent()
          w && w.layout && this.animationProgress !== 1
            ? ((this.relativeParent = w),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = xt()),
              (this.relativeTargetOrigin = xt()),
              Za(this.relativeTargetOrigin, this.layout.layoutBox, w.layout.layoutBox),
              Hn(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target || ((this.target = xt()), (this.targetWithTransforms = xt())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                EA(this.target, this.relativeTarget, this.relativeParent.target))
              : this.targetDelta
                ? (this.resumingFrom
                    ? (this.target = this.applyTransform(this.layout.layoutBox))
                    : Hn(this.target, this.layout.layoutBox),
                  L6(this.target, this.targetDelta))
                : Hn(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1
            const w = this.getClosestProjectingParent()
            w &&
            !!w.resumingFrom == !!this.resumingFrom &&
            !w.options.layoutScroll &&
            w.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = w),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = xt()),
                (this.relativeTargetOrigin = xt()),
                Za(this.relativeTargetOrigin, this.target, w.target),
                Hn(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0)
          }
          Ma && ns.resolvedTargetDeltas++
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || tf(this.parent.latestValues) || D6(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
    }
    calcProjection() {
      var o
      const c = this.getLead(),
        h = !!this.resumingFrom || this !== c
      let f = !0
      if (
        ((this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) && o.isProjectionDirty)) &&
          (f = !1),
        h && (this.isSharedProjectionDirty || this.isTransformDirty) && (f = !1),
        this.resolvedRelativeTargetAt === zt.timestamp && (f = !1),
        f)
      )
        return
      const { layout: p, layoutId: y } = this.options
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(p || y))
      )
        return
      Hn(this.layoutCorrected, this.layout.layoutBox)
      const w = this.treeScale.x,
        x = this.treeScale.y
      ;(RA(this.layoutCorrected, this.treeScale, this.path, h),
        c.layout &&
          !c.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((c.target = c.layout.layoutBox), (c.targetWithTransforms = xt())))
      const { target: E } = c
      if (!E) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender())
        return
      }
      ;(!this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (Z2(this.prevProjectionDelta.x, this.projectionDelta.x),
          Z2(this.prevProjectionDelta.y, this.projectionDelta.y)),
        Ya(this.projectionDelta, this.layoutCorrected, E, this.latestValues),
        (this.treeScale.x !== w ||
          this.treeScale.y !== x ||
          !nm(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !nm(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners('projectionUpdate', E)),
        Ma && ns.recalculatedProjection++)
    }
    hide() {
      this.isVisible = !1
    }
    show() {
      this.isVisible = !0
    }
    scheduleRender(o = !0) {
      var c
      if (((c = this.options.visualElement) === null || c === void 0 || c.scheduleRender(), o)) {
        const h = this.getStack()
        h && h.scheduleRender()
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
    }
    createProjectionDeltas() {
      ;((this.prevProjectionDelta = wo()),
        (this.projectionDelta = wo()),
        (this.projectionDeltaWithTransform = wo()))
    }
    setAnimationOrigin(o, c = !1) {
      const h = this.snapshot,
        f = h ? h.latestValues : {},
        p = { ...this.latestValues },
        y = wo()
      ;((!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !c))
      const w = xt(),
        x = h ? h.source : void 0,
        E = this.layout ? this.layout.source : void 0,
        S = x !== E,
        k = this.getStack(),
        P = !k || k.members.length <= 1,
        I = !!(S && !P && this.options.crossfade === !0 && !this.path.some(m7))
      this.animationProgress = 0
      let R
      ;((this.mixTargetDelta = (M) => {
        const O = M / 1e3
        ;(om(y.x, o.x, O),
          om(y.y, o.y, O),
          this.setTargetDelta(y),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Za(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            g7(this.relativeTarget, this.relativeTargetOrigin, w, O),
            R && JA(this.relativeTarget, R) && (this.isProjectionDirty = !1),
            R || (R = xt()),
            Hn(R, this.relativeTarget)),
          S && ((this.animationValues = p), YA(p, f, this.latestValues, O, I, P)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = O))
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0))
    }
    startAnimation(o) {
      ;(this.notifyListeners('animationStart'),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation && (Di(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = rt.update(() => {
          ;((qc.hasAnimatedSinceResize = !0),
            (this.currentAnimation = UA(0, rm, {
              ...o,
              onUpdate: (c) => {
                ;(this.mixTargetDelta(c), o.onUpdate && o.onUpdate(c))
              },
              onComplete: () => {
                ;(o.onComplete && o.onComplete(), this.completeAnimation())
              },
            })),
            this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0))
        })))
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0))
      const o = this.getStack()
      ;(o && o.exitAnimationComplete(),
        (this.resumingFrom = this.currentAnimation = this.animationValues = void 0),
        this.notifyListeners('animationComplete'))
    }
    finishAnimation() {
      ;(this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(rm), this.currentAnimation.stop()),
        this.completeAnimation())
    }
    applyTransformsToTarget() {
      const o = this.getLead()
      let { targetWithTransforms: c, target: h, layout: f, latestValues: p } = o
      if (!(!c || !h || !f)) {
        if (
          this !== o &&
          this.layout &&
          f &&
          X6(this.options.animationType, this.layout.layoutBox, f.layoutBox)
        ) {
          h = this.target || xt()
          const y = Bn(this.layout.layoutBox.x)
          ;((h.x.min = o.target.x.min), (h.x.max = h.x.min + y))
          const w = Bn(this.layout.layoutBox.y)
          ;((h.y.min = o.target.y.min), (h.y.max = h.y.min + w))
        }
        ;(Hn(c, h), vo(c, p), Ya(this.projectionDeltaWithTransform, this.layoutCorrected, c, p))
      }
    }
    registerSharedNode(o, c) {
      ;(this.sharedNodes.has(o) || this.sharedNodes.set(o, new e7()),
        this.sharedNodes.get(o).add(c))
      const h = c.options.initialPromotionConfig
      c.promote({
        transition: h ? h.transition : void 0,
        preserveFollowOpacity:
          h && h.shouldPreserveFollowOpacity ? h.shouldPreserveFollowOpacity(c) : void 0,
      })
    }
    isLead() {
      const o = this.getStack()
      return o ? o.lead === this : !0
    }
    getLead() {
      var o
      const { layoutId: c } = this.options
      return c ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
    }
    getPrevLead() {
      var o
      const { layoutId: c } = this.options
      return c ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead) : void 0
    }
    getStack() {
      const { layoutId: o } = this.options
      if (o) return this.root.sharedNodes.get(o)
    }
    promote({ needsReset: o, transition: c, preserveFollowOpacity: h } = {}) {
      const f = this.getStack()
      ;(f && f.promote(this, h),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        c && this.setOptions({ transition: c }))
    }
    relegate() {
      const o = this.getStack()
      return o ? o.relegate(this) : !1
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options
      if (!o) return
      let c = !1
      const { latestValues: h } = o
      if (
        ((h.z || h.rotate || h.rotateX || h.rotateY || h.rotateZ || h.skewX || h.skewY) && (c = !0),
        !c)
      )
        return
      const f = {}
      h.z && Td('z', o, f, this.animationValues)
      for (let p = 0; p < Nd.length; p++)
        (Td(`rotate${Nd[p]}`, o, f, this.animationValues),
          Td(`skew${Nd[p]}`, o, f, this.animationValues))
      o.render()
      for (const p in f)
        (o.setStaticValue(p, f[p]), this.animationValues && (this.animationValues[p] = f[p]))
      o.scheduleRender()
    }
    getProjectionStyles(o) {
      var c, h
      if (!this.instance || this.isSVG) return
      if (!this.isVisible) return n7
      const f = { visibility: '' },
        p = this.getTransformTemplate()
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (f.opacity = ''),
          (f.pointerEvents = Zc(o == null ? void 0 : o.pointerEvents) || ''),
          (f.transform = p ? p(this.latestValues, '') : 'none'),
          f
        )
      const y = this.getLead()
      if (!this.projectionDelta || !this.layout || !y.target) {
        const S = {}
        return (
          this.options.layoutId &&
            ((S.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1),
            (S.pointerEvents = Zc(o == null ? void 0 : o.pointerEvents) || '')),
          this.hasProjected &&
            !ts(this.latestValues) &&
            ((S.transform = p ? p({}, '') : 'none'), (this.hasProjected = !1)),
          S
        )
      }
      const w = y.animationValues || y.latestValues
      ;(this.applyTransformsToTarget(),
        (f.transform = t7(this.projectionDeltaWithTransform, this.treeScale, w)),
        p && (f.transform = p(w, f.transform)))
      const { x, y: E } = this.projectionDelta
      ;((f.transformOrigin = `${x.origin * 100}% ${E.origin * 100}% 0`),
        y.animationValues
          ? (f.opacity =
              y === this
                ? (h = (c = w.opacity) !== null && c !== void 0 ? c : this.latestValues.opacity) !==
                    null && h !== void 0
                  ? h
                  : 1
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : w.opacityExit)
          : (f.opacity =
              y === this
                ? w.opacity !== void 0
                  ? w.opacity
                  : ''
                : w.opacityExit !== void 0
                  ? w.opacityExit
                  : 0))
      for (const S in Ru) {
        if (w[S] === void 0) continue
        const { correct: k, applyTo: P } = Ru[S],
          I = f.transform === 'none' ? w[S] : k(w[S], y)
        if (P) {
          const R = P.length
          for (let M = 0; M < R; M++) f[P[M]] = I
        } else f[S] = I
      }
      return (
        this.options.layoutId &&
          (f.pointerEvents = y === this ? Zc(o == null ? void 0 : o.pointerEvents) || '' : 'none'),
        f
      )
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0
    }
    resetTree() {
      ;(this.root.nodes.forEach((o) => {
        var c
        return (c = o.currentAnimation) === null || c === void 0 ? void 0 : c.stop()
      }),
        this.root.nodes.forEach(im),
        this.root.sharedNodes.clear())
    }
  }
}
function i7(e) {
  e.updateLayout()
}
function s7(e) {
  var t
  const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot
  if (e.isLead() && e.layout && n && e.hasListeners('didUpdate')) {
    const { layoutBox: r, measuredBox: i } = e.layout,
      { animationType: o } = e.options,
      c = n.source !== e.layout.source
    o === 'size'
      ? Gn((w) => {
          const x = c ? n.measuredBox[w] : n.layoutBox[w],
            E = Bn(x)
          ;((x.min = r[w].min), (x.max = x.min + E))
        })
      : X6(o, n.layoutBox, r) &&
        Gn((w) => {
          const x = c ? n.measuredBox[w] : n.layoutBox[w],
            E = Bn(r[w])
          ;((x.max = x.min + E),
            e.relativeTarget &&
              !e.currentAnimation &&
              ((e.isProjectionDirty = !0), (e.relativeTarget[w].max = e.relativeTarget[w].min + E)))
        })
    const h = wo()
    Ya(h, r, n.layoutBox)
    const f = wo()
    c ? Ya(f, e.applyTransform(i, !0), n.measuredBox) : Ya(f, r, n.layoutBox)
    const p = !U6(h)
    let y = !1
    if (!e.resumeFrom) {
      const w = e.getClosestProjectingParent()
      if (w && !w.resumeFrom) {
        const { snapshot: x, layout: E } = w
        if (x && E) {
          const S = xt()
          Za(S, n.layoutBox, x.layoutBox)
          const k = xt()
          ;(Za(k, r, E.layoutBox),
            W6(S, k) || (y = !0),
            w.options.layoutRoot &&
              ((e.relativeTarget = k), (e.relativeTargetOrigin = S), (e.relativeParent = w)))
        }
      }
    }
    e.notifyListeners('didUpdate', {
      layout: r,
      snapshot: n,
      delta: f,
      layoutDelta: h,
      hasLayoutChanged: p,
      hasRelativeTargetChanged: y,
    })
  } else if (e.isLead()) {
    const { onExitComplete: r } = e.options
    r && r()
  }
  e.options.transition = void 0
}
function o7(e) {
  ;(Ma && ns.totalNodes++,
    e.parent &&
      (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
      e.isSharedProjectionDirty ||
        (e.isSharedProjectionDirty = !!(
          e.isProjectionDirty ||
          e.parent.isProjectionDirty ||
          e.parent.isSharedProjectionDirty
        )),
      e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)))
}
function a7(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}
function l7(e) {
  e.clearSnapshot()
}
function im(e) {
  e.clearMeasurements()
}
function c7(e) {
  e.isLayoutDirty = !1
}
function u7(e) {
  const { visualElement: t } = e.options
  ;(t && t.getProps().onBeforeLayoutMeasure && t.notify('BeforeLayoutMeasure'), e.resetTransform())
}
function sm(e) {
  ;(e.finishAnimation(),
    (e.targetDelta = e.relativeTarget = e.target = void 0),
    (e.isProjectionDirty = !0))
}
function h7(e) {
  e.resolveTargetDelta()
}
function d7(e) {
  e.calcProjection()
}
function f7(e) {
  e.resetSkewAndRotation()
}
function p7(e) {
  e.removeLeadSnapshot()
}
function om(e, t, n) {
  ;((e.translate = lt(t.translate, 0, n)),
    (e.scale = lt(t.scale, 1, n)),
    (e.origin = t.origin),
    (e.originPoint = t.originPoint))
}
function am(e, t, n, r) {
  ;((e.min = lt(t.min, n.min, r)), (e.max = lt(t.max, n.max, r)))
}
function g7(e, t, n, r) {
  ;(am(e.x, t.x, n.x, r), am(e.y, t.y, n.y, r))
}
function m7(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0
}
const y7 = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  lm = (e) =>
    typeof navigator < 'u' && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e),
  cm = lm('applewebkit/') && !lm('chrome/') ? Math.round : Dn
function um(e) {
  ;((e.min = cm(e.min)), (e.max = cm(e.max)))
}
function w7(e) {
  ;(um(e.x), um(e.y))
}
function X6(e, t, n) {
  return e === 'position' || (e === 'preserve-aspect' && !xA(tm(t), tm(n), 0.2))
}
function b7(e) {
  var t
  return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot)
}
const v7 = H6({
    attachResizeListener: (e, t) => Sl(e, 'resize', t),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  Rd = { current: void 0 },
  G6 = H6({
    measureScroll: (e) => ({ x: e.scrollLeft, y: e.scrollTop }),
    defaultParent: () => {
      if (!Rd.current) {
        const e = new v7({})
        ;(e.mount(window), e.setOptions({ layoutScroll: !0 }), (Rd.current = e))
      }
      return Rd.current
    },
    resetTransform: (e, t) => {
      e.style.transform = t !== void 0 ? t : 'none'
    },
    checkIsScrollRoot: (e) => window.getComputedStyle(e).position === 'fixed',
  }),
  x7 = { pan: { Feature: BA }, drag: { Feature: OA, ProjectionNode: G6, MeasureLayout: F6 } }
function hm(e, t, n) {
  const { props: r } = e
  e.animationState && r.whileHover && e.animationState.setActive('whileHover', n === 'Start')
  const i = 'onHover' + n,
    o = r[i]
  o && rt.postRender(() => o(t, jl(t)))
}
class E7 extends Ui {
  mount() {
    const { current: t } = this.node
    t && (this.unmount = x5(t, (n) => (hm(this.node, n, 'Start'), (r) => hm(this.node, r, 'End'))))
  }
  unmount() {}
}
class C7 extends Ui {
  constructor() {
    ;(super(...arguments), (this.isActive = !1))
  }
  onFocus() {
    let t = !1
    try {
      t = this.node.current.matches(':focus-visible')
    } catch {
      t = !0
    }
    !t ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !0), (this.isActive = !0))
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !1), (this.isActive = !1))
  }
  mount() {
    this.unmount = Fl(
      Sl(this.node.current, 'focus', () => this.onFocus()),
      Sl(this.node.current, 'blur', () => this.onBlur())
    )
  }
  unmount() {}
}
function dm(e, t, n) {
  const { props: r } = e
  e.animationState && r.whileTap && e.animationState.setActive('whileTap', n === 'Start')
  const i = 'onTap' + (n === 'End' ? '' : n),
    o = r[i]
  o && rt.postRender(() => o(t, jl(t)))
}
class S7 extends Ui {
  mount() {
    const { current: t } = this.node
    t &&
      (this.unmount = A5(
        t,
        (n) => (
          dm(this.node, n, 'Start'),
          (r, { success: i }) => dm(this.node, r, i ? 'End' : 'Cancel')
        ),
        { useGlobalTarget: this.node.props.globalTapTarget }
      ))
  }
  unmount() {}
}
const rf = new WeakMap(),
  Md = new WeakMap(),
  A7 = (e) => {
    const t = rf.get(e.target)
    t && t(e)
  },
  k7 = (e) => {
    e.forEach(A7)
  }
function _7({ root: e, ...t }) {
  const n = e || document
  Md.has(n) || Md.set(n, {})
  const r = Md.get(n),
    i = JSON.stringify(t)
  return (r[i] || (r[i] = new IntersectionObserver(k7, { root: e, ...t })), r[i])
}
function I7(e, t, n) {
  const r = _7(t)
  return (
    rf.set(e, n),
    r.observe(e),
    () => {
      ;(rf.delete(e), r.unobserve(e))
    }
  )
}
const N7 = { some: 0, all: 1 }
class T7 extends Ui {
  constructor() {
    ;(super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1))
  }
  startObserver() {
    this.unmount()
    const { viewport: t = {} } = this.node.getProps(),
      { root: n, margin: r, amount: i = 'some', once: o } = t,
      c = {
        root: n ? n.current : void 0,
        rootMargin: r,
        threshold: typeof i == 'number' ? i : N7[i],
      },
      h = (f) => {
        const { isIntersecting: p } = f
        if (this.isInView === p || ((this.isInView = p), o && !p && this.hasEnteredView)) return
        ;(p && (this.hasEnteredView = !0),
          this.node.animationState && this.node.animationState.setActive('whileInView', p))
        const { onViewportEnter: y, onViewportLeave: w } = this.node.getProps(),
          x = p ? y : w
        x && x(f)
      }
    return I7(this.node.current, c, h)
  }
  mount() {
    this.startObserver()
  }
  update() {
    if (typeof IntersectionObserver > 'u') return
    const { props: t, prevProps: n } = this.node
    ;['amount', 'margin', 'root'].some(R7(t, n)) && this.startObserver()
  }
  unmount() {}
}
function R7({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n]
}
const M7 = {
    inView: { Feature: T7 },
    tap: { Feature: S7 },
    focus: { Feature: C7 },
    hover: { Feature: E7 },
  },
  P7 = { layout: { ProjectionNode: G6, MeasureLayout: F6 } },
  sf = { current: null },
  Y6 = { current: !1 }
function D7() {
  if (((Y6.current = !0), !!x0))
    if (window.matchMedia) {
      const e = window.matchMedia('(prefers-reduced-motion)'),
        t = () => (sf.current = e.matches)
      ;(e.addListener(t), t())
    } else sf.current = !1
}
const L7 = [...w6, Qt, Li],
  O7 = (e) => L7.find(y6(e)),
  fm = new WeakMap()
function B7(e, t, n) {
  for (const r in t) {
    const i = t[r],
      o = n[r]
    if (Jt(i)) e.addValue(r, i)
    else if (Jt(o)) e.addValue(r, El(i, { owner: e }))
    else if (o !== i)
      if (e.hasValue(r)) {
        const c = e.getValue(r)
        c.liveStyle === !0 ? c.jump(i) : c.hasAnimated || c.set(i)
      } else {
        const c = e.getStaticValue(r)
        e.addValue(r, El(c !== void 0 ? c : i, { owner: e }))
      }
  }
  for (const r in n) t[r] === void 0 && e.removeValue(r)
  return t
}
const pm = [
  'AnimationStart',
  'AnimationComplete',
  'Update',
  'BeforeLayoutMeasure',
  'LayoutMeasure',
  'LayoutAnimationStart',
  'LayoutAnimationComplete',
]
class F7 {
  scrapeMotionValuesFromProps(t, n, r) {
    return {}
  }
  constructor(
    {
      parent: t,
      props: n,
      presenceContext: r,
      reducedMotionConfig: i,
      blockInitialAnimation: o,
      visualState: c,
    },
    h = {}
  ) {
    ;((this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = Z0),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify('Update', this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const E = Ir.now()
        this.renderScheduledAt < E && ((this.renderScheduledAt = E), rt.render(this.render, !1, !0))
      }))
    const { latestValues: f, renderState: p, onUpdate: y } = c
    ;((this.onUpdate = y),
      (this.latestValues = f),
      (this.baseTarget = { ...f }),
      (this.initialValues = n.initial ? { ...f } : {}),
      (this.renderState = p),
      (this.parent = t),
      (this.props = n),
      (this.presenceContext = r),
      (this.depth = t ? t.depth + 1 : 0),
      (this.reducedMotionConfig = i),
      (this.options = h),
      (this.blockInitialAnimation = !!o),
      (this.isControllingVariants = mh(n)),
      (this.isVariantNode = kw(n)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(t && t.current)))
    const { willChange: w, ...x } = this.scrapeMotionValuesFromProps(n, {}, this)
    for (const E in x) {
      const S = x[E]
      f[E] !== void 0 && Jt(S) && S.set(f[E], !1)
    }
  }
  mount(t) {
    ;((this.current = t),
      fm.set(t, this),
      this.projection && !this.projection.instance && this.projection.mount(t),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((n, r) => this.bindToMotionValue(r, n)),
      Y6.current || D7(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === 'never'
          ? !1
          : this.reducedMotionConfig === 'always'
            ? !0
            : sf.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext))
  }
  unmount() {
    ;(fm.delete(this.current),
      this.projection && this.projection.unmount(),
      Di(this.notifyUpdate),
      Di(this.render),
      this.valueSubscriptions.forEach((t) => t()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this))
    for (const t in this.events) this.events[t].clear()
    for (const t in this.features) {
      const n = this.features[t]
      n && (n.unmount(), (n.isMounted = !1))
    }
    this.current = null
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)()
    const r = Is.has(t),
      i = n.on('change', (h) => {
        ;((this.latestValues[t] = h),
          this.props.onUpdate && rt.preRender(this.notifyUpdate),
          r && this.projection && (this.projection.isTransformDirty = !0))
      }),
      o = n.on('renderRequest', this.scheduleRender)
    let c
    ;(window.MotionCheckAppearSync && (c = window.MotionCheckAppearSync(this, t, n)),
      this.valueSubscriptions.set(t, () => {
        ;(i(), o(), c && c(), n.owner && n.stop())
      }))
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type
      ? 0
      : this.sortInstanceNodePosition(this.current, t.current)
  }
  updateFeatures() {
    let t = 'animation'
    for (t in jo) {
      const n = jo[t]
      if (!n) continue
      const { isEnabled: r, Feature: i } = n
      if (
        (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)),
        this.features[t])
      ) {
        const o = this.features[t]
        o.isMounted ? o.update() : (o.mount(), (o.isMounted = !0))
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props)
  }
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : xt()
  }
  getStaticValue(t) {
    return this.latestValues[t]
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n
  }
  update(t, n) {
    ;((t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = t),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = n))
    for (let r = 0; r < pm.length; r++) {
      const i = pm[r]
      this.propEventSubscriptions[i] &&
        (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i])
      const o = 'on' + i,
        c = t[o]
      c && (this.propEventSubscriptions[i] = this.on(i, c))
    }
    ;((this.prevMotionValues = B7(
      this,
      this.scrapeMotionValuesFromProps(t, this.prevProps, this),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue(),
      this.onUpdate && this.onUpdate(this))
  }
  getProps() {
    return this.props
  }
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0
  }
  getDefaultTransition() {
    return this.props.transition
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
  }
  addVariantChild(t) {
    const n = this.getClosestVariantNode()
    if (n) return (n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t))
  }
  addValue(t, n) {
    const r = this.values.get(t)
    n !== r &&
      (r && this.removeValue(t),
      this.bindToMotionValue(t, n),
      this.values.set(t, n),
      (this.latestValues[t] = n.get()))
  }
  removeValue(t) {
    this.values.delete(t)
    const n = this.valueSubscriptions.get(t)
    ;(n && (n(), this.valueSubscriptions.delete(t)),
      delete this.latestValues[t],
      this.removeValueFromRenderState(t, this.renderState))
  }
  hasValue(t) {
    return this.values.has(t)
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t]) return this.props.values[t]
    let r = this.values.get(t)
    return (
      r === void 0 &&
        n !== void 0 &&
        ((r = El(n === null ? void 0 : n, { owner: this })), this.addValue(t, r)),
      r
    )
  }
  readValue(t, n) {
    var r
    let i =
      this.latestValues[t] !== void 0 || !this.current
        ? this.latestValues[t]
        : (r = this.getBaseTargetFromProps(this.props, t)) !== null && r !== void 0
          ? r
          : this.readValueFromInstance(this.current, t, this.options)
    return (
      i != null &&
        (typeof i == 'string' && (g6(i) || o6(i))
          ? (i = parseFloat(i))
          : !O7(i) && Li.test(n) && (i = d6(t, n)),
        this.setBaseTarget(t, Jt(i) ? i.get() : i)),
      Jt(i) ? i.get() : i
    )
  }
  setBaseTarget(t, n) {
    this.baseTarget[t] = n
  }
  getBaseTarget(t) {
    var n
    const { initial: r } = this.props
    let i
    if (typeof r == 'string' || typeof r == 'object') {
      const c = I0(
        this.props,
        r,
        (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom
      )
      c && (i = c[t])
    }
    if (r && i !== void 0) return i
    const o = this.getBaseTargetFromProps(this.props, t)
    return o !== void 0 && !Jt(o)
      ? o
      : this.initialValues[t] !== void 0 && i === void 0
        ? void 0
        : this.baseTarget[t]
  }
  on(t, n) {
    return (this.events[t] || (this.events[t] = new W0()), this.events[t].add(n))
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n)
  }
}
class Z6 extends F7 {
  constructor() {
    ;(super(...arguments), (this.KeyframeResolver = b6))
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    ;(delete n[t], delete r[t])
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription)
    const { children: t } = this.props
    Jt(t) &&
      (this.childSubscription = t.on('change', (n) => {
        this.current && (this.current.textContent = `${n}`)
      }))
  }
}
function j7(e) {
  return window.getComputedStyle(e)
}
class V7 extends Z6 {
  constructor() {
    ;(super(...arguments), (this.type = 'html'), (this.renderInstance = Lw))
  }
  readValueFromInstance(t, n) {
    if (Is.has(n)) {
      const r = Y0(n)
      return (r && r.default) || 0
    } else {
      const r = j7(t),
        i = (Mw(n) ? r.getPropertyValue(n) : r[n]) || 0
      return typeof i == 'string' ? i.trim() : i
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return O6(t, n)
  }
  build(t, n, r) {
    R0(t, n, r.transformTemplate)
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return L0(t, n, r)
  }
}
class U7 extends Z6 {
  constructor() {
    ;(super(...arguments),
      (this.type = 'svg'),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = xt))
  }
  getBaseTargetFromProps(t, n) {
    return t[n]
  }
  readValueFromInstance(t, n) {
    if (Is.has(n)) {
      const r = Y0(n)
      return (r && r.default) || 0
    }
    return ((n = Ow.has(n) ? n : A0(n)), t.getAttribute(n))
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return jw(t, n, r)
  }
  build(t, n, r) {
    M0(t, n, this.isSVGTag, r.transformTemplate)
  }
  renderInstance(t, n, r, i) {
    Bw(t, n, r, i)
  }
  mount(t) {
    ;((this.isSVGTag = D0(t.tagName)), super.mount(t))
  }
}
const W7 = (e, t) => (_0(e) ? new U7(t) : new V7(t, { allowProjection: e !== X.Fragment })),
  z7 = p5({ ...dA, ...M7, ...x7, ...P7 }, W7),
  qn = NC(z7)
var H7 = X.createContext({ color: 'currentColor', size: '1em', weight: 'regular', mirrored: !1 }),
  Cn = function (e, t, n) {
    var r = n.get(e)
    return r
      ? r(t)
      : (console.error(
          'Unsupported icon weight. Choose from "thin", "light", "regular", "bold", "fill", or "duotone".'
        ),
        null)
  }
function gm(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++) ((i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i]))
  return n
}
var cn = X.forwardRef(function (e, t) {
  var n = e.alt,
    r = e.color,
    i = e.size,
    o = e.weight,
    c = e.mirrored,
    h = e.children,
    f = e.renderPath,
    p = gm(e, ['alt', 'color', 'size', 'weight', 'mirrored', 'children', 'renderPath']),
    y = X.useContext(H7),
    w = y.color,
    x = w === void 0 ? 'currentColor' : w,
    E = y.size,
    S = y.weight,
    k = S === void 0 ? 'regular' : S,
    P = y.mirrored,
    I = P === void 0 ? !1 : P,
    R = gm(y, ['color', 'size', 'weight', 'mirrored'])
  return A.createElement(
    'svg',
    Object.assign(
      {
        ref: t,
        xmlns: 'http://www.w3.org/2000/svg',
        width: i ?? E,
        height: i ?? E,
        fill: r ?? x,
        viewBox: '0 0 256 256',
        transform: c || I ? 'scale(-1, 1)' : void 0,
      },
      R,
      p
    ),
    !!n && A.createElement('title', null, n),
    h,
    A.createElement('rect', { width: '256', height: '256', fill: 'none' }),
    f(o ?? k, r ?? x)
  )
})
cn.displayName = 'IconBase'
var Ns = new Map()
Ns.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Ns.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', { d: 'M128,128,44.9,176h-.1A96.1,96.1,0,0,1,128,32Z', opacity: '0.2' }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Ns.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M218.3,76.4a.8.8,0,0,1-.2-.4l-.4-.5a104,104,0,0,0-180,104.1l.2.4.3.4a104,104,0,0,0,180.1-104Zm-18.4.9L136,114.1V40.4A88.2,88.2,0,0,1,199.9,77.3ZM128,216a88,88,0,0,1-71.9-37.3L207.9,91.1A88,88,0,0,1,128,216Z',
    })
  )
})
Ns.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Ns.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Ns.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var X7 = function (e, t) {
    return Cn(e, t, Ns)
  },
  bh = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: X7 }))
  })
bh.displayName = 'ChartPie'
var Ts = new Map()
Ts.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M184.6,128H224a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H71.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '16' })
  )
})
Ts.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '24',
      y: '128',
      width: '208',
      height: '80',
      rx: '8',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M176,128h48a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H80',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '12' })
  )
})
Ts.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M74.3,85.7A8.1,8.1,0,0,1,85.7,74.3L120,108.7V24a8,8,0,0,1,16,0v84.7l34.3-34.4a8.1,8.1,0,0,1,11.4,11.4l-48,48a8.2,8.2,0,0,1-11.4,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a3.6,3.6,0,0,1,2.8,1.2L111,145a24.1,24.1,0,0,0,34,0l23.8-23.8a3.6,3.6,0,0,1,2.8-1.2H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z',
    })
  )
})
Ts.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M176,128h48a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H80',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '10' })
  )
})
Ts.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M176,128h48a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H80',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '8' })
  )
})
Ts.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M176,128h48a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H80',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '12' })
  )
})
var G7 = function (e, t) {
    return Cn(e, t, Ts)
  },
  K6 = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: G7 }))
  })
K6.displayName = 'Download'
var Rs = new Map()
Rs.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Rs.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Zm0,112a40,40,0,1,1,40-40A40,40,0,0,1,128,168Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Rs.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M247.3,124.8c-.3-.8-8.8-19.6-27.6-38.5C194.6,61.3,162.9,48,128,48S61.4,61.3,36.3,86.3C17.5,105.2,9,124,8.7,124.8a7.9,7.9,0,0,0,0,6.4c.3.8,8.8,19.6,27.6,38.5C61.4,194.7,93.1,208,128,208s66.6-13.3,91.7-38.3c18.8-18.9,27.3-37.7,27.6-38.5A7.9,7.9,0,0,0,247.3,124.8ZM128,92a36,36,0,1,1-36,36A36,36,0,0,1,128,92Z',
    })
  )
})
Rs.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Rs.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Rs.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var Y7 = function (e, t) {
    return Cn(e, t, Rs)
  },
  q6 = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: Y7 }))
  })
q6.displayName = 'Eye'
var Ms = new Map()
Ms.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M214.4,163.6C232.1,145.7,240,128,240,128S208,56,128,56c-3.8,0-7.4.2-11,.5',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Ms.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Zm0,112a40,40,0,1,1,40-40A40,40,0,0,1,128,168Z',
      opacity: '0.2',
    }),
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M154.9,157.6A39.6,39.6,0,0,1,128,168a40,40,0,0,1-26.9-69.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M208.6,169.1C230.4,149.6,240,128,240,128S208,56,128,56a123.9,123.9,0,0,0-20.7,1.7',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M135.5,88.7a39.9,39.9,0,0,1,32.3,35.5',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Ms.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M247.3,124.8c-.3-.8-8.8-19.6-27.6-38.5C194.6,61.3,162.9,48,128,48a132.4,132.4,0,0,0-22,1.8,8.1,8.1,0,0,0-4.6,13.3L202.7,174.5a8,8,0,0,0,5.9,2.6,8.6,8.6,0,0,0,5.4-2c22.8-20.5,32.9-42.9,33.3-43.8A8.2,8.2,0,0,0,247.3,124.8Z',
    }),
    A.createElement('path', {
      d: 'M53.9,34.6A8,8,0,0,0,42.1,45.4L61.3,66.5C25,88.8,9.4,123.2,8.7,124.8a8.2,8.2,0,0,0,0,6.5c.3.7,8.8,19.5,27.6,38.4C61.4,194.7,93.1,208,128,208a126.9,126.9,0,0,0,52.1-10.8l22,24.2A8,8,0,0,0,208,224a8.2,8.2,0,0,0,5.4-2.1,7.9,7.9,0,0,0,.5-11.3ZM128,164a36,36,0,0,1-29.5-56.6l47.2,51.9A35.4,35.4,0,0,1,128,164Z',
    })
  )
})
Ms.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M154.9,157.6A39.6,39.6,0,0,1,128,168a40,40,0,0,1-26.9-69.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M208.6,169.1C230.4,149.6,240,128,240,128S208,56,128,56a123.9,123.9,0,0,0-20.7,1.7',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M135.5,88.7a39.9,39.9,0,0,1,32.3,35.5',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Ms.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M154.9,157.6A39.6,39.6,0,0,1,128,168a40,40,0,0,1-26.9-69.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M208.6,169.1C230.4,149.6,240,128,240,128S208,56,128,56a123.9,123.9,0,0,0-20.7,1.7',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M135.5,88.7a39.9,39.9,0,0,1,32.3,35.5',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Ms.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M154.9,157.6A39.6,39.6,0,0,1,128,168a40,40,0,0,1-26.9-69.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M208.6,169.1C230.4,149.6,240,128,240,128S208,56,128,56a123.9,123.9,0,0,0-20.7,1.7',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M135.5,88.7a39.9,39.9,0,0,1,32.3,35.5',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var Z7 = function (e, t) {
    return Cn(e, t, Ms)
  },
  of = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: Z7 }))
  })
of.displayName = 'EyeSlash'
var Ps = new Map()
Ps.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Ps.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Ps.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M240,160v24a16,16,0,0,1-16,16H115.5a4,4,0,0,1-3.2-6.4L178,108a8.2,8.2,0,0,0-1.1-11.3A7.9,7.9,0,0,0,165.5,98L88.4,198.4a3.8,3.8,0,0,1-3.1,1.6H32a16,16,0,0,1-16-16V161.1a116.1,116.1,0,0,1,2.2-22.2L40.9,145l2.1.2a8,8,0,0,0,7.8-6.2,8.1,8.1,0,0,0-6-9.6l-22.4-6C37,82,74.9,51.5,120,48.3V71.7a8.2,8.2,0,0,0,7.5,8.3,8,8,0,0,0,8.5-8V48.3a111.5,111.5,0,0,1,71.1,32.4,112.7,112.7,0,0,1,26.8,42.6l-22.7,6.1a8.1,8.1,0,0,0-6,9.6,8,8,0,0,0,7.8,6.2l2.1-.2,22.9-6.2A114.5,114.5,0,0,1,240,160Z',
    })
  )
})
Ps.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Ps.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Ps.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var K7 = function (e, t) {
    return Cn(e, t, Ps)
  },
  $0 = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: K7 }))
  })
$0.displayName = 'Gauge'
var Ds = new Map()
Ds.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '60',
      height: '60',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('rect', {
      x: '48',
      y: '148',
      width: '60',
      height: '60',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('rect', {
      x: '148',
      y: '48',
      width: '60',
      height: '60',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '148',
      y1: '148',
      x2: '148',
      y2: '172',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('polyline', {
      points: '148 208 184 208 184 148',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '184',
      y1: '164',
      x2: '208',
      y2: '164',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Ds.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      opacity: '0.2',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      opacity: '0.2',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      opacity: '0.2',
    }),
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '144',
      y1: '144',
      x2: '144',
      y2: '176',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '144 208 176 208 176 144',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '160',
      x2: '208',
      y2: '160',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '208',
      y1: '192',
      x2: '208',
      y2: '208',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Ds.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', { x: '40', y: '40', width: '80', height: '80', rx: '16' }),
    A.createElement('rect', { x: '40', y: '136', width: '80', height: '80', rx: '16' }),
    A.createElement('rect', { x: '136', y: '40', width: '80', height: '80', rx: '16' }),
    A.createElement('path', {
      d: 'M144,184a8,8,0,0,0,8-8V144a8,8,0,0,0-16,0v32A8,8,0,0,0,144,184Z',
    }),
    A.createElement('path', {
      d: 'M208,152H184v-8a8,8,0,0,0-16,0v56H144a8,8,0,0,0,0,16h32a8,8,0,0,0,8-8V168h24a8,8,0,0,0,0-16Z',
    }),
    A.createElement('path', {
      d: 'M208,184a8,8,0,0,0-8,8v16a8,8,0,0,0,16,0V192A8,8,0,0,0,208,184Z',
    })
  )
})
Ds.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '144',
      y1: '144',
      x2: '144',
      y2: '176',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('polyline', {
      points: '144 208 176 208 176 144',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '160',
      x2: '208',
      y2: '160',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '208',
      y1: '192',
      x2: '208',
      y2: '208',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Ds.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '144',
      y1: '144',
      x2: '144',
      y2: '176',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('polyline', {
      points: '144 208 176 208 176 144',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '160',
      x2: '208',
      y2: '160',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '208',
      y1: '192',
      x2: '208',
      y2: '208',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Ds.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '144',
      y1: '144',
      x2: '144',
      y2: '176',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '144 208 176 208 176 144',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '160',
      x2: '208',
      y2: '160',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '208',
      y1: '192',
      x2: '208',
      y2: '208',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var q7 = function (e, t) {
    return Cn(e, t, Ds)
  },
  Vl = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: q7 }))
  })
Vl.displayName = 'QrCode'
var Ls = new Map()
Ls.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Ls.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Ls.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M208,40H48A16,16,0,0,0,32,56v58.7c0,89.4,75.8,119.1,91,124.1a16,16,0,0,0,10,0c15.2-5,91-34.7,91-124.1V56A16,16,0,0,0,208,40Z',
    })
  )
})
Ls.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Ls.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Ls.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var Q7 = function (e, t) {
    return Cn(e, t, Ls)
  },
  xs = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: Q7 }))
  })
xs.displayName = 'Shield'
var Os = new Map()
Os.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Os.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Os.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M208,40H48A16,16,0,0,0,32,56v58.7c0,89.4,75.8,119.1,91,124.1a16,16,0,0,0,10,0c15.2-5,91-34.7,91-124.1V56A16,16,0,0,0,208,40Zm-30.5,69.8-58.6,56a8.1,8.1,0,0,1-5.6,2.2,7.9,7.9,0,0,1-5.5-2.2l-29.3-28a8,8,0,1,1,11-11.6l23.8,22.7,53.2-50.7a8,8,0,0,1,11,11.6Z',
    })
  )
})
Os.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Os.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Os.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var $7 = function (e, t) {
    return Cn(e, t, Os)
  },
  Q6 = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: $7 }))
  })
Q6.displayName = 'ShieldCheck'
var Bs = new Map()
Bs.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Bs.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Bs.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M208.9,144a15.8,15.8,0,0,1-10.5,15l-52.2,19.2L127,230.4a16,16,0,0,1-30,0L77.8,178.2,25.6,159a16,16,0,0,1,0-30l52.2-19.2L97,57.6a16,16,0,0,1,30,0l19.2,52.2L198.4,129A15.8,15.8,0,0,1,208.9,144ZM152,48h16V64a8,8,0,0,0,16,0V48h16a8,8,0,0,0,0-16H184V16a8,8,0,0,0-16,0V32H152a8,8,0,0,0,0,16Zm88,32h-8V72a8,8,0,0,0-16,0v8h-8a8,8,0,0,0,0,16h8v8a8,8,0,0,0,16,0V96h8a8,8,0,0,0,0-16Z',
    })
  )
})
Bs.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Bs.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Bs.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var J7 = function (e, t) {
    return Cn(e, t, Bs)
  },
  Qo = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: J7 }))
  })
Qo.displayName = 'Sparkle'
var Fs = new Map()
Fs.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,0,67.8,47.1,47.1,0,0,0,13.2-24.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1A96.1,96.1,0,1,0,218,94.6',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Fs.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', { cx: '128', cy: '128', r: '48', opacity: '0.2' }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1a96.2,96.2,0,1,0,18.7,26.5',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,14,31.2',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Fs.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M211.2,79.4a8,8,0,0,0-3.8,10.7,88,88,0,1,1-23.1-29.7L161.5,83.2a56,56,0,0,0-73.1,84.4h0a56,56,0,0,0,95.5-42.8,7.9,7.9,0,0,0-8.4-7.5,8,8,0,0,0-7.6,8.4,40,40,0,0,1-62,35.7l24-24,37.7-37.7h0l62.1-62a8.1,8.1,0,0,0-11.4-11.4L195.7,49A104,104,0,0,0,54.5,54.5a103.8,103.8,0,0,0,0,147,103.8,103.8,0,0,0,147,0A104,104,0,0,0,221.9,83.2,8,8,0,0,0,211.2,79.4Z',
    })
  )
})
Fs.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1a96.2,96.2,0,1,0,18.7,26.5',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,14,31.2',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Fs.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1a96.2,96.2,0,1,0,18.7,26.5',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,14,31.2',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Fs.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1a96.2,96.2,0,1,0,18.7,26.5',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,14,31.2',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var ek = function (e, t) {
    return Cn(e, t, Fs)
  },
  J0 = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: ek }))
  })
J0.displayName = 'Target'
var js = new Map()
js.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '140',
      x2: '161.9',
      y2: '106.1',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '12',
      x2: '152',
      y2: '12',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
js.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', { cx: '128', cy: '128', r: '88', opacity: '0.2' }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '88',
      fill: 'none',
      stroke: e,
      strokeMiterlimit: '10',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '167.6',
      y2: '88.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '8',
      x2: '152',
      y2: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
js.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', { d: 'M104,16h48a8,8,0,0,0,0-16H104a8,8,0,0,0,0,16Z' }),
    A.createElement('path', {
      d: 'M128,32a96,96,0,1,0,96,96A96.2,96.2,0,0,0,128,32Zm45.3,62.1-39.6,39.6a8.2,8.2,0,0,1-11.4,0,8.1,8.1,0,0,1,0-11.4l39.6-39.6a8.1,8.1,0,1,1,11.4,11.4Z',
    })
  )
})
js.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '167.6',
      y2: '88.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '8',
      x2: '152',
      y2: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
js.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '88',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '167.6',
      y2: '88.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '8',
      x2: '152',
      y2: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
js.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '88',
      fill: 'none',
      stroke: e,
      strokeMiterlimit: '10',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '167.6',
      y2: '88.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '8',
      x2: '152',
      y2: '8',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var tk = function (e, t) {
    return Cn(e, t, js)
  },
  $6 = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: tk }))
  })
$6.displayName = 'Timer'
var Vs = new Map()
Vs.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Vs.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Vs.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M240,56v64a8,8,0,0,1-4.9,7.4,8.5,8.5,0,0,1-3.1.6,8.3,8.3,0,0,1-5.7-2.3L200,99.3l-58.3,58.4a8.1,8.1,0,0,1-11.4,0L96,123.3,29.7,189.7A8.3,8.3,0,0,1,24,192a8.5,8.5,0,0,1-5.7-2.3,8.1,8.1,0,0,1,0-11.4l72-72a8.1,8.1,0,0,1,11.4,0L136,140.7,188.7,88,162.3,61.7a8.4,8.4,0,0,1-1.7-8.8A8.1,8.1,0,0,1,168,48h64A8,8,0,0,1,240,56Z',
    })
  )
})
Vs.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Vs.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Vs.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var nk = function (e, t) {
    return Cn(e, t, Vs)
  },
  ep = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: nk }))
  })
ep.displayName = 'TrendUp'
var Us = new Map()
Us.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M204.5,116.6A60.1,60.1,0,0,1,244,140',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M167.1,70.2A32,32,0,1,1,204,115',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M52,115A32,32,0,1,1,88.9,70.2',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M12,140a60.1,60.1,0,0,1,39.5-23.4',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Us.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', { cx: '128', cy: '140', r: '40', opacity: '0.2' }),
    A.createElement('circle', { cx: '60', cy: '84', r: '32', opacity: '0.2' }),
    A.createElement('circle', { cx: '196', cy: '84', r: '32', opacity: '0.2' }),
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M196,116a59.8,59.8,0,0,1,48,24',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M12,140a59.8,59.8,0,0,1,48-24',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M60,116A32,32,0,1,1,91.4,78',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M164.6,78A32,32,0,1,1,196,116',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Us.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M64,140a7.9,7.9,0,0,1-8,8H12a8.2,8.2,0,0,1-7.2-4.4,8.2,8.2,0,0,1,.8-8.4A67.8,67.8,0,0,1,33,113.5a40,40,0,1,1,66.3-37,8.1,8.1,0,0,1-3.8,8.4,64.3,64.3,0,0,0-27.8,33.8A61.6,61.6,0,0,0,64,140Zm186.4-4.8A67.8,67.8,0,0,0,223,113.5a40,40,0,1,0-66.3-37,8.1,8.1,0,0,0,3.8,8.4,64,64,0,0,1,27.8,33.8A61.6,61.6,0,0,1,192,140a7.9,7.9,0,0,0,8,8h44a8,8,0,0,0,6.4-12.8Zm-93.2,42.9a48,48,0,1,0-58.4,0,72.1,72.1,0,0,0-35.6,34.4,7.8,7.8,0,0,0,.5,7.7,7.8,7.8,0,0,0,6.7,3.8H185.6a7.8,7.8,0,0,0,6.7-3.8,7.8,7.8,0,0,0,.5-7.7A72.1,72.1,0,0,0,157.2,178.1Z',
    })
  )
})
Us.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M196,116a59.8,59.8,0,0,1,48,24',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M12,140a59.8,59.8,0,0,1,48-24',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M60,116A32,32,0,1,1,91.4,78',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M164.6,78A32,32,0,1,1,196,116',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Us.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M196,116a59.8,59.8,0,0,1,48,24',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M12,140a59.8,59.8,0,0,1,48-24',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M60,116A32,32,0,1,1,91.4,78',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M164.6,78A32,32,0,1,1,196,116',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Us.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M196,116a59.8,59.8,0,0,1,48,24',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M12,140a59.8,59.8,0,0,1,48-24',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M60,116A32,32,0,1,1,91.4,78',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M164.6,78A32,32,0,1,1,196,116',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var rk = function (e, t) {
    return Cn(e, t, Us)
  },
  J6 = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: rk }))
  })
J6.displayName = 'UsersThree'
var Ws = new Map()
Ws.set('bold', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '104',
      x2: '128',
      y2: '136',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('circle', { cx: '128', cy: '176', r: '16' })
  )
})
Ws.set('duotone', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      opacity: '0.2',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '112',
      x2: '128',
      y2: '144',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', { cx: '128', cy: '180', r: '12' })
  )
})
Ws.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M236.7,188,148.8,36a24,24,0,0,0-41.6,0h0L19.3,188A23.9,23.9,0,0,0,40,224H216a23.9,23.9,0,0,0,20.7-36ZM120,104a8,8,0,0,1,16,0v40a8,8,0,0,1-16,0Zm8,88a12,12,0,1,1,12-12A12,12,0,0,1,128,192Z',
    })
  )
})
Ws.set('light', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '104',
      x2: '128',
      y2: '144',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('circle', { cx: '128', cy: '180', r: '10' })
  )
})
Ws.set('thin', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '104',
      x2: '128',
      y2: '144',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('circle', { cx: '128', cy: '180', r: '8' })
  )
})
Ws.set('regular', function (e) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '104',
      x2: '128',
      y2: '144',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: e,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', { cx: '128', cy: '180', r: '12' })
  )
})
var ik = function (e, t) {
    return Cn(e, t, Ws)
  },
  Qc = X.forwardRef(function (e, t) {
    return A.createElement(cn, Object.assign({ ref: t }, e, { renderPath: ik }))
  })
Qc.displayName = 'Warning'
const sk = () =>
    N.jsxs('div', {
      className: 'mx-auto flex w-full max-w-6xl flex-col gap-16 px-6 py-16',
      children: [
        N.jsxs('header', {
          className: 'grid gap-8 lg:grid-cols-[1.1fr_0.9fr] lg:items-center',
          children: [
            N.jsxs('div', {
              children: [
                N.jsx(qn.p, {
                  initial: { opacity: 0, y: 8 },
                  animate: { opacity: 1, y: 0 },
                  className: 'text-sm uppercase tracking-[0.3em] text-emerald-200',
                  children: 'Vibe Prism',
                }),
                N.jsx(qn.h1, {
                  initial: { opacity: 0, y: 10 },
                  animate: { opacity: 1, y: 0 },
                  transition: { delay: 0.1 },
                  className: 'mt-4 text-4xl font-semibold text-slate-50 md:text-5xl',
                  children: 'A full-scale signal mirror for the vibe you bring into every room.',
                }),
                N.jsx(qn.p, {
                  initial: { opacity: 0, y: 10 },
                  animate: { opacity: 1, y: 0 },
                  transition: { delay: 0.2 },
                  className: 'mt-4 text-base text-slate-300',
                  children:
                    'Nexus Who is the flagship minisite for Vibe Prism. Answer 32 calibrated questions to reveal your social style, unlock momentum insights, and generate a private token you can restore on demand.',
                }),
                N.jsxs('div', {
                  className: 'mt-8 flex flex-wrap gap-3',
                  children: [
                    N.jsxs(er, {
                      to: '/quiz',
                      className: 'button-primary',
                      children: [N.jsx(Qo, { size: 20 }), 'Start the quiz'],
                    }),
                    N.jsxs(er, {
                      to: '/restore',
                      className: 'button-secondary',
                      children: [N.jsx(xs, { size: 20 }), 'Restore a profile'],
                    }),
                  ],
                }),
                N.jsx('div', {
                  className: 'mt-8 grid gap-4 sm:grid-cols-3',
                  children: [
                    { label: 'Questions', value: '32' },
                    { label: 'Persona Bands', value: '3' },
                    { label: 'Signals Measured', value: '4' },
                  ].map((e) =>
                    N.jsxs(
                      'div',
                      {
                        className: 'stat-card',
                        children: [
                          N.jsx('p', {
                            className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                            children: e.label,
                          }),
                          N.jsx('p', {
                            className: 'mt-2 text-2xl font-semibold text-slate-50',
                            children: e.value,
                          }),
                        ],
                      },
                      e.label
                    )
                  ),
                }),
              ],
            }),
            N.jsx('div', {
              className: 'glass-panel p-6',
              children: N.jsxs('div', {
                className: 'grid gap-4',
                children: [
                  N.jsxs('div', {
                    className: 'flex items-start gap-3',
                    children: [
                      N.jsx(bh, { size: 24, className: 'text-emerald-300' }),
                      N.jsxs('div', {
                        children: [
                          N.jsx('h3', {
                            className: 'text-lg font-semibold',
                            children: 'Balanced insights',
                          }),
                          N.jsx('p', {
                            className: 'text-sm text-slate-400',
                            children:
                              'See a radar snapshot of your vibe strengths without heavy jargon.',
                          }),
                        ],
                      }),
                    ],
                  }),
                  N.jsxs('div', {
                    className: 'flex items-start gap-3',
                    children: [
                      N.jsx($0, { size: 24, className: 'text-emerald-300' }),
                      N.jsxs('div', {
                        children: [
                          N.jsx('h3', {
                            className: 'text-lg font-semibold',
                            children: 'Momentum score',
                          }),
                          N.jsx('p', {
                            className: 'text-sm text-slate-400',
                            children: 'Track how your energy reads to others in social settings.',
                          }),
                        ],
                      }),
                    ],
                  }),
                  N.jsxs('div', {
                    className: 'flex items-start gap-3',
                    children: [
                      N.jsx(Vl, { size: 24, className: 'text-emerald-300' }),
                      N.jsxs('div', {
                        children: [
                          N.jsx('h3', {
                            className: 'text-lg font-semibold',
                            children: 'Portable profile',
                          }),
                          N.jsx('p', {
                            className: 'text-sm text-slate-400',
                            children:
                              'Save your results as a private QR token for later restoration.',
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            }),
          ],
        }),
        N.jsxs('section', {
          className: 'grid gap-6 lg:grid-cols-[1.1fr_0.9fr]',
          children: [
            N.jsxs('div', {
              children: [
                N.jsx('p', { className: 'section-title', children: 'How the signal gets built' }),
                N.jsx('p', {
                  className: 'section-lead',
                  children:
                    'Each section of the quiz is engineered to surface micro-decisions, composure, and directional energy.',
                }),
                N.jsx('div', {
                  className: 'mt-6 grid gap-4 md:grid-cols-3',
                  children: [
                    {
                      title: 'Pulse',
                      copy: 'Time-based responses capture your instinctive tempo.',
                    },
                    { title: 'Balance', copy: 'Reversed items measure stability under tension.' },
                    { title: 'Integrity', copy: 'Built-in flags detect masking and halo bias.' },
                  ].map((e) =>
                    N.jsxs(
                      'div',
                      {
                        className: 'glass-panel p-5',
                        children: [
                          N.jsx('h3', {
                            className: 'text-lg font-semibold text-slate-50',
                            children: e.title,
                          }),
                          N.jsx('p', {
                            className: 'mt-2 text-sm text-slate-400',
                            children: e.copy,
                          }),
                        ],
                      },
                      e.title
                    )
                  ),
                }),
              ],
            }),
            N.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                N.jsx('p', {
                  className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                  children: 'Signal Spectrum',
                }),
                N.jsx('h3', {
                  className: 'mt-2 text-xl font-semibold text-slate-50',
                  children: 'Four traits, one profile.',
                }),
                N.jsx('p', {
                  className: 'mt-3 text-sm text-slate-400',
                  children:
                    'Presence, Strategy, Composure, and Guidance form the core of the Vibe Prism scoring engine.',
                }),
                N.jsx('div', {
                  className: 'mt-6 space-y-4',
                  children: [
                    { label: 'Presence', icon: J6, copy: 'How visible and central you feel.' },
                    { label: 'Strategy', icon: J0, copy: 'How intentional your moves are.' },
                    { label: 'Composure', icon: xs, copy: 'How calm you stay under pressure.' },
                    { label: 'Guidance', icon: ep, copy: 'How you direct group energy.' },
                  ].map((e) =>
                    N.jsxs(
                      'div',
                      {
                        className: 'flex items-start gap-3',
                        children: [
                          N.jsx(e.icon, { size: 20, className: 'text-emerald-300' }),
                          N.jsxs('div', {
                            children: [
                              N.jsx('p', {
                                className: 'text-sm font-semibold text-slate-100',
                                children: e.label,
                              }),
                              N.jsx('p', { className: 'text-xs text-slate-400', children: e.copy }),
                            ],
                          }),
                        ],
                      },
                      e.label
                    )
                  ),
                }),
              ],
            }),
          ],
        }),
        N.jsxs('section', {
          children: [
            N.jsx('p', { className: 'section-title', children: 'What you unlock' }),
            N.jsx('p', {
              className: 'section-lead',
              children:
                'The minisite is designed as a full-scale profile hub you can share with your team or keep private.',
            }),
            N.jsx('div', {
              className: 'mt-6 grid gap-6 md:grid-cols-2',
              children: [
                {
                  title: 'Social Flow',
                  copy: 'Discover the pace you set when you walk into a room.',
                },
                {
                  title: 'Connection Style',
                  copy: 'See how you naturally build rapport and alignment.',
                },
                {
                  title: 'Decision Energy',
                  copy: 'Track how you balance outcomes, feelings, and follow-through.',
                },
                {
                  title: 'Influence Pattern',
                  copy: 'Understand the way you guide group momentum.',
                },
              ].map((e) =>
                N.jsxs(
                  qn.div,
                  {
                    initial: { opacity: 0, y: 12 },
                    whileInView: { opacity: 1, y: 0 },
                    viewport: { once: !0 },
                    className: 'glass-panel p-5',
                    children: [
                      N.jsx('h3', {
                        className: 'text-lg font-semibold text-slate-50',
                        children: e.title,
                      }),
                      N.jsx('p', { className: 'mt-2 text-sm text-slate-400', children: e.copy }),
                    ],
                  },
                  e.title
                )
              ),
            }),
          ],
        }),
        N.jsxs('section', {
          className: 'grid gap-6 lg:grid-cols-[1.1fr_0.9fr]',
          children: [
            N.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                N.jsx('p', {
                  className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                  children: 'Who it is for',
                }),
                N.jsx('h3', {
                  className: 'mt-2 text-xl font-semibold',
                  children: 'Designed for focused leaders.',
                }),
                N.jsx('ul', {
                  className: 'mt-4 space-y-3 text-sm text-slate-300',
                  children: [
                    'Founders who want to calibrate presence before a pitch.',
                    'Teams decoding momentum and friction in collaboration.',
                    'Creators tracking how their energy lands across audiences.',
                  ].map((e) => N.jsx('li', { className: 'list-item', children: e }, e)),
                }),
              ],
            }),
            N.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                N.jsx('p', {
                  className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                  children: 'Mini FAQ',
                }),
                N.jsxs('div', {
                  className: 'mt-4 space-y-4 text-sm text-slate-300',
                  children: [
                    N.jsxs('div', {
                      children: [
                        N.jsx('p', {
                          className: 'font-semibold text-slate-100',
                          children: 'Is this stored in the cloud?',
                        }),
                        N.jsx('p', {
                          className: 'mt-1 text-slate-400',
                          children:
                            'No. Tokens are stored locally in your browser and encrypted in transit.',
                        }),
                      ],
                    }),
                    N.jsxs('div', {
                      children: [
                        N.jsx('p', {
                          className: 'font-semibold text-slate-100',
                          children: 'Can I retake the quiz?',
                        }),
                        N.jsx('p', {
                          className: 'mt-1 text-slate-400',
                          children:
                            'One session per pass. Use the restore tool to revisit your profile any time.',
                        }),
                      ],
                    }),
                    N.jsxs('div', {
                      children: [
                        N.jsx('p', {
                          className: 'font-semibold text-slate-100',
                          children: 'How long does it take?',
                        }),
                        N.jsx('p', {
                          className: 'mt-1 text-slate-400',
                          children: 'Less than 6 minutes for most people.',
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
          ],
        }),
      ],
    }),
  af = [
    {
      id: 1,
      text: 'I enjoy being the person others look to for direction.',
      trait: 'N',
      rationale: 'Captures comfort with visibility and influence within groups.',
    },
    {
      id: 2,
      text: 'I plan my social moves with long-term outcomes in mind.',
      trait: 'M',
      rationale: 'Checks for strategy-driven social navigation.',
    },
    {
      id: 3,
      text: 'I can stay calm when others get emotional around me.',
      trait: 'P',
      rationale: 'Measures emotional detachment under pressure.',
    },
    {
      id: 4,
      text: 'I pay attention to how people can be guided toward a goal.',
      trait: 'MD',
      rationale: 'Tracks comfort with directing group dynamics.',
    },
    {
      id: 5,
      text: 'It feels natural to set the tone in a room.',
      trait: 'N',
      rationale: 'Assesses ease with status-setting behaviors.',
    },
    {
      id: 6,
      text: 'I keep a quiet mental map of other peoples priorities.',
      trait: 'M',
      rationale: 'Tests awareness of leverage points.',
    },
    {
      id: 7,
      text: 'I rarely feel guilty after making a hard decision.',
      trait: 'P',
      rationale: 'Signals low emotional friction after decisive actions.',
    },
    {
      id: 8,
      text: 'When needed, I can mirror someones style to build rapport.',
      trait: 'MD',
      rationale: 'Tracks adaptive influence tactics.',
    },
    {
      id: 9,
      text: 'Compliments feel better when they are public.',
      trait: 'N',
      rationale: 'Evaluates preference for public recognition.',
    },
    {
      id: 10,
      text: 'I hold back information until the timing feels right.',
      trait: 'M',
      rationale: 'Measures calculated disclosure behavior.',
    },
    {
      id: 11,
      text: 'Rules are flexible if the outcome is important enough.',
      trait: 'P',
      safetyTrigger: !0,
      rationale: 'Checks willingness to bend boundaries under pressure.',
    },
    {
      id: 12,
      text: 'I can separate feelings from outcomes with ease.',
      trait: 'P',
      rationale: 'Tests emotional compartmentalization.',
    },
    {
      id: 13,
      text: 'I prefer to be the person others consult before acting.',
      trait: 'N',
      rationale: 'Assesses influence-seeking behavior.',
    },
    {
      id: 14,
      text: 'I notice the social leverage in almost every situation.',
      trait: 'M',
      rationale: 'Tracks analytical social awareness.',
    },
    {
      id: 15,
      text: 'I am comfortable using pressure to keep things on track.',
      trait: 'MD',
      safetyTrigger: !0,
      rationale: 'Identifies comfort with forceful coordination.',
    },
    {
      id: 16,
      text: 'People describe me as intense.',
      trait: 'P',
      rationale: 'Captures intensity linked to bold decision making.',
    },
    {
      id: 17,
      text: 'I carefully manage the image people have of me.',
      trait: 'N',
      rationale: 'Tests image management orientation.',
    },
    {
      id: 18,
      text: 'I can persuade someone even when they disagree.',
      trait: 'MD',
      safetyTrigger: !0,
      rationale: 'Evaluates persuasion confidence under resistance.',
    },
    {
      id: 19,
      text: 'I keep multiple options open when negotiating.',
      trait: 'M',
      rationale: 'Measures contingency planning in negotiations.',
    },
    {
      id: 20,
      text: 'I focus on outcomes more than emotional fallout.',
      trait: 'P',
      rationale: 'Tracks priority on results over feelings.',
    },
    {
      id: 21,
      text: 'I enjoy being a visible source of momentum.',
      trait: 'N',
      rationale: 'Gauges enjoyment of being the catalyst.',
    },
    {
      id: 22,
      text: 'I notice when someone is predictable and plan around it.',
      trait: 'M',
      rationale: 'Assesses strategic adaptation to predictability.',
    },
    {
      id: 23,
      text: 'I can stay composed even when others are upset with me.',
      trait: 'P',
      rationale: 'Checks emotional steadiness under criticism.',
    },
    {
      id: 24,
      text: 'Im good at guiding a conversation toward the outcome I want.',
      trait: 'MD',
      rationale: 'Measures conversational steering confidence.',
    },
    {
      id: 25,
      text: 'I like to be recognized for my taste and standards.',
      trait: 'N',
      rationale: 'Tracks desire for recognition of discernment.',
    },
    {
      id: 26,
      text: 'I avoid showing all my cards right away.',
      trait: 'M',
      rationale: 'Checks for guarded positioning.',
    },
    {
      id: 27,
      text: 'I can disconnect from a situation if it becomes inconvenient.',
      trait: 'P',
      rationale: 'Measures ease of detachment.',
    },
    {
      id: 28,
      text: 'I adapt my approach to fit whoever Im with.',
      trait: 'MD',
      rationale: 'Tracks adaptive social shaping.',
    },
    {
      id: 29,
      text: 'Its important that others see the best version of me.',
      trait: 'N',
      rationale: 'Assesses presentation focus.',
    },
    {
      id: 30,
      text: 'I am rarely surprised by other peoples motives.',
      trait: 'M',
      rationale: 'Checks for predictive social thinking.',
    },
    {
      id: 31,
      text: 'I believe honesty should be consistent, even under pressure.',
      trait: 'M',
      reverse: !0,
      lieTrap: !0,
      rationale: 'Reverse-coded to detect contradictions with strategic behavior.',
    },
    {
      id: 32,
      text: 'I feel uneasy when someone is treated unfairly.',
      trait: 'P',
      reverse: !0,
      lieTrap: !0,
      rationale: 'Reverse-coded to detect emotional distance.',
    },
  ],
  ok = ['Not me', 'Rarely me', 'Often me', 'Definitely me'],
  ak = {
    hidden: { opacity: 0, y: 12 },
    visible: (e) => ({ opacity: 1, y: 0, transition: { delay: 0.08 * e } }),
  },
  lk = ({ question: e, sequence: t, total: n, onAnswer: r }) =>
    N.jsxs(
      qn.div,
      {
        initial: { opacity: 0, y: 16 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: -12 },
        transition: { duration: 0.3 },
        className: 'glass-panel p-6',
        children: [
          N.jsxs('div', {
            className:
              'flex items-center justify-between text-xs uppercase tracking-[0.2em] text-slate-400',
            children: [
              N.jsxs('span', { children: ['Question ', t, ' of ', n] }),
              N.jsx('span', {
                className: 'rounded-full bg-white/10 px-3 py-1',
                children: 'Vibe Prism',
              }),
            ],
          }),
          N.jsx('h2', { className: 'mt-4 text-2xl font-semibold text-slate-50', children: e.text }),
          N.jsx('p', { className: 'mt-2 text-sm text-slate-400', children: e.rationale }),
          N.jsx('div', {
            className: 'mt-6 grid gap-3',
            children: ok.map((i, o) =>
              N.jsxs(
                qn.button,
                {
                  type: 'button',
                  custom: o,
                  variants: ak,
                  initial: 'hidden',
                  animate: 'visible',
                  onClick: () => r(o),
                  className:
                    'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-4 py-3 text-left text-sm font-medium text-slate-100 transition hover:border-emerald-400/40 hover:bg-emerald-500/10',
                  children: [
                    N.jsx('span', { children: i }),
                    N.jsx('span', { className: 'text-xs text-slate-400', children: o }),
                  ],
                },
                i
              )
            ),
          }),
        ],
      },
      e.id
    ),
  ck = ({ value: e }) =>
    N.jsx('div', {
      className: 'h-2 w-full overflow-hidden rounded-full bg-white/10',
      children: N.jsx(qn.div, {
        className:
          'h-full bg-gradient-to-r from-emerald-500/40 via-emerald-400/50 to-emerald-300/60',
        initial: { width: 0 },
        animate: { width: `${e}%` },
        transition: { duration: 0.4 },
      }),
    }),
  uk = (e) => {
    const t = [...e]
    for (let n = t.length - 1; n > 0; n -= 1) {
      const r = Math.floor(Math.random() * (n + 1))
      ;[t[n], t[r]] = [t[r], t[n]]
    }
    return t
  },
  Pd = (e) => Math.min(100, Math.max(0, Math.round(e))),
  hk = { N: 1, M: 1.2, P: 1.4, MD: 1.3 },
  dk = (e, t) => {
    const n = { N: 0, M: 0, P: 0, MD: 0 },
      r = { N: 0, M: 0, P: 0, MD: 0 },
      i = new Map(t.map((O) => [O.questionId, O]))
    let o = !1,
      c = !1,
      h = 0
    e.forEach((O) => {
      const F = i.get(O.id)
      if (!F) return
      const z = O.reverse ? 3 - F.answer : F.answer
      ;((n[O.trait] += z),
        (r[O.trait] += 1),
        (h += F.answer),
        F.rtMs < 450 && F.answer >= 2 && (o = !0),
        O.lieTrap && F.answer >= 2 && (c = !0))
    })
    const f = h / t.length >= 2.7,
      p = Object.keys(n).reduce(
        (O, F) => {
          const z = r[F] * 3,
            V = (z > 0 ? (n[F] / z) * 100 : 0) * hk[F]
          return ((O[F] = Pd(V)), O)
        },
        { N: 0, M: 0, P: 0, MD: 0 }
      ),
      y = { masking: o, contradictions: c, halo: f },
      w = Object.values(y).filter(Boolean).length,
      x = Math.max(70, 100 - w * 10),
      E = 0.9 * p.N + 1.1 * p.M + 1.3 * p.P,
      S = Pd(E / 3),
      k = w >= 2 ? Pd(S * 1.25) : S,
      P = e
        .filter((O) => O.safetyTrigger)
        .map((O) => {
          const F = i.get(O.id)
          return F && F.answer >= 2 ? `Q${O.id}: ${O.text}` : null
        })
        .filter((O) => !!O)
    p.P > 75 && p.MD > 60 && P.push('Trait combination: P > 75 and MD > 60')
    const I = { triggered: P.length > 0, triggers: P }
    let R = 'GREEN'
    k >= 60 || I.triggered ? (R = 'RED') : k >= 35 && (R = 'YELLOW')
    const M =
      p.P >= 70 && p.M >= 70
        ? 'APX'
        : p.M >= 70 && p.MD >= 70
          ? 'PUP'
          : p.N >= 70
            ? 'EGO'
            : p.M >= 60 && p.N >= 55
              ? 'SMR'
              : Math.max(p.N, p.M, p.P, p.MD) < 45
                ? 'LOW'
                : 'DRM'
    return {
      scores: p,
      dtiBase: S,
      dtiFinal: k,
      band: R,
      archetype: M,
      integrity: x,
      integrityFlags: y,
      safetyOverrides: I,
    }
  },
  fk = (e) => btoa(e).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''),
  e3 = (e) => {
    const t = e.replace(/-/g, '+').replace(/_/g, '/'),
      n = (4 - (t.length % 4)) % 4,
      r = t + '='.repeat(n)
    return atob(r)
  },
  tp = async (e) => {
    const t = new TextEncoder().encode(e),
      n = await crypto.subtle.digest('SHA-256', t)
    return Array.from(new Uint8Array(n))
      .map((r) => r.toString(16).padStart(2, '0'))
      .join('')
  },
  vh = { attempt: 'VIBE_PRISM_ATTEMPT', token: 'VIBE_PRISM_LAST_TOKEN' },
  pk = () => {
    localStorage.setItem(vh.attempt, new Date().toISOString())
  },
  gk = () => !!localStorage.getItem(vh.attempt),
  mk = (e) => {
    localStorage.setItem(vh.token, e)
  },
  t3 = () => localStorage.getItem(vh.token),
  yk = () => {
    const e = b0(),
      [t, n] = X.useState(!1),
      [r, i] = X.useState(0),
      [o, c] = X.useState([]),
      h = X.useRef(crypto.randomUUID()),
      f = X.useRef(performance.now())
    X.useEffect(() => {
      n(gk())
    }, [])
    const p = X.useMemo(() => uk(af), []),
      y = ((r + 1) / p.length) * 100,
      w = async (x) => {
        const E = p[r],
          S = Math.round(performance.now() - f.current),
          k = [...o, { questionId: E.id, answer: x, rtMs: S }]
        if ((c(k), r === p.length - 1)) {
          const P = dk(af, k),
            I = JSON.stringify(k),
            R = `masking:${P.integrityFlags.masking};contradictions:${P.integrityFlags.contradictions};halo:${P.integrityFlags.halo}`,
            M = P.safetyOverrides.triggers.join('~') || 'none',
            O = [
              'VP1',
              h.current,
              new Date().toISOString(),
              P.band,
              P.dtiBase.toString(),
              P.dtiFinal.toString(),
              P.scores.N.toString(),
              P.scores.M.toString(),
              P.scores.P.toString(),
              P.scores.MD.toString(),
              P.integrity.toString(),
              P.archetype,
              R,
              M,
              I,
            ].join('|'),
            F = (await tp(O)).slice(0, 8),
            z = fk(`${O}|${F}`)
          ;(mk(z), pk(), e('/result'))
          return
        }
        ;(i((P) => P + 1), (f.current = performance.now()))
      }
    return t
      ? N.jsx('div', {
          className: 'mx-auto flex w-full max-w-3xl flex-col gap-6 px-6 py-16',
          children: N.jsxs('div', {
            className: 'glass-panel p-6',
            children: [
              N.jsxs('div', {
                className: 'flex items-center gap-3',
                children: [
                  N.jsx(xs, { size: 24, className: 'text-emerald-300' }),
                  N.jsxs('div', {
                    children: [
                      N.jsx('h2', {
                        className: 'text-xl font-semibold',
                        children: 'One attempt per session',
                      }),
                      N.jsx('p', {
                        className: 'text-sm text-slate-400',
                        children:
                          'This quiz allows only a single pass. You can restore your latest profile or continue to the decoder if you have a token.',
                      }),
                    ],
                  }),
                ],
              }),
              N.jsxs('div', {
                className: 'mt-6 flex flex-wrap gap-3',
                children: [
                  N.jsx(er, {
                    to: '/result',
                    className: 'button-primary',
                    children: 'View results',
                  }),
                  N.jsx(er, {
                    to: '/restore',
                    className: 'button-secondary',
                    children: 'Restore profile',
                  }),
                ],
              }),
            ],
          }),
        })
      : N.jsxs('div', {
          className: 'mx-auto flex w-full max-w-6xl flex-col gap-6 px-6 py-16',
          children: [
            N.jsxs('div', {
              className:
                'flex flex-wrap items-center justify-between gap-4 text-xs uppercase tracking-[0.3em] text-slate-400',
              children: [
                N.jsx('span', { children: 'Vibe Prism  quiz flow' }),
                N.jsxs('span', { children: [r + 1, ' / ', p.length] }),
              ],
            }),
            N.jsx(ck, { value: y }),
            N.jsxs('div', {
              className: 'grid gap-6 lg:grid-cols-[1.2fr_0.8fr]',
              children: [
                N.jsx(qn.div, {
                  layout: !0,
                  children: N.jsx(lk, {
                    question: p[r],
                    sequence: r + 1,
                    total: p.length,
                    onAnswer: w,
                  }),
                }),
                N.jsxs('div', {
                  className: 'flex flex-col gap-4',
                  children: [
                    N.jsxs('div', {
                      className: 'glass-panel p-6',
                      children: [
                        N.jsxs('div', {
                          className: 'flex items-center gap-3',
                          children: [
                            N.jsx(Qo, { size: 20, className: 'text-emerald-300' }),
                            N.jsxs('div', {
                              children: [
                                N.jsx('h3', {
                                  className: 'text-lg font-semibold',
                                  children: 'Session Guidance',
                                }),
                                N.jsx('p', {
                                  className: 'text-sm text-slate-400',
                                  children:
                                    'Answer quickly, but stay honest. The system listens for clarity.',
                                }),
                              ],
                            }),
                          ],
                        }),
                        N.jsx('ul', {
                          className: 'mt-4 space-y-2 text-sm text-slate-300',
                          children: [
                            'No backtracking once you move forward.',
                            'Response timing shapes integrity scores.',
                            'Your token is stored on this device only.',
                          ].map((x) => N.jsx('li', { className: 'list-item', children: x }, x)),
                        }),
                      ],
                    }),
                    N.jsxs('div', {
                      className: 'glass-panel p-6',
                      children: [
                        N.jsxs('div', {
                          className: 'flex items-center gap-3',
                          children: [
                            N.jsx($6, { size: 20, className: 'text-emerald-300' }),
                            N.jsxs('div', {
                              children: [
                                N.jsx('h3', {
                                  className: 'text-lg font-semibold',
                                  children: 'Answer Scale',
                                }),
                                N.jsx('p', {
                                  className: 'text-sm text-slate-400',
                                  children: 'Score 0-3 based on how true each statement feels.',
                                }),
                              ],
                            }),
                          ],
                        }),
                        N.jsxs('div', {
                          className: 'mt-4 grid gap-2 text-sm text-slate-300',
                          children: [
                            N.jsxs('div', {
                              className:
                                'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                              children: [
                                N.jsx('span', { children: '0' }),
                                N.jsx('span', { className: 'text-slate-400', children: 'Not me' }),
                              ],
                            }),
                            N.jsxs('div', {
                              className:
                                'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                              children: [
                                N.jsx('span', { children: '1' }),
                                N.jsx('span', {
                                  className: 'text-slate-400',
                                  children: 'Rarely true',
                                }),
                              ],
                            }),
                            N.jsxs('div', {
                              className:
                                'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                              children: [
                                N.jsx('span', { children: '2' }),
                                N.jsx('span', {
                                  className: 'text-slate-400',
                                  children: 'Often true',
                                }),
                              ],
                            }),
                            N.jsxs('div', {
                              className:
                                'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                              children: [
                                N.jsx('span', { children: '3' }),
                                N.jsx('span', {
                                  className: 'text-slate-400',
                                  children: 'Always true',
                                }),
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
          ],
        })
  }
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */ function Ul(e) {
  return (e + 0.5) | 0
}
const mi = (e, t, n) => Math.max(Math.min(e, n), t)
function Pa(e) {
  return mi(Ul(e * 2.55), 0, 255)
}
function Ri(e) {
  return mi(Ul(e * 255), 0, 255)
}
function Br(e) {
  return mi(Ul(e / 2.55) / 100, 0, 1)
}
function mm(e) {
  return mi(Ul(e * 100), 0, 100)
}
const Xn = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
  },
  lf = [...'0123456789ABCDEF'],
  wk = (e) => lf[e & 15],
  bk = (e) => lf[(e & 240) >> 4] + lf[e & 15],
  Ec = (e) => (e & 240) >> 4 === (e & 15),
  vk = (e) => Ec(e.r) && Ec(e.g) && Ec(e.b) && Ec(e.a)
function xk(e) {
  var t = e.length,
    n
  return (
    e[0] === '#' &&
      (t === 4 || t === 5
        ? (n = {
            r: 255 & (Xn[e[1]] * 17),
            g: 255 & (Xn[e[2]] * 17),
            b: 255 & (Xn[e[3]] * 17),
            a: t === 5 ? Xn[e[4]] * 17 : 255,
          })
        : (t === 7 || t === 9) &&
          (n = {
            r: (Xn[e[1]] << 4) | Xn[e[2]],
            g: (Xn[e[3]] << 4) | Xn[e[4]],
            b: (Xn[e[5]] << 4) | Xn[e[6]],
            a: t === 9 ? (Xn[e[7]] << 4) | Xn[e[8]] : 255,
          })),
    n
  )
}
const Ek = (e, t) => (e < 255 ? t(e) : '')
function Ck(e) {
  var t = vk(e) ? wk : bk
  return e ? '#' + t(e.r) + t(e.g) + t(e.b) + Ek(e.a, t) : void 0
}
const Sk =
  /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/
function n3(e, t, n) {
  const r = t * Math.min(n, 1 - n),
    i = (o, c = (o + e / 30) % 12) => n - r * Math.max(Math.min(c - 3, 9 - c, 1), -1)
  return [i(0), i(8), i(4)]
}
function Ak(e, t, n) {
  const r = (i, o = (i + e / 60) % 6) => n - n * t * Math.max(Math.min(o, 4 - o, 1), 0)
  return [r(5), r(3), r(1)]
}
function kk(e, t, n) {
  const r = n3(e, 1, 0.5)
  let i
  for (t + n > 1 && ((i = 1 / (t + n)), (t *= i), (n *= i)), i = 0; i < 3; i++)
    ((r[i] *= 1 - t - n), (r[i] += t))
  return r
}
function _k(e, t, n, r, i) {
  return e === i ? (t - n) / r + (t < n ? 6 : 0) : t === i ? (n - e) / r + 2 : (e - t) / r + 4
}
function np(e) {
  const t = e.r / 255,
    n = e.g / 255,
    r = e.b / 255,
    i = Math.max(t, n, r),
    o = Math.min(t, n, r),
    c = (i + o) / 2
  let h, f, p
  return (
    i !== o &&
      ((p = i - o),
      (f = c > 0.5 ? p / (2 - i - o) : p / (i + o)),
      (h = _k(t, n, r, p, i)),
      (h = h * 60 + 0.5)),
    [h | 0, f || 0, c]
  )
}
function rp(e, t, n, r) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, r)).map(Ri)
}
function ip(e, t, n) {
  return rp(n3, e, t, n)
}
function Ik(e, t, n) {
  return rp(kk, e, t, n)
}
function Nk(e, t, n) {
  return rp(Ak, e, t, n)
}
function r3(e) {
  return ((e % 360) + 360) % 360
}
function Tk(e) {
  const t = Sk.exec(e)
  let n = 255,
    r
  if (!t) return
  t[5] !== r && (n = t[6] ? Pa(+t[5]) : Ri(+t[5]))
  const i = r3(+t[2]),
    o = +t[3] / 100,
    c = +t[4] / 100
  return (
    t[1] === 'hwb' ? (r = Ik(i, o, c)) : t[1] === 'hsv' ? (r = Nk(i, o, c)) : (r = ip(i, o, c)),
    { r: r[0], g: r[1], b: r[2], a: n }
  )
}
function Rk(e, t) {
  var n = np(e)
  ;((n[0] = r3(n[0] + t)), (n = ip(n)), (e.r = n[0]), (e.g = n[1]), (e.b = n[2]))
}
function Mk(e) {
  if (!e) return
  const t = np(e),
    n = t[0],
    r = mm(t[1]),
    i = mm(t[2])
  return e.a < 255 ? `hsla(${n}, ${r}%, ${i}%, ${Br(e.a)})` : `hsl(${n}, ${r}%, ${i}%)`
}
const ym = {
    x: 'dark',
    Z: 'light',
    Y: 're',
    X: 'blu',
    W: 'gr',
    V: 'medium',
    U: 'slate',
    A: 'ee',
    T: 'ol',
    S: 'or',
    B: 'ra',
    C: 'lateg',
    D: 'ights',
    R: 'in',
    Q: 'turquois',
    E: 'hi',
    P: 'ro',
    O: 'al',
    N: 'le',
    M: 'de',
    L: 'yello',
    F: 'en',
    K: 'ch',
    G: 'arks',
    H: 'ea',
    I: 'ightg',
    J: 'wh',
  },
  wm = {
    OiceXe: 'f0f8ff',
    antiquewEte: 'faebd7',
    aqua: 'ffff',
    aquamarRe: '7fffd4',
    azuY: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '0',
    blanKedOmond: 'ffebcd',
    Xe: 'ff',
    XeviTet: '8a2be2',
    bPwn: 'a52a2a',
    burlywood: 'deb887',
    caMtXe: '5f9ea0',
    KartYuse: '7fff00',
    KocTate: 'd2691e',
    cSO: 'ff7f50',
    cSnflowerXe: '6495ed',
    cSnsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: 'ffff',
    xXe: '8b',
    xcyan: '8b8b',
    xgTMnPd: 'b8860b',
    xWay: 'a9a9a9',
    xgYF: '6400',
    xgYy: 'a9a9a9',
    xkhaki: 'bdb76b',
    xmagFta: '8b008b',
    xTivegYF: '556b2f',
    xSange: 'ff8c00',
    xScEd: '9932cc',
    xYd: '8b0000',
    xsOmon: 'e9967a',
    xsHgYF: '8fbc8f',
    xUXe: '483d8b',
    xUWay: '2f4f4f',
    xUgYy: '2f4f4f',
    xQe: 'ced1',
    xviTet: '9400d3',
    dAppRk: 'ff1493',
    dApskyXe: 'bfff',
    dimWay: '696969',
    dimgYy: '696969',
    dodgerXe: '1e90ff',
    fiYbrick: 'b22222',
    flSOwEte: 'fffaf0',
    foYstWAn: '228b22',
    fuKsia: 'ff00ff',
    gaRsbSo: 'dcdcdc',
    ghostwEte: 'f8f8ff',
    gTd: 'ffd700',
    gTMnPd: 'daa520',
    Way: '808080',
    gYF: '8000',
    gYFLw: 'adff2f',
    gYy: '808080',
    honeyMw: 'f0fff0',
    hotpRk: 'ff69b4',
    RdianYd: 'cd5c5c',
    Rdigo: '4b0082',
    ivSy: 'fffff0',
    khaki: 'f0e68c',
    lavFMr: 'e6e6fa',
    lavFMrXsh: 'fff0f5',
    lawngYF: '7cfc00',
    NmoncEffon: 'fffacd',
    ZXe: 'add8e6',
    ZcSO: 'f08080',
    Zcyan: 'e0ffff',
    ZgTMnPdLw: 'fafad2',
    ZWay: 'd3d3d3',
    ZgYF: '90ee90',
    ZgYy: 'd3d3d3',
    ZpRk: 'ffb6c1',
    ZsOmon: 'ffa07a',
    ZsHgYF: '20b2aa',
    ZskyXe: '87cefa',
    ZUWay: '778899',
    ZUgYy: '778899',
    ZstAlXe: 'b0c4de',
    ZLw: 'ffffe0',
    lime: 'ff00',
    limegYF: '32cd32',
    lRF: 'faf0e6',
    magFta: 'ff00ff',
    maPon: '800000',
    VaquamarRe: '66cdaa',
    VXe: 'cd',
    VScEd: 'ba55d3',
    VpurpN: '9370db',
    VsHgYF: '3cb371',
    VUXe: '7b68ee',
    VsprRggYF: 'fa9a',
    VQe: '48d1cc',
    VviTetYd: 'c71585',
    midnightXe: '191970',
    mRtcYam: 'f5fffa',
    mistyPse: 'ffe4e1',
    moccasR: 'ffe4b5',
    navajowEte: 'ffdead',
    navy: '80',
    Tdlace: 'fdf5e6',
    Tive: '808000',
    TivedBb: '6b8e23',
    Sange: 'ffa500',
    SangeYd: 'ff4500',
    ScEd: 'da70d6',
    pOegTMnPd: 'eee8aa',
    pOegYF: '98fb98',
    pOeQe: 'afeeee',
    pOeviTetYd: 'db7093',
    papayawEp: 'ffefd5',
    pHKpuff: 'ffdab9',
    peru: 'cd853f',
    pRk: 'ffc0cb',
    plum: 'dda0dd',
    powMrXe: 'b0e0e6',
    purpN: '800080',
    YbeccapurpN: '663399',
    Yd: 'ff0000',
    Psybrown: 'bc8f8f',
    PyOXe: '4169e1',
    saddNbPwn: '8b4513',
    sOmon: 'fa8072',
    sandybPwn: 'f4a460',
    sHgYF: '2e8b57',
    sHshell: 'fff5ee',
    siFna: 'a0522d',
    silver: 'c0c0c0',
    skyXe: '87ceeb',
    UXe: '6a5acd',
    UWay: '708090',
    UgYy: '708090',
    snow: 'fffafa',
    sprRggYF: 'ff7f',
    stAlXe: '4682b4',
    tan: 'd2b48c',
    teO: '8080',
    tEstN: 'd8bfd8',
    tomato: 'ff6347',
    Qe: '40e0d0',
    viTet: 'ee82ee',
    JHt: 'f5deb3',
    wEte: 'ffffff',
    wEtesmoke: 'f5f5f5',
    Lw: 'ffff00',
    LwgYF: '9acd32',
  }
function Pk() {
  const e = {},
    t = Object.keys(wm),
    n = Object.keys(ym)
  let r, i, o, c, h
  for (r = 0; r < t.length; r++) {
    for (c = h = t[r], i = 0; i < n.length; i++) ((o = n[i]), (h = h.replace(o, ym[o])))
    ;((o = parseInt(wm[c], 16)), (e[h] = [(o >> 16) & 255, (o >> 8) & 255, o & 255]))
  }
  return e
}
let Cc
function Dk(e) {
  Cc || ((Cc = Pk()), (Cc.transparent = [0, 0, 0, 0]))
  const t = Cc[e.toLowerCase()]
  return t && { r: t[0], g: t[1], b: t[2], a: t.length === 4 ? t[3] : 255 }
}
const Lk =
  /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/
function Ok(e) {
  const t = Lk.exec(e)
  let n = 255,
    r,
    i,
    o
  if (t) {
    if (t[7] !== r) {
      const c = +t[7]
      n = t[8] ? Pa(c) : mi(c * 255, 0, 255)
    }
    return (
      (r = +t[1]),
      (i = +t[3]),
      (o = +t[5]),
      (r = 255 & (t[2] ? Pa(r) : mi(r, 0, 255))),
      (i = 255 & (t[4] ? Pa(i) : mi(i, 0, 255))),
      (o = 255 & (t[6] ? Pa(o) : mi(o, 0, 255))),
      { r, g: i, b: o, a: n }
    )
  }
}
function Bk(e) {
  return (
    e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${Br(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`)
  )
}
const Dd = (e) => (e <= 0.0031308 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055),
  to = (e) => (e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4))
function Fk(e, t, n) {
  const r = to(Br(e.r)),
    i = to(Br(e.g)),
    o = to(Br(e.b))
  return {
    r: Ri(Dd(r + n * (to(Br(t.r)) - r))),
    g: Ri(Dd(i + n * (to(Br(t.g)) - i))),
    b: Ri(Dd(o + n * (to(Br(t.b)) - o))),
    a: e.a + n * (t.a - e.a),
  }
}
function Sc(e, t, n) {
  if (e) {
    let r = np(e)
    ;((r[t] = Math.max(0, Math.min(r[t] + r[t] * n, t === 0 ? 360 : 1))),
      (r = ip(r)),
      (e.r = r[0]),
      (e.g = r[1]),
      (e.b = r[2]))
  }
}
function i3(e, t) {
  return e && Object.assign(t || {}, e)
}
function bm(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 }
  return (
    Array.isArray(e)
      ? e.length >= 3 &&
        ((t = { r: e[0], g: e[1], b: e[2], a: 255 }), e.length > 3 && (t.a = Ri(e[3])))
      : ((t = i3(e, { r: 0, g: 0, b: 0, a: 1 })), (t.a = Ri(t.a))),
    t
  )
}
function jk(e) {
  return e.charAt(0) === 'r' ? Ok(e) : Tk(e)
}
class Al {
  constructor(t) {
    if (t instanceof Al) return t
    const n = typeof t
    let r
    ;(n === 'object' ? (r = bm(t)) : n === 'string' && (r = xk(t) || Dk(t) || jk(t)),
      (this._rgb = r),
      (this._valid = !!r))
  }
  get valid() {
    return this._valid
  }
  get rgb() {
    var t = i3(this._rgb)
    return (t && (t.a = Br(t.a)), t)
  }
  set rgb(t) {
    this._rgb = bm(t)
  }
  rgbString() {
    return this._valid ? Bk(this._rgb) : void 0
  }
  hexString() {
    return this._valid ? Ck(this._rgb) : void 0
  }
  hslString() {
    return this._valid ? Mk(this._rgb) : void 0
  }
  mix(t, n) {
    if (t) {
      const r = this.rgb,
        i = t.rgb
      let o
      const c = n === o ? 0.5 : n,
        h = 2 * c - 1,
        f = r.a - i.a,
        p = ((h * f === -1 ? h : (h + f) / (1 + h * f)) + 1) / 2
      ;((o = 1 - p),
        (r.r = 255 & (p * r.r + o * i.r + 0.5)),
        (r.g = 255 & (p * r.g + o * i.g + 0.5)),
        (r.b = 255 & (p * r.b + o * i.b + 0.5)),
        (r.a = c * r.a + (1 - c) * i.a),
        (this.rgb = r))
    }
    return this
  }
  interpolate(t, n) {
    return (t && (this._rgb = Fk(this._rgb, t._rgb, n)), this)
  }
  clone() {
    return new Al(this.rgb)
  }
  alpha(t) {
    return ((this._rgb.a = Ri(t)), this)
  }
  clearer(t) {
    const n = this._rgb
    return ((n.a *= 1 - t), this)
  }
  greyscale() {
    const t = this._rgb,
      n = Ul(t.r * 0.3 + t.g * 0.59 + t.b * 0.11)
    return ((t.r = t.g = t.b = n), this)
  }
  opaquer(t) {
    const n = this._rgb
    return ((n.a *= 1 + t), this)
  }
  negate() {
    const t = this._rgb
    return ((t.r = 255 - t.r), (t.g = 255 - t.g), (t.b = 255 - t.b), this)
  }
  lighten(t) {
    return (Sc(this._rgb, 2, t), this)
  }
  darken(t) {
    return (Sc(this._rgb, 2, -t), this)
  }
  saturate(t) {
    return (Sc(this._rgb, 1, t), this)
  }
  desaturate(t) {
    return (Sc(this._rgb, 1, -t), this)
  }
  rotate(t) {
    return (Rk(this._rgb, t), this)
  }
}
/*!
 * Chart.js v4.5.1
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */ function Rr() {}
const Vk = (() => {
  let e = 0
  return () => e++
})()
function Oe(e) {
  return e == null
}
function ct(e) {
  if (Array.isArray && Array.isArray(e)) return !0
  const t = Object.prototype.toString.call(e)
  return t.slice(0, 7) === '[object' && t.slice(-6) === 'Array]'
}
function Me(e) {
  return e !== null && Object.prototype.toString.call(e) === '[object Object]'
}
function Bt(e) {
  return (typeof e == 'number' || e instanceof Number) && isFinite(+e)
}
function vr(e, t) {
  return Bt(e) ? e : t
}
function _e(e, t) {
  return typeof e > 'u' ? t : e
}
const Uk = (e, t) => (typeof e == 'string' && e.endsWith('%') ? (parseFloat(e) / 100) * t : +e)
function Qe(e, t, n) {
  if (e && typeof e.call == 'function') return e.apply(n, t)
}
function ze(e, t, n, r) {
  let i, o, c
  if (ct(e)) for (o = e.length, i = 0; i < o; i++) t.call(n, e[i], i)
  else if (Me(e)) for (c = Object.keys(e), o = c.length, i = 0; i < o; i++) t.call(n, e[c[i]], c[i])
}
function Bu(e, t) {
  let n, r, i, o
  if (!e || !t || e.length !== t.length) return !1
  for (n = 0, r = e.length; n < r; ++n)
    if (((i = e[n]), (o = t[n]), i.datasetIndex !== o.datasetIndex || i.index !== o.index))
      return !1
  return !0
}
function Fu(e) {
  if (ct(e)) return e.map(Fu)
  if (Me(e)) {
    const t = Object.create(null),
      n = Object.keys(e),
      r = n.length
    let i = 0
    for (; i < r; ++i) t[n[i]] = Fu(e[n[i]])
    return t
  }
  return e
}
function s3(e) {
  return ['__proto__', 'prototype', 'constructor'].indexOf(e) === -1
}
function Wk(e, t, n, r) {
  if (!s3(e)) return
  const i = t[e],
    o = n[e]
  Me(i) && Me(o) ? kl(i, o, r) : (t[e] = Fu(o))
}
function kl(e, t, n) {
  const r = ct(t) ? t : [t],
    i = r.length
  if (!Me(e)) return e
  n = n || {}
  const o = n.merger || Wk
  let c
  for (let h = 0; h < i; ++h) {
    if (((c = r[h]), !Me(c))) continue
    const f = Object.keys(c)
    for (let p = 0, y = f.length; p < y; ++p) o(f[p], e, c, n)
  }
  return e
}
function Ka(e, t) {
  return kl(e, t, { merger: zk })
}
function zk(e, t, n) {
  if (!s3(e)) return
  const r = t[e],
    i = n[e]
  Me(r) && Me(i) ? Ka(r, i) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = Fu(i))
}
const vm = { '': (e) => e, x: (e) => e.x, y: (e) => e.y }
function Hk(e) {
  const t = e.split('.'),
    n = []
  let r = ''
  for (const i of t)
    ((r += i), r.endsWith('\\') ? (r = r.slice(0, -1) + '.') : (n.push(r), (r = '')))
  return n
}
function Xk(e) {
  const t = Hk(e)
  return (n) => {
    for (const r of t) {
      if (r === '') break
      n = n && n[r]
    }
    return n
  }
}
function Es(e, t) {
  return (vm[t] || (vm[t] = Xk(t)))(e)
}
function sp(e) {
  return e.charAt(0).toUpperCase() + e.slice(1)
}
const _l = (e) => typeof e < 'u',
  Oi = (e) => typeof e == 'function',
  xm = (e, t) => {
    if (e.size !== t.size) return !1
    for (const n of e) if (!t.has(n)) return !1
    return !0
  }
function Gk(e) {
  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu'
}
const Ot = Math.PI,
  Ln = 2 * Ot,
  Yk = Ln + Ot,
  ju = Number.POSITIVE_INFINITY,
  Zk = Ot / 180,
  Rn = Ot / 2,
  qi = Ot / 4,
  Em = (Ot * 2) / 3,
  o3 = Math.log10,
  Nr = Math.sign
function qa(e, t, n) {
  return Math.abs(e - t) < n
}
function Cm(e) {
  const t = Math.round(e)
  e = qa(e, t, e / 1e3) ? t : e
  const n = Math.pow(10, Math.floor(o3(e))),
    r = e / n
  return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n
}
function Kk(e) {
  const t = [],
    n = Math.sqrt(e)
  let r
  for (r = 1; r < n; r++) e % r === 0 && (t.push(r), t.push(e / r))
  return (n === (n | 0) && t.push(n), t.sort((i, o) => i - o).pop(), t)
}
function qk(e) {
  return (
    typeof e == 'symbol' ||
    (typeof e == 'object' &&
      e !== null &&
      !(Symbol.toPrimitive in e || 'toString' in e || 'valueOf' in e))
  )
}
function Il(e) {
  return !qk(e) && !isNaN(parseFloat(e)) && isFinite(e)
}
function Qk(e, t) {
  const n = Math.round(e)
  return n - t <= e && n + t >= e
}
function $k(e, t, n) {
  let r, i, o
  for (r = 0, i = e.length; r < i; r++)
    ((o = e[r][n]), isNaN(o) || ((t.min = Math.min(t.min, o)), (t.max = Math.max(t.max, o))))
}
function yi(e) {
  return e * (Ot / 180)
}
function op(e) {
  return e * (180 / Ot)
}
function Sm(e) {
  if (!Bt(e)) return
  let t = 1,
    n = 0
  for (; Math.round(e * t) / t !== e; ) ((t *= 10), n++)
  return n
}
function Jk(e, t) {
  const n = t.x - e.x,
    r = t.y - e.y,
    i = Math.sqrt(n * n + r * r)
  let o = Math.atan2(r, n)
  return (o < -0.5 * Ot && (o += Ln), { angle: o, distance: i })
}
function cf(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}
function e9(e, t) {
  return ((e - t + Yk) % Ln) - Ot
}
function Nn(e) {
  return ((e % Ln) + Ln) % Ln
}
function a3(e, t, n, r) {
  const i = Nn(e),
    o = Nn(t),
    c = Nn(n),
    h = Nn(o - i),
    f = Nn(c - i),
    p = Nn(i - o),
    y = Nn(i - c)
  return i === o || i === c || (r && o === c) || (h > f && p < y)
}
function Mn(e, t, n) {
  return Math.max(t, Math.min(n, e))
}
function t9(e) {
  return Mn(e, -32768, 32767)
}
function wi(e, t, n, r = 1e-6) {
  return e >= Math.min(t, n) - r && e <= Math.max(t, n) + r
}
function ap(e, t, n) {
  n = n || ((c) => e[c] < t)
  let r = e.length - 1,
    i = 0,
    o
  for (; r - i > 1; ) ((o = (i + r) >> 1), n(o) ? (i = o) : (r = o))
  return { lo: i, hi: r }
}
const cs = (e, t, n, r) =>
    ap(
      e,
      n,
      r
        ? (i) => {
            const o = e[i][t]
            return o < n || (o === n && e[i + 1][t] === n)
          }
        : (i) => e[i][t] < n
    ),
  n9 = (e, t, n) => ap(e, n, (r) => e[r][t] >= n)
function r9(e, t, n) {
  let r = 0,
    i = e.length
  for (; r < i && e[r] < t; ) r++
  for (; i > r && e[i - 1] > n; ) i--
  return r > 0 || i < e.length ? e.slice(r, i) : e
}
const l3 = ['push', 'pop', 'shift', 'splice', 'unshift']
function i9(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t)
    return
  }
  ;(Object.defineProperty(e, '_chartjs', {
    configurable: !0,
    enumerable: !1,
    value: { listeners: [t] },
  }),
    l3.forEach((n) => {
      const r = '_onData' + sp(n),
        i = e[n]
      Object.defineProperty(e, n, {
        configurable: !0,
        enumerable: !1,
        value(...o) {
          const c = i.apply(this, o)
          return (
            e._chartjs.listeners.forEach((h) => {
              typeof h[r] == 'function' && h[r](...o)
            }),
            c
          )
        },
      })
    }))
}
function Am(e, t) {
  const n = e._chartjs
  if (!n) return
  const r = n.listeners,
    i = r.indexOf(t)
  ;(i !== -1 && r.splice(i, 1),
    !(r.length > 0) &&
      (l3.forEach((o) => {
        delete e[o]
      }),
      delete e._chartjs))
}
function c3(e) {
  const t = new Set(e)
  return t.size === e.length ? e : Array.from(t)
}
const u3 = (function () {
  return typeof window > 'u'
    ? function (e) {
        return e()
      }
    : window.requestAnimationFrame
})()
function h3(e, t) {
  let n = [],
    r = !1
  return function (...i) {
    ;((n = i),
      r ||
        ((r = !0),
        u3.call(window, () => {
          ;((r = !1), e.apply(t, n))
        })))
  }
}
function s9(e, t) {
  let n
  return function (...r) {
    return (t ? (clearTimeout(n), (n = setTimeout(e, t, r))) : e.apply(this, r), t)
  }
}
const d3 = (e) => (e === 'start' ? 'left' : e === 'end' ? 'right' : 'center'),
  kn = (e, t, n) => (e === 'start' ? t : e === 'end' ? n : (t + n) / 2),
  o9 = (e, t, n, r) => (e === (r ? 'left' : 'right') ? n : e === 'center' ? (t + n) / 2 : t)
function a9(e, t, n) {
  const r = t.length
  let i = 0,
    o = r
  if (e._sorted) {
    const { iScale: c, vScale: h, _parsed: f } = e,
      p = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null,
      y = c.axis,
      { min: w, max: x, minDefined: E, maxDefined: S } = c.getUserBounds()
    if (E) {
      if (((i = Math.min(cs(f, y, w).lo, n ? r : cs(t, y, c.getPixelForValue(w)).lo)), p)) {
        const k = f
          .slice(0, i + 1)
          .reverse()
          .findIndex((P) => !Oe(P[h.axis]))
        i -= Math.max(0, k)
      }
      i = Mn(i, 0, r - 1)
    }
    if (S) {
      let k = Math.max(
        cs(f, c.axis, x, !0).hi + 1,
        n ? 0 : cs(t, y, c.getPixelForValue(x), !0).hi + 1
      )
      if (p) {
        const P = f.slice(k - 1).findIndex((I) => !Oe(I[h.axis]))
        k += Math.max(0, P)
      }
      o = Mn(k, i, r) - i
    } else o = r - i
  }
  return { start: i, count: o }
}
function l9(e) {
  const { xScale: t, yScale: n, _scaleRanges: r } = e,
    i = { xmin: t.min, xmax: t.max, ymin: n.min, ymax: n.max }
  if (!r) return ((e._scaleRanges = i), !0)
  const o = r.xmin !== t.min || r.xmax !== t.max || r.ymin !== n.min || r.ymax !== n.max
  return (Object.assign(r, i), o)
}
const Ac = (e) => e === 0 || e === 1,
  km = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin(((e - t) * Ln) / n)),
  _m = (e, t, n) => Math.pow(2, -10 * e) * Math.sin(((e - t) * Ln) / n) + 1,
  Qa = {
    linear: (e) => e,
    easeInQuad: (e) => e * e,
    easeOutQuad: (e) => -e * (e - 2),
    easeInOutQuad: (e) => ((e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1)),
    easeInCubic: (e) => e * e * e,
    easeOutCubic: (e) => (e -= 1) * e * e + 1,
    easeInOutCubic: (e) => ((e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2)),
    easeInQuart: (e) => e * e * e * e,
    easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
    easeInOutQuart: (e) =>
      (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
    easeInQuint: (e) => e * e * e * e * e,
    easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
    easeInOutQuint: (e) =>
      (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
    easeInSine: (e) => -Math.cos(e * Rn) + 1,
    easeOutSine: (e) => Math.sin(e * Rn),
    easeInOutSine: (e) => -0.5 * (Math.cos(Ot * e) - 1),
    easeInExpo: (e) => (e === 0 ? 0 : Math.pow(2, 10 * (e - 1))),
    easeOutExpo: (e) => (e === 1 ? 1 : -Math.pow(2, -10 * e) + 1),
    easeInOutExpo: (e) =>
      Ac(e)
        ? e
        : e < 0.5
          ? 0.5 * Math.pow(2, 10 * (e * 2 - 1))
          : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
    easeInCirc: (e) => (e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1)),
    easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
    easeInOutCirc: (e) =>
      (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
    easeInElastic: (e) => (Ac(e) ? e : km(e, 0.075, 0.3)),
    easeOutElastic: (e) => (Ac(e) ? e : _m(e, 0.075, 0.3)),
    easeInOutElastic(e) {
      return Ac(e)
        ? e
        : e < 0.5
          ? 0.5 * km(e * 2, 0.1125, 0.45)
          : 0.5 + 0.5 * _m(e * 2 - 1, 0.1125, 0.45)
    },
    easeInBack(e) {
      return e * e * ((1.70158 + 1) * e - 1.70158)
    },
    easeOutBack(e) {
      return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1
    },
    easeInOutBack(e) {
      let t = 1.70158
      return (e /= 0.5) < 1
        ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t))
        : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2)
    },
    easeInBounce: (e) => 1 - Qa.easeOutBounce(1 - e),
    easeOutBounce(e) {
      return e < 1 / 2.75
        ? 7.5625 * e * e
        : e < 2 / 2.75
          ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75
          : e < 2.5 / 2.75
            ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375
            : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375
    },
    easeInOutBounce: (e) =>
      e < 0.5 ? Qa.easeInBounce(e * 2) * 0.5 : Qa.easeOutBounce(e * 2 - 1) * 0.5 + 0.5,
  }
function lp(e) {
  if (e && typeof e == 'object') {
    const t = e.toString()
    return t === '[object CanvasPattern]' || t === '[object CanvasGradient]'
  }
  return !1
}
function Im(e) {
  return lp(e) ? e : new Al(e)
}
function Ld(e) {
  return lp(e) ? e : new Al(e).saturate(0.5).darken(0.1).hexString()
}
const c9 = ['x', 'y', 'borderWidth', 'radius', 'tension'],
  u9 = ['color', 'borderColor', 'backgroundColor']
function h9(e) {
  ;(e.set('animation', {
    delay: void 0,
    duration: 1e3,
    easing: 'easeOutQuart',
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0,
  }),
    e.describe('animation', {
      _fallback: !1,
      _indexable: !1,
      _scriptable: (t) => t !== 'onProgress' && t !== 'onComplete' && t !== 'fn',
    }),
    e.set('animations', {
      colors: { type: 'color', properties: u9 },
      numbers: { type: 'number', properties: c9 },
    }),
    e.describe('animations', { _fallback: 'animation' }),
    e.set('transitions', {
      active: { animation: { duration: 400 } },
      resize: { animation: { duration: 0 } },
      show: {
        animations: { colors: { from: 'transparent' }, visible: { type: 'boolean', duration: 0 } },
      },
      hide: {
        animations: {
          colors: { to: 'transparent' },
          visible: { type: 'boolean', easing: 'linear', fn: (t) => t | 0 },
        },
      },
    }))
}
function d9(e) {
  e.set('layout', { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } })
}
const Nm = new Map()
function f9(e, t) {
  t = t || {}
  const n = e + JSON.stringify(t)
  let r = Nm.get(n)
  return (r || ((r = new Intl.NumberFormat(e, t)), Nm.set(n, r)), r)
}
function f3(e, t, n) {
  return f9(t, n).format(e)
}
const p9 = {
  values(e) {
    return ct(e) ? e : '' + e
  },
  numeric(e, t, n) {
    if (e === 0) return '0'
    const r = this.chart.options.locale
    let i,
      o = e
    if (n.length > 1) {
      const p = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value))
      ;((p < 1e-4 || p > 1e15) && (i = 'scientific'), (o = g9(e, n)))
    }
    const c = o3(Math.abs(o)),
      h = isNaN(c) ? 1 : Math.max(Math.min(-1 * Math.floor(c), 20), 0),
      f = { notation: i, minimumFractionDigits: h, maximumFractionDigits: h }
    return (Object.assign(f, this.options.ticks.format), f3(e, r, f))
  },
}
function g9(e, t) {
  let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value
  return (Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n)
}
var cp = { formatters: p9 }
function m9(e) {
  ;(e.set('scale', {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: 'ticks',
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, n) => n.lineWidth,
      tickColor: (t, n) => n.color,
      offset: !1,
    },
    border: { display: !0, dash: [], dashOffset: 0, width: 1 },
    title: { display: !1, text: '', padding: { top: 4, bottom: 4 } },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: '',
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: cp.formatters.values,
      minor: {},
      major: {},
      align: 'center',
      crossAlign: 'near',
      showLabelBackdrop: !1,
      backdropColor: 'rgba(255, 255, 255, 0.75)',
      backdropPadding: 2,
    },
  }),
    e.route('scale.ticks', 'color', '', 'color'),
    e.route('scale.grid', 'color', '', 'borderColor'),
    e.route('scale.border', 'color', '', 'borderColor'),
    e.route('scale.title', 'color', '', 'color'),
    e.describe('scale', {
      _fallback: !1,
      _scriptable: (t) =>
        !t.startsWith('before') && !t.startsWith('after') && t !== 'callback' && t !== 'parser',
      _indexable: (t) => t !== 'borderDash' && t !== 'tickBorderDash' && t !== 'dash',
    }),
    e.describe('scales', { _fallback: 'scale' }),
    e.describe('scale.ticks', {
      _scriptable: (t) => t !== 'backdropPadding' && t !== 'callback',
      _indexable: (t) => t !== 'backdropPadding',
    }))
}
const Cs = Object.create(null),
  uf = Object.create(null)
function $a(e, t) {
  if (!t) return e
  const n = t.split('.')
  for (let r = 0, i = n.length; r < i; ++r) {
    const o = n[r]
    e = e[o] || (e[o] = Object.create(null))
  }
  return e
}
function Od(e, t, n) {
  return typeof t == 'string' ? kl($a(e, t), n) : kl($a(e, ''), t)
}
class y9 {
  constructor(t, n) {
    ;((this.animation = void 0),
      (this.backgroundColor = 'rgba(0,0,0,0.1)'),
      (this.borderColor = 'rgba(0,0,0,0.1)'),
      (this.color = '#666'),
      (this.datasets = {}),
      (this.devicePixelRatio = (r) => r.chart.platform.getDevicePixelRatio()),
      (this.elements = {}),
      (this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove']),
      (this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: 'normal',
        lineHeight: 1.2,
        weight: null,
      }),
      (this.hover = {}),
      (this.hoverBackgroundColor = (r, i) => Ld(i.backgroundColor)),
      (this.hoverBorderColor = (r, i) => Ld(i.borderColor)),
      (this.hoverColor = (r, i) => Ld(i.color)),
      (this.indexAxis = 'x'),
      (this.interaction = { mode: 'nearest', intersect: !0, includeInvisible: !1 }),
      (this.maintainAspectRatio = !0),
      (this.onHover = null),
      (this.onClick = null),
      (this.parsing = !0),
      (this.plugins = {}),
      (this.responsive = !0),
      (this.scale = void 0),
      (this.scales = {}),
      (this.showLine = !0),
      (this.drawActiveElementsOnTop = !0),
      this.describe(t),
      this.apply(n))
  }
  set(t, n) {
    return Od(this, t, n)
  }
  get(t) {
    return $a(this, t)
  }
  describe(t, n) {
    return Od(uf, t, n)
  }
  override(t, n) {
    return Od(Cs, t, n)
  }
  route(t, n, r, i) {
    const o = $a(this, t),
      c = $a(this, r),
      h = '_' + n
    Object.defineProperties(o, {
      [h]: { value: o[n], writable: !0 },
      [n]: {
        enumerable: !0,
        get() {
          const f = this[h],
            p = c[i]
          return Me(f) ? Object.assign({}, p, f) : _e(f, p)
        },
        set(f) {
          this[h] = f
        },
      },
    })
  }
  apply(t) {
    t.forEach((n) => n(this))
  }
}
var bt = new y9(
  {
    _scriptable: (e) => !e.startsWith('on'),
    _indexable: (e) => e !== 'events',
    hover: { _fallback: 'interaction' },
    interaction: { _scriptable: !1, _indexable: !1 },
  },
  [h9, d9, m9]
)
function w9(e) {
  return !e || Oe(e.size) || Oe(e.family)
    ? null
    : (e.style ? e.style + ' ' : '') + (e.weight ? e.weight + ' ' : '') + e.size + 'px ' + e.family
}
function Vu(e, t, n, r, i) {
  let o = t[i]
  return (o || ((o = t[i] = e.measureText(i).width), n.push(i)), o > r && (r = o), r)
}
function b9(e, t, n, r) {
  r = r || {}
  let i = (r.data = r.data || {}),
    o = (r.garbageCollect = r.garbageCollect || [])
  ;(r.font !== t && ((i = r.data = {}), (o = r.garbageCollect = []), (r.font = t)),
    e.save(),
    (e.font = t))
  let c = 0
  const h = n.length
  let f, p, y, w, x
  for (f = 0; f < h; f++)
    if (((w = n[f]), w != null && !ct(w))) c = Vu(e, i, o, c, w)
    else if (ct(w))
      for (p = 0, y = w.length; p < y; p++)
        ((x = w[p]), x != null && !ct(x) && (c = Vu(e, i, o, c, x)))
  e.restore()
  const E = o.length / 2
  if (E > n.length) {
    for (f = 0; f < E; f++) delete i[o[f]]
    o.splice(0, E)
  }
  return c
}
function Qi(e, t, n) {
  const r = e.currentDevicePixelRatio,
    i = n !== 0 ? Math.max(n / 2, 0.5) : 0
  return Math.round((t - i) * r) / r + i
}
function Tm(e, t) {
  ;(!t && !e) ||
    ((t = t || e.getContext('2d')),
    t.save(),
    t.resetTransform(),
    t.clearRect(0, 0, e.width, e.height),
    t.restore())
}
function hf(e, t, n, r) {
  p3(e, t, n, r, null)
}
function p3(e, t, n, r, i) {
  let o, c, h, f, p, y, w, x
  const E = t.pointStyle,
    S = t.rotation,
    k = t.radius
  let P = (S || 0) * Zk
  if (
    E &&
    typeof E == 'object' &&
    ((o = E.toString()), o === '[object HTMLImageElement]' || o === '[object HTMLCanvasElement]')
  ) {
    ;(e.save(),
      e.translate(n, r),
      e.rotate(P),
      e.drawImage(E, -E.width / 2, -E.height / 2, E.width, E.height),
      e.restore())
    return
  }
  if (!(isNaN(k) || k <= 0)) {
    switch ((e.beginPath(), E)) {
      default:
        ;(i ? e.ellipse(n, r, i / 2, k, 0, 0, Ln) : e.arc(n, r, k, 0, Ln), e.closePath())
        break
      case 'triangle':
        ;((y = i ? i / 2 : k),
          e.moveTo(n + Math.sin(P) * y, r - Math.cos(P) * k),
          (P += Em),
          e.lineTo(n + Math.sin(P) * y, r - Math.cos(P) * k),
          (P += Em),
          e.lineTo(n + Math.sin(P) * y, r - Math.cos(P) * k),
          e.closePath())
        break
      case 'rectRounded':
        ;((p = k * 0.516),
          (f = k - p),
          (c = Math.cos(P + qi) * f),
          (w = Math.cos(P + qi) * (i ? i / 2 - p : f)),
          (h = Math.sin(P + qi) * f),
          (x = Math.sin(P + qi) * (i ? i / 2 - p : f)),
          e.arc(n - w, r - h, p, P - Ot, P - Rn),
          e.arc(n + x, r - c, p, P - Rn, P),
          e.arc(n + w, r + h, p, P, P + Rn),
          e.arc(n - x, r + c, p, P + Rn, P + Ot),
          e.closePath())
        break
      case 'rect':
        if (!S) {
          ;((f = Math.SQRT1_2 * k), (y = i ? i / 2 : f), e.rect(n - y, r - f, 2 * y, 2 * f))
          break
        }
        P += qi
      case 'rectRot':
        ;((w = Math.cos(P) * (i ? i / 2 : k)),
          (c = Math.cos(P) * k),
          (h = Math.sin(P) * k),
          (x = Math.sin(P) * (i ? i / 2 : k)),
          e.moveTo(n - w, r - h),
          e.lineTo(n + x, r - c),
          e.lineTo(n + w, r + h),
          e.lineTo(n - x, r + c),
          e.closePath())
        break
      case 'crossRot':
        P += qi
      case 'cross':
        ;((w = Math.cos(P) * (i ? i / 2 : k)),
          (c = Math.cos(P) * k),
          (h = Math.sin(P) * k),
          (x = Math.sin(P) * (i ? i / 2 : k)),
          e.moveTo(n - w, r - h),
          e.lineTo(n + w, r + h),
          e.moveTo(n + x, r - c),
          e.lineTo(n - x, r + c))
        break
      case 'star':
        ;((w = Math.cos(P) * (i ? i / 2 : k)),
          (c = Math.cos(P) * k),
          (h = Math.sin(P) * k),
          (x = Math.sin(P) * (i ? i / 2 : k)),
          e.moveTo(n - w, r - h),
          e.lineTo(n + w, r + h),
          e.moveTo(n + x, r - c),
          e.lineTo(n - x, r + c),
          (P += qi),
          (w = Math.cos(P) * (i ? i / 2 : k)),
          (c = Math.cos(P) * k),
          (h = Math.sin(P) * k),
          (x = Math.sin(P) * (i ? i / 2 : k)),
          e.moveTo(n - w, r - h),
          e.lineTo(n + w, r + h),
          e.moveTo(n + x, r - c),
          e.lineTo(n - x, r + c))
        break
      case 'line':
        ;((c = i ? i / 2 : Math.cos(P) * k),
          (h = Math.sin(P) * k),
          e.moveTo(n - c, r - h),
          e.lineTo(n + c, r + h))
        break
      case 'dash':
        ;(e.moveTo(n, r), e.lineTo(n + Math.cos(P) * (i ? i / 2 : k), r + Math.sin(P) * k))
        break
      case !1:
        e.closePath()
        break
    }
    ;(e.fill(), t.borderWidth > 0 && e.stroke())
  }
}
function Vr(e, t, n) {
  return (
    (n = n || 0.5),
    !t || (e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n)
  )
}
function xh(e, t) {
  ;(e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip())
}
function Eh(e) {
  e.restore()
}
function v9(e, t, n, r, i) {
  if (!t) return e.lineTo(n.x, n.y)
  if (i === 'middle') {
    const o = (t.x + n.x) / 2
    ;(e.lineTo(o, t.y), e.lineTo(o, n.y))
  } else (i === 'after') != !!r ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y)
  e.lineTo(n.x, n.y)
}
function x9(e, t, n, r) {
  if (!t) return e.lineTo(n.x, n.y)
  e.bezierCurveTo(
    r ? t.cp1x : t.cp2x,
    r ? t.cp1y : t.cp2y,
    r ? n.cp2x : n.cp1x,
    r ? n.cp2y : n.cp1y,
    n.x,
    n.y
  )
}
function E9(e, t) {
  ;(t.translation && e.translate(t.translation[0], t.translation[1]),
    Oe(t.rotation) || e.rotate(t.rotation),
    t.color && (e.fillStyle = t.color),
    t.textAlign && (e.textAlign = t.textAlign),
    t.textBaseline && (e.textBaseline = t.textBaseline))
}
function C9(e, t, n, r, i) {
  if (i.strikethrough || i.underline) {
    const o = e.measureText(r),
      c = t - o.actualBoundingBoxLeft,
      h = t + o.actualBoundingBoxRight,
      f = n - o.actualBoundingBoxAscent,
      p = n + o.actualBoundingBoxDescent,
      y = i.strikethrough ? (f + p) / 2 : p
    ;((e.strokeStyle = e.fillStyle),
      e.beginPath(),
      (e.lineWidth = i.decorationWidth || 2),
      e.moveTo(c, y),
      e.lineTo(h, y),
      e.stroke())
  }
}
function S9(e, t) {
  const n = e.fillStyle
  ;((e.fillStyle = t.color), e.fillRect(t.left, t.top, t.width, t.height), (e.fillStyle = n))
}
function Uo(e, t, n, r, i, o = {}) {
  const c = ct(t) ? t : [t],
    h = o.strokeWidth > 0 && o.strokeColor !== ''
  let f, p
  for (e.save(), e.font = i.string, E9(e, o), f = 0; f < c.length; ++f)
    ((p = c[f]),
      o.backdrop && S9(e, o.backdrop),
      h &&
        (o.strokeColor && (e.strokeStyle = o.strokeColor),
        Oe(o.strokeWidth) || (e.lineWidth = o.strokeWidth),
        e.strokeText(p, n, r, o.maxWidth)),
      e.fillText(p, n, r, o.maxWidth),
      C9(e, n, r, p, o),
      (r += Number(i.lineHeight)))
  e.restore()
}
function Nl(e, t) {
  const { x: n, y: r, w: i, h: o, radius: c } = t
  ;(e.arc(n + c.topLeft, r + c.topLeft, c.topLeft, 1.5 * Ot, Ot, !0),
    e.lineTo(n, r + o - c.bottomLeft),
    e.arc(n + c.bottomLeft, r + o - c.bottomLeft, c.bottomLeft, Ot, Rn, !0),
    e.lineTo(n + i - c.bottomRight, r + o),
    e.arc(n + i - c.bottomRight, r + o - c.bottomRight, c.bottomRight, Rn, 0, !0),
    e.lineTo(n + i, r + c.topRight),
    e.arc(n + i - c.topRight, r + c.topRight, c.topRight, 0, -Rn, !0),
    e.lineTo(n + c.topLeft, r))
}
const A9 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
  k9 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/
function _9(e, t) {
  const n = ('' + e).match(A9)
  if (!n || n[1] === 'normal') return t * 1.2
  switch (((e = +n[2]), n[3])) {
    case 'px':
      return e
    case '%':
      e /= 100
      break
  }
  return t * e
}
const I9 = (e) => +e || 0
function g3(e, t) {
  const n = {},
    r = Me(t),
    i = r ? Object.keys(t) : t,
    o = Me(e) ? (r ? (c) => _e(e[c], e[t[c]]) : (c) => e[c]) : () => e
  for (const c of i) n[c] = I9(o(c))
  return n
}
function m3(e) {
  return g3(e, { top: 'y', right: 'x', bottom: 'y', left: 'x' })
}
function fs(e) {
  return g3(e, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'])
}
function on(e) {
  const t = m3(e)
  return ((t.width = t.left + t.right), (t.height = t.top + t.bottom), t)
}
function Ht(e, t) {
  ;((e = e || {}), (t = t || bt.font))
  let n = _e(e.size, t.size)
  typeof n == 'string' && (n = parseInt(n, 10))
  let r = _e(e.style, t.style)
  r &&
    !('' + r).match(k9) &&
    (console.warn('Invalid font style specified: "' + r + '"'), (r = void 0))
  const i = {
    family: _e(e.family, t.family),
    lineHeight: _9(_e(e.lineHeight, t.lineHeight), n),
    size: n,
    style: r,
    weight: _e(e.weight, t.weight),
    string: '',
  }
  return ((i.string = w9(i)), i)
}
function kc(e, t, n, r) {
  let i, o, c
  for (i = 0, o = e.length; i < o; ++i) if (((c = e[i]), c !== void 0 && c !== void 0)) return c
}
function N9(e, t, n) {
  const { min: r, max: i } = e,
    o = Uk(t, (i - r) / 2),
    c = (h, f) => (n && h === 0 ? 0 : h + f)
  return { min: c(r, -Math.abs(o)), max: c(i, o) }
}
function Wi(e, t) {
  return Object.assign(Object.create(e), t)
}
function up(e, t = [''], n, r, i = () => e[0]) {
  const o = n || e
  typeof r > 'u' && (r = v3('_fallback', e))
  const c = {
    [Symbol.toStringTag]: 'Object',
    _cacheable: !0,
    _scopes: e,
    _rootScopes: o,
    _fallback: r,
    _getTarget: i,
    override: (h) => up([h, ...e], t, o, r),
  }
  return new Proxy(c, {
    deleteProperty(h, f) {
      return (delete h[f], delete h._keys, delete e[0][f], !0)
    },
    get(h, f) {
      return w3(h, f, () => B9(f, t, e, h))
    },
    getOwnPropertyDescriptor(h, f) {
      return Reflect.getOwnPropertyDescriptor(h._scopes[0], f)
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0])
    },
    has(h, f) {
      return Mm(h).includes(f)
    },
    ownKeys(h) {
      return Mm(h)
    },
    set(h, f, p) {
      const y = h._storage || (h._storage = i())
      return ((h[f] = y[f] = p), delete h._keys, !0)
    },
  })
}
function Wo(e, t, n, r) {
  const i = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: n,
    _stack: new Set(),
    _descriptors: y3(e, r),
    setContext: (o) => Wo(e, o, n, r),
    override: (o) => Wo(e.override(o), t, n, r),
  }
  return new Proxy(i, {
    deleteProperty(o, c) {
      return (delete o[c], delete e[c], !0)
    },
    get(o, c, h) {
      return w3(o, c, () => R9(o, c, h))
    },
    getOwnPropertyDescriptor(o, c) {
      return o._descriptors.allKeys
        ? Reflect.has(e, c)
          ? { enumerable: !0, configurable: !0 }
          : void 0
        : Reflect.getOwnPropertyDescriptor(e, c)
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e)
    },
    has(o, c) {
      return Reflect.has(e, c)
    },
    ownKeys() {
      return Reflect.ownKeys(e)
    },
    set(o, c, h) {
      return ((e[c] = h), delete o[c], !0)
    },
  })
}
function y3(e, t = { scriptable: !0, indexable: !0 }) {
  const { _scriptable: n = t.scriptable, _indexable: r = t.indexable, _allKeys: i = t.allKeys } = e
  return {
    allKeys: i,
    scriptable: n,
    indexable: r,
    isScriptable: Oi(n) ? n : () => n,
    isIndexable: Oi(r) ? r : () => r,
  }
}
const T9 = (e, t) => (e ? e + sp(t) : t),
  hp = (e, t) =>
    Me(t) && e !== 'adapters' && (Object.getPrototypeOf(t) === null || t.constructor === Object)
function w3(e, t, n) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === 'constructor') return e[t]
  const r = n()
  return ((e[t] = r), r)
}
function R9(e, t, n) {
  const { _proxy: r, _context: i, _subProxy: o, _descriptors: c } = e
  let h = r[t]
  return (
    Oi(h) && c.isScriptable(t) && (h = M9(t, h, e, n)),
    ct(h) && h.length && (h = P9(t, h, e, c.isIndexable)),
    hp(t, h) && (h = Wo(h, i, o && o[t], c)),
    h
  )
}
function M9(e, t, n, r) {
  const { _proxy: i, _context: o, _subProxy: c, _stack: h } = n
  if (h.has(e)) throw new Error('Recursion detected: ' + Array.from(h).join('->') + '->' + e)
  h.add(e)
  let f = t(o, c || r)
  return (h.delete(e), hp(e, f) && (f = dp(i._scopes, i, e, f)), f)
}
function P9(e, t, n, r) {
  const { _proxy: i, _context: o, _subProxy: c, _descriptors: h } = n
  if (typeof o.index < 'u' && r(e)) return t[o.index % t.length]
  if (Me(t[0])) {
    const f = t,
      p = i._scopes.filter((y) => y !== f)
    t = []
    for (const y of f) {
      const w = dp(p, i, e, y)
      t.push(Wo(w, o, c && c[e], h))
    }
  }
  return t
}
function b3(e, t, n) {
  return Oi(e) ? e(t, n) : e
}
const D9 = (e, t) => (e === !0 ? t : typeof e == 'string' ? Es(t, e) : void 0)
function L9(e, t, n, r, i) {
  for (const o of t) {
    const c = D9(n, o)
    if (c) {
      e.add(c)
      const h = b3(c._fallback, n, i)
      if (typeof h < 'u' && h !== n && h !== r) return h
    } else if (c === !1 && typeof r < 'u' && n !== r) return null
  }
  return !1
}
function dp(e, t, n, r) {
  const i = t._rootScopes,
    o = b3(t._fallback, n, r),
    c = [...e, ...i],
    h = new Set()
  h.add(r)
  let f = Rm(h, c, n, o || n, r)
  return f === null || (typeof o < 'u' && o !== n && ((f = Rm(h, c, o, f, r)), f === null))
    ? !1
    : up(Array.from(h), [''], i, o, () => O9(t, n, r))
}
function Rm(e, t, n, r, i) {
  for (; n; ) n = L9(e, t, n, r, i)
  return n
}
function O9(e, t, n) {
  const r = e._getTarget()
  t in r || (r[t] = {})
  const i = r[t]
  return ct(i) && Me(n) ? n : i || {}
}
function B9(e, t, n, r) {
  let i
  for (const o of t)
    if (((i = v3(T9(o, e), n)), typeof i < 'u')) return hp(e, i) ? dp(n, r, e, i) : i
}
function v3(e, t) {
  for (const n of t) {
    if (!n) continue
    const r = n[e]
    if (typeof r < 'u') return r
  }
}
function Mm(e) {
  let t = e._keys
  return (t || (t = e._keys = F9(e._scopes)), t)
}
function F9(e) {
  const t = new Set()
  for (const n of e) for (const r of Object.keys(n).filter((i) => !i.startsWith('_'))) t.add(r)
  return Array.from(t)
}
function j9(e, t, n, r) {
  const { iScale: i } = e,
    { key: o = 'r' } = this._parsing,
    c = new Array(r)
  let h, f, p, y
  for (h = 0, f = r; h < f; ++h) ((p = h + n), (y = t[p]), (c[h] = { r: i.parse(Es(y, o), p) }))
  return c
}
const V9 = Number.EPSILON || 1e-14,
  zo = (e, t) => t < e.length && !e[t].skip && e[t],
  x3 = (e) => (e === 'x' ? 'y' : 'x')
function U9(e, t, n, r) {
  const i = e.skip ? t : e,
    o = t,
    c = n.skip ? t : n,
    h = cf(o, i),
    f = cf(c, o)
  let p = h / (h + f),
    y = f / (h + f)
  ;((p = isNaN(p) ? 0 : p), (y = isNaN(y) ? 0 : y))
  const w = r * p,
    x = r * y
  return {
    previous: { x: o.x - w * (c.x - i.x), y: o.y - w * (c.y - i.y) },
    next: { x: o.x + x * (c.x - i.x), y: o.y + x * (c.y - i.y) },
  }
}
function W9(e, t, n) {
  const r = e.length
  let i,
    o,
    c,
    h,
    f,
    p = zo(e, 0)
  for (let y = 0; y < r - 1; ++y)
    if (((f = p), (p = zo(e, y + 1)), !(!f || !p))) {
      if (qa(t[y], 0, V9)) {
        n[y] = n[y + 1] = 0
        continue
      }
      ;((i = n[y] / t[y]),
        (o = n[y + 1] / t[y]),
        (h = Math.pow(i, 2) + Math.pow(o, 2)),
        !(h <= 9) && ((c = 3 / Math.sqrt(h)), (n[y] = i * c * t[y]), (n[y + 1] = o * c * t[y])))
    }
}
function z9(e, t, n = 'x') {
  const r = x3(n),
    i = e.length
  let o,
    c,
    h,
    f = zo(e, 0)
  for (let p = 0; p < i; ++p) {
    if (((c = h), (h = f), (f = zo(e, p + 1)), !h)) continue
    const y = h[n],
      w = h[r]
    ;(c && ((o = (y - c[n]) / 3), (h[`cp1${n}`] = y - o), (h[`cp1${r}`] = w - o * t[p])),
      f && ((o = (f[n] - y) / 3), (h[`cp2${n}`] = y + o), (h[`cp2${r}`] = w + o * t[p])))
  }
}
function H9(e, t = 'x') {
  const n = x3(t),
    r = e.length,
    i = Array(r).fill(0),
    o = Array(r)
  let c,
    h,
    f,
    p = zo(e, 0)
  for (c = 0; c < r; ++c)
    if (((h = f), (f = p), (p = zo(e, c + 1)), !!f)) {
      if (p) {
        const y = p[t] - f[t]
        i[c] = y !== 0 ? (p[n] - f[n]) / y : 0
      }
      o[c] = h ? (p ? (Nr(i[c - 1]) !== Nr(i[c]) ? 0 : (i[c - 1] + i[c]) / 2) : i[c - 1]) : i[c]
    }
  ;(W9(e, i, o), z9(e, o, t))
}
function _c(e, t, n) {
  return Math.max(Math.min(e, n), t)
}
function X9(e, t) {
  let n,
    r,
    i,
    o,
    c,
    h = Vr(e[0], t)
  for (n = 0, r = e.length; n < r; ++n)
    ((c = o),
      (o = h),
      (h = n < r - 1 && Vr(e[n + 1], t)),
      o &&
        ((i = e[n]),
        c && ((i.cp1x = _c(i.cp1x, t.left, t.right)), (i.cp1y = _c(i.cp1y, t.top, t.bottom))),
        h && ((i.cp2x = _c(i.cp2x, t.left, t.right)), (i.cp2y = _c(i.cp2y, t.top, t.bottom)))))
}
function G9(e, t, n, r, i) {
  let o, c, h, f
  if ((t.spanGaps && (e = e.filter((p) => !p.skip)), t.cubicInterpolationMode === 'monotone'))
    H9(e, i)
  else {
    let p = r ? e[e.length - 1] : e[0]
    for (o = 0, c = e.length; o < c; ++o)
      ((h = e[o]),
        (f = U9(p, h, e[Math.min(o + 1, c - (r ? 0 : 1)) % c], t.tension)),
        (h.cp1x = f.previous.x),
        (h.cp1y = f.previous.y),
        (h.cp2x = f.next.x),
        (h.cp2y = f.next.y),
        (p = h))
  }
  t.capBezierPoints && X9(e, n)
}
function fp() {
  return typeof window < 'u' && typeof document < 'u'
}
function pp(e) {
  let t = e.parentNode
  return (t && t.toString() === '[object ShadowRoot]' && (t = t.host), t)
}
function Uu(e, t, n) {
  let r
  return (
    typeof e == 'string'
      ? ((r = parseInt(e, 10)), e.indexOf('%') !== -1 && (r = (r / 100) * t.parentNode[n]))
      : (r = e),
    r
  )
}
const Ch = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null)
function Y9(e, t) {
  return Ch(e).getPropertyValue(t)
}
const Z9 = ['top', 'right', 'bottom', 'left']
function ps(e, t, n) {
  const r = {}
  n = n ? '-' + n : ''
  for (let i = 0; i < 4; i++) {
    const o = Z9[i]
    r[o] = parseFloat(e[t + '-' + o + n]) || 0
  }
  return ((r.width = r.left + r.right), (r.height = r.top + r.bottom), r)
}
const K9 = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot)
function q9(e, t) {
  const n = e.touches,
    r = n && n.length ? n[0] : e,
    { offsetX: i, offsetY: o } = r
  let c = !1,
    h,
    f
  if (K9(i, o, e.target)) ((h = i), (f = o))
  else {
    const p = t.getBoundingClientRect()
    ;((h = r.clientX - p.left), (f = r.clientY - p.top), (c = !0))
  }
  return { x: h, y: f, box: c }
}
function rs(e, t) {
  if ('native' in e) return e
  const { canvas: n, currentDevicePixelRatio: r } = t,
    i = Ch(n),
    o = i.boxSizing === 'border-box',
    c = ps(i, 'padding'),
    h = ps(i, 'border', 'width'),
    { x: f, y: p, box: y } = q9(e, n),
    w = c.left + (y && h.left),
    x = c.top + (y && h.top)
  let { width: E, height: S } = t
  return (
    o && ((E -= c.width + h.width), (S -= c.height + h.height)),
    { x: Math.round((((f - w) / E) * n.width) / r), y: Math.round((((p - x) / S) * n.height) / r) }
  )
}
function Q9(e, t, n) {
  let r, i
  if (t === void 0 || n === void 0) {
    const o = e && pp(e)
    if (!o) ((t = e.clientWidth), (n = e.clientHeight))
    else {
      const c = o.getBoundingClientRect(),
        h = Ch(o),
        f = ps(h, 'border', 'width'),
        p = ps(h, 'padding')
      ;((t = c.width - p.width - f.width),
        (n = c.height - p.height - f.height),
        (r = Uu(h.maxWidth, o, 'clientWidth')),
        (i = Uu(h.maxHeight, o, 'clientHeight')))
    }
  }
  return { width: t, height: n, maxWidth: r || ju, maxHeight: i || ju }
}
const bi = (e) => Math.round(e * 10) / 10
function $9(e, t, n, r) {
  const i = Ch(e),
    o = ps(i, 'margin'),
    c = Uu(i.maxWidth, e, 'clientWidth') || ju,
    h = Uu(i.maxHeight, e, 'clientHeight') || ju,
    f = Q9(e, t, n)
  let { width: p, height: y } = f
  if (i.boxSizing === 'content-box') {
    const w = ps(i, 'border', 'width'),
      x = ps(i, 'padding')
    ;((p -= x.width + w.width), (y -= x.height + w.height))
  }
  return (
    (p = Math.max(0, p - o.width)),
    (y = Math.max(0, r ? p / r : y - o.height)),
    (p = bi(Math.min(p, c, f.maxWidth))),
    (y = bi(Math.min(y, h, f.maxHeight))),
    p && !y && (y = bi(p / 2)),
    (t !== void 0 || n !== void 0) &&
      r &&
      f.height &&
      y > f.height &&
      ((y = f.height), (p = bi(Math.floor(y * r)))),
    { width: p, height: y }
  )
}
function Pm(e, t, n) {
  const r = t || 1,
    i = bi(e.height * r),
    o = bi(e.width * r)
  ;((e.height = bi(e.height)), (e.width = bi(e.width)))
  const c = e.canvas
  return (
    c.style &&
      (n || (!c.style.height && !c.style.width)) &&
      ((c.style.height = `${e.height}px`), (c.style.width = `${e.width}px`)),
    e.currentDevicePixelRatio !== r || c.height !== i || c.width !== o
      ? ((e.currentDevicePixelRatio = r),
        (c.height = i),
        (c.width = o),
        e.ctx.setTransform(r, 0, 0, r, 0, 0),
        !0)
      : !1
  )
}
const J9 = (function () {
  let e = !1
  try {
    const t = {
      get passive() {
        return ((e = !0), !1)
      },
    }
    fp() && (window.addEventListener('test', null, t), window.removeEventListener('test', null, t))
  } catch {}
  return e
})()
function Dm(e, t) {
  const n = Y9(e, t),
    r = n && n.match(/^(\d+)(\.\d+)?px$/)
  return r ? +r[1] : void 0
}
function is(e, t, n, r) {
  return { x: e.x + n * (t.x - e.x), y: e.y + n * (t.y - e.y) }
}
function e_(e, t, n, r) {
  return {
    x: e.x + n * (t.x - e.x),
    y:
      r === 'middle'
        ? n < 0.5
          ? e.y
          : t.y
        : r === 'after'
          ? n < 1
            ? e.y
            : t.y
          : n > 0
            ? t.y
            : e.y,
  }
}
function t_(e, t, n, r) {
  const i = { x: e.cp2x, y: e.cp2y },
    o = { x: t.cp1x, y: t.cp1y },
    c = is(e, i, n),
    h = is(i, o, n),
    f = is(o, t, n),
    p = is(c, h, n),
    y = is(h, f, n)
  return is(p, y, n)
}
const n_ = function (e, t) {
    return {
      x(n) {
        return e + e + t - n
      },
      setWidth(n) {
        t = n
      },
      textAlign(n) {
        return n === 'center' ? n : n === 'right' ? 'left' : 'right'
      },
      xPlus(n, r) {
        return n - r
      },
      leftForLtr(n, r) {
        return n - r
      },
    }
  },
  r_ = function () {
    return {
      x(e) {
        return e
      },
      setWidth(e) {},
      textAlign(e) {
        return e
      },
      xPlus(e, t) {
        return e + t
      },
      leftForLtr(e, t) {
        return e
      },
    }
  }
function No(e, t, n) {
  return e ? n_(t, n) : r_()
}
function E3(e, t) {
  let n, r
  ;(t === 'ltr' || t === 'rtl') &&
    ((n = e.canvas.style),
    (r = [n.getPropertyValue('direction'), n.getPropertyPriority('direction')]),
    n.setProperty('direction', t, 'important'),
    (e.prevTextDirection = r))
}
function C3(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty('direction', t[0], t[1]))
}
function S3(e) {
  return e === 'angle'
    ? { between: a3, compare: e9, normalize: Nn }
    : { between: wi, compare: (t, n) => t - n, normalize: (t) => t }
}
function Lm({ start: e, end: t, count: n, loop: r, style: i }) {
  return { start: e % n, end: t % n, loop: r && (t - e + 1) % n === 0, style: i }
}
function i_(e, t, n) {
  const { property: r, start: i, end: o } = n,
    { between: c, normalize: h } = S3(r),
    f = t.length
  let { start: p, end: y, loop: w } = e,
    x,
    E
  if (w) {
    for (p += f, y += f, x = 0, E = f; x < E && c(h(t[p % f][r]), i, o); ++x) (p--, y--)
    ;((p %= f), (y %= f))
  }
  return (y < p && (y += f), { start: p, end: y, loop: w, style: e.style })
}
function A3(e, t, n) {
  if (!n) return [e]
  const { property: r, start: i, end: o } = n,
    c = t.length,
    { compare: h, between: f, normalize: p } = S3(r),
    { start: y, end: w, loop: x, style: E } = i_(e, t, n),
    S = []
  let k = !1,
    P = null,
    I,
    R,
    M
  const O = () => f(i, M, I) && h(i, M) !== 0,
    F = () => h(o, I) === 0 || f(o, M, I),
    z = () => k || O(),
    V = () => !k || F()
  for (let U = y, Z = y; U <= w; ++U)
    ((R = t[U % c]),
      !R.skip &&
        ((I = p(R[r])),
        I !== M &&
          ((k = f(I, i, o)),
          P === null && z() && (P = h(I, i) === 0 ? U : Z),
          P !== null &&
            V() &&
            (S.push(Lm({ start: P, end: U, loop: x, count: c, style: E })), (P = null)),
          (Z = U),
          (M = I))))
  return (P !== null && S.push(Lm({ start: P, end: w, loop: x, count: c, style: E })), S)
}
function k3(e, t) {
  const n = [],
    r = e.segments
  for (let i = 0; i < r.length; i++) {
    const o = A3(r[i], e.points, t)
    o.length && n.push(...o)
  }
  return n
}
function s_(e, t, n, r) {
  let i = 0,
    o = t - 1
  if (n && !r) for (; i < t && !e[i].skip; ) i++
  for (; i < t && e[i].skip; ) i++
  for (i %= t, n && (o += i); o > i && e[o % t].skip; ) o--
  return ((o %= t), { start: i, end: o })
}
function o_(e, t, n, r) {
  const i = e.length,
    o = []
  let c = t,
    h = e[t],
    f
  for (f = t + 1; f <= n; ++f) {
    const p = e[f % i]
    ;(p.skip || p.stop
      ? h.skip ||
        ((r = !1), o.push({ start: t % i, end: (f - 1) % i, loop: r }), (t = c = p.stop ? f : null))
      : ((c = f), h.skip && (t = f)),
      (h = p))
  }
  return (c !== null && o.push({ start: t % i, end: c % i, loop: r }), o)
}
function a_(e, t) {
  const n = e.points,
    r = e.options.spanGaps,
    i = n.length
  if (!i) return []
  const o = !!e._loop,
    { start: c, end: h } = s_(n, i, o, r)
  if (r === !0) return Om(e, [{ start: c, end: h, loop: o }], n, t)
  const f = h < c ? h + i : h,
    p = !!e._fullLoop && c === 0 && h === i - 1
  return Om(e, o_(n, c, f, p), n, t)
}
function Om(e, t, n, r) {
  return !r || !r.setContext || !n ? t : l_(e, t, n, r)
}
function l_(e, t, n, r) {
  const i = e._chart.getContext(),
    o = Bm(e.options),
    {
      _datasetIndex: c,
      options: { spanGaps: h },
    } = e,
    f = n.length,
    p = []
  let y = o,
    w = t[0].start,
    x = w
  function E(S, k, P, I) {
    const R = h ? -1 : 1
    if (S !== k) {
      for (S += f; n[S % f].skip; ) S -= R
      for (; n[k % f].skip; ) k += R
      S % f !== k % f &&
        (p.push({ start: S % f, end: k % f, loop: P, style: I }), (y = I), (w = k % f))
    }
  }
  for (const S of t) {
    w = h ? w : S.start
    let k = n[w % f],
      P
    for (x = w + 1; x <= S.end; x++) {
      const I = n[x % f]
      ;((P = Bm(
        r.setContext(
          Wi(i, {
            type: 'segment',
            p0: k,
            p1: I,
            p0DataIndex: (x - 1) % f,
            p1DataIndex: x % f,
            datasetIndex: c,
          })
        )
      )),
        c_(P, y) && E(w, x - 1, S.loop, y),
        (k = I),
        (y = P))
    }
    w < x - 1 && E(w, x - 1, S.loop, y)
  }
  return p
}
function Bm(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor,
  }
}
function c_(e, t) {
  if (!t) return !1
  const n = [],
    r = function (i, o) {
      return lp(o) ? (n.includes(o) || n.push(o), n.indexOf(o)) : o
    }
  return JSON.stringify(e, r) !== JSON.stringify(t, r)
}
function Ic(e, t, n) {
  return e.options.clip ? e[n] : t[n]
}
function u_(e, t) {
  const { xScale: n, yScale: r } = e
  return n && r
    ? {
        left: Ic(n, t, 'left'),
        right: Ic(n, t, 'right'),
        top: Ic(r, t, 'top'),
        bottom: Ic(r, t, 'bottom'),
      }
    : t
}
function _3(e, t) {
  const n = t._clip
  if (n.disabled) return !1
  const r = u_(t, e.chartArea)
  return {
    left: n.left === !1 ? 0 : r.left - (n.left === !0 ? 0 : n.left),
    right: n.right === !1 ? e.width : r.right + (n.right === !0 ? 0 : n.right),
    top: n.top === !1 ? 0 : r.top - (n.top === !0 ? 0 : n.top),
    bottom: n.bottom === !1 ? e.height : r.bottom + (n.bottom === !0 ? 0 : n.bottom),
  }
}
/*!
 * Chart.js v4.5.1
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */ class h_ {
  constructor() {
    ;((this._request = null),
      (this._charts = new Map()),
      (this._running = !1),
      (this._lastDate = void 0))
  }
  _notify(t, n, r, i) {
    const o = n.listeners[i],
      c = n.duration
    o.forEach((h) =>
      h({ chart: t, initial: n.initial, numSteps: c, currentStep: Math.min(r - n.start, c) })
    )
  }
  _refresh() {
    this._request ||
      ((this._running = !0),
      (this._request = u3.call(window, () => {
        ;(this._update(), (this._request = null), this._running && this._refresh())
      })))
  }
  _update(t = Date.now()) {
    let n = 0
    ;(this._charts.forEach((r, i) => {
      if (!r.running || !r.items.length) return
      const o = r.items
      let c = o.length - 1,
        h = !1,
        f
      for (; c >= 0; --c)
        ((f = o[c]),
          f._active
            ? (f._total > r.duration && (r.duration = f._total), f.tick(t), (h = !0))
            : ((o[c] = o[o.length - 1]), o.pop()))
      ;(h && (i.draw(), this._notify(i, r, t, 'progress')),
        o.length || ((r.running = !1), this._notify(i, r, t, 'complete'), (r.initial = !1)),
        (n += o.length))
    }),
      (this._lastDate = t),
      n === 0 && (this._running = !1))
  }
  _getAnims(t) {
    const n = this._charts
    let r = n.get(t)
    return (
      r ||
        ((r = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }),
        n.set(t, r)),
      r
    )
  }
  listen(t, n, r) {
    this._getAnims(t).listeners[n].push(r)
  }
  add(t, n) {
    !n || !n.length || this._getAnims(t).items.push(...n)
  }
  has(t) {
    return this._getAnims(t).items.length > 0
  }
  start(t) {
    const n = this._charts.get(t)
    n &&
      ((n.running = !0),
      (n.start = Date.now()),
      (n.duration = n.items.reduce((r, i) => Math.max(r, i._duration), 0)),
      this._refresh())
  }
  running(t) {
    if (!this._running) return !1
    const n = this._charts.get(t)
    return !(!n || !n.running || !n.items.length)
  }
  stop(t) {
    const n = this._charts.get(t)
    if (!n || !n.items.length) return
    const r = n.items
    let i = r.length - 1
    for (; i >= 0; --i) r[i].cancel()
    ;((n.items = []), this._notify(t, n, Date.now(), 'complete'))
  }
  remove(t) {
    return this._charts.delete(t)
  }
}
var Mr = new h_()
const Fm = 'transparent',
  d_ = {
    boolean(e, t, n) {
      return n > 0.5 ? t : e
    },
    color(e, t, n) {
      const r = Im(e || Fm),
        i = r.valid && Im(t || Fm)
      return i && i.valid ? i.mix(r, n).hexString() : t
    },
    number(e, t, n) {
      return e + (t - e) * n
    },
  }
class f_ {
  constructor(t, n, r, i) {
    const o = n[r]
    i = kc([t.to, i, o, t.from])
    const c = kc([t.from, o, i])
    ;((this._active = !0),
      (this._fn = t.fn || d_[t.type || typeof c]),
      (this._easing = Qa[t.easing] || Qa.linear),
      (this._start = Math.floor(Date.now() + (t.delay || 0))),
      (this._duration = this._total = Math.floor(t.duration)),
      (this._loop = !!t.loop),
      (this._target = n),
      (this._prop = r),
      (this._from = c),
      (this._to = i),
      (this._promises = void 0))
  }
  active() {
    return this._active
  }
  update(t, n, r) {
    if (this._active) {
      this._notify(!1)
      const i = this._target[this._prop],
        o = r - this._start,
        c = this._duration - o
      ;((this._start = r),
        (this._duration = Math.floor(Math.max(c, t.duration))),
        (this._total += o),
        (this._loop = !!t.loop),
        (this._to = kc([t.to, n, i, t.from])),
        (this._from = kc([t.from, i, n])))
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), (this._active = !1), this._notify(!1))
  }
  tick(t) {
    const n = t - this._start,
      r = this._duration,
      i = this._prop,
      o = this._from,
      c = this._loop,
      h = this._to
    let f
    if (((this._active = o !== h && (c || n < r)), !this._active)) {
      ;((this._target[i] = h), this._notify(!0))
      return
    }
    if (n < 0) {
      this._target[i] = o
      return
    }
    ;((f = (n / r) % 2),
      (f = c && f > 1 ? 2 - f : f),
      (f = this._easing(Math.min(1, Math.max(0, f)))),
      (this._target[i] = this._fn(o, h, f)))
  }
  wait() {
    const t = this._promises || (this._promises = [])
    return new Promise((n, r) => {
      t.push({ res: n, rej: r })
    })
  }
  _notify(t) {
    const n = t ? 'res' : 'rej',
      r = this._promises || []
    for (let i = 0; i < r.length; i++) r[i][n]()
  }
}
class I3 {
  constructor(t, n) {
    ;((this._chart = t), (this._properties = new Map()), this.configure(n))
  }
  configure(t) {
    if (!Me(t)) return
    const n = Object.keys(bt.animation),
      r = this._properties
    Object.getOwnPropertyNames(t).forEach((i) => {
      const o = t[i]
      if (!Me(o)) return
      const c = {}
      for (const h of n) c[h] = o[h]
      ;((ct(o.properties) && o.properties) || [i]).forEach((h) => {
        ;(h === i || !r.has(h)) && r.set(h, c)
      })
    })
  }
  _animateOptions(t, n) {
    const r = n.options,
      i = g_(t, r)
    if (!i) return []
    const o = this._createAnimations(i, r)
    return (
      r.$shared &&
        p_(t.options.$animations, r).then(
          () => {
            t.options = r
          },
          () => {}
        ),
      o
    )
  }
  _createAnimations(t, n) {
    const r = this._properties,
      i = [],
      o = t.$animations || (t.$animations = {}),
      c = Object.keys(n),
      h = Date.now()
    let f
    for (f = c.length - 1; f >= 0; --f) {
      const p = c[f]
      if (p.charAt(0) === '$') continue
      if (p === 'options') {
        i.push(...this._animateOptions(t, n))
        continue
      }
      const y = n[p]
      let w = o[p]
      const x = r.get(p)
      if (w)
        if (x && w.active()) {
          w.update(x, y, h)
          continue
        } else w.cancel()
      if (!x || !x.duration) {
        t[p] = y
        continue
      }
      ;((o[p] = w = new f_(x, t, p, y)), i.push(w))
    }
    return i
  }
  update(t, n) {
    if (this._properties.size === 0) {
      Object.assign(t, n)
      return
    }
    const r = this._createAnimations(t, n)
    if (r.length) return (Mr.add(this._chart, r), !0)
  }
}
function p_(e, t) {
  const n = [],
    r = Object.keys(t)
  for (let i = 0; i < r.length; i++) {
    const o = e[r[i]]
    o && o.active() && n.push(o.wait())
  }
  return Promise.all(n)
}
function g_(e, t) {
  if (!t) return
  let n = e.options
  if (!n) {
    e.options = t
    return
  }
  return (n.$shared && (e.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n)
}
function jm(e, t) {
  const n = (e && e.options) || {},
    r = n.reverse,
    i = n.min === void 0 ? t : 0,
    o = n.max === void 0 ? t : 0
  return { start: r ? o : i, end: r ? i : o }
}
function m_(e, t, n) {
  if (n === !1) return !1
  const r = jm(e, n),
    i = jm(t, n)
  return { top: i.end, right: r.end, bottom: i.start, left: r.start }
}
function y_(e) {
  let t, n, r, i
  return (
    Me(e) ? ((t = e.top), (n = e.right), (r = e.bottom), (i = e.left)) : (t = n = r = i = e),
    { top: t, right: n, bottom: r, left: i, disabled: e === !1 }
  )
}
function N3(e, t) {
  const n = [],
    r = e._getSortedDatasetMetas(t)
  let i, o
  for (i = 0, o = r.length; i < o; ++i) n.push(r[i].index)
  return n
}
function Vm(e, t, n, r = {}) {
  const i = e.keys,
    o = r.mode === 'single'
  let c, h, f, p
  if (t === null) return
  let y = !1
  for (c = 0, h = i.length; c < h; ++c) {
    if (((f = +i[c]), f === n)) {
      if (((y = !0), r.all)) continue
      break
    }
    ;((p = e.values[f]), Bt(p) && (o || t === 0 || Nr(t) === Nr(p)) && (t += p))
  }
  return !y && !r.all ? 0 : t
}
function w_(e, t) {
  const { iScale: n, vScale: r } = t,
    i = n.axis === 'x' ? 'x' : 'y',
    o = r.axis === 'x' ? 'x' : 'y',
    c = Object.keys(e),
    h = new Array(c.length)
  let f, p, y
  for (f = 0, p = c.length; f < p; ++f) ((y = c[f]), (h[f] = { [i]: y, [o]: e[y] }))
  return h
}
function Bd(e, t) {
  const n = e && e.options.stacked
  return n || (n === void 0 && t.stack !== void 0)
}
function b_(e, t, n) {
  return `${e.id}.${t.id}.${n.stack || n.type}`
}
function v_(e) {
  const { min: t, max: n, minDefined: r, maxDefined: i } = e.getUserBounds()
  return { min: r ? t : Number.NEGATIVE_INFINITY, max: i ? n : Number.POSITIVE_INFINITY }
}
function x_(e, t, n) {
  const r = e[t] || (e[t] = {})
  return r[n] || (r[n] = {})
}
function Um(e, t, n, r) {
  for (const i of t.getMatchingVisibleMetas(r).reverse()) {
    const o = e[i.index]
    if ((n && o > 0) || (!n && o < 0)) return i.index
  }
  return null
}
function Wm(e, t) {
  const { chart: n, _cachedMeta: r } = e,
    i = n._stacks || (n._stacks = {}),
    { iScale: o, vScale: c, index: h } = r,
    f = o.axis,
    p = c.axis,
    y = b_(o, c, r),
    w = t.length
  let x
  for (let E = 0; E < w; ++E) {
    const S = t[E],
      { [f]: k, [p]: P } = S,
      I = S._stacks || (S._stacks = {})
    ;((x = I[p] = x_(i, y, k)),
      (x[h] = P),
      (x._top = Um(x, c, !0, r.type)),
      (x._bottom = Um(x, c, !1, r.type)))
    const R = x._visualValues || (x._visualValues = {})
    R[h] = P
  }
}
function Fd(e, t) {
  const n = e.scales
  return Object.keys(n)
    .filter((r) => n[r].axis === t)
    .shift()
}
function E_(e, t) {
  return Wi(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: 'default',
    type: 'dataset',
  })
}
function C_(e, t, n) {
  return Wi(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: t,
    mode: 'default',
    type: 'data',
  })
}
function xa(e, t) {
  const n = e.controller.index,
    r = e.vScale && e.vScale.axis
  if (r) {
    t = t || e._parsed
    for (const i of t) {
      const o = i._stacks
      if (!o || o[r] === void 0 || o[r][n] === void 0) return
      ;(delete o[r][n],
        o[r]._visualValues !== void 0 &&
          o[r]._visualValues[n] !== void 0 &&
          delete o[r]._visualValues[n])
    }
  }
}
const jd = (e) => e === 'reset' || e === 'none',
  zm = (e, t) => (t ? e : Object.assign({}, e)),
  S_ = (e, t, n) => e && !t.hidden && t._stacked && { keys: N3(n, !0), values: null }
class gs {
  constructor(t, n) {
    ;((this.chart = t),
      (this._ctx = t.ctx),
      (this.index = n),
      (this._cachedDataOpts = {}),
      (this._cachedMeta = this.getMeta()),
      (this._type = this._cachedMeta.type),
      (this.options = void 0),
      (this._parsing = !1),
      (this._data = void 0),
      (this._objectData = void 0),
      (this._sharedOptions = void 0),
      (this._drawStart = void 0),
      (this._drawCount = void 0),
      (this.enableOptionSharing = !1),
      (this.supportsDecimation = !1),
      (this.$context = void 0),
      (this._syncList = []),
      (this.datasetElementType = new.target.datasetElementType),
      (this.dataElementType = new.target.dataElementType),
      this.initialize())
  }
  initialize() {
    const t = this._cachedMeta
    ;(this.configure(),
      this.linkScales(),
      (t._stacked = Bd(t.vScale, t)),
      this.addElements(),
      this.options.fill &&
        !this.chart.isPluginEnabled('filler') &&
        console.warn(
          "Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options"
        ))
  }
  updateIndex(t) {
    ;(this.index !== t && xa(this._cachedMeta), (this.index = t))
  }
  linkScales() {
    const t = this.chart,
      n = this._cachedMeta,
      r = this.getDataset(),
      i = (w, x, E, S) => (w === 'x' ? x : w === 'r' ? S : E),
      o = (n.xAxisID = _e(r.xAxisID, Fd(t, 'x'))),
      c = (n.yAxisID = _e(r.yAxisID, Fd(t, 'y'))),
      h = (n.rAxisID = _e(r.rAxisID, Fd(t, 'r'))),
      f = n.indexAxis,
      p = (n.iAxisID = i(f, o, c, h)),
      y = (n.vAxisID = i(f, c, o, h))
    ;((n.xScale = this.getScaleForId(o)),
      (n.yScale = this.getScaleForId(c)),
      (n.rScale = this.getScaleForId(h)),
      (n.iScale = this.getScaleForId(p)),
      (n.vScale = this.getScaleForId(y)))
  }
  getDataset() {
    return this.chart.data.datasets[this.index]
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index)
  }
  getScaleForId(t) {
    return this.chart.scales[t]
  }
  _getOtherScale(t) {
    const n = this._cachedMeta
    return t === n.iScale ? n.vScale : n.iScale
  }
  reset() {
    this._update('reset')
  }
  _destroy() {
    const t = this._cachedMeta
    ;(this._data && Am(this._data, this), t._stacked && xa(t))
  }
  _dataCheck() {
    const t = this.getDataset(),
      n = t.data || (t.data = []),
      r = this._data
    if (Me(n)) {
      const i = this._cachedMeta
      this._data = w_(n, i)
    } else if (r !== n) {
      if (r) {
        Am(r, this)
        const i = this._cachedMeta
        ;(xa(i), (i._parsed = []))
      }
      ;(n && Object.isExtensible(n) && i9(n, this), (this._syncList = []), (this._data = n))
    }
  }
  addElements() {
    const t = this._cachedMeta
    ;(this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType()))
  }
  buildOrUpdateElements(t) {
    const n = this._cachedMeta,
      r = this.getDataset()
    let i = !1
    this._dataCheck()
    const o = n._stacked
    ;((n._stacked = Bd(n.vScale, n)),
      n.stack !== r.stack && ((i = !0), xa(n), (n.stack = r.stack)),
      this._resyncElements(t),
      (i || o !== n._stacked) && (Wm(this, n._parsed), (n._stacked = Bd(n.vScale, n))))
  }
  configure() {
    const t = this.chart.config,
      n = t.datasetScopeKeys(this._type),
      r = t.getOptionScopes(this.getDataset(), n, !0)
    ;((this.options = t.createResolver(r, this.getContext())),
      (this._parsing = this.options.parsing),
      (this._cachedDataOpts = {}))
  }
  parse(t, n) {
    const { _cachedMeta: r, _data: i } = this,
      { iScale: o, _stacked: c } = r,
      h = o.axis
    let f = t === 0 && n === i.length ? !0 : r._sorted,
      p = t > 0 && r._parsed[t - 1],
      y,
      w,
      x
    if (this._parsing === !1) ((r._parsed = i), (r._sorted = !0), (x = i))
    else {
      ct(i[t])
        ? (x = this.parseArrayData(r, i, t, n))
        : Me(i[t])
          ? (x = this.parseObjectData(r, i, t, n))
          : (x = this.parsePrimitiveData(r, i, t, n))
      const E = () => w[h] === null || (p && w[h] < p[h])
      for (y = 0; y < n; ++y) ((r._parsed[y + t] = w = x[y]), f && (E() && (f = !1), (p = w)))
      r._sorted = f
    }
    c && Wm(this, x)
  }
  parsePrimitiveData(t, n, r, i) {
    const { iScale: o, vScale: c } = t,
      h = o.axis,
      f = c.axis,
      p = o.getLabels(),
      y = o === c,
      w = new Array(i)
    let x, E, S
    for (x = 0, E = i; x < E; ++x)
      ((S = x + r), (w[x] = { [h]: y || o.parse(p[S], S), [f]: c.parse(n[S], S) }))
    return w
  }
  parseArrayData(t, n, r, i) {
    const { xScale: o, yScale: c } = t,
      h = new Array(i)
    let f, p, y, w
    for (f = 0, p = i; f < p; ++f)
      ((y = f + r), (w = n[y]), (h[f] = { x: o.parse(w[0], y), y: c.parse(w[1], y) }))
    return h
  }
  parseObjectData(t, n, r, i) {
    const { xScale: o, yScale: c } = t,
      { xAxisKey: h = 'x', yAxisKey: f = 'y' } = this._parsing,
      p = new Array(i)
    let y, w, x, E
    for (y = 0, w = i; y < w; ++y)
      ((x = y + r), (E = n[x]), (p[y] = { x: o.parse(Es(E, h), x), y: c.parse(Es(E, f), x) }))
    return p
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t]
  }
  getDataElement(t) {
    return this._cachedMeta.data[t]
  }
  applyStack(t, n, r) {
    const i = this.chart,
      o = this._cachedMeta,
      c = n[t.axis],
      h = { keys: N3(i, !0), values: n._stacks[t.axis]._visualValues }
    return Vm(h, c, o.index, { mode: r })
  }
  updateRangeFromParsed(t, n, r, i) {
    const o = r[n.axis]
    let c = o === null ? NaN : o
    const h = i && r._stacks[n.axis]
    ;(i && h && ((i.values = h), (c = Vm(i, o, this._cachedMeta.index))),
      (t.min = Math.min(t.min, c)),
      (t.max = Math.max(t.max, c)))
  }
  getMinMax(t, n) {
    const r = this._cachedMeta,
      i = r._parsed,
      o = r._sorted && t === r.iScale,
      c = i.length,
      h = this._getOtherScale(t),
      f = S_(n, r, this.chart),
      p = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },
      { min: y, max: w } = v_(h)
    let x, E
    function S() {
      E = i[x]
      const k = E[h.axis]
      return !Bt(E[t.axis]) || y > k || w < k
    }
    for (x = 0; x < c && !(!S() && (this.updateRangeFromParsed(p, t, E, f), o)); ++x);
    if (o) {
      for (x = c - 1; x >= 0; --x)
        if (!S()) {
          this.updateRangeFromParsed(p, t, E, f)
          break
        }
    }
    return p
  }
  getAllParsedValues(t) {
    const n = this._cachedMeta._parsed,
      r = []
    let i, o, c
    for (i = 0, o = n.length; i < o; ++i) ((c = n[i][t.axis]), Bt(c) && r.push(c))
    return r
  }
  getMaxOverflow() {
    return !1
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta,
      r = n.iScale,
      i = n.vScale,
      o = this.getParsed(t)
    return {
      label: r ? '' + r.getLabelForValue(o[r.axis]) : '',
      value: i ? '' + i.getLabelForValue(o[i.axis]) : '',
    }
  }
  _update(t) {
    const n = this._cachedMeta
    ;(this.update(t || 'default'),
      (n._clip = y_(_e(this.options.clip, m_(n.xScale, n.yScale, this.getMaxOverflow())))))
  }
  update(t) {}
  draw() {
    const t = this._ctx,
      n = this.chart,
      r = this._cachedMeta,
      i = r.data || [],
      o = n.chartArea,
      c = [],
      h = this._drawStart || 0,
      f = this._drawCount || i.length - h,
      p = this.options.drawActiveElementsOnTop
    let y
    for (r.dataset && r.dataset.draw(t, o, h, f), y = h; y < h + f; ++y) {
      const w = i[y]
      w.hidden || (w.active && p ? c.push(w) : w.draw(t, o))
    }
    for (y = 0; y < c.length; ++y) c[y].draw(t, o)
  }
  getStyle(t, n) {
    const r = n ? 'active' : 'default'
    return t === void 0 && this._cachedMeta.dataset
      ? this.resolveDatasetElementOptions(r)
      : this.resolveDataElementOptions(t || 0, r)
  }
  getContext(t, n, r) {
    const i = this.getDataset()
    let o
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const c = this._cachedMeta.data[t]
      ;((o = c.$context || (c.$context = C_(this.getContext(), t, c))),
        (o.parsed = this.getParsed(t)),
        (o.raw = i.data[t]),
        (o.index = o.dataIndex = t))
    } else
      ((o = this.$context || (this.$context = E_(this.chart.getContext(), this.index))),
        (o.dataset = i),
        (o.index = o.datasetIndex = this.index))
    return ((o.active = !!n), (o.mode = r), o)
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t)
  }
  resolveDataElementOptions(t, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, t)
  }
  _resolveElementOptions(t, n = 'default', r) {
    const i = n === 'active',
      o = this._cachedDataOpts,
      c = t + '-' + n,
      h = o[c],
      f = this.enableOptionSharing && _l(r)
    if (h) return zm(h, f)
    const p = this.chart.config,
      y = p.datasetElementScopeKeys(this._type, t),
      w = i ? [`${t}Hover`, 'hover', t, ''] : [t, ''],
      x = p.getOptionScopes(this.getDataset(), y),
      E = Object.keys(bt.elements[t]),
      S = () => this.getContext(r, i, n),
      k = p.resolveNamedOptions(x, E, S, w)
    return (k.$shared && ((k.$shared = f), (o[c] = Object.freeze(zm(k, f)))), k)
  }
  _resolveAnimations(t, n, r) {
    const i = this.chart,
      o = this._cachedDataOpts,
      c = `animation-${n}`,
      h = o[c]
    if (h) return h
    let f
    if (i.options.animation !== !1) {
      const y = this.chart.config,
        w = y.datasetAnimationScopeKeys(this._type, n),
        x = y.getOptionScopes(this.getDataset(), w)
      f = y.createResolver(x, this.getContext(t, r, n))
    }
    const p = new I3(i, f && f.animations)
    return (f && f._cacheable && (o[c] = Object.freeze(p)), p)
  }
  getSharedOptions(t) {
    if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
  }
  includeOptions(t, n) {
    return !n || jd(t) || this.chart._animationsDisabled
  }
  _getSharedOptions(t, n) {
    const r = this.resolveDataElementOptions(t, n),
      i = this._sharedOptions,
      o = this.getSharedOptions(r),
      c = this.includeOptions(n, o) || o !== i
    return (this.updateSharedOptions(o, n, r), { sharedOptions: o, includeOptions: c })
  }
  updateElement(t, n, r, i) {
    jd(i) ? Object.assign(t, r) : this._resolveAnimations(n, i).update(t, r)
  }
  updateSharedOptions(t, n, r) {
    t && !jd(n) && this._resolveAnimations(void 0, n).update(t, r)
  }
  _setStyle(t, n, r, i) {
    t.active = i
    const o = this.getStyle(n, i)
    this._resolveAnimations(n, r, i).update(t, { options: (!i && this.getSharedOptions(o)) || o })
  }
  removeHoverStyle(t, n, r) {
    this._setStyle(t, r, 'active', !1)
  }
  setHoverStyle(t, n, r) {
    this._setStyle(t, r, 'active', !0)
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset
    t && this._setStyle(t, void 0, 'active', !1)
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset
    t && this._setStyle(t, void 0, 'active', !0)
  }
  _resyncElements(t) {
    const n = this._data,
      r = this._cachedMeta.data
    for (const [h, f, p] of this._syncList) this[h](f, p)
    this._syncList = []
    const i = r.length,
      o = n.length,
      c = Math.min(o, i)
    ;(c && this.parse(0, c),
      o > i ? this._insertElements(i, o - i, t) : o < i && this._removeElements(o, i - o))
  }
  _insertElements(t, n, r = !0) {
    const i = this._cachedMeta,
      o = i.data,
      c = t + n
    let h
    const f = (p) => {
      for (p.length += n, h = p.length - 1; h >= c; h--) p[h] = p[h - n]
    }
    for (f(o), h = t; h < c; ++h) o[h] = new this.dataElementType()
    ;(this._parsing && f(i._parsed), this.parse(t, n), r && this.updateElements(o, t, n, 'reset'))
  }
  updateElements(t, n, r, i) {}
  _removeElements(t, n) {
    const r = this._cachedMeta
    if (this._parsing) {
      const i = r._parsed.splice(t, n)
      r._stacked && xa(r, i)
    }
    r.data.splice(t, n)
  }
  _sync(t) {
    if (this._parsing) this._syncList.push(t)
    else {
      const [n, r, i] = t
      this[n](r, i)
    }
    this.chart._dataChanges.push([this.index, ...t])
  }
  _onDataPush() {
    const t = arguments.length
    this._sync(['_insertElements', this.getDataset().data.length - t, t])
  }
  _onDataPop() {
    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1])
  }
  _onDataShift() {
    this._sync(['_removeElements', 0, 1])
  }
  _onDataSplice(t, n) {
    n && this._sync(['_removeElements', t, n])
    const r = arguments.length - 2
    r && this._sync(['_insertElements', t, r])
  }
  _onDataUnshift() {
    this._sync(['_insertElements', 0, arguments.length])
  }
}
;(ye(gs, 'defaults', {}), ye(gs, 'datasetElementType', null), ye(gs, 'dataElementType', null))
function A_(e, t) {
  if (!e._cache.$bar) {
    const n = e.getMatchingVisibleMetas(t)
    let r = []
    for (let i = 0, o = n.length; i < o; i++) r = r.concat(n[i].controller.getAllParsedValues(e))
    e._cache.$bar = c3(r.sort((i, o) => i - o))
  }
  return e._cache.$bar
}
function k_(e) {
  const t = e.iScale,
    n = A_(t, e.type)
  let r = t._length,
    i,
    o,
    c,
    h
  const f = () => {
    c === 32767 || c === -32768 || (_l(h) && (r = Math.min(r, Math.abs(c - h) || r)), (h = c))
  }
  for (i = 0, o = n.length; i < o; ++i) ((c = t.getPixelForValue(n[i])), f())
  for (h = void 0, i = 0, o = t.ticks.length; i < o; ++i) ((c = t.getPixelForTick(i)), f())
  return r
}
function __(e, t, n, r) {
  const i = n.barThickness
  let o, c
  return (
    Oe(i) ? ((o = t.min * n.categoryPercentage), (c = n.barPercentage)) : ((o = i * r), (c = 1)),
    { chunk: o / r, ratio: c, start: t.pixels[e] - o / 2 }
  )
}
function I_(e, t, n, r) {
  const i = t.pixels,
    o = i[e]
  let c = e > 0 ? i[e - 1] : null,
    h = e < i.length - 1 ? i[e + 1] : null
  const f = n.categoryPercentage
  ;(c === null && (c = o - (h === null ? t.end - t.start : h - o)), h === null && (h = o + o - c))
  const p = o - ((o - Math.min(c, h)) / 2) * f
  return { chunk: ((Math.abs(h - c) / 2) * f) / r, ratio: n.barPercentage, start: p }
}
function N_(e, t, n, r) {
  const i = n.parse(e[0], r),
    o = n.parse(e[1], r),
    c = Math.min(i, o),
    h = Math.max(i, o)
  let f = c,
    p = h
  ;(Math.abs(c) > Math.abs(h) && ((f = h), (p = c)),
    (t[n.axis] = p),
    (t._custom = { barStart: f, barEnd: p, start: i, end: o, min: c, max: h }))
}
function T3(e, t, n, r) {
  return (ct(e) ? N_(e, t, n, r) : (t[n.axis] = n.parse(e, r)), t)
}
function Hm(e, t, n, r) {
  const i = e.iScale,
    o = e.vScale,
    c = i.getLabels(),
    h = i === o,
    f = []
  let p, y, w, x
  for (p = n, y = n + r; p < y; ++p)
    ((x = t[p]), (w = {}), (w[i.axis] = h || i.parse(c[p], p)), f.push(T3(x, w, o, p)))
  return f
}
function Vd(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0
}
function T_(e, t, n) {
  return e !== 0 ? Nr(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1)
}
function R_(e) {
  let t, n, r, i, o
  return (
    e.horizontal
      ? ((t = e.base > e.x), (n = 'left'), (r = 'right'))
      : ((t = e.base < e.y), (n = 'bottom'), (r = 'top')),
    t ? ((i = 'end'), (o = 'start')) : ((i = 'start'), (o = 'end')),
    { start: n, end: r, reverse: t, top: i, bottom: o }
  )
}
function M_(e, t, n, r) {
  let i = t.borderSkipped
  const o = {}
  if (!i) {
    e.borderSkipped = o
    return
  }
  if (i === !0) {
    e.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }
    return
  }
  const { start: c, end: h, reverse: f, top: p, bottom: y } = R_(e)
  ;(i === 'middle' &&
    n &&
    ((e.enableBorderRadius = !0),
    (n._top || 0) === r
      ? (i = p)
      : (n._bottom || 0) === r
        ? (i = y)
        : ((o[Xm(y, c, h, f)] = !0), (i = p))),
    (o[Xm(i, c, h, f)] = !0),
    (e.borderSkipped = o))
}
function Xm(e, t, n, r) {
  return (r ? ((e = P_(e, t, n)), (e = Gm(e, n, t))) : (e = Gm(e, t, n)), e)
}
function P_(e, t, n) {
  return e === t ? n : e === n ? t : e
}
function Gm(e, t, n) {
  return e === 'start' ? t : e === 'end' ? n : e
}
function D_(e, { inflateAmount: t }, n) {
  e.inflateAmount = t === 'auto' ? (n === 1 ? 0.33 : 0) : t
}
class $c extends gs {
  parsePrimitiveData(t, n, r, i) {
    return Hm(t, n, r, i)
  }
  parseArrayData(t, n, r, i) {
    return Hm(t, n, r, i)
  }
  parseObjectData(t, n, r, i) {
    const { iScale: o, vScale: c } = t,
      { xAxisKey: h = 'x', yAxisKey: f = 'y' } = this._parsing,
      p = o.axis === 'x' ? h : f,
      y = c.axis === 'x' ? h : f,
      w = []
    let x, E, S, k
    for (x = r, E = r + i; x < E; ++x)
      ((k = n[x]), (S = {}), (S[o.axis] = o.parse(Es(k, p), x)), w.push(T3(Es(k, y), S, c, x)))
    return w
  }
  updateRangeFromParsed(t, n, r, i) {
    super.updateRangeFromParsed(t, n, r, i)
    const o = r._custom
    o &&
      n === this._cachedMeta.vScale &&
      ((t.min = Math.min(t.min, o.min)), (t.max = Math.max(t.max, o.max)))
  }
  getMaxOverflow() {
    return 0
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta,
      { iScale: r, vScale: i } = n,
      o = this.getParsed(t),
      c = o._custom,
      h = Vd(c) ? '[' + c.start + ', ' + c.end + ']' : '' + i.getLabelForValue(o[i.axis])
    return { label: '' + r.getLabelForValue(o[r.axis]), value: h }
  }
  initialize() {
    ;((this.enableOptionSharing = !0), super.initialize())
    const t = this._cachedMeta
    t.stack = this.getDataset().stack
  }
  update(t) {
    const n = this._cachedMeta
    this.updateElements(n.data, 0, n.data.length, t)
  }
  updateElements(t, n, r, i) {
    const o = i === 'reset',
      {
        index: c,
        _cachedMeta: { vScale: h },
      } = this,
      f = h.getBasePixel(),
      p = h.isHorizontal(),
      y = this._getRuler(),
      { sharedOptions: w, includeOptions: x } = this._getSharedOptions(n, i)
    for (let E = n; E < n + r; E++) {
      const S = this.getParsed(E),
        k = o || Oe(S[h.axis]) ? { base: f, head: f } : this._calculateBarValuePixels(E),
        P = this._calculateBarIndexPixels(E, y),
        I = (S._stacks || {})[h.axis],
        R = {
          horizontal: p,
          base: k.base,
          enableBorderRadius: !I || Vd(S._custom) || c === I._top || c === I._bottom,
          x: p ? k.head : P.center,
          y: p ? P.center : k.head,
          height: p ? P.size : Math.abs(k.size),
          width: p ? Math.abs(k.size) : P.size,
        }
      x && (R.options = w || this.resolveDataElementOptions(E, t[E].active ? 'active' : i))
      const M = R.options || t[E].options
      ;(M_(R, M, I, c), D_(R, M, y.ratio), this.updateElement(t[E], E, R, i))
    }
  }
  _getStacks(t, n) {
    const { iScale: r } = this._cachedMeta,
      i = r.getMatchingVisibleMetas(this._type).filter((y) => y.controller.options.grouped),
      o = r.options.stacked,
      c = [],
      h = this._cachedMeta.controller.getParsed(n),
      f = h && h[r.axis],
      p = (y) => {
        const w = y._parsed.find((E) => E[r.axis] === f),
          x = w && w[y.vScale.axis]
        if (Oe(x) || isNaN(x)) return !0
      }
    for (const y of i)
      if (
        !(n !== void 0 && p(y)) &&
        ((o === !1 || c.indexOf(y.stack) === -1 || (o === void 0 && y.stack === void 0)) &&
          c.push(y.stack),
        y.index === t)
      )
        break
    return (c.length || c.push(void 0), c)
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length
  }
  _getAxisCount() {
    return this._getAxis().length
  }
  getFirstScaleIdForIndexAxis() {
    const t = this.chart.scales,
      n = this.chart.options.indexAxis
    return Object.keys(t)
      .filter((r) => t[r].axis === n)
      .shift()
  }
  _getAxis() {
    const t = {},
      n = this.getFirstScaleIdForIndexAxis()
    for (const r of this.chart.data.datasets)
      t[_e(this.chart.options.indexAxis === 'x' ? r.xAxisID : r.yAxisID, n)] = !0
    return Object.keys(t)
  }
  _getStackIndex(t, n, r) {
    const i = this._getStacks(t, r),
      o = n !== void 0 ? i.indexOf(n) : -1
    return o === -1 ? i.length - 1 : o
  }
  _getRuler() {
    const t = this.options,
      n = this._cachedMeta,
      r = n.iScale,
      i = []
    let o, c
    for (o = 0, c = n.data.length; o < c; ++o)
      i.push(r.getPixelForValue(this.getParsed(o)[r.axis], o))
    const h = t.barThickness
    return {
      min: h || k_(n),
      pixels: i,
      start: r._startPixel,
      end: r._endPixel,
      stackCount: this._getStackCount(),
      scale: r,
      grouped: t.grouped,
      ratio: h ? 1 : t.categoryPercentage * t.barPercentage,
    }
  }
  _calculateBarValuePixels(t) {
    const {
        _cachedMeta: { vScale: n, _stacked: r, index: i },
        options: { base: o, minBarLength: c },
      } = this,
      h = o || 0,
      f = this.getParsed(t),
      p = f._custom,
      y = Vd(p)
    let w = f[n.axis],
      x = 0,
      E = r ? this.applyStack(n, f, r) : w,
      S,
      k
    ;(E !== w && ((x = E - w), (E = w)),
      y &&
        ((w = p.barStart),
        (E = p.barEnd - p.barStart),
        w !== 0 && Nr(w) !== Nr(p.barEnd) && (x = 0),
        (x += w)))
    const P = !Oe(o) && !y ? o : x
    let I = n.getPixelForValue(P)
    if (
      (this.chart.getDataVisibility(t) ? (S = n.getPixelForValue(x + E)) : (S = I),
      (k = S - I),
      Math.abs(k) < c)
    ) {
      ;((k = T_(k, n, h) * c), w === h && (I -= k / 2))
      const R = n.getPixelForDecimal(0),
        M = n.getPixelForDecimal(1),
        O = Math.min(R, M),
        F = Math.max(R, M)
      ;((I = Math.max(Math.min(I, F), O)),
        (S = I + k),
        r &&
          !y &&
          (f._stacks[n.axis]._visualValues[i] = n.getValueForPixel(S) - n.getValueForPixel(I)))
    }
    if (I === n.getPixelForValue(h)) {
      const R = (Nr(k) * n.getLineWidthForValue(h)) / 2
      ;((I += R), (k -= R))
    }
    return { size: k, base: I, head: S, center: S + k / 2 }
  }
  _calculateBarIndexPixels(t, n) {
    const r = n.scale,
      i = this.options,
      o = i.skipNull,
      c = _e(i.maxBarThickness, 1 / 0)
    let h, f
    const p = this._getAxisCount()
    if (n.grouped) {
      const y = o ? this._getStackCount(t) : n.stackCount,
        w = i.barThickness === 'flex' ? I_(t, n, i, y * p) : __(t, n, i, y * p),
        x =
          this.chart.options.indexAxis === 'x'
            ? this.getDataset().xAxisID
            : this.getDataset().yAxisID,
        E = this._getAxis().indexOf(_e(x, this.getFirstScaleIdForIndexAxis())),
        S = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0) + E
      ;((h = w.start + w.chunk * S + w.chunk / 2), (f = Math.min(c, w.chunk * w.ratio)))
    } else
      ((h = r.getPixelForValue(this.getParsed(t)[r.axis], t)), (f = Math.min(c, n.min * n.ratio)))
    return { base: h - f / 2, head: h + f / 2, center: h, size: f }
  }
  draw() {
    const t = this._cachedMeta,
      n = t.vScale,
      r = t.data,
      i = r.length
    let o = 0
    for (; o < i; ++o) this.getParsed(o)[n.axis] !== null && !r[o].hidden && r[o].draw(this._ctx)
  }
}
;(ye($c, 'id', 'bar'),
  ye($c, 'defaults', {
    datasetElementType: !1,
    dataElementType: 'bar',
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: { numbers: { type: 'number', properties: ['x', 'y', 'base', 'width', 'height'] } },
  }),
  ye($c, 'overrides', {
    scales: {
      _index_: { type: 'category', offset: !0, grid: { offset: !0 } },
      _value_: { type: 'linear', beginAtZero: !0 },
    },
  }))
class Jc extends gs {
  initialize() {
    ;((this.enableOptionSharing = !0), (this.supportsDecimation = !0), super.initialize())
  }
  update(t) {
    const n = this._cachedMeta,
      { dataset: r, data: i = [], _dataset: o } = n,
      c = this.chart._animationsDisabled
    let { start: h, count: f } = a9(n, i, c)
    ;((this._drawStart = h),
      (this._drawCount = f),
      l9(n) && ((h = 0), (f = i.length)),
      (r._chart = this.chart),
      (r._datasetIndex = this.index),
      (r._decimated = !!o._decimated),
      (r.points = i))
    const p = this.resolveDatasetElementOptions(t)
    ;(this.options.showLine || (p.borderWidth = 0),
      (p.segment = this.options.segment),
      this.updateElement(r, void 0, { animated: !c, options: p }, t),
      this.updateElements(i, h, f, t))
  }
  updateElements(t, n, r, i) {
    const o = i === 'reset',
      { iScale: c, vScale: h, _stacked: f, _dataset: p } = this._cachedMeta,
      { sharedOptions: y, includeOptions: w } = this._getSharedOptions(n, i),
      x = c.axis,
      E = h.axis,
      { spanGaps: S, segment: k } = this.options,
      P = Il(S) ? S : Number.POSITIVE_INFINITY,
      I = this.chart._animationsDisabled || o || i === 'none',
      R = n + r,
      M = t.length
    let O = n > 0 && this.getParsed(n - 1)
    for (let F = 0; F < M; ++F) {
      const z = t[F],
        V = I ? z : {}
      if (F < n || F >= R) {
        V.skip = !0
        continue
      }
      const U = this.getParsed(F),
        Z = Oe(U[E]),
        J = (V[x] = c.getPixelForValue(U[x], F)),
        oe = (V[E] =
          o || Z ? h.getBasePixel() : h.getPixelForValue(f ? this.applyStack(h, U, f) : U[E], F))
      ;((V.skip = isNaN(J) || isNaN(oe) || Z),
        (V.stop = F > 0 && Math.abs(U[x] - O[x]) > P),
        k && ((V.parsed = U), (V.raw = p.data[F])),
        w && (V.options = y || this.resolveDataElementOptions(F, z.active ? 'active' : i)),
        I || this.updateElement(z, F, V, i),
        (O = U))
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta,
      n = t.dataset,
      r = (n.options && n.options.borderWidth) || 0,
      i = t.data || []
    if (!i.length) return r
    const o = i[0].size(this.resolveDataElementOptions(0)),
      c = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1))
    return Math.max(r, o, c) / 2
  }
  draw() {
    const t = this._cachedMeta
    ;(t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw())
  }
}
;(ye(Jc, 'id', 'line'),
  ye(Jc, 'defaults', {
    datasetElementType: 'line',
    dataElementType: 'point',
    showLine: !0,
    spanGaps: !1,
  }),
  ye(Jc, 'overrides', { scales: { _index_: { type: 'category' }, _value_: { type: 'linear' } } }))
class eu extends gs {
  getLabelAndValue(t) {
    const n = this._cachedMeta.vScale,
      r = this.getParsed(t)
    return { label: n.getLabels()[t], value: '' + n.getLabelForValue(r[n.axis]) }
  }
  parseObjectData(t, n, r, i) {
    return j9.bind(this)(t, n, r, i)
  }
  update(t) {
    const n = this._cachedMeta,
      r = n.dataset,
      i = n.data || [],
      o = n.iScale.getLabels()
    if (((r.points = i), t !== 'resize')) {
      const c = this.resolveDatasetElementOptions(t)
      this.options.showLine || (c.borderWidth = 0)
      const h = { _loop: !0, _fullLoop: o.length === i.length, options: c }
      this.updateElement(r, void 0, h, t)
    }
    this.updateElements(i, 0, i.length, t)
  }
  updateElements(t, n, r, i) {
    const o = this._cachedMeta.rScale,
      c = i === 'reset'
    for (let h = n; h < n + r; h++) {
      const f = t[h],
        p = this.resolveDataElementOptions(h, f.active ? 'active' : i),
        y = o.getPointPositionForValue(h, this.getParsed(h).r),
        w = c ? o.xCenter : y.x,
        x = c ? o.yCenter : y.y,
        E = { x: w, y: x, angle: y.angle, skip: isNaN(w) || isNaN(x), options: p }
      this.updateElement(f, h, E, i)
    }
  }
}
;(ye(eu, 'id', 'radar'),
  ye(eu, 'defaults', {
    datasetElementType: 'line',
    dataElementType: 'point',
    indexAxis: 'r',
    showLine: !0,
    elements: { line: { fill: 'start' } },
  }),
  ye(eu, 'overrides', { aspectRatio: 1, scales: { r: { type: 'radialLinear' } } }))
function $i() {
  throw new Error('This method is not implemented: Check that a complete date adapter is provided.')
}
class gp {
  constructor(t) {
    ;(ye(this, 'options'), (this.options = t || {}))
  }
  static override(t) {
    Object.assign(gp.prototype, t)
  }
  init() {}
  formats() {
    return $i()
  }
  parse() {
    return $i()
  }
  format() {
    return $i()
  }
  add() {
    return $i()
  }
  diff() {
    return $i()
  }
  startOf() {
    return $i()
  }
  endOf() {
    return $i()
  }
}
var L_ = { _date: gp }
function O_(e, t, n, r) {
  const { controller: i, data: o, _sorted: c } = e,
    h = i._cachedMeta.iScale,
    f = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null
  if (h && t === h.axis && t !== 'r' && c && o.length) {
    const p = h._reversePixels ? n9 : cs
    if (r) {
      if (i._sharedOptions) {
        const y = o[0],
          w = typeof y.getRange == 'function' && y.getRange(t)
        if (w) {
          const x = p(o, t, n - w),
            E = p(o, t, n + w)
          return { lo: x.lo, hi: E.hi }
        }
      }
    } else {
      const y = p(o, t, n)
      if (f) {
        const { vScale: w } = i._cachedMeta,
          { _parsed: x } = e,
          E = x
            .slice(0, y.lo + 1)
            .reverse()
            .findIndex((k) => !Oe(k[w.axis]))
        y.lo -= Math.max(0, E)
        const S = x.slice(y.hi).findIndex((k) => !Oe(k[w.axis]))
        y.hi += Math.max(0, S)
      }
      return y
    }
  }
  return { lo: 0, hi: o.length - 1 }
}
function Sh(e, t, n, r, i) {
  const o = e.getSortedVisibleDatasetMetas(),
    c = n[t]
  for (let h = 0, f = o.length; h < f; ++h) {
    const { index: p, data: y } = o[h],
      { lo: w, hi: x } = O_(o[h], t, c, i)
    for (let E = w; E <= x; ++E) {
      const S = y[E]
      S.skip || r(S, p, E)
    }
  }
}
function B_(e) {
  const t = e.indexOf('x') !== -1,
    n = e.indexOf('y') !== -1
  return function (r, i) {
    const o = t ? Math.abs(r.x - i.x) : 0,
      c = n ? Math.abs(r.y - i.y) : 0
    return Math.sqrt(Math.pow(o, 2) + Math.pow(c, 2))
  }
}
function Ud(e, t, n, r, i) {
  const o = []
  return (
    (!i && !e.isPointInArea(t)) ||
      Sh(
        e,
        n,
        t,
        function (c, h, f) {
          ;(!i && !Vr(c, e.chartArea, 0)) ||
            (c.inRange(t.x, t.y, r) && o.push({ element: c, datasetIndex: h, index: f }))
        },
        !0
      ),
    o
  )
}
function F_(e, t, n, r) {
  let i = []
  function o(c, h, f) {
    const { startAngle: p, endAngle: y } = c.getProps(['startAngle', 'endAngle'], r),
      { angle: w } = Jk(c, { x: t.x, y: t.y })
    a3(w, p, y) && i.push({ element: c, datasetIndex: h, index: f })
  }
  return (Sh(e, n, t, o), i)
}
function j_(e, t, n, r, i, o) {
  let c = []
  const h = B_(n)
  let f = Number.POSITIVE_INFINITY
  function p(y, w, x) {
    const E = y.inRange(t.x, t.y, i)
    if (r && !E) return
    const S = y.getCenterPoint(i)
    if (!(o || e.isPointInArea(S)) && !E) return
    const k = h(t, S)
    k < f
      ? ((c = [{ element: y, datasetIndex: w, index: x }]), (f = k))
      : k === f && c.push({ element: y, datasetIndex: w, index: x })
  }
  return (Sh(e, n, t, p), c)
}
function Wd(e, t, n, r, i, o) {
  return !o && !e.isPointInArea(t) ? [] : n === 'r' && !r ? F_(e, t, n, i) : j_(e, t, n, r, i, o)
}
function Ym(e, t, n, r, i) {
  const o = [],
    c = n === 'x' ? 'inXRange' : 'inYRange'
  let h = !1
  return (
    Sh(e, n, t, (f, p, y) => {
      f[c] &&
        f[c](t[n], i) &&
        (o.push({ element: f, datasetIndex: p, index: y }), (h = h || f.inRange(t.x, t.y, i)))
    }),
    r && !h ? [] : o
  )
}
var V_ = {
  modes: {
    index(e, t, n, r) {
      const i = rs(t, e),
        o = n.axis || 'x',
        c = n.includeInvisible || !1,
        h = n.intersect ? Ud(e, i, o, r, c) : Wd(e, i, o, !1, r, c),
        f = []
      return h.length
        ? (e.getSortedVisibleDatasetMetas().forEach((p) => {
            const y = h[0].index,
              w = p.data[y]
            w && !w.skip && f.push({ element: w, datasetIndex: p.index, index: y })
          }),
          f)
        : []
    },
    dataset(e, t, n, r) {
      const i = rs(t, e),
        o = n.axis || 'xy',
        c = n.includeInvisible || !1
      let h = n.intersect ? Ud(e, i, o, r, c) : Wd(e, i, o, !1, r, c)
      if (h.length > 0) {
        const f = h[0].datasetIndex,
          p = e.getDatasetMeta(f).data
        h = []
        for (let y = 0; y < p.length; ++y) h.push({ element: p[y], datasetIndex: f, index: y })
      }
      return h
    },
    point(e, t, n, r) {
      const i = rs(t, e),
        o = n.axis || 'xy',
        c = n.includeInvisible || !1
      return Ud(e, i, o, r, c)
    },
    nearest(e, t, n, r) {
      const i = rs(t, e),
        o = n.axis || 'xy',
        c = n.includeInvisible || !1
      return Wd(e, i, o, n.intersect, r, c)
    },
    x(e, t, n, r) {
      const i = rs(t, e)
      return Ym(e, i, 'x', n.intersect, r)
    },
    y(e, t, n, r) {
      const i = rs(t, e)
      return Ym(e, i, 'y', n.intersect, r)
    },
  },
}
const R3 = ['left', 'top', 'right', 'bottom']
function Ea(e, t) {
  return e.filter((n) => n.pos === t)
}
function Zm(e, t) {
  return e.filter((n) => R3.indexOf(n.pos) === -1 && n.box.axis === t)
}
function Ca(e, t) {
  return e.sort((n, r) => {
    const i = t ? r : n,
      o = t ? n : r
    return i.weight === o.weight ? i.index - o.index : i.weight - o.weight
  })
}
function U_(e) {
  const t = []
  let n, r, i, o, c, h
  for (n = 0, r = (e || []).length; n < r; ++n)
    ((i = e[n]),
      ({
        position: o,
        options: { stack: c, stackWeight: h = 1 },
      } = i),
      t.push({
        index: n,
        box: i,
        pos: o,
        horizontal: i.isHorizontal(),
        weight: i.weight,
        stack: c && o + c,
        stackWeight: h,
      }))
  return t
}
function W_(e) {
  const t = {}
  for (const n of e) {
    const { stack: r, pos: i, stackWeight: o } = n
    if (!r || !R3.includes(i)) continue
    const c = t[r] || (t[r] = { count: 0, placed: 0, weight: 0, size: 0 })
    ;(c.count++, (c.weight += o))
  }
  return t
}
function z_(e, t) {
  const n = W_(e),
    { vBoxMaxWidth: r, hBoxMaxHeight: i } = t
  let o, c, h
  for (o = 0, c = e.length; o < c; ++o) {
    h = e[o]
    const { fullSize: f } = h.box,
      p = n[h.stack],
      y = p && h.stackWeight / p.weight
    h.horizontal
      ? ((h.width = y ? y * r : f && t.availableWidth), (h.height = i))
      : ((h.width = r), (h.height = y ? y * i : f && t.availableHeight))
  }
  return n
}
function H_(e) {
  const t = U_(e),
    n = Ca(
      t.filter((p) => p.box.fullSize),
      !0
    ),
    r = Ca(Ea(t, 'left'), !0),
    i = Ca(Ea(t, 'right')),
    o = Ca(Ea(t, 'top'), !0),
    c = Ca(Ea(t, 'bottom')),
    h = Zm(t, 'x'),
    f = Zm(t, 'y')
  return {
    fullSize: n,
    leftAndTop: r.concat(o),
    rightAndBottom: i.concat(f).concat(c).concat(h),
    chartArea: Ea(t, 'chartArea'),
    vertical: r.concat(i).concat(f),
    horizontal: o.concat(c).concat(h),
  }
}
function Km(e, t, n, r) {
  return Math.max(e[n], t[n]) + Math.max(e[r], t[r])
}
function M3(e, t) {
  ;((e.top = Math.max(e.top, t.top)),
    (e.left = Math.max(e.left, t.left)),
    (e.bottom = Math.max(e.bottom, t.bottom)),
    (e.right = Math.max(e.right, t.right)))
}
function X_(e, t, n, r) {
  const { pos: i, box: o } = n,
    c = e.maxPadding
  if (!Me(i)) {
    n.size && (e[i] -= n.size)
    const w = r[n.stack] || { size: 0, count: 1 }
    ;((w.size = Math.max(w.size, n.horizontal ? o.height : o.width)),
      (n.size = w.size / w.count),
      (e[i] += n.size))
  }
  o.getPadding && M3(c, o.getPadding())
  const h = Math.max(0, t.outerWidth - Km(c, e, 'left', 'right')),
    f = Math.max(0, t.outerHeight - Km(c, e, 'top', 'bottom')),
    p = h !== e.w,
    y = f !== e.h
  return ((e.w = h), (e.h = f), n.horizontal ? { same: p, other: y } : { same: y, other: p })
}
function G_(e) {
  const t = e.maxPadding
  function n(r) {
    const i = Math.max(t[r] - e[r], 0)
    return ((e[r] += i), i)
  }
  ;((e.y += n('top')), (e.x += n('left')), n('right'), n('bottom'))
}
function Y_(e, t) {
  const n = t.maxPadding
  function r(i) {
    const o = { left: 0, top: 0, right: 0, bottom: 0 }
    return (
      i.forEach((c) => {
        o[c] = Math.max(t[c], n[c])
      }),
      o
    )
  }
  return r(e ? ['left', 'right'] : ['top', 'bottom'])
}
function Da(e, t, n, r) {
  const i = []
  let o, c, h, f, p, y
  for (o = 0, c = e.length, p = 0; o < c; ++o) {
    ;((h = e[o]), (f = h.box), f.update(h.width || t.w, h.height || t.h, Y_(h.horizontal, t)))
    const { same: w, other: x } = X_(t, n, h, r)
    ;((p |= w && i.length), (y = y || x), f.fullSize || i.push(h))
  }
  return (p && Da(i, t, n, r)) || y
}
function Nc(e, t, n, r, i) {
  ;((e.top = n), (e.left = t), (e.right = t + r), (e.bottom = n + i), (e.width = r), (e.height = i))
}
function qm(e, t, n, r) {
  const i = n.padding
  let { x: o, y: c } = t
  for (const h of e) {
    const f = h.box,
      p = r[h.stack] || { placed: 0, weight: 1 },
      y = h.stackWeight / p.weight || 1
    if (h.horizontal) {
      const w = t.w * y,
        x = p.size || f.height
      ;(_l(p.start) && (c = p.start),
        f.fullSize
          ? Nc(f, i.left, c, n.outerWidth - i.right - i.left, x)
          : Nc(f, t.left + p.placed, c, w, x),
        (p.start = c),
        (p.placed += w),
        (c = f.bottom))
    } else {
      const w = t.h * y,
        x = p.size || f.width
      ;(_l(p.start) && (o = p.start),
        f.fullSize
          ? Nc(f, o, i.top, x, n.outerHeight - i.bottom - i.top)
          : Nc(f, o, t.top + p.placed, x, w),
        (p.start = o),
        (p.placed += w),
        (o = f.right))
    }
  }
  ;((t.x = o), (t.y = c))
}
var vi = {
  addBox(e, t) {
    ;(e.boxes || (e.boxes = []),
      (t.fullSize = t.fullSize || !1),
      (t.position = t.position || 'top'),
      (t.weight = t.weight || 0),
      (t._layers =
        t._layers ||
        function () {
          return [
            {
              z: 0,
              draw(n) {
                t.draw(n)
              },
            },
          ]
        }),
      e.boxes.push(t))
  },
  removeBox(e, t) {
    const n = e.boxes ? e.boxes.indexOf(t) : -1
    n !== -1 && e.boxes.splice(n, 1)
  },
  configure(e, t, n) {
    ;((t.fullSize = n.fullSize), (t.position = n.position), (t.weight = n.weight))
  },
  update(e, t, n, r) {
    if (!e) return
    const i = on(e.options.layout.padding),
      o = Math.max(t - i.width, 0),
      c = Math.max(n - i.height, 0),
      h = H_(e.boxes),
      f = h.vertical,
      p = h.horizontal
    ze(e.boxes, (k) => {
      typeof k.beforeLayout == 'function' && k.beforeLayout()
    })
    const y =
        f.reduce((k, P) => (P.box.options && P.box.options.display === !1 ? k : k + 1), 0) || 1,
      w = Object.freeze({
        outerWidth: t,
        outerHeight: n,
        padding: i,
        availableWidth: o,
        availableHeight: c,
        vBoxMaxWidth: o / 2 / y,
        hBoxMaxHeight: c / 2,
      }),
      x = Object.assign({}, i)
    M3(x, on(r))
    const E = Object.assign({ maxPadding: x, w: o, h: c, x: i.left, y: i.top }, i),
      S = z_(f.concat(p), w)
    ;(Da(h.fullSize, E, w, S),
      Da(f, E, w, S),
      Da(p, E, w, S) && Da(f, E, w, S),
      G_(E),
      qm(h.leftAndTop, E, w, S),
      (E.x += E.w),
      (E.y += E.h),
      qm(h.rightAndBottom, E, w, S),
      (e.chartArea = {
        left: E.left,
        top: E.top,
        right: E.left + E.w,
        bottom: E.top + E.h,
        height: E.h,
        width: E.w,
      }),
      ze(h.chartArea, (k) => {
        const P = k.box
        ;(Object.assign(P, e.chartArea),
          P.update(E.w, E.h, { left: 0, top: 0, right: 0, bottom: 0 }))
      }))
  },
}
class P3 {
  acquireContext(t, n) {}
  releaseContext(t) {
    return !1
  }
  addEventListener(t, n, r) {}
  removeEventListener(t, n, r) {}
  getDevicePixelRatio() {
    return 1
  }
  getMaximumSize(t, n, r, i) {
    return (
      (n = Math.max(0, n || t.width)),
      (r = r || t.height),
      { width: n, height: Math.max(0, i ? Math.floor(n / i) : r) }
    )
  }
  isAttached(t) {
    return !0
  }
  updateConfig(t) {}
}
class Z_ extends P3 {
  acquireContext(t) {
    return (t && t.getContext && t.getContext('2d')) || null
  }
  updateConfig(t) {
    t.options.animation = !1
  }
}
const tu = '$chartjs',
  K_ = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout',
  },
  Qm = (e) => e === null || e === ''
function q_(e, t) {
  const n = e.style,
    r = e.getAttribute('height'),
    i = e.getAttribute('width')
  if (
    ((e[tu] = {
      initial: {
        height: r,
        width: i,
        style: { display: n.display, height: n.height, width: n.width },
      },
    }),
    (n.display = n.display || 'block'),
    (n.boxSizing = n.boxSizing || 'border-box'),
    Qm(i))
  ) {
    const o = Dm(e, 'width')
    o !== void 0 && (e.width = o)
  }
  if (Qm(r))
    if (e.style.height === '') e.height = e.width / (t || 2)
    else {
      const o = Dm(e, 'height')
      o !== void 0 && (e.height = o)
    }
  return e
}
const D3 = J9 ? { passive: !0 } : !1
function Q_(e, t, n) {
  e && e.addEventListener(t, n, D3)
}
function $_(e, t, n) {
  e && e.canvas && e.canvas.removeEventListener(t, n, D3)
}
function J_(e, t) {
  const n = K_[e.type] || e.type,
    { x: r, y: i } = rs(e, t)
  return { type: n, chart: t, native: e, x: r !== void 0 ? r : null, y: i !== void 0 ? i : null }
}
function Wu(e, t) {
  for (const n of e) if (n === t || n.contains(t)) return !0
}
function eI(e, t, n) {
  const r = e.canvas,
    i = new MutationObserver((o) => {
      let c = !1
      for (const h of o) ((c = c || Wu(h.addedNodes, r)), (c = c && !Wu(h.removedNodes, r)))
      c && n()
    })
  return (i.observe(document, { childList: !0, subtree: !0 }), i)
}
function tI(e, t, n) {
  const r = e.canvas,
    i = new MutationObserver((o) => {
      let c = !1
      for (const h of o) ((c = c || Wu(h.removedNodes, r)), (c = c && !Wu(h.addedNodes, r)))
      c && n()
    })
  return (i.observe(document, { childList: !0, subtree: !0 }), i)
}
const Tl = new Map()
let $m = 0
function L3() {
  const e = window.devicePixelRatio
  e !== $m &&
    (($m = e),
    Tl.forEach((t, n) => {
      n.currentDevicePixelRatio !== e && t()
    }))
}
function nI(e, t) {
  ;(Tl.size || window.addEventListener('resize', L3), Tl.set(e, t))
}
function rI(e) {
  ;(Tl.delete(e), Tl.size || window.removeEventListener('resize', L3))
}
function iI(e, t, n) {
  const r = e.canvas,
    i = r && pp(r)
  if (!i) return
  const o = h3((h, f) => {
      const p = i.clientWidth
      ;(n(h, f), p < i.clientWidth && n())
    }, window),
    c = new ResizeObserver((h) => {
      const f = h[0],
        p = f.contentRect.width,
        y = f.contentRect.height
      ;(p === 0 && y === 0) || o(p, y)
    })
  return (c.observe(i), nI(e, o), c)
}
function zd(e, t, n) {
  ;(n && n.disconnect(), t === 'resize' && rI(e))
}
function sI(e, t, n) {
  const r = e.canvas,
    i = h3((o) => {
      e.ctx !== null && n(J_(o, e))
    }, e)
  return (Q_(r, t, i), i)
}
class oI extends P3 {
  acquireContext(t, n) {
    const r = t && t.getContext && t.getContext('2d')
    return r && r.canvas === t ? (q_(t, n), r) : null
  }
  releaseContext(t) {
    const n = t.canvas
    if (!n[tu]) return !1
    const r = n[tu].initial
    ;['height', 'width'].forEach((o) => {
      const c = r[o]
      Oe(c) ? n.removeAttribute(o) : n.setAttribute(o, c)
    })
    const i = r.style || {}
    return (
      Object.keys(i).forEach((o) => {
        n.style[o] = i[o]
      }),
      (n.width = n.width),
      delete n[tu],
      !0
    )
  }
  addEventListener(t, n, r) {
    this.removeEventListener(t, n)
    const i = t.$proxies || (t.$proxies = {}),
      o = { attach: eI, detach: tI, resize: iI }[n] || sI
    i[n] = o(t, n, r)
  }
  removeEventListener(t, n) {
    const r = t.$proxies || (t.$proxies = {}),
      i = r[n]
    i && (({ attach: zd, detach: zd, resize: zd }[n] || $_)(t, n, i), (r[n] = void 0))
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio
  }
  getMaximumSize(t, n, r, i) {
    return $9(t, n, r, i)
  }
  isAttached(t) {
    const n = t && pp(t)
    return !!(n && n.isConnected)
  }
}
function aI(e) {
  return !fp() || (typeof OffscreenCanvas < 'u' && e instanceof OffscreenCanvas) ? Z_ : oI
}
var Tc
let zs =
  ((Tc = class {
    constructor() {
      ;(ye(this, 'x'),
        ye(this, 'y'),
        ye(this, 'active', !1),
        ye(this, 'options'),
        ye(this, '$animations'))
    }
    tooltipPosition(e) {
      const { x: t, y: n } = this.getProps(['x', 'y'], e)
      return { x: t, y: n }
    }
    hasValue() {
      return Il(this.x) && Il(this.y)
    }
    getProps(e, t) {
      const n = this.$animations
      if (!t || !n) return this
      const r = {}
      return (
        e.forEach((i) => {
          r[i] = n[i] && n[i].active() ? n[i]._to : this[i]
        }),
        r
      )
    }
  }),
  ye(Tc, 'defaults', {}),
  ye(Tc, 'defaultRoutes'),
  Tc)
function lI(e, t) {
  const n = e.options.ticks,
    r = cI(e),
    i = Math.min(n.maxTicksLimit || r, r),
    o = n.major.enabled ? hI(t) : [],
    c = o.length,
    h = o[0],
    f = o[c - 1],
    p = []
  if (c > i) return (dI(t, p, o, c / i), p)
  const y = uI(o, t, i)
  if (c > 0) {
    let w, x
    const E = c > 1 ? Math.round((f - h) / (c - 1)) : null
    for (Rc(t, p, y, Oe(E) ? 0 : h - E, h), w = 0, x = c - 1; w < x; w++)
      Rc(t, p, y, o[w], o[w + 1])
    return (Rc(t, p, y, f, Oe(E) ? t.length : f + E), p)
  }
  return (Rc(t, p, y), p)
}
function cI(e) {
  const t = e.options.offset,
    n = e._tickSize(),
    r = e._length / n + (t ? 0 : 1),
    i = e._maxLength / n
  return Math.floor(Math.min(r, i))
}
function uI(e, t, n) {
  const r = fI(e),
    i = t.length / n
  if (!r) return Math.max(i, 1)
  const o = Kk(r)
  for (let c = 0, h = o.length - 1; c < h; c++) {
    const f = o[c]
    if (f > i) return f
  }
  return Math.max(i, 1)
}
function hI(e) {
  const t = []
  let n, r
  for (n = 0, r = e.length; n < r; n++) e[n].major && t.push(n)
  return t
}
function dI(e, t, n, r) {
  let i = 0,
    o = n[0],
    c
  for (r = Math.ceil(r), c = 0; c < e.length; c++) c === o && (t.push(e[c]), i++, (o = n[i * r]))
}
function Rc(e, t, n, r, i) {
  const o = _e(r, 0),
    c = Math.min(_e(i, e.length), e.length)
  let h = 0,
    f,
    p,
    y
  for (n = Math.ceil(n), i && ((f = i - r), (n = f / Math.floor(f / n))), y = o; y < 0; )
    (h++, (y = Math.round(o + h * n)))
  for (p = Math.max(o, 0); p < c; p++) p === y && (t.push(e[p]), h++, (y = Math.round(o + h * n)))
}
function fI(e) {
  const t = e.length
  let n, r
  if (t < 2) return !1
  for (r = e[0], n = 1; n < t; ++n) if (e[n] - e[n - 1] !== r) return !1
  return r
}
const pI = (e) => (e === 'left' ? 'right' : e === 'right' ? 'left' : e),
  Jm = (e, t, n) => (t === 'top' || t === 'left' ? e[t] + n : e[t] - n),
  ey = (e, t) => Math.min(t || e, e)
function ty(e, t) {
  const n = [],
    r = e.length / t,
    i = e.length
  let o = 0
  for (; o < i; o += r) n.push(e[Math.floor(o)])
  return n
}
function gI(e, t, n) {
  const r = e.ticks.length,
    i = Math.min(t, r - 1),
    o = e._startPixel,
    c = e._endPixel,
    h = 1e-6
  let f = e.getPixelForTick(i),
    p
  if (
    !(
      n &&
      (r === 1
        ? (p = Math.max(f - o, c - f))
        : t === 0
          ? (p = (e.getPixelForTick(1) - f) / 2)
          : (p = (f - e.getPixelForTick(i - 1)) / 2),
      (f += i < t ? p : -p),
      f < o - h || f > c + h)
    )
  )
    return f
}
function mI(e, t) {
  ze(e, (n) => {
    const r = n.gc,
      i = r.length / 2
    let o
    if (i > t) {
      for (o = 0; o < i; ++o) delete n.data[r[o]]
      r.splice(0, i)
    }
  })
}
function Sa(e) {
  return e.drawTicks ? e.tickLength : 0
}
function ny(e, t) {
  if (!e.display) return 0
  const n = Ht(e.font, t),
    r = on(e.padding)
  return (ct(e.text) ? e.text.length : 1) * n.lineHeight + r.height
}
function yI(e, t) {
  return Wi(e, { scale: t, type: 'scale' })
}
function wI(e, t, n) {
  return Wi(e, { tick: n, index: t, type: 'tick' })
}
function bI(e, t, n) {
  let r = d3(e)
  return (((n && t !== 'right') || (!n && t === 'right')) && (r = pI(r)), r)
}
function vI(e, t, n, r) {
  const { top: i, left: o, bottom: c, right: h, chart: f } = e,
    { chartArea: p, scales: y } = f
  let w = 0,
    x,
    E,
    S
  const k = c - i,
    P = h - o
  if (e.isHorizontal()) {
    if (((E = kn(r, o, h)), Me(n))) {
      const I = Object.keys(n)[0],
        R = n[I]
      S = y[I].getPixelForValue(R) + k - t
    } else n === 'center' ? (S = (p.bottom + p.top) / 2 + k - t) : (S = Jm(e, n, t))
    x = h - o
  } else {
    if (Me(n)) {
      const I = Object.keys(n)[0],
        R = n[I]
      E = y[I].getPixelForValue(R) - P + t
    } else n === 'center' ? (E = (p.left + p.right) / 2 - P + t) : (E = Jm(e, n, t))
    ;((S = kn(r, c, i)), (w = n === 'left' ? -Rn : Rn))
  }
  return { titleX: E, titleY: S, maxWidth: x, rotation: w }
}
class $o extends zs {
  constructor(t) {
    ;(super(),
      (this.id = t.id),
      (this.type = t.type),
      (this.options = void 0),
      (this.ctx = t.ctx),
      (this.chart = t.chart),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this._margins = { left: 0, right: 0, top: 0, bottom: 0 }),
      (this.maxWidth = void 0),
      (this.maxHeight = void 0),
      (this.paddingTop = void 0),
      (this.paddingBottom = void 0),
      (this.paddingLeft = void 0),
      (this.paddingRight = void 0),
      (this.axis = void 0),
      (this.labelRotation = void 0),
      (this.min = void 0),
      (this.max = void 0),
      (this._range = void 0),
      (this.ticks = []),
      (this._gridLineItems = null),
      (this._labelItems = null),
      (this._labelSizes = null),
      (this._length = 0),
      (this._maxLength = 0),
      (this._longestTextCache = {}),
      (this._startPixel = void 0),
      (this._endPixel = void 0),
      (this._reversePixels = !1),
      (this._userMax = void 0),
      (this._userMin = void 0),
      (this._suggestedMax = void 0),
      (this._suggestedMin = void 0),
      (this._ticksLength = 0),
      (this._borderValue = 0),
      (this._cache = {}),
      (this._dataLimitsCached = !1),
      (this.$context = void 0))
  }
  init(t) {
    ;((this.options = t.setContext(this.getContext())),
      (this.axis = t.axis),
      (this._userMin = this.parse(t.min)),
      (this._userMax = this.parse(t.max)),
      (this._suggestedMin = this.parse(t.suggestedMin)),
      (this._suggestedMax = this.parse(t.suggestedMax)))
  }
  parse(t, n) {
    return t
  }
  getUserBounds() {
    let { _userMin: t, _userMax: n, _suggestedMin: r, _suggestedMax: i } = this
    return (
      (t = vr(t, Number.POSITIVE_INFINITY)),
      (n = vr(n, Number.NEGATIVE_INFINITY)),
      (r = vr(r, Number.POSITIVE_INFINITY)),
      (i = vr(i, Number.NEGATIVE_INFINITY)),
      { min: vr(t, r), max: vr(n, i), minDefined: Bt(t), maxDefined: Bt(n) }
    )
  }
  getMinMax(t) {
    let { min: n, max: r, minDefined: i, maxDefined: o } = this.getUserBounds(),
      c
    if (i && o) return { min: n, max: r }
    const h = this.getMatchingVisibleMetas()
    for (let f = 0, p = h.length; f < p; ++f)
      ((c = h[f].controller.getMinMax(this, t)),
        i || (n = Math.min(n, c.min)),
        o || (r = Math.max(r, c.max)))
    return (
      (n = o && n > r ? r : n),
      (r = i && n > r ? n : r),
      { min: vr(n, vr(r, n)), max: vr(r, vr(n, r)) }
    )
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0,
    }
  }
  getTicks() {
    return this.ticks
  }
  getLabels() {
    const t = this.chart.data
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t))
  }
  beforeLayout() {
    ;((this._cache = {}), (this._dataLimitsCached = !1))
  }
  beforeUpdate() {
    Qe(this.options.beforeUpdate, [this])
  }
  update(t, n, r) {
    const { beginAtZero: i, grace: o, ticks: c } = this.options,
      h = c.sampleSize
    ;(this.beforeUpdate(),
      (this.maxWidth = t),
      (this.maxHeight = n),
      (this._margins = r = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, r)),
      (this.ticks = null),
      (this._labelSizes = null),
      (this._gridLineItems = null),
      (this._labelItems = null),
      this.beforeSetDimensions(),
      this.setDimensions(),
      this.afterSetDimensions(),
      (this._maxLength = this.isHorizontal()
        ? this.width + r.left + r.right
        : this.height + r.top + r.bottom),
      this._dataLimitsCached ||
        (this.beforeDataLimits(),
        this.determineDataLimits(),
        this.afterDataLimits(),
        (this._range = N9(this, o, i)),
        (this._dataLimitsCached = !0)),
      this.beforeBuildTicks(),
      (this.ticks = this.buildTicks() || []),
      this.afterBuildTicks())
    const f = h < this.ticks.length
    ;(this._convertTicksToLabels(f ? ty(this.ticks, h) : this.ticks),
      this.configure(),
      this.beforeCalculateLabelRotation(),
      this.calculateLabelRotation(),
      this.afterCalculateLabelRotation(),
      c.display &&
        (c.autoSkip || c.source === 'auto') &&
        ((this.ticks = lI(this, this.ticks)), (this._labelSizes = null), this.afterAutoSkip()),
      f && this._convertTicksToLabels(this.ticks),
      this.beforeFit(),
      this.fit(),
      this.afterFit(),
      this.afterUpdate())
  }
  configure() {
    let t = this.options.reverse,
      n,
      r
    ;(this.isHorizontal()
      ? ((n = this.left), (r = this.right))
      : ((n = this.top), (r = this.bottom), (t = !t)),
      (this._startPixel = n),
      (this._endPixel = r),
      (this._reversePixels = t),
      (this._length = r - n),
      (this._alignToPixels = this.options.alignToPixels))
  }
  afterUpdate() {
    Qe(this.options.afterUpdate, [this])
  }
  beforeSetDimensions() {
    Qe(this.options.beforeSetDimensions, [this])
  }
  setDimensions() {
    ;(this.isHorizontal()
      ? ((this.width = this.maxWidth), (this.left = 0), (this.right = this.width))
      : ((this.height = this.maxHeight), (this.top = 0), (this.bottom = this.height)),
      (this.paddingLeft = 0),
      (this.paddingTop = 0),
      (this.paddingRight = 0),
      (this.paddingBottom = 0))
  }
  afterSetDimensions() {
    Qe(this.options.afterSetDimensions, [this])
  }
  _callHooks(t) {
    ;(this.chart.notifyPlugins(t, this.getContext()), Qe(this.options[t], [this]))
  }
  beforeDataLimits() {
    this._callHooks('beforeDataLimits')
  }
  determineDataLimits() {}
  afterDataLimits() {
    this._callHooks('afterDataLimits')
  }
  beforeBuildTicks() {
    this._callHooks('beforeBuildTicks')
  }
  buildTicks() {
    return []
  }
  afterBuildTicks() {
    this._callHooks('afterBuildTicks')
  }
  beforeTickToLabelConversion() {
    Qe(this.options.beforeTickToLabelConversion, [this])
  }
  generateTickLabels(t) {
    const n = this.options.ticks
    let r, i, o
    for (r = 0, i = t.length; r < i; r++)
      ((o = t[r]), (o.label = Qe(n.callback, [o.value, r, t], this)))
  }
  afterTickToLabelConversion() {
    Qe(this.options.afterTickToLabelConversion, [this])
  }
  beforeCalculateLabelRotation() {
    Qe(this.options.beforeCalculateLabelRotation, [this])
  }
  calculateLabelRotation() {
    const t = this.options,
      n = t.ticks,
      r = ey(this.ticks.length, t.ticks.maxTicksLimit),
      i = n.minRotation || 0,
      o = n.maxRotation
    let c = i,
      h,
      f,
      p
    if (!this._isVisible() || !n.display || i >= o || r <= 1 || !this.isHorizontal()) {
      this.labelRotation = i
      return
    }
    const y = this._getLabelSizes(),
      w = y.widest.width,
      x = y.highest.height,
      E = Mn(this.chart.width - w, 0, this.maxWidth)
    ;((h = t.offset ? this.maxWidth / r : E / (r - 1)),
      w + 6 > h &&
        ((h = E / (r - (t.offset ? 0.5 : 1))),
        (f = this.maxHeight - Sa(t.grid) - n.padding - ny(t.title, this.chart.options.font)),
        (p = Math.sqrt(w * w + x * x)),
        (c = op(
          Math.min(
            Math.asin(Mn((y.highest.height + 6) / h, -1, 1)),
            Math.asin(Mn(f / p, -1, 1)) - Math.asin(Mn(x / p, -1, 1))
          )
        )),
        (c = Math.max(i, Math.min(o, c)))),
      (this.labelRotation = c))
  }
  afterCalculateLabelRotation() {
    Qe(this.options.afterCalculateLabelRotation, [this])
  }
  afterAutoSkip() {}
  beforeFit() {
    Qe(this.options.beforeFit, [this])
  }
  fit() {
    const t = { width: 0, height: 0 },
      {
        chart: n,
        options: { ticks: r, title: i, grid: o },
      } = this,
      c = this._isVisible(),
      h = this.isHorizontal()
    if (c) {
      const f = ny(i, n.options.font)
      if (
        (h
          ? ((t.width = this.maxWidth), (t.height = Sa(o) + f))
          : ((t.height = this.maxHeight), (t.width = Sa(o) + f)),
        r.display && this.ticks.length)
      ) {
        const { first: p, last: y, widest: w, highest: x } = this._getLabelSizes(),
          E = r.padding * 2,
          S = yi(this.labelRotation),
          k = Math.cos(S),
          P = Math.sin(S)
        if (h) {
          const I = r.mirror ? 0 : P * w.width + k * x.height
          t.height = Math.min(this.maxHeight, t.height + I + E)
        } else {
          const I = r.mirror ? 0 : k * w.width + P * x.height
          t.width = Math.min(this.maxWidth, t.width + I + E)
        }
        this._calculatePadding(p, y, P, k)
      }
    }
    ;(this._handleMargins(),
      h
        ? ((this.width = this._length = n.width - this._margins.left - this._margins.right),
          (this.height = t.height))
        : ((this.width = t.width),
          (this.height = this._length = n.height - this._margins.top - this._margins.bottom)))
  }
  _calculatePadding(t, n, r, i) {
    const {
        ticks: { align: o, padding: c },
        position: h,
      } = this.options,
      f = this.labelRotation !== 0,
      p = h !== 'top' && this.axis === 'x'
    if (this.isHorizontal()) {
      const y = this.getPixelForTick(0) - this.left,
        w = this.right - this.getPixelForTick(this.ticks.length - 1)
      let x = 0,
        E = 0
      ;(f
        ? p
          ? ((x = i * t.width), (E = r * n.height))
          : ((x = r * t.height), (E = i * n.width))
        : o === 'start'
          ? (E = n.width)
          : o === 'end'
            ? (x = t.width)
            : o !== 'inner' && ((x = t.width / 2), (E = n.width / 2)),
        (this.paddingLeft = Math.max(((x - y + c) * this.width) / (this.width - y), 0)),
        (this.paddingRight = Math.max(((E - w + c) * this.width) / (this.width - w), 0)))
    } else {
      let y = n.height / 2,
        w = t.height / 2
      ;(o === 'start' ? ((y = 0), (w = t.height)) : o === 'end' && ((y = n.height), (w = 0)),
        (this.paddingTop = y + c),
        (this.paddingBottom = w + c))
    }
  }
  _handleMargins() {
    this._margins &&
      ((this._margins.left = Math.max(this.paddingLeft, this._margins.left)),
      (this._margins.top = Math.max(this.paddingTop, this._margins.top)),
      (this._margins.right = Math.max(this.paddingRight, this._margins.right)),
      (this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)))
  }
  afterFit() {
    Qe(this.options.afterFit, [this])
  }
  isHorizontal() {
    const { axis: t, position: n } = this.options
    return n === 'top' || n === 'bottom' || t === 'x'
  }
  isFullSize() {
    return this.options.fullSize
  }
  _convertTicksToLabels(t) {
    ;(this.beforeTickToLabelConversion(), this.generateTickLabels(t))
    let n, r
    for (n = 0, r = t.length; n < r; n++) Oe(t[n].label) && (t.splice(n, 1), r--, n--)
    this.afterTickToLabelConversion()
  }
  _getLabelSizes() {
    let t = this._labelSizes
    if (!t) {
      const n = this.options.ticks.sampleSize
      let r = this.ticks
      ;(n < r.length && (r = ty(r, n)),
        (this._labelSizes = t =
          this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit)))
    }
    return t
  }
  _computeLabelSizes(t, n, r) {
    const { ctx: i, _longestTextCache: o } = this,
      c = [],
      h = [],
      f = Math.floor(n / ey(n, r))
    let p = 0,
      y = 0,
      w,
      x,
      E,
      S,
      k,
      P,
      I,
      R,
      M,
      O,
      F
    for (w = 0; w < n; w += f) {
      if (
        ((S = t[w].label),
        (k = this._resolveTickFontOptions(w)),
        (i.font = P = k.string),
        (I = o[P] = o[P] || { data: {}, gc: [] }),
        (R = k.lineHeight),
        (M = O = 0),
        !Oe(S) && !ct(S))
      )
        ((M = Vu(i, I.data, I.gc, M, S)), (O = R))
      else if (ct(S))
        for (x = 0, E = S.length; x < E; ++x)
          ((F = S[x]), !Oe(F) && !ct(F) && ((M = Vu(i, I.data, I.gc, M, F)), (O += R)))
      ;(c.push(M), h.push(O), (p = Math.max(M, p)), (y = Math.max(O, y)))
    }
    mI(o, n)
    const z = c.indexOf(p),
      V = h.indexOf(y),
      U = (Z) => ({ width: c[Z] || 0, height: h[Z] || 0 })
    return { first: U(0), last: U(n - 1), widest: U(z), highest: U(V), widths: c, heights: h }
  }
  getLabelForValue(t) {
    return t
  }
  getPixelForValue(t, n) {
    return NaN
  }
  getValueForPixel(t) {}
  getPixelForTick(t) {
    const n = this.ticks
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value)
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t)
    const n = this._startPixel + t * this._length
    return t9(this._alignToPixels ? Qi(this.chart, n, 0) : n)
  }
  getDecimalForPixel(t) {
    const n = (t - this._startPixel) / this._length
    return this._reversePixels ? 1 - n : n
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue())
  }
  getBaseValue() {
    const { min: t, max: n } = this
    return t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0
  }
  getContext(t) {
    const n = this.ticks || []
    if (t >= 0 && t < n.length) {
      const r = n[t]
      return r.$context || (r.$context = wI(this.getContext(), t, r))
    }
    return this.$context || (this.$context = yI(this.chart.getContext(), this))
  }
  _tickSize() {
    const t = this.options.ticks,
      n = yi(this.labelRotation),
      r = Math.abs(Math.cos(n)),
      i = Math.abs(Math.sin(n)),
      o = this._getLabelSizes(),
      c = t.autoSkipPadding || 0,
      h = o ? o.widest.width + c : 0,
      f = o ? o.highest.height + c : 0
    return this.isHorizontal() ? (f * r > h * i ? h / r : f / i) : f * i < h * r ? f / r : h / i
  }
  _isVisible() {
    const t = this.options.display
    return t !== 'auto' ? !!t : this.getMatchingVisibleMetas().length > 0
  }
  _computeGridLineItems(t) {
    const n = this.axis,
      r = this.chart,
      i = this.options,
      { grid: o, position: c, border: h } = i,
      f = o.offset,
      p = this.isHorizontal(),
      y = this.ticks.length + (f ? 1 : 0),
      w = Sa(o),
      x = [],
      E = h.setContext(this.getContext()),
      S = E.display ? E.width : 0,
      k = S / 2,
      P = function (H) {
        return Qi(r, H, S)
      }
    let I, R, M, O, F, z, V, U, Z, J, oe, re
    if (c === 'top')
      ((I = P(this.bottom)),
        (z = this.bottom - w),
        (U = I - k),
        (J = P(t.top) + k),
        (re = t.bottom))
    else if (c === 'bottom')
      ((I = P(this.top)), (J = t.top), (re = P(t.bottom) - k), (z = I + k), (U = this.top + w))
    else if (c === 'left')
      ((I = P(this.right)), (F = this.right - w), (V = I - k), (Z = P(t.left) + k), (oe = t.right))
    else if (c === 'right')
      ((I = P(this.left)), (Z = t.left), (oe = P(t.right) - k), (F = I + k), (V = this.left + w))
    else if (n === 'x') {
      if (c === 'center') I = P((t.top + t.bottom) / 2 + 0.5)
      else if (Me(c)) {
        const H = Object.keys(c)[0],
          xe = c[H]
        I = P(this.chart.scales[H].getPixelForValue(xe))
      }
      ;((J = t.top), (re = t.bottom), (z = I + k), (U = z + w))
    } else if (n === 'y') {
      if (c === 'center') I = P((t.left + t.right) / 2)
      else if (Me(c)) {
        const H = Object.keys(c)[0],
          xe = c[H]
        I = P(this.chart.scales[H].getPixelForValue(xe))
      }
      ;((F = I - k), (V = F - w), (Z = t.left), (oe = t.right))
    }
    const ve = _e(i.ticks.maxTicksLimit, y),
      Ie = Math.max(1, Math.ceil(y / ve))
    for (R = 0; R < y; R += Ie) {
      const H = this.getContext(R),
        xe = o.setContext(H),
        ge = h.setContext(H),
        se = xe.lineWidth,
        fe = xe.color,
        pe = ge.dash || [],
        We = ge.dashOffset,
        Se = xe.tickWidth,
        Tt = xe.tickColor,
        Be = xe.tickBorderDash || [],
        Sn = xe.tickBorderDashOffset
      ;((M = gI(this, R, f)),
        M !== void 0 &&
          ((O = Qi(r, M, se)),
          p ? (F = V = Z = oe = O) : (z = U = J = re = O),
          x.push({
            tx1: F,
            ty1: z,
            tx2: V,
            ty2: U,
            x1: Z,
            y1: J,
            x2: oe,
            y2: re,
            width: se,
            color: fe,
            borderDash: pe,
            borderDashOffset: We,
            tickWidth: Se,
            tickColor: Tt,
            tickBorderDash: Be,
            tickBorderDashOffset: Sn,
          })))
    }
    return ((this._ticksLength = y), (this._borderValue = I), x)
  }
  _computeLabelItems(t) {
    const n = this.axis,
      r = this.options,
      { position: i, ticks: o } = r,
      c = this.isHorizontal(),
      h = this.ticks,
      { align: f, crossAlign: p, padding: y, mirror: w } = o,
      x = Sa(r.grid),
      E = x + y,
      S = w ? -y : E,
      k = -yi(this.labelRotation),
      P = []
    let I,
      R,
      M,
      O,
      F,
      z,
      V,
      U,
      Z,
      J,
      oe,
      re,
      ve = 'middle'
    if (i === 'top') ((z = this.bottom - S), (V = this._getXAxisLabelAlignment()))
    else if (i === 'bottom') ((z = this.top + S), (V = this._getXAxisLabelAlignment()))
    else if (i === 'left') {
      const H = this._getYAxisLabelAlignment(x)
      ;((V = H.textAlign), (F = H.x))
    } else if (i === 'right') {
      const H = this._getYAxisLabelAlignment(x)
      ;((V = H.textAlign), (F = H.x))
    } else if (n === 'x') {
      if (i === 'center') z = (t.top + t.bottom) / 2 + E
      else if (Me(i)) {
        const H = Object.keys(i)[0],
          xe = i[H]
        z = this.chart.scales[H].getPixelForValue(xe) + E
      }
      V = this._getXAxisLabelAlignment()
    } else if (n === 'y') {
      if (i === 'center') F = (t.left + t.right) / 2 - E
      else if (Me(i)) {
        const H = Object.keys(i)[0],
          xe = i[H]
        F = this.chart.scales[H].getPixelForValue(xe)
      }
      V = this._getYAxisLabelAlignment(x).textAlign
    }
    n === 'y' && (f === 'start' ? (ve = 'top') : f === 'end' && (ve = 'bottom'))
    const Ie = this._getLabelSizes()
    for (I = 0, R = h.length; I < R; ++I) {
      ;((M = h[I]), (O = M.label))
      const H = o.setContext(this.getContext(I))
      ;((U = this.getPixelForTick(I) + o.labelOffset),
        (Z = this._resolveTickFontOptions(I)),
        (J = Z.lineHeight),
        (oe = ct(O) ? O.length : 1))
      const xe = oe / 2,
        ge = H.color,
        se = H.textStrokeColor,
        fe = H.textStrokeWidth
      let pe = V
      c
        ? ((F = U),
          V === 'inner' &&
            (I === R - 1
              ? (pe = this.options.reverse ? 'left' : 'right')
              : I === 0
                ? (pe = this.options.reverse ? 'right' : 'left')
                : (pe = 'center')),
          i === 'top'
            ? p === 'near' || k !== 0
              ? (re = -oe * J + J / 2)
              : p === 'center'
                ? (re = -Ie.highest.height / 2 - xe * J + J)
                : (re = -Ie.highest.height + J / 2)
            : p === 'near' || k !== 0
              ? (re = J / 2)
              : p === 'center'
                ? (re = Ie.highest.height / 2 - xe * J)
                : (re = Ie.highest.height - oe * J),
          w && (re *= -1),
          k !== 0 && !H.showLabelBackdrop && (F += (J / 2) * Math.sin(k)))
        : ((z = U), (re = ((1 - oe) * J) / 2))
      let We
      if (H.showLabelBackdrop) {
        const Se = on(H.backdropPadding),
          Tt = Ie.heights[I],
          Be = Ie.widths[I]
        let Sn = re - Se.top,
          ue = 0 - Se.left
        switch (ve) {
          case 'middle':
            Sn -= Tt / 2
            break
          case 'bottom':
            Sn -= Tt
            break
        }
        switch (V) {
          case 'center':
            ue -= Be / 2
            break
          case 'right':
            ue -= Be
            break
          case 'inner':
            I === R - 1 ? (ue -= Be) : I > 0 && (ue -= Be / 2)
            break
        }
        We = {
          left: ue,
          top: Sn,
          width: Be + Se.width,
          height: Tt + Se.height,
          color: H.backdropColor,
        }
      }
      P.push({
        label: O,
        font: Z,
        textOffset: re,
        options: {
          rotation: k,
          color: ge,
          strokeColor: se,
          strokeWidth: fe,
          textAlign: pe,
          textBaseline: ve,
          translation: [F, z],
          backdrop: We,
        },
      })
    }
    return P
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: n } = this.options
    if (-yi(this.labelRotation)) return t === 'top' ? 'left' : 'right'
    let r = 'center'
    return (
      n.align === 'start'
        ? (r = 'left')
        : n.align === 'end'
          ? (r = 'right')
          : n.align === 'inner' && (r = 'inner'),
      r
    )
  }
  _getYAxisLabelAlignment(t) {
    const {
        position: n,
        ticks: { crossAlign: r, mirror: i, padding: o },
      } = this.options,
      c = this._getLabelSizes(),
      h = t + o,
      f = c.widest.width
    let p, y
    return (
      n === 'left'
        ? i
          ? ((y = this.right + o),
            r === 'near'
              ? (p = 'left')
              : r === 'center'
                ? ((p = 'center'), (y += f / 2))
                : ((p = 'right'), (y += f)))
          : ((y = this.right - h),
            r === 'near'
              ? (p = 'right')
              : r === 'center'
                ? ((p = 'center'), (y -= f / 2))
                : ((p = 'left'), (y = this.left)))
        : n === 'right'
          ? i
            ? ((y = this.left + o),
              r === 'near'
                ? (p = 'right')
                : r === 'center'
                  ? ((p = 'center'), (y -= f / 2))
                  : ((p = 'left'), (y -= f)))
            : ((y = this.left + h),
              r === 'near'
                ? (p = 'left')
                : r === 'center'
                  ? ((p = 'center'), (y += f / 2))
                  : ((p = 'right'), (y = this.right)))
          : (p = 'right'),
      { textAlign: p, x: y }
    )
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) return
    const t = this.chart,
      n = this.options.position
    if (n === 'left' || n === 'right')
      return { top: 0, left: this.left, bottom: t.height, right: this.right }
    if (n === 'top' || n === 'bottom')
      return { top: this.top, left: 0, bottom: this.bottom, right: t.width }
  }
  drawBackground() {
    const {
      ctx: t,
      options: { backgroundColor: n },
      left: r,
      top: i,
      width: o,
      height: c,
    } = this
    n && (t.save(), (t.fillStyle = n), t.fillRect(r, i, o, c), t.restore())
  }
  getLineWidthForValue(t) {
    const n = this.options.grid
    if (!this._isVisible() || !n.display) return 0
    const r = this.ticks.findIndex((i) => i.value === t)
    return r >= 0 ? n.setContext(this.getContext(r)).lineWidth : 0
  }
  drawGrid(t) {
    const n = this.options.grid,
      r = this.ctx,
      i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t))
    let o, c
    const h = (f, p, y) => {
      !y.width ||
        !y.color ||
        (r.save(),
        (r.lineWidth = y.width),
        (r.strokeStyle = y.color),
        r.setLineDash(y.borderDash || []),
        (r.lineDashOffset = y.borderDashOffset),
        r.beginPath(),
        r.moveTo(f.x, f.y),
        r.lineTo(p.x, p.y),
        r.stroke(),
        r.restore())
    }
    if (n.display)
      for (o = 0, c = i.length; o < c; ++o) {
        const f = i[o]
        ;(n.drawOnChartArea && h({ x: f.x1, y: f.y1 }, { x: f.x2, y: f.y2 }, f),
          n.drawTicks &&
            h(
              { x: f.tx1, y: f.ty1 },
              { x: f.tx2, y: f.ty2 },
              {
                color: f.tickColor,
                width: f.tickWidth,
                borderDash: f.tickBorderDash,
                borderDashOffset: f.tickBorderDashOffset,
              }
            ))
      }
  }
  drawBorder() {
    const {
        chart: t,
        ctx: n,
        options: { border: r, grid: i },
      } = this,
      o = r.setContext(this.getContext()),
      c = r.display ? o.width : 0
    if (!c) return
    const h = i.setContext(this.getContext(0)).lineWidth,
      f = this._borderValue
    let p, y, w, x
    ;(this.isHorizontal()
      ? ((p = Qi(t, this.left, c) - c / 2), (y = Qi(t, this.right, h) + h / 2), (w = x = f))
      : ((w = Qi(t, this.top, c) - c / 2), (x = Qi(t, this.bottom, h) + h / 2), (p = y = f)),
      n.save(),
      (n.lineWidth = o.width),
      (n.strokeStyle = o.color),
      n.beginPath(),
      n.moveTo(p, w),
      n.lineTo(y, x),
      n.stroke(),
      n.restore())
  }
  drawLabels(t) {
    if (!this.options.ticks.display) return
    const n = this.ctx,
      r = this._computeLabelArea()
    r && xh(n, r)
    const i = this.getLabelItems(t)
    for (const o of i) {
      const c = o.options,
        h = o.font,
        f = o.label,
        p = o.textOffset
      Uo(n, f, 0, p, h, c)
    }
    r && Eh(n)
  }
  drawTitle() {
    const {
      ctx: t,
      options: { position: n, title: r, reverse: i },
    } = this
    if (!r.display) return
    const o = Ht(r.font),
      c = on(r.padding),
      h = r.align
    let f = o.lineHeight / 2
    n === 'bottom' || n === 'center' || Me(n)
      ? ((f += c.bottom), ct(r.text) && (f += o.lineHeight * (r.text.length - 1)))
      : (f += c.top)
    const { titleX: p, titleY: y, maxWidth: w, rotation: x } = vI(this, f, n, h)
    Uo(t, r.text, 0, 0, o, {
      color: r.color,
      maxWidth: w,
      rotation: x,
      textAlign: bI(h, n, i),
      textBaseline: 'middle',
      translation: [p, y],
    })
  }
  draw(t) {
    this._isVisible() &&
      (this.drawBackground(),
      this.drawGrid(t),
      this.drawBorder(),
      this.drawTitle(),
      this.drawLabels(t))
  }
  _layers() {
    const t = this.options,
      n = (t.ticks && t.ticks.z) || 0,
      r = _e(t.grid && t.grid.z, -1),
      i = _e(t.border && t.border.z, 0)
    return !this._isVisible() || this.draw !== $o.prototype.draw
      ? [
          {
            z: n,
            draw: (o) => {
              this.draw(o)
            },
          },
        ]
      : [
          {
            z: r,
            draw: (o) => {
              ;(this.drawBackground(), this.drawGrid(o), this.drawTitle())
            },
          },
          {
            z: i,
            draw: () => {
              this.drawBorder()
            },
          },
          {
            z: n,
            draw: (o) => {
              this.drawLabels(o)
            },
          },
        ]
  }
  getMatchingVisibleMetas(t) {
    const n = this.chart.getSortedVisibleDatasetMetas(),
      r = this.axis + 'AxisID',
      i = []
    let o, c
    for (o = 0, c = n.length; o < c; ++o) {
      const h = n[o]
      h[r] === this.id && (!t || h.type === t) && i.push(h)
    }
    return i
  }
  _resolveTickFontOptions(t) {
    const n = this.options.ticks.setContext(this.getContext(t))
    return Ht(n.font)
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight
    return (this.isHorizontal() ? this.width : this.height) / t
  }
}
class Mc {
  constructor(t, n, r) {
    ;((this.type = t), (this.scope = n), (this.override = r), (this.items = Object.create(null)))
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
  }
  register(t) {
    const n = Object.getPrototypeOf(t)
    let r
    CI(n) && (r = this.register(n))
    const i = this.items,
      o = t.id,
      c = this.scope + '.' + o
    if (!o) throw new Error('class does not have id: ' + t)
    return (o in i || ((i[o] = t), xI(t, c, r), this.override && bt.override(t.id, t.overrides)), c)
  }
  get(t) {
    return this.items[t]
  }
  unregister(t) {
    const n = this.items,
      r = t.id,
      i = this.scope
    ;(r in n && delete n[r], i && r in bt[i] && (delete bt[i][r], this.override && delete Cs[r]))
  }
}
function xI(e, t, n) {
  const r = kl(Object.create(null), [n ? bt.get(n) : {}, bt.get(t), e.defaults])
  ;(bt.set(t, r),
    e.defaultRoutes && EI(t, e.defaultRoutes),
    e.descriptors && bt.describe(t, e.descriptors))
}
function EI(e, t) {
  Object.keys(t).forEach((n) => {
    const r = n.split('.'),
      i = r.pop(),
      o = [e].concat(r).join('.'),
      c = t[n].split('.'),
      h = c.pop(),
      f = c.join('.')
    bt.route(o, i, f, h)
  })
}
function CI(e) {
  return 'id' in e && 'defaults' in e
}
class SI {
  constructor() {
    ;((this.controllers = new Mc(gs, 'datasets', !0)),
      (this.elements = new Mc(zs, 'elements')),
      (this.plugins = new Mc(Object, 'plugins')),
      (this.scales = new Mc($o, 'scales')),
      (this._typedRegistries = [this.controllers, this.scales, this.elements]))
  }
  add(...t) {
    this._each('register', t)
  }
  remove(...t) {
    this._each('unregister', t)
  }
  addControllers(...t) {
    this._each('register', t, this.controllers)
  }
  addElements(...t) {
    this._each('register', t, this.elements)
  }
  addPlugins(...t) {
    this._each('register', t, this.plugins)
  }
  addScales(...t) {
    this._each('register', t, this.scales)
  }
  getController(t) {
    return this._get(t, this.controllers, 'controller')
  }
  getElement(t) {
    return this._get(t, this.elements, 'element')
  }
  getPlugin(t) {
    return this._get(t, this.plugins, 'plugin')
  }
  getScale(t) {
    return this._get(t, this.scales, 'scale')
  }
  removeControllers(...t) {
    this._each('unregister', t, this.controllers)
  }
  removeElements(...t) {
    this._each('unregister', t, this.elements)
  }
  removePlugins(...t) {
    this._each('unregister', t, this.plugins)
  }
  removeScales(...t) {
    this._each('unregister', t, this.scales)
  }
  _each(t, n, r) {
    ;[...n].forEach((i) => {
      const o = r || this._getRegistryForType(i)
      r || o.isForType(i) || (o === this.plugins && i.id)
        ? this._exec(t, o, i)
        : ze(i, (c) => {
            const h = r || this._getRegistryForType(c)
            this._exec(t, h, c)
          })
    })
  }
  _exec(t, n, r) {
    const i = sp(t)
    ;(Qe(r['before' + i], [], r), n[t](r), Qe(r['after' + i], [], r))
  }
  _getRegistryForType(t) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const r = this._typedRegistries[n]
      if (r.isForType(t)) return r
    }
    return this.plugins
  }
  _get(t, n, r) {
    const i = n.get(t)
    if (i === void 0) throw new Error('"' + t + '" is not a registered ' + r + '.')
    return i
  }
}
var Cr = new SI()
class AI {
  constructor() {
    this._init = void 0
  }
  notify(t, n, r, i) {
    if (
      (n === 'beforeInit' &&
        ((this._init = this._createDescriptors(t, !0)), this._notify(this._init, t, 'install')),
      this._init === void 0)
    )
      return
    const o = i ? this._descriptors(t).filter(i) : this._descriptors(t),
      c = this._notify(o, t, n, r)
    return (
      n === 'afterDestroy' &&
        (this._notify(o, t, 'stop'),
        this._notify(this._init, t, 'uninstall'),
        (this._init = void 0)),
      c
    )
  }
  _notify(t, n, r, i) {
    i = i || {}
    for (const o of t) {
      const c = o.plugin,
        h = c[r],
        f = [n, i, o.options]
      if (Qe(h, f, c) === !1 && i.cancelable) return !1
    }
    return !0
  }
  invalidate() {
    Oe(this._cache) || ((this._oldCache = this._cache), (this._cache = void 0))
  }
  _descriptors(t) {
    if (this._cache) return this._cache
    const n = (this._cache = this._createDescriptors(t))
    return (this._notifyStateChanges(t), n)
  }
  _createDescriptors(t, n) {
    const r = t && t.config,
      i = _e(r.options && r.options.plugins, {}),
      o = kI(r)
    return i === !1 && !n ? [] : II(t, o, i, n)
  }
  _notifyStateChanges(t) {
    const n = this._oldCache || [],
      r = this._cache,
      i = (o, c) => o.filter((h) => !c.some((f) => h.plugin.id === f.plugin.id))
    ;(this._notify(i(n, r), t, 'stop'), this._notify(i(r, n), t, 'start'))
  }
}
function kI(e) {
  const t = {},
    n = [],
    r = Object.keys(Cr.plugins.items)
  for (let o = 0; o < r.length; o++) n.push(Cr.getPlugin(r[o]))
  const i = e.plugins || []
  for (let o = 0; o < i.length; o++) {
    const c = i[o]
    n.indexOf(c) === -1 && (n.push(c), (t[c.id] = !0))
  }
  return { plugins: n, localIds: t }
}
function _I(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e
}
function II(e, { plugins: t, localIds: n }, r, i) {
  const o = [],
    c = e.getContext()
  for (const h of t) {
    const f = h.id,
      p = _I(r[f], i)
    p !== null && o.push({ plugin: h, options: NI(e.config, { plugin: h, local: n[f] }, p, c) })
  }
  return o
}
function NI(e, { plugin: t, local: n }, r, i) {
  const o = e.pluginScopeKeys(t),
    c = e.getOptionScopes(r, o)
  return (
    n && t.defaults && c.push(t.defaults),
    e.createResolver(c, i, [''], { scriptable: !1, indexable: !1, allKeys: !0 })
  )
}
function df(e, t) {
  const n = bt.datasets[e] || {}
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || 'x'
}
function TI(e, t) {
  let n = e
  return (e === '_index_' ? (n = t) : e === '_value_' && (n = t === 'x' ? 'y' : 'x'), n)
}
function RI(e, t) {
  return e === t ? '_index_' : '_value_'
}
function ry(e) {
  if (e === 'x' || e === 'y' || e === 'r') return e
}
function MI(e) {
  if (e === 'top' || e === 'bottom') return 'x'
  if (e === 'left' || e === 'right') return 'y'
}
function ff(e, ...t) {
  if (ry(e)) return e
  for (const n of t) {
    const r = n.axis || MI(n.position) || (e.length > 1 && ry(e[0].toLowerCase()))
    if (r) return r
  }
  throw new Error(
    `Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`
  )
}
function iy(e, t, n) {
  if (n[t + 'AxisID'] === e) return { axis: t }
}
function PI(e, t) {
  if (t.data && t.data.datasets) {
    const n = t.data.datasets.filter((r) => r.xAxisID === e || r.yAxisID === e)
    if (n.length) return iy(e, 'x', n[0]) || iy(e, 'y', n[0])
  }
  return {}
}
function DI(e, t) {
  const n = Cs[e.type] || { scales: {} },
    r = t.scales || {},
    i = df(e.type, t),
    o = Object.create(null)
  return (
    Object.keys(r).forEach((c) => {
      const h = r[c]
      if (!Me(h)) return console.error(`Invalid scale configuration for scale: ${c}`)
      if (h._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${c}`)
      const f = ff(c, h, PI(c, e), bt.scales[h.type]),
        p = RI(f, i),
        y = n.scales || {}
      o[c] = Ka(Object.create(null), [{ axis: f }, h, y[f], y[p]])
    }),
    e.data.datasets.forEach((c) => {
      const h = c.type || e.type,
        f = c.indexAxis || df(h, t),
        p = (Cs[h] || {}).scales || {}
      Object.keys(p).forEach((y) => {
        const w = TI(y, f),
          x = c[w + 'AxisID'] || w
        ;((o[x] = o[x] || Object.create(null)), Ka(o[x], [{ axis: w }, r[x], p[y]]))
      })
    }),
    Object.keys(o).forEach((c) => {
      const h = o[c]
      Ka(h, [bt.scales[h.type], bt.scale])
    }),
    o
  )
}
function O3(e) {
  const t = e.options || (e.options = {})
  ;((t.plugins = _e(t.plugins, {})), (t.scales = DI(e, t)))
}
function B3(e) {
  return ((e = e || {}), (e.datasets = e.datasets || []), (e.labels = e.labels || []), e)
}
function LI(e) {
  return ((e = e || {}), (e.data = B3(e.data)), O3(e), e)
}
const sy = new Map(),
  F3 = new Set()
function Pc(e, t) {
  let n = sy.get(e)
  return (n || ((n = t()), sy.set(e, n), F3.add(n)), n)
}
const Aa = (e, t, n) => {
  const r = Es(t, n)
  r !== void 0 && e.add(r)
}
class OI {
  constructor(t) {
    ;((this._config = LI(t)), (this._scopeCache = new Map()), (this._resolverCache = new Map()))
  }
  get platform() {
    return this._config.platform
  }
  get type() {
    return this._config.type
  }
  set type(t) {
    this._config.type = t
  }
  get data() {
    return this._config.data
  }
  set data(t) {
    this._config.data = B3(t)
  }
  get options() {
    return this._config.options
  }
  set options(t) {
    this._config.options = t
  }
  get plugins() {
    return this._config.plugins
  }
  update() {
    const t = this._config
    ;(this.clearCache(), O3(t))
  }
  clearCache() {
    ;(this._scopeCache.clear(), this._resolverCache.clear())
  }
  datasetScopeKeys(t) {
    return Pc(t, () => [[`datasets.${t}`, '']])
  }
  datasetAnimationScopeKeys(t, n) {
    return Pc(`${t}.transition.${n}`, () => [
      [`datasets.${t}.transitions.${n}`, `transitions.${n}`],
      [`datasets.${t}`, ''],
    ])
  }
  datasetElementScopeKeys(t, n) {
    return Pc(`${t}-${n}`, () => [
      [`datasets.${t}.elements.${n}`, `datasets.${t}`, `elements.${n}`, ''],
    ])
  }
  pluginScopeKeys(t) {
    const n = t.id,
      r = this.type
    return Pc(`${r}-plugin-${n}`, () => [[`plugins.${n}`, ...(t.additionalOptionScopes || [])]])
  }
  _cachedScopes(t, n) {
    const r = this._scopeCache
    let i = r.get(t)
    return ((!i || n) && ((i = new Map()), r.set(t, i)), i)
  }
  getOptionScopes(t, n, r) {
    const { options: i, type: o } = this,
      c = this._cachedScopes(t, r),
      h = c.get(n)
    if (h) return h
    const f = new Set()
    n.forEach((y) => {
      ;(t && (f.add(t), y.forEach((w) => Aa(f, t, w))),
        y.forEach((w) => Aa(f, i, w)),
        y.forEach((w) => Aa(f, Cs[o] || {}, w)),
        y.forEach((w) => Aa(f, bt, w)),
        y.forEach((w) => Aa(f, uf, w)))
    })
    const p = Array.from(f)
    return (p.length === 0 && p.push(Object.create(null)), F3.has(n) && c.set(n, p), p)
  }
  chartOptionScopes() {
    const { options: t, type: n } = this
    return [t, Cs[n] || {}, bt.datasets[n] || {}, { type: n }, bt, uf]
  }
  resolveNamedOptions(t, n, r, i = ['']) {
    const o = { $shared: !0 },
      { resolver: c, subPrefixes: h } = oy(this._resolverCache, t, i)
    let f = c
    if (FI(c, n)) {
      ;((o.$shared = !1), (r = Oi(r) ? r() : r))
      const p = this.createResolver(t, r, h)
      f = Wo(c, r, p)
    }
    for (const p of n) o[p] = f[p]
    return o
  }
  createResolver(t, n, r = [''], i) {
    const { resolver: o } = oy(this._resolverCache, t, r)
    return Me(n) ? Wo(o, n, void 0, i) : o
  }
}
function oy(e, t, n) {
  let r = e.get(t)
  r || ((r = new Map()), e.set(t, r))
  const i = n.join()
  let o = r.get(i)
  return (
    o ||
      ((o = {
        resolver: up(t, n),
        subPrefixes: n.filter((c) => !c.toLowerCase().includes('hover')),
      }),
      r.set(i, o)),
    o
  )
}
const BI = (e) => Me(e) && Object.getOwnPropertyNames(e).some((t) => Oi(e[t]))
function FI(e, t) {
  const { isScriptable: n, isIndexable: r } = y3(e)
  for (const i of t) {
    const o = n(i),
      c = r(i),
      h = (c || o) && e[i]
    if ((o && (Oi(h) || BI(h))) || (c && ct(h))) return !0
  }
  return !1
}
var jI = '4.5.1'
const VI = ['top', 'bottom', 'left', 'right', 'chartArea']
function ay(e, t) {
  return e === 'top' || e === 'bottom' || (VI.indexOf(e) === -1 && t === 'x')
}
function ly(e, t) {
  return function (n, r) {
    return n[e] === r[e] ? n[t] - r[t] : n[e] - r[e]
  }
}
function cy(e) {
  const t = e.chart,
    n = t.options.animation
  ;(t.notifyPlugins('afterRender'), Qe(n && n.onComplete, [e], t))
}
function UI(e) {
  const t = e.chart,
    n = t.options.animation
  Qe(n && n.onProgress, [e], t)
}
function j3(e) {
  return (
    fp() && typeof e == 'string' ? (e = document.getElementById(e)) : e && e.length && (e = e[0]),
    e && e.canvas && (e = e.canvas),
    e
  )
}
const nu = {},
  uy = (e) => {
    const t = j3(e)
    return Object.values(nu)
      .filter((n) => n.canvas === t)
      .pop()
  }
function WI(e, t, n) {
  const r = Object.keys(e)
  for (const i of r) {
    const o = +i
    if (o >= t) {
      const c = e[i]
      ;(delete e[i], (n > 0 || o > t) && (e[o + n] = c))
    }
  }
}
function zI(e, t, n, r) {
  return !n || e.type === 'mouseout' ? null : r ? t : e
}
var ai
let Wl =
  ((ai = class {
    static register(...e) {
      ;(Cr.add(...e), hy())
    }
    static unregister(...e) {
      ;(Cr.remove(...e), hy())
    }
    constructor(e, t) {
      const n = (this.config = new OI(t)),
        r = j3(e),
        i = uy(r)
      if (i)
        throw new Error(
          "Canvas is already in use. Chart with ID '" +
            i.id +
            "' must be destroyed before the canvas with ID '" +
            i.canvas.id +
            "' can be reused."
        )
      const o = n.createResolver(n.chartOptionScopes(), this.getContext())
      ;((this.platform = new (n.platform || aI(r))()), this.platform.updateConfig(n))
      const c = this.platform.acquireContext(r, o.aspectRatio),
        h = c && c.canvas,
        f = h && h.height,
        p = h && h.width
      if (
        ((this.id = Vk()),
        (this.ctx = c),
        (this.canvas = h),
        (this.width = p),
        (this.height = f),
        (this._options = o),
        (this._aspectRatio = this.aspectRatio),
        (this._layers = []),
        (this._metasets = []),
        (this._stacks = void 0),
        (this.boxes = []),
        (this.currentDevicePixelRatio = void 0),
        (this.chartArea = void 0),
        (this._active = []),
        (this._lastEvent = void 0),
        (this._listeners = {}),
        (this._responsiveListeners = void 0),
        (this._sortedMetasets = []),
        (this.scales = {}),
        (this._plugins = new AI()),
        (this.$proxies = {}),
        (this._hiddenIndices = {}),
        (this.attached = !1),
        (this._animationsDisabled = void 0),
        (this.$context = void 0),
        (this._doResize = s9((y) => this.update(y), o.resizeDelay || 0)),
        (this._dataChanges = []),
        (nu[this.id] = this),
        !c || !h)
      ) {
        console.error("Failed to create chart: can't acquire context from the given item")
        return
      }
      ;(Mr.listen(this, 'complete', cy),
        Mr.listen(this, 'progress', UI),
        this._initialize(),
        this.attached && this.update())
    }
    get aspectRatio() {
      const {
        options: { aspectRatio: e, maintainAspectRatio: t },
        width: n,
        height: r,
        _aspectRatio: i,
      } = this
      return Oe(e) ? (t && i ? i : r ? n / r : null) : e
    }
    get data() {
      return this.config.data
    }
    set data(e) {
      this.config.data = e
    }
    get options() {
      return this._options
    }
    set options(e) {
      this.config.options = e
    }
    get registry() {
      return Cr
    }
    _initialize() {
      return (
        this.notifyPlugins('beforeInit'),
        this.options.responsive ? this.resize() : Pm(this, this.options.devicePixelRatio),
        this.bindEvents(),
        this.notifyPlugins('afterInit'),
        this
      )
    }
    clear() {
      return (Tm(this.canvas, this.ctx), this)
    }
    stop() {
      return (Mr.stop(this), this)
    }
    resize(e, t) {
      Mr.running(this) ? (this._resizeBeforeDraw = { width: e, height: t }) : this._resize(e, t)
    }
    _resize(e, t) {
      const n = this.options,
        r = this.canvas,
        i = n.maintainAspectRatio && this.aspectRatio,
        o = this.platform.getMaximumSize(r, e, t, i),
        c = n.devicePixelRatio || this.platform.getDevicePixelRatio(),
        h = this.width ? 'resize' : 'attach'
      ;((this.width = o.width),
        (this.height = o.height),
        (this._aspectRatio = this.aspectRatio),
        Pm(this, c, !0) &&
          (this.notifyPlugins('resize', { size: o }),
          Qe(n.onResize, [this, o], this),
          this.attached && this._doResize(h) && this.render()))
    }
    ensureScalesHaveIDs() {
      const e = this.options.scales || {}
      ze(e, (t, n) => {
        t.id = n
      })
    }
    buildOrUpdateScales() {
      const e = this.options,
        t = e.scales,
        n = this.scales,
        r = Object.keys(n).reduce((o, c) => ((o[c] = !1), o), {})
      let i = []
      ;(t &&
        (i = i.concat(
          Object.keys(t).map((o) => {
            const c = t[o],
              h = ff(o, c),
              f = h === 'r',
              p = h === 'x'
            return {
              options: c,
              dposition: f ? 'chartArea' : p ? 'bottom' : 'left',
              dtype: f ? 'radialLinear' : p ? 'category' : 'linear',
            }
          })
        )),
        ze(i, (o) => {
          const c = o.options,
            h = c.id,
            f = ff(h, c),
            p = _e(c.type, o.dtype)
          ;((c.position === void 0 || ay(c.position, f) !== ay(o.dposition)) &&
            (c.position = o.dposition),
            (r[h] = !0))
          let y = null
          if (h in n && n[h].type === p) y = n[h]
          else {
            const w = Cr.getScale(p)
            ;((y = new w({ id: h, type: p, ctx: this.ctx, chart: this })), (n[y.id] = y))
          }
          y.init(c, e)
        }),
        ze(r, (o, c) => {
          o || delete n[c]
        }),
        ze(n, (o) => {
          ;(vi.configure(this, o, o.options), vi.addBox(this, o))
        }))
    }
    _updateMetasets() {
      const e = this._metasets,
        t = this.data.datasets.length,
        n = e.length
      if ((e.sort((r, i) => r.index - i.index), n > t)) {
        for (let r = t; r < n; ++r) this._destroyDatasetMeta(r)
        e.splice(t, n - t)
      }
      this._sortedMetasets = e.slice(0).sort(ly('order', 'index'))
    }
    _removeUnreferencedMetasets() {
      const {
        _metasets: e,
        data: { datasets: t },
      } = this
      ;(e.length > t.length && delete this._stacks,
        e.forEach((n, r) => {
          t.filter((i) => i === n._dataset).length === 0 && this._destroyDatasetMeta(r)
        }))
    }
    buildOrUpdateControllers() {
      const e = [],
        t = this.data.datasets
      let n, r
      for (this._removeUnreferencedMetasets(), n = 0, r = t.length; n < r; n++) {
        const i = t[n]
        let o = this.getDatasetMeta(n)
        const c = i.type || this.config.type
        if (
          (o.type && o.type !== c && (this._destroyDatasetMeta(n), (o = this.getDatasetMeta(n))),
          (o.type = c),
          (o.indexAxis = i.indexAxis || df(c, this.options)),
          (o.order = i.order || 0),
          (o.index = n),
          (o.label = '' + i.label),
          (o.visible = this.isDatasetVisible(n)),
          o.controller)
        )
          (o.controller.updateIndex(n), o.controller.linkScales())
        else {
          const h = Cr.getController(c),
            { datasetElementType: f, dataElementType: p } = bt.datasets[c]
          ;(Object.assign(h, {
            dataElementType: Cr.getElement(p),
            datasetElementType: f && Cr.getElement(f),
          }),
            (o.controller = new h(this, n)),
            e.push(o.controller))
        }
      }
      return (this._updateMetasets(), e)
    }
    _resetElements() {
      ze(
        this.data.datasets,
        (e, t) => {
          this.getDatasetMeta(t).controller.reset()
        },
        this
      )
    }
    reset() {
      ;(this._resetElements(), this.notifyPlugins('reset'))
    }
    update(e) {
      const t = this.config
      t.update()
      const n = (this._options = t.createResolver(t.chartOptionScopes(), this.getContext())),
        r = (this._animationsDisabled = !n.animation)
      if (
        (this._updateScales(),
        this._checkEventBindings(),
        this._updateHiddenIndices(),
        this._plugins.invalidate(),
        this.notifyPlugins('beforeUpdate', { mode: e, cancelable: !0 }) === !1)
      )
        return
      const i = this.buildOrUpdateControllers()
      this.notifyPlugins('beforeElementsUpdate')
      let o = 0
      for (let f = 0, p = this.data.datasets.length; f < p; f++) {
        const { controller: y } = this.getDatasetMeta(f),
          w = !r && i.indexOf(y) === -1
        ;(y.buildOrUpdateElements(w), (o = Math.max(+y.getMaxOverflow(), o)))
      }
      ;((o = this._minPadding = n.layout.autoPadding ? o : 0),
        this._updateLayout(o),
        r ||
          ze(i, (f) => {
            f.reset()
          }),
        this._updateDatasets(e),
        this.notifyPlugins('afterUpdate', { mode: e }),
        this._layers.sort(ly('z', '_idx')))
      const { _active: c, _lastEvent: h } = this
      ;(h ? this._eventHandler(h, !0) : c.length && this._updateHoverStyles(c, c, !0),
        this.render())
    }
    _updateScales() {
      ;(ze(this.scales, (e) => {
        vi.removeBox(this, e)
      }),
        this.ensureScalesHaveIDs(),
        this.buildOrUpdateScales())
    }
    _checkEventBindings() {
      const e = this.options,
        t = new Set(Object.keys(this._listeners)),
        n = new Set(e.events)
      ;(!xm(t, n) || !!this._responsiveListeners !== e.responsive) &&
        (this.unbindEvents(), this.bindEvents())
    }
    _updateHiddenIndices() {
      const { _hiddenIndices: e } = this,
        t = this._getUniformDataChanges() || []
      for (const { method: n, start: r, count: i } of t) {
        const o = n === '_removeElements' ? -i : i
        WI(e, r, o)
      }
    }
    _getUniformDataChanges() {
      const e = this._dataChanges
      if (!e || !e.length) return
      this._dataChanges = []
      const t = this.data.datasets.length,
        n = (i) =>
          new Set(e.filter((o) => o[0] === i).map((o, c) => c + ',' + o.splice(1).join(','))),
        r = n(0)
      for (let i = 1; i < t; i++) if (!xm(r, n(i))) return
      return Array.from(r)
        .map((i) => i.split(','))
        .map((i) => ({ method: i[1], start: +i[2], count: +i[3] }))
    }
    _updateLayout(e) {
      if (this.notifyPlugins('beforeLayout', { cancelable: !0 }) === !1) return
      vi.update(this, this.width, this.height, e)
      const t = this.chartArea,
        n = t.width <= 0 || t.height <= 0
      ;((this._layers = []),
        ze(
          this.boxes,
          (r) => {
            ;(n && r.position === 'chartArea') ||
              (r.configure && r.configure(), this._layers.push(...r._layers()))
          },
          this
        ),
        this._layers.forEach((r, i) => {
          r._idx = i
        }),
        this.notifyPlugins('afterLayout'))
    }
    _updateDatasets(e) {
      if (this.notifyPlugins('beforeDatasetsUpdate', { mode: e, cancelable: !0 }) !== !1) {
        for (let t = 0, n = this.data.datasets.length; t < n; ++t)
          this.getDatasetMeta(t).controller.configure()
        for (let t = 0, n = this.data.datasets.length; t < n; ++t)
          this._updateDataset(t, Oi(e) ? e({ datasetIndex: t }) : e)
        this.notifyPlugins('afterDatasetsUpdate', { mode: e })
      }
    }
    _updateDataset(e, t) {
      const n = this.getDatasetMeta(e),
        r = { meta: n, index: e, mode: t, cancelable: !0 }
      this.notifyPlugins('beforeDatasetUpdate', r) !== !1 &&
        (n.controller._update(t), (r.cancelable = !1), this.notifyPlugins('afterDatasetUpdate', r))
    }
    render() {
      this.notifyPlugins('beforeRender', { cancelable: !0 }) !== !1 &&
        (Mr.has(this)
          ? this.attached && !Mr.running(this) && Mr.start(this)
          : (this.draw(), cy({ chart: this })))
    }
    draw() {
      let e
      if (this._resizeBeforeDraw) {
        const { width: n, height: r } = this._resizeBeforeDraw
        ;((this._resizeBeforeDraw = null), this._resize(n, r))
      }
      if (
        (this.clear(),
        this.width <= 0 ||
          this.height <= 0 ||
          this.notifyPlugins('beforeDraw', { cancelable: !0 }) === !1)
      )
        return
      const t = this._layers
      for (e = 0; e < t.length && t[e].z <= 0; ++e) t[e].draw(this.chartArea)
      for (this._drawDatasets(); e < t.length; ++e) t[e].draw(this.chartArea)
      this.notifyPlugins('afterDraw')
    }
    _getSortedDatasetMetas(e) {
      const t = this._sortedMetasets,
        n = []
      let r, i
      for (r = 0, i = t.length; r < i; ++r) {
        const o = t[r]
        ;(!e || o.visible) && n.push(o)
      }
      return n
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(!0)
    }
    _drawDatasets() {
      if (this.notifyPlugins('beforeDatasetsDraw', { cancelable: !0 }) === !1) return
      const e = this.getSortedVisibleDatasetMetas()
      for (let t = e.length - 1; t >= 0; --t) this._drawDataset(e[t])
      this.notifyPlugins('afterDatasetsDraw')
    }
    _drawDataset(e) {
      const t = this.ctx,
        n = { meta: e, index: e.index, cancelable: !0 },
        r = _3(this, e)
      this.notifyPlugins('beforeDatasetDraw', n) !== !1 &&
        (r && xh(t, r),
        e.controller.draw(),
        r && Eh(t),
        (n.cancelable = !1),
        this.notifyPlugins('afterDatasetDraw', n))
    }
    isPointInArea(e) {
      return Vr(e, this.chartArea, this._minPadding)
    }
    getElementsAtEventForMode(e, t, n, r) {
      const i = V_.modes[t]
      return typeof i == 'function' ? i(this, e, n, r) : []
    }
    getDatasetMeta(e) {
      const t = this.data.datasets[e],
        n = this._metasets
      let r = n.filter((i) => i && i._dataset === t).pop()
      return (
        r ||
          ((r = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: (t && t.order) || 0,
            index: e,
            _dataset: t,
            _parsed: [],
            _sorted: !1,
          }),
          n.push(r)),
        r
      )
    }
    getContext() {
      return this.$context || (this.$context = Wi(null, { chart: this, type: 'chart' }))
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length
    }
    isDatasetVisible(e) {
      const t = this.data.datasets[e]
      if (!t) return !1
      const n = this.getDatasetMeta(e)
      return typeof n.hidden == 'boolean' ? !n.hidden : !t.hidden
    }
    setDatasetVisibility(e, t) {
      const n = this.getDatasetMeta(e)
      n.hidden = !t
    }
    toggleDataVisibility(e) {
      this._hiddenIndices[e] = !this._hiddenIndices[e]
    }
    getDataVisibility(e) {
      return !this._hiddenIndices[e]
    }
    _updateVisibility(e, t, n) {
      const r = n ? 'show' : 'hide',
        i = this.getDatasetMeta(e),
        o = i.controller._resolveAnimations(void 0, r)
      _l(t)
        ? ((i.data[t].hidden = !n), this.update())
        : (this.setDatasetVisibility(e, n),
          o.update(i, { visible: n }),
          this.update((c) => (c.datasetIndex === e ? r : void 0)))
    }
    hide(e, t) {
      this._updateVisibility(e, t, !1)
    }
    show(e, t) {
      this._updateVisibility(e, t, !0)
    }
    _destroyDatasetMeta(e) {
      const t = this._metasets[e]
      ;(t && t.controller && t.controller._destroy(), delete this._metasets[e])
    }
    _stop() {
      let e, t
      for (this.stop(), Mr.remove(this), e = 0, t = this.data.datasets.length; e < t; ++e)
        this._destroyDatasetMeta(e)
    }
    destroy() {
      this.notifyPlugins('beforeDestroy')
      const { canvas: e, ctx: t } = this
      ;(this._stop(),
        this.config.clearCache(),
        e &&
          (this.unbindEvents(),
          Tm(e, t),
          this.platform.releaseContext(t),
          (this.canvas = null),
          (this.ctx = null)),
        delete nu[this.id],
        this.notifyPlugins('afterDestroy'))
    }
    toBase64Image(...e) {
      return this.canvas.toDataURL(...e)
    }
    bindEvents() {
      ;(this.bindUserEvents(),
        this.options.responsive ? this.bindResponsiveEvents() : (this.attached = !0))
    }
    bindUserEvents() {
      const e = this._listeners,
        t = this.platform,
        n = (i, o) => {
          ;(t.addEventListener(this, i, o), (e[i] = o))
        },
        r = (i, o, c) => {
          ;((i.offsetX = o), (i.offsetY = c), this._eventHandler(i))
        }
      ze(this.options.events, (i) => n(i, r))
    }
    bindResponsiveEvents() {
      this._responsiveListeners || (this._responsiveListeners = {})
      const e = this._responsiveListeners,
        t = this.platform,
        n = (h, f) => {
          ;(t.addEventListener(this, h, f), (e[h] = f))
        },
        r = (h, f) => {
          e[h] && (t.removeEventListener(this, h, f), delete e[h])
        },
        i = (h, f) => {
          this.canvas && this.resize(h, f)
        }
      let o
      const c = () => {
        ;(r('attach', c), (this.attached = !0), this.resize(), n('resize', i), n('detach', o))
      }
      ;((o = () => {
        ;((this.attached = !1), r('resize', i), this._stop(), this._resize(0, 0), n('attach', c))
      }),
        t.isAttached(this.canvas) ? c() : o())
    }
    unbindEvents() {
      ;(ze(this._listeners, (e, t) => {
        this.platform.removeEventListener(this, t, e)
      }),
        (this._listeners = {}),
        ze(this._responsiveListeners, (e, t) => {
          this.platform.removeEventListener(this, t, e)
        }),
        (this._responsiveListeners = void 0))
    }
    updateHoverStyle(e, t, n) {
      const r = n ? 'set' : 'remove'
      let i, o, c, h
      for (
        t === 'dataset' &&
          ((i = this.getDatasetMeta(e[0].datasetIndex)),
          i.controller['_' + r + 'DatasetHoverStyle']()),
          c = 0,
          h = e.length;
        c < h;
        ++c
      ) {
        o = e[c]
        const f = o && this.getDatasetMeta(o.datasetIndex).controller
        f && f[r + 'HoverStyle'](o.element, o.datasetIndex, o.index)
      }
    }
    getActiveElements() {
      return this._active || []
    }
    setActiveElements(e) {
      const t = this._active || [],
        n = e.map(({ datasetIndex: r, index: i }) => {
          const o = this.getDatasetMeta(r)
          if (!o) throw new Error('No dataset found at index ' + r)
          return { datasetIndex: r, element: o.data[i], index: i }
        })
      !Bu(n, t) && ((this._active = n), (this._lastEvent = null), this._updateHoverStyles(n, t))
    }
    notifyPlugins(e, t, n) {
      return this._plugins.notify(this, e, t, n)
    }
    isPluginEnabled(e) {
      return this._plugins._cache.filter((t) => t.plugin.id === e).length === 1
    }
    _updateHoverStyles(e, t, n) {
      const r = this.options.hover,
        i = (h, f) =>
          h.filter((p) => !f.some((y) => p.datasetIndex === y.datasetIndex && p.index === y.index)),
        o = i(t, e),
        c = n ? e : i(e, t)
      ;(o.length && this.updateHoverStyle(o, r.mode, !1),
        c.length && r.mode && this.updateHoverStyle(c, r.mode, !0))
    }
    _eventHandler(e, t) {
      const n = { event: e, replay: t, cancelable: !0, inChartArea: this.isPointInArea(e) },
        r = (o) => (o.options.events || this.options.events).includes(e.native.type)
      if (this.notifyPlugins('beforeEvent', n, r) === !1) return
      const i = this._handleEvent(e, t, n.inChartArea)
      return (
        (n.cancelable = !1),
        this.notifyPlugins('afterEvent', n, r),
        (i || n.changed) && this.render(),
        this
      )
    }
    _handleEvent(e, t, n) {
      const { _active: r = [], options: i } = this,
        o = t,
        c = this._getActiveElements(e, r, n, o),
        h = Gk(e),
        f = zI(e, this._lastEvent, n, h)
      n &&
        ((this._lastEvent = null),
        Qe(i.onHover, [e, c, this], this),
        h && Qe(i.onClick, [e, c, this], this))
      const p = !Bu(c, r)
      return (
        (p || t) && ((this._active = c), this._updateHoverStyles(c, r, t)),
        (this._lastEvent = f),
        p
      )
    }
    _getActiveElements(e, t, n, r) {
      if (e.type === 'mouseout') return []
      if (!n) return t
      const i = this.options.hover
      return this.getElementsAtEventForMode(e, i.mode, i, r)
    }
  }),
  ye(ai, 'defaults', bt),
  ye(ai, 'instances', nu),
  ye(ai, 'overrides', Cs),
  ye(ai, 'registry', Cr),
  ye(ai, 'version', jI),
  ye(ai, 'getChart', uy),
  ai)
function hy() {
  return ze(Wl.instances, (e) => e._plugins.invalidate())
}
function V3(e, t, n = t) {
  ;((e.lineCap = _e(n.borderCapStyle, t.borderCapStyle)),
    e.setLineDash(_e(n.borderDash, t.borderDash)),
    (e.lineDashOffset = _e(n.borderDashOffset, t.borderDashOffset)),
    (e.lineJoin = _e(n.borderJoinStyle, t.borderJoinStyle)),
    (e.lineWidth = _e(n.borderWidth, t.borderWidth)),
    (e.strokeStyle = _e(n.borderColor, t.borderColor)))
}
function HI(e, t, n) {
  e.lineTo(n.x, n.y)
}
function XI(e) {
  return e.stepped ? v9 : e.tension || e.cubicInterpolationMode === 'monotone' ? x9 : HI
}
function U3(e, t, n = {}) {
  const r = e.length,
    { start: i = 0, end: o = r - 1 } = n,
    { start: c, end: h } = t,
    f = Math.max(i, c),
    p = Math.min(o, h),
    y = (i < c && o < c) || (i > h && o > h)
  return { count: r, start: f, loop: t.loop, ilen: p < f && !y ? r + p - f : p - f }
}
function GI(e, t, n, r) {
  const { points: i, options: o } = t,
    { count: c, start: h, loop: f, ilen: p } = U3(i, n, r),
    y = XI(o)
  let { move: w = !0, reverse: x } = r || {},
    E,
    S,
    k
  for (E = 0; E <= p; ++E)
    ((S = i[(h + (x ? p - E : E)) % c]),
      !S.skip && (w ? (e.moveTo(S.x, S.y), (w = !1)) : y(e, k, S, x, o.stepped), (k = S)))
  return (f && ((S = i[(h + (x ? p : 0)) % c]), y(e, k, S, x, o.stepped)), !!f)
}
function YI(e, t, n, r) {
  const i = t.points,
    { count: o, start: c, ilen: h } = U3(i, n, r),
    { move: f = !0, reverse: p } = r || {}
  let y = 0,
    w = 0,
    x,
    E,
    S,
    k,
    P,
    I
  const R = (O) => (c + (p ? h - O : O)) % o,
    M = () => {
      k !== P && (e.lineTo(y, P), e.lineTo(y, k), e.lineTo(y, I))
    }
  for (f && ((E = i[R(0)]), e.moveTo(E.x, E.y)), x = 0; x <= h; ++x) {
    if (((E = i[R(x)]), E.skip)) continue
    const O = E.x,
      F = E.y,
      z = O | 0
    ;(z === S
      ? (F < k ? (k = F) : F > P && (P = F), (y = (w * y + O) / ++w))
      : (M(), e.lineTo(O, F), (S = z), (w = 0), (k = P = F)),
      (I = F))
  }
  M()
}
function pf(e) {
  const t = e.options,
    n = t.borderDash && t.borderDash.length
  return !e._decimated &&
    !e._loop &&
    !t.tension &&
    t.cubicInterpolationMode !== 'monotone' &&
    !t.stepped &&
    !n
    ? YI
    : GI
}
function ZI(e) {
  return e.stepped ? e_ : e.tension || e.cubicInterpolationMode === 'monotone' ? t_ : is
}
function KI(e, t, n, r) {
  let i = t._path
  ;(i || ((i = t._path = new Path2D()), t.path(i, n, r) && i.closePath()),
    V3(e, t.options),
    e.stroke(i))
}
function qI(e, t, n, r) {
  const { segments: i, options: o } = t,
    c = pf(t)
  for (const h of i)
    (V3(e, o, h.style),
      e.beginPath(),
      c(e, t, h, { start: n, end: n + r - 1 }) && e.closePath(),
      e.stroke())
}
const QI = typeof Path2D == 'function'
function $I(e, t, n, r) {
  QI && !t.options.segment ? KI(e, t, n, r) : qI(e, t, n, r)
}
class Ur extends zs {
  constructor(t) {
    ;(super(),
      (this.animated = !0),
      (this.options = void 0),
      (this._chart = void 0),
      (this._loop = void 0),
      (this._fullLoop = void 0),
      (this._path = void 0),
      (this._points = void 0),
      (this._segments = void 0),
      (this._decimated = !1),
      (this._pointsUpdated = !1),
      (this._datasetIndex = void 0),
      t && Object.assign(this, t))
  }
  updateControlPoints(t, n) {
    const r = this.options
    if (
      (r.tension || r.cubicInterpolationMode === 'monotone') &&
      !r.stepped &&
      !this._pointsUpdated
    ) {
      const i = r.spanGaps ? this._loop : this._fullLoop
      ;(G9(this._points, r, t, i, n), (this._pointsUpdated = !0))
    }
  }
  set points(t) {
    ;((this._points = t), delete this._segments, delete this._path, (this._pointsUpdated = !1))
  }
  get points() {
    return this._points
  }
  get segments() {
    return this._segments || (this._segments = a_(this, this.options.segment))
  }
  first() {
    const t = this.segments,
      n = this.points
    return t.length && n[t[0].start]
  }
  last() {
    const t = this.segments,
      n = this.points,
      r = t.length
    return r && n[t[r - 1].end]
  }
  interpolate(t, n) {
    const r = this.options,
      i = t[n],
      o = this.points,
      c = k3(this, { property: n, start: i, end: i })
    if (!c.length) return
    const h = [],
      f = ZI(r)
    let p, y
    for (p = 0, y = c.length; p < y; ++p) {
      const { start: w, end: x } = c[p],
        E = o[w],
        S = o[x]
      if (E === S) {
        h.push(E)
        continue
      }
      const k = Math.abs((i - E[n]) / (S[n] - E[n])),
        P = f(E, S, k, r.stepped)
      ;((P[n] = t[n]), h.push(P))
    }
    return h.length === 1 ? h[0] : h
  }
  pathSegment(t, n, r) {
    return pf(this)(t, this, n, r)
  }
  path(t, n, r) {
    const i = this.segments,
      o = pf(this)
    let c = this._loop
    ;((n = n || 0), (r = r || this.points.length - n))
    for (const h of i) c &= o(t, this, h, { start: n, end: n + r - 1 })
    return !!c
  }
  draw(t, n, r, i) {
    const o = this.options || {}
    ;((this.points || []).length && o.borderWidth && (t.save(), $I(t, this, r, i), t.restore()),
      this.animated && ((this._pointsUpdated = !1), (this._path = void 0)))
  }
}
;(ye(Ur, 'id', 'line'),
  ye(Ur, 'defaults', {
    borderCapStyle: 'butt',
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: 'miter',
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: 'default',
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0,
  }),
  ye(Ur, 'defaultRoutes', { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }),
  ye(Ur, 'descriptors', { _scriptable: !0, _indexable: (e) => e !== 'borderDash' && e !== 'fill' }))
function dy(e, t, n, r) {
  const i = e.options,
    { [n]: o } = e.getProps([n], r)
  return Math.abs(t - o) < i.radius + i.hitRadius
}
class Ja extends zs {
  constructor(t) {
    ;(super(),
      ye(this, 'parsed'),
      ye(this, 'skip'),
      ye(this, 'stop'),
      (this.options = void 0),
      (this.parsed = void 0),
      (this.skip = void 0),
      (this.stop = void 0),
      t && Object.assign(this, t))
  }
  inRange(t, n, r) {
    const i = this.options,
      { x: o, y: c } = this.getProps(['x', 'y'], r)
    return Math.pow(t - o, 2) + Math.pow(n - c, 2) < Math.pow(i.hitRadius + i.radius, 2)
  }
  inXRange(t, n) {
    return dy(this, t, 'x', n)
  }
  inYRange(t, n) {
    return dy(this, t, 'y', n)
  }
  getCenterPoint(t) {
    const { x: n, y: r } = this.getProps(['x', 'y'], t)
    return { x: n, y: r }
  }
  size(t) {
    t = t || this.options || {}
    let n = t.radius || 0
    n = Math.max(n, (n && t.hoverRadius) || 0)
    const r = (n && t.borderWidth) || 0
    return (n + r) * 2
  }
  draw(t, n) {
    const r = this.options
    this.skip ||
      r.radius < 0.1 ||
      !Vr(this, n, this.size(r) / 2) ||
      ((t.strokeStyle = r.borderColor),
      (t.lineWidth = r.borderWidth),
      (t.fillStyle = r.backgroundColor),
      hf(t, r, this.x, this.y))
  }
  getRange() {
    const t = this.options || {}
    return t.radius + t.hitRadius
  }
}
;(ye(Ja, 'id', 'point'),
  ye(Ja, 'defaults', {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: 'circle',
    radius: 3,
    rotation: 0,
  }),
  ye(Ja, 'defaultRoutes', { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }))
function W3(e, t) {
  const {
    x: n,
    y: r,
    base: i,
    width: o,
    height: c,
  } = e.getProps(['x', 'y', 'base', 'width', 'height'], t)
  let h, f, p, y, w
  return (
    e.horizontal
      ? ((w = c / 2), (h = Math.min(n, i)), (f = Math.max(n, i)), (p = r - w), (y = r + w))
      : ((w = o / 2), (h = n - w), (f = n + w), (p = Math.min(r, i)), (y = Math.max(r, i))),
    { left: h, top: p, right: f, bottom: y }
  )
}
function xi(e, t, n, r) {
  return e ? 0 : Mn(t, n, r)
}
function JI(e, t, n) {
  const r = e.options.borderWidth,
    i = e.borderSkipped,
    o = m3(r)
  return {
    t: xi(i.top, o.top, 0, n),
    r: xi(i.right, o.right, 0, t),
    b: xi(i.bottom, o.bottom, 0, n),
    l: xi(i.left, o.left, 0, t),
  }
}
function eN(e, t, n) {
  const { enableBorderRadius: r } = e.getProps(['enableBorderRadius']),
    i = e.options.borderRadius,
    o = fs(i),
    c = Math.min(t, n),
    h = e.borderSkipped,
    f = r || Me(i)
  return {
    topLeft: xi(!f || h.top || h.left, o.topLeft, 0, c),
    topRight: xi(!f || h.top || h.right, o.topRight, 0, c),
    bottomLeft: xi(!f || h.bottom || h.left, o.bottomLeft, 0, c),
    bottomRight: xi(!f || h.bottom || h.right, o.bottomRight, 0, c),
  }
}
function tN(e) {
  const t = W3(e),
    n = t.right - t.left,
    r = t.bottom - t.top,
    i = JI(e, n / 2, r / 2),
    o = eN(e, n / 2, r / 2)
  return {
    outer: { x: t.left, y: t.top, w: n, h: r, radius: o },
    inner: {
      x: t.left + i.l,
      y: t.top + i.t,
      w: n - i.l - i.r,
      h: r - i.t - i.b,
      radius: {
        topLeft: Math.max(0, o.topLeft - Math.max(i.t, i.l)),
        topRight: Math.max(0, o.topRight - Math.max(i.t, i.r)),
        bottomLeft: Math.max(0, o.bottomLeft - Math.max(i.b, i.l)),
        bottomRight: Math.max(0, o.bottomRight - Math.max(i.b, i.r)),
      },
    },
  }
}
function Hd(e, t, n, r) {
  const i = t === null,
    o = n === null,
    c = e && !(i && o) && W3(e, r)
  return c && (i || wi(t, c.left, c.right)) && (o || wi(n, c.top, c.bottom))
}
function nN(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight
}
function rN(e, t) {
  e.rect(t.x, t.y, t.w, t.h)
}
function Xd(e, t, n = {}) {
  const r = e.x !== n.x ? -t : 0,
    i = e.y !== n.y ? -t : 0,
    o = (e.x + e.w !== n.x + n.w ? t : 0) - r,
    c = (e.y + e.h !== n.y + n.h ? t : 0) - i
  return { x: e.x + r, y: e.y + i, w: e.w + o, h: e.h + c, radius: e.radius }
}
class ru extends zs {
  constructor(t) {
    ;(super(),
      (this.options = void 0),
      (this.horizontal = void 0),
      (this.base = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this.inflateAmount = void 0),
      t && Object.assign(this, t))
  }
  draw(t) {
    const {
        inflateAmount: n,
        options: { borderColor: r, backgroundColor: i },
      } = this,
      { inner: o, outer: c } = tN(this),
      h = nN(c.radius) ? Nl : rN
    ;(t.save(),
      (c.w !== o.w || c.h !== o.h) &&
        (t.beginPath(),
        h(t, Xd(c, n, o)),
        t.clip(),
        h(t, Xd(o, -n, c)),
        (t.fillStyle = r),
        t.fill('evenodd')),
      t.beginPath(),
      h(t, Xd(o, n)),
      (t.fillStyle = i),
      t.fill(),
      t.restore())
  }
  inRange(t, n, r) {
    return Hd(this, t, n, r)
  }
  inXRange(t, n) {
    return Hd(this, t, null, n)
  }
  inYRange(t, n) {
    return Hd(this, null, t, n)
  }
  getCenterPoint(t) {
    const {
      x: n,
      y: r,
      base: i,
      horizontal: o,
    } = this.getProps(['x', 'y', 'base', 'horizontal'], t)
    return { x: o ? (n + i) / 2 : n, y: o ? r : (r + i) / 2 }
  }
  getRange(t) {
    return t === 'x' ? this.width / 2 : this.height / 2
  }
}
;(ye(ru, 'id', 'bar'),
  ye(ru, 'defaults', {
    borderSkipped: 'start',
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: 'auto',
    pointStyle: void 0,
  }),
  ye(ru, 'defaultRoutes', { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }))
function iN(e, t, n) {
  const r = e.segments,
    i = e.points,
    o = t.points,
    c = []
  for (const h of r) {
    let { start: f, end: p } = h
    p = Ah(f, p, i)
    const y = gf(n, i[f], i[p], h.loop)
    if (!t.segments) {
      c.push({ source: h, target: y, start: i[f], end: i[p] })
      continue
    }
    const w = k3(t, y)
    for (const x of w) {
      const E = gf(n, o[x.start], o[x.end], x.loop),
        S = A3(h, i, E)
      for (const k of S)
        c.push({
          source: k,
          target: x,
          start: { [n]: fy(y, E, 'start', Math.max) },
          end: { [n]: fy(y, E, 'end', Math.min) },
        })
    }
  }
  return c
}
function gf(e, t, n, r) {
  if (r) return
  let i = t[e],
    o = n[e]
  return (e === 'angle' && ((i = Nn(i)), (o = Nn(o))), { property: e, start: i, end: o })
}
function sN(e, t) {
  const { x: n = null, y: r = null } = e || {},
    i = t.points,
    o = []
  return (
    t.segments.forEach(({ start: c, end: h }) => {
      h = Ah(c, h, i)
      const f = i[c],
        p = i[h]
      r !== null
        ? (o.push({ x: f.x, y: r }), o.push({ x: p.x, y: r }))
        : n !== null && (o.push({ x: n, y: f.y }), o.push({ x: n, y: p.y }))
    }),
    o
  )
}
function Ah(e, t, n) {
  for (; t > e; t--) {
    const r = n[t]
    if (!isNaN(r.x) && !isNaN(r.y)) break
  }
  return t
}
function fy(e, t, n, r) {
  return e && t ? r(e[n], t[n]) : e ? e[n] : t ? t[n] : 0
}
function z3(e, t) {
  let n = [],
    r = !1
  return (
    ct(e) ? ((r = !0), (n = e)) : (n = sN(e, t)),
    n.length ? new Ur({ points: n, options: { tension: 0 }, _loop: r, _fullLoop: r }) : null
  )
}
function py(e) {
  return e && e.fill !== !1
}
function oN(e, t, n) {
  let r = e[t].fill
  const i = [t]
  let o
  if (!n) return r
  for (; r !== !1 && i.indexOf(r) === -1; ) {
    if (!Bt(r)) return r
    if (((o = e[r]), !o)) return !1
    if (o.visible) return r
    ;(i.push(r), (r = o.fill))
  }
  return !1
}
function aN(e, t, n) {
  const r = hN(e)
  if (Me(r)) return isNaN(r.value) ? !1 : r
  let i = parseFloat(r)
  return Bt(i) && Math.floor(i) === i
    ? lN(r[0], t, i, n)
    : ['origin', 'start', 'end', 'stack', 'shape'].indexOf(r) >= 0 && r
}
function lN(e, t, n, r) {
  return ((e === '-' || e === '+') && (n = t + n), n === t || n < 0 || n >= r ? !1 : n)
}
function cN(e, t) {
  let n = null
  return (
    e === 'start'
      ? (n = t.bottom)
      : e === 'end'
        ? (n = t.top)
        : Me(e)
          ? (n = t.getPixelForValue(e.value))
          : t.getBasePixel && (n = t.getBasePixel()),
    n
  )
}
function uN(e, t, n) {
  let r
  return (
    e === 'start'
      ? (r = n)
      : e === 'end'
        ? (r = t.options.reverse ? t.min : t.max)
        : Me(e)
          ? (r = e.value)
          : (r = t.getBaseValue()),
    r
  )
}
function hN(e) {
  const t = e.options,
    n = t.fill
  let r = _e(n && n.target, n)
  return (
    r === void 0 && (r = !!t.backgroundColor),
    r === !1 || r === null ? !1 : r === !0 ? 'origin' : r
  )
}
function dN(e) {
  const { scale: t, index: n, line: r } = e,
    i = [],
    o = r.segments,
    c = r.points,
    h = fN(t, n)
  h.push(z3({ x: null, y: t.bottom }, r))
  for (let f = 0; f < o.length; f++) {
    const p = o[f]
    for (let y = p.start; y <= p.end; y++) pN(i, c[y], h)
  }
  return new Ur({ points: i, options: {} })
}
function fN(e, t) {
  const n = [],
    r = e.getMatchingVisibleMetas('line')
  for (let i = 0; i < r.length; i++) {
    const o = r[i]
    if (o.index === t) break
    o.hidden || n.unshift(o.dataset)
  }
  return n
}
function pN(e, t, n) {
  const r = []
  for (let i = 0; i < n.length; i++) {
    const o = n[i],
      { first: c, last: h, point: f } = gN(o, t, 'x')
    if (!(!f || (c && h))) {
      if (c) r.unshift(f)
      else if ((e.push(f), !h)) break
    }
  }
  e.push(...r)
}
function gN(e, t, n) {
  const r = e.interpolate(t, n)
  if (!r) return {}
  const i = r[n],
    o = e.segments,
    c = e.points
  let h = !1,
    f = !1
  for (let p = 0; p < o.length; p++) {
    const y = o[p],
      w = c[y.start][n],
      x = c[y.end][n]
    if (wi(i, w, x)) {
      ;((h = i === w), (f = i === x))
      break
    }
  }
  return { first: h, last: f, point: r }
}
class H3 {
  constructor(t) {
    ;((this.x = t.x), (this.y = t.y), (this.radius = t.radius))
  }
  pathSegment(t, n, r) {
    const { x: i, y: o, radius: c } = this
    return ((n = n || { start: 0, end: Ln }), t.arc(i, o, c, n.end, n.start, !0), !r.bounds)
  }
  interpolate(t) {
    const { x: n, y: r, radius: i } = this,
      o = t.angle
    return { x: n + Math.cos(o) * i, y: r + Math.sin(o) * i, angle: o }
  }
}
function mN(e) {
  const { chart: t, fill: n, line: r } = e
  if (Bt(n)) return yN(t, n)
  if (n === 'stack') return dN(e)
  if (n === 'shape') return !0
  const i = wN(e)
  return i instanceof H3 ? i : z3(i, r)
}
function yN(e, t) {
  const n = e.getDatasetMeta(t)
  return n && e.isDatasetVisible(t) ? n.dataset : null
}
function wN(e) {
  return (e.scale || {}).getPointPositionForValue ? vN(e) : bN(e)
}
function bN(e) {
  const { scale: t = {}, fill: n } = e,
    r = cN(n, t)
  if (Bt(r)) {
    const i = t.isHorizontal()
    return { x: i ? r : null, y: i ? null : r }
  }
  return null
}
function vN(e) {
  const { scale: t, fill: n } = e,
    r = t.options,
    i = t.getLabels().length,
    o = r.reverse ? t.max : t.min,
    c = uN(n, t, o),
    h = []
  if (r.grid.circular) {
    const f = t.getPointPositionForValue(0, o)
    return new H3({ x: f.x, y: f.y, radius: t.getDistanceFromCenterForValue(c) })
  }
  for (let f = 0; f < i; ++f) h.push(t.getPointPositionForValue(f, c))
  return h
}
function Gd(e, t, n) {
  const r = mN(t),
    { chart: i, index: o, line: c, scale: h, axis: f } = t,
    p = c.options,
    y = p.fill,
    w = p.backgroundColor,
    { above: x = w, below: E = w } = y || {},
    S = i.getDatasetMeta(o),
    k = _3(i, S)
  r &&
    c.points.length &&
    (xh(e, n),
    xN(e, { line: c, target: r, above: x, below: E, area: n, scale: h, axis: f, clip: k }),
    Eh(e))
}
function xN(e, t) {
  const { line: n, target: r, above: i, below: o, area: c, scale: h, clip: f } = t,
    p = n._loop ? 'angle' : t.axis
  e.save()
  let y = o
  ;(o !== i &&
    (p === 'x'
      ? (gy(e, r, c.top),
        Yd(e, { line: n, target: r, color: i, scale: h, property: p, clip: f }),
        e.restore(),
        e.save(),
        gy(e, r, c.bottom))
      : p === 'y' &&
        (my(e, r, c.left),
        Yd(e, { line: n, target: r, color: o, scale: h, property: p, clip: f }),
        e.restore(),
        e.save(),
        my(e, r, c.right),
        (y = i))),
    Yd(e, { line: n, target: r, color: y, scale: h, property: p, clip: f }),
    e.restore())
}
function gy(e, t, n) {
  const { segments: r, points: i } = t
  let o = !0,
    c = !1
  e.beginPath()
  for (const h of r) {
    const { start: f, end: p } = h,
      y = i[f],
      w = i[Ah(f, p, i)]
    ;(o ? (e.moveTo(y.x, y.y), (o = !1)) : (e.lineTo(y.x, n), e.lineTo(y.x, y.y)),
      (c = !!t.pathSegment(e, h, { move: c })),
      c ? e.closePath() : e.lineTo(w.x, n))
  }
  ;(e.lineTo(t.first().x, n), e.closePath(), e.clip())
}
function my(e, t, n) {
  const { segments: r, points: i } = t
  let o = !0,
    c = !1
  e.beginPath()
  for (const h of r) {
    const { start: f, end: p } = h,
      y = i[f],
      w = i[Ah(f, p, i)]
    ;(o ? (e.moveTo(y.x, y.y), (o = !1)) : (e.lineTo(n, y.y), e.lineTo(y.x, y.y)),
      (c = !!t.pathSegment(e, h, { move: c })),
      c ? e.closePath() : e.lineTo(n, w.y))
  }
  ;(e.lineTo(n, t.first().y), e.closePath(), e.clip())
}
function Yd(e, t) {
  const { line: n, target: r, property: i, color: o, scale: c, clip: h } = t,
    f = iN(n, r, i)
  for (const { source: p, target: y, start: w, end: x } of f) {
    const { style: { backgroundColor: E = o } = {} } = p,
      S = r !== !0
    ;(e.save(), (e.fillStyle = E), EN(e, c, h, S && gf(i, w, x)), e.beginPath())
    const k = !!n.pathSegment(e, p)
    let P
    if (S) {
      k ? e.closePath() : yy(e, r, x, i)
      const I = !!r.pathSegment(e, y, { move: k, reverse: !0 })
      ;((P = k && I), P || yy(e, r, w, i))
    }
    ;(e.closePath(), e.fill(P ? 'evenodd' : 'nonzero'), e.restore())
  }
}
function EN(e, t, n, r) {
  const i = t.chart.chartArea,
    { property: o, start: c, end: h } = r || {}
  if (o === 'x' || o === 'y') {
    let f, p, y, w
    ;(o === 'x'
      ? ((f = c), (p = i.top), (y = h), (w = i.bottom))
      : ((f = i.left), (p = c), (y = i.right), (w = h)),
      e.beginPath(),
      n &&
        ((f = Math.max(f, n.left)),
        (y = Math.min(y, n.right)),
        (p = Math.max(p, n.top)),
        (w = Math.min(w, n.bottom))),
      e.rect(f, p, y - f, w - p),
      e.clip())
  }
}
function yy(e, t, n, r) {
  const i = t.interpolate(n, r)
  i && e.lineTo(i.x, i.y)
}
var X3 = {
  id: 'filler',
  afterDatasetsUpdate(e, t, n) {
    const r = (e.data.datasets || []).length,
      i = []
    let o, c, h, f
    for (c = 0; c < r; ++c)
      ((o = e.getDatasetMeta(c)),
        (h = o.dataset),
        (f = null),
        h &&
          h.options &&
          h instanceof Ur &&
          (f = {
            visible: e.isDatasetVisible(c),
            index: c,
            fill: aN(h, c, r),
            chart: e,
            axis: o.controller.options.indexAxis,
            scale: o.vScale,
            line: h,
          }),
        (o.$filler = f),
        i.push(f))
    for (c = 0; c < r; ++c) ((f = i[c]), !(!f || f.fill === !1) && (f.fill = oN(i, c, n.propagate)))
  },
  beforeDraw(e, t, n) {
    const r = n.drawTime === 'beforeDraw',
      i = e.getSortedVisibleDatasetMetas(),
      o = e.chartArea
    for (let c = i.length - 1; c >= 0; --c) {
      const h = i[c].$filler
      h && (h.line.updateControlPoints(o, h.axis), r && h.fill && Gd(e.ctx, h, o))
    }
  },
  beforeDatasetsDraw(e, t, n) {
    if (n.drawTime !== 'beforeDatasetsDraw') return
    const r = e.getSortedVisibleDatasetMetas()
    for (let i = r.length - 1; i >= 0; --i) {
      const o = r[i].$filler
      py(o) && Gd(e.ctx, o, e.chartArea)
    }
  },
  beforeDatasetDraw(e, t, n) {
    const r = t.meta.$filler
    !py(r) || n.drawTime !== 'beforeDatasetDraw' || Gd(e.ctx, r, e.chartArea)
  },
  defaults: { propagate: !0, drawTime: 'beforeDatasetDraw' },
}
const wy = (e, t) => {
    let { boxHeight: n = t, boxWidth: r = t } = e
    return (
      e.usePointStyle && ((n = Math.min(n, t)), (r = e.pointStyleWidth || Math.min(r, t))),
      { boxWidth: r, boxHeight: n, itemHeight: Math.max(t, n) }
    )
  },
  CN = (e, t) =>
    e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index
class by extends zs {
  constructor(t) {
    ;(super(),
      (this._added = !1),
      (this.legendHitBoxes = []),
      (this._hoveredItem = null),
      (this.doughnutMode = !1),
      (this.chart = t.chart),
      (this.options = t.options),
      (this.ctx = t.ctx),
      (this.legendItems = void 0),
      (this.columnSizes = void 0),
      (this.lineWidths = void 0),
      (this.maxHeight = void 0),
      (this.maxWidth = void 0),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this._margins = void 0),
      (this.position = void 0),
      (this.weight = void 0),
      (this.fullSize = void 0))
  }
  update(t, n, r) {
    ;((this.maxWidth = t),
      (this.maxHeight = n),
      (this._margins = r),
      this.setDimensions(),
      this.buildLabels(),
      this.fit())
  }
  setDimensions() {
    this.isHorizontal()
      ? ((this.width = this.maxWidth), (this.left = this._margins.left), (this.right = this.width))
      : ((this.height = this.maxHeight),
        (this.top = this._margins.top),
        (this.bottom = this.height))
  }
  buildLabels() {
    const t = this.options.labels || {}
    let n = Qe(t.generateLabels, [this.chart], this) || []
    ;(t.filter && (n = n.filter((r) => t.filter(r, this.chart.data))),
      t.sort && (n = n.sort((r, i) => t.sort(r, i, this.chart.data))),
      this.options.reverse && n.reverse(),
      (this.legendItems = n))
  }
  fit() {
    const { options: t, ctx: n } = this
    if (!t.display) {
      this.width = this.height = 0
      return
    }
    const r = t.labels,
      i = Ht(r.font),
      o = i.size,
      c = this._computeTitleHeight(),
      { boxWidth: h, itemHeight: f } = wy(r, o)
    let p, y
    ;((n.font = i.string),
      this.isHorizontal()
        ? ((p = this.maxWidth), (y = this._fitRows(c, o, h, f) + 10))
        : ((y = this.maxHeight), (p = this._fitCols(c, i, h, f) + 10)),
      (this.width = Math.min(p, t.maxWidth || this.maxWidth)),
      (this.height = Math.min(y, t.maxHeight || this.maxHeight)))
  }
  _fitRows(t, n, r, i) {
    const {
        ctx: o,
        maxWidth: c,
        options: {
          labels: { padding: h },
        },
      } = this,
      f = (this.legendHitBoxes = []),
      p = (this.lineWidths = [0]),
      y = i + h
    let w = t
    ;((o.textAlign = 'left'), (o.textBaseline = 'middle'))
    let x = -1,
      E = -y
    return (
      this.legendItems.forEach((S, k) => {
        const P = r + n / 2 + o.measureText(S.text).width
        ;((k === 0 || p[p.length - 1] + P + 2 * h > c) &&
          ((w += y), (p[p.length - (k > 0 ? 0 : 1)] = 0), (E += y), x++),
          (f[k] = { left: 0, top: E, row: x, width: P, height: i }),
          (p[p.length - 1] += P + h))
      }),
      w
    )
  }
  _fitCols(t, n, r, i) {
    const {
        ctx: o,
        maxHeight: c,
        options: {
          labels: { padding: h },
        },
      } = this,
      f = (this.legendHitBoxes = []),
      p = (this.columnSizes = []),
      y = c - t
    let w = h,
      x = 0,
      E = 0,
      S = 0,
      k = 0
    return (
      this.legendItems.forEach((P, I) => {
        const { itemWidth: R, itemHeight: M } = SN(r, n, o, P, i)
        ;(I > 0 &&
          E + M + 2 * h > y &&
          ((w += x + h), p.push({ width: x, height: E }), (S += x + h), k++, (x = E = 0)),
          (f[I] = { left: S, top: E, col: k, width: R, height: M }),
          (x = Math.max(x, R)),
          (E += M + h))
      }),
      (w += x),
      p.push({ width: x, height: E }),
      w
    )
  }
  adjustHitBoxes() {
    if (!this.options.display) return
    const t = this._computeTitleHeight(),
      {
        legendHitBoxes: n,
        options: {
          align: r,
          labels: { padding: i },
          rtl: o,
        },
      } = this,
      c = No(o, this.left, this.width)
    if (this.isHorizontal()) {
      let h = 0,
        f = kn(r, this.left + i, this.right - this.lineWidths[h])
      for (const p of n)
        (h !== p.row && ((h = p.row), (f = kn(r, this.left + i, this.right - this.lineWidths[h]))),
          (p.top += this.top + t + i),
          (p.left = c.leftForLtr(c.x(f), p.width)),
          (f += p.width + i))
    } else {
      let h = 0,
        f = kn(r, this.top + t + i, this.bottom - this.columnSizes[h].height)
      for (const p of n)
        (p.col !== h &&
          ((h = p.col), (f = kn(r, this.top + t + i, this.bottom - this.columnSizes[h].height))),
          (p.top = f),
          (p.left += this.left + i),
          (p.left = c.leftForLtr(c.x(p.left), p.width)),
          (f += p.height + i))
    }
  }
  isHorizontal() {
    return this.options.position === 'top' || this.options.position === 'bottom'
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx
      ;(xh(t, this), this._draw(), Eh(t))
    }
  }
  _draw() {
    const { options: t, columnSizes: n, lineWidths: r, ctx: i } = this,
      { align: o, labels: c } = t,
      h = bt.color,
      f = No(t.rtl, this.left, this.width),
      p = Ht(c.font),
      { padding: y } = c,
      w = p.size,
      x = w / 2
    let E
    ;(this.drawTitle(),
      (i.textAlign = f.textAlign('left')),
      (i.textBaseline = 'middle'),
      (i.lineWidth = 0.5),
      (i.font = p.string))
    const { boxWidth: S, boxHeight: k, itemHeight: P } = wy(c, w),
      I = function (z, V, U) {
        if (isNaN(S) || S <= 0 || isNaN(k) || k < 0) return
        i.save()
        const Z = _e(U.lineWidth, 1)
        if (
          ((i.fillStyle = _e(U.fillStyle, h)),
          (i.lineCap = _e(U.lineCap, 'butt')),
          (i.lineDashOffset = _e(U.lineDashOffset, 0)),
          (i.lineJoin = _e(U.lineJoin, 'miter')),
          (i.lineWidth = Z),
          (i.strokeStyle = _e(U.strokeStyle, h)),
          i.setLineDash(_e(U.lineDash, [])),
          c.usePointStyle)
        ) {
          const J = {
              radius: (k * Math.SQRT2) / 2,
              pointStyle: U.pointStyle,
              rotation: U.rotation,
              borderWidth: Z,
            },
            oe = f.xPlus(z, S / 2),
            re = V + x
          p3(i, J, oe, re, c.pointStyleWidth && S)
        } else {
          const J = V + Math.max((w - k) / 2, 0),
            oe = f.leftForLtr(z, S),
            re = fs(U.borderRadius)
          ;(i.beginPath(),
            Object.values(re).some((ve) => ve !== 0)
              ? Nl(i, { x: oe, y: J, w: S, h: k, radius: re })
              : i.rect(oe, J, S, k),
            i.fill(),
            Z !== 0 && i.stroke())
        }
        i.restore()
      },
      R = function (z, V, U) {
        Uo(i, U.text, z, V + P / 2, p, {
          strikethrough: U.hidden,
          textAlign: f.textAlign(U.textAlign),
        })
      },
      M = this.isHorizontal(),
      O = this._computeTitleHeight()
    ;(M
      ? (E = { x: kn(o, this.left + y, this.right - r[0]), y: this.top + y + O, line: 0 })
      : (E = { x: this.left + y, y: kn(o, this.top + O + y, this.bottom - n[0].height), line: 0 }),
      E3(this.ctx, t.textDirection))
    const F = P + y
    ;(this.legendItems.forEach((z, V) => {
      ;((i.strokeStyle = z.fontColor), (i.fillStyle = z.fontColor))
      const U = i.measureText(z.text).width,
        Z = f.textAlign(z.textAlign || (z.textAlign = c.textAlign)),
        J = S + x + U
      let oe = E.x,
        re = E.y
      ;(f.setWidth(this.width),
        M
          ? V > 0 &&
            oe + J + y > this.right &&
            ((re = E.y += F), E.line++, (oe = E.x = kn(o, this.left + y, this.right - r[E.line])))
          : V > 0 &&
            re + F > this.bottom &&
            ((oe = E.x = oe + n[E.line].width + y),
            E.line++,
            (re = E.y = kn(o, this.top + O + y, this.bottom - n[E.line].height))))
      const ve = f.x(oe)
      if (
        (I(ve, re, z),
        (oe = o9(Z, oe + S + x, M ? oe + J : this.right, t.rtl)),
        R(f.x(oe), re, z),
        M)
      )
        E.x += J + y
      else if (typeof z.text != 'string') {
        const Ie = p.lineHeight
        E.y += G3(z, Ie) + y
      } else E.y += F
    }),
      C3(this.ctx, t.textDirection))
  }
  drawTitle() {
    const t = this.options,
      n = t.title,
      r = Ht(n.font),
      i = on(n.padding)
    if (!n.display) return
    const o = No(t.rtl, this.left, this.width),
      c = this.ctx,
      h = n.position,
      f = r.size / 2,
      p = i.top + f
    let y,
      w = this.left,
      x = this.width
    if (this.isHorizontal())
      ((x = Math.max(...this.lineWidths)), (y = this.top + p), (w = kn(t.align, w, this.right - x)))
    else {
      const S = this.columnSizes.reduce((k, P) => Math.max(k, P.height), 0)
      y = p + kn(t.align, this.top, this.bottom - S - t.labels.padding - this._computeTitleHeight())
    }
    const E = kn(h, w, w + x)
    ;((c.textAlign = o.textAlign(d3(h))),
      (c.textBaseline = 'middle'),
      (c.strokeStyle = n.color),
      (c.fillStyle = n.color),
      (c.font = r.string),
      Uo(c, n.text, E, y, r))
  }
  _computeTitleHeight() {
    const t = this.options.title,
      n = Ht(t.font),
      r = on(t.padding)
    return t.display ? n.lineHeight + r.height : 0
  }
  _getLegendItemAt(t, n) {
    let r, i, o
    if (wi(t, this.left, this.right) && wi(n, this.top, this.bottom)) {
      for (o = this.legendHitBoxes, r = 0; r < o.length; ++r)
        if (((i = o[r]), wi(t, i.left, i.left + i.width) && wi(n, i.top, i.top + i.height)))
          return this.legendItems[r]
    }
    return null
  }
  handleEvent(t) {
    const n = this.options
    if (!_N(t.type, n)) return
    const r = this._getLegendItemAt(t.x, t.y)
    if (t.type === 'mousemove' || t.type === 'mouseout') {
      const i = this._hoveredItem,
        o = CN(i, r)
      ;(i && !o && Qe(n.onLeave, [t, i, this], this),
        (this._hoveredItem = r),
        r && !o && Qe(n.onHover, [t, r, this], this))
    } else r && Qe(n.onClick, [t, r, this], this)
  }
}
function SN(e, t, n, r, i) {
  const o = AN(r, e, t, n),
    c = kN(i, r, t.lineHeight)
  return { itemWidth: o, itemHeight: c }
}
function AN(e, t, n, r) {
  let i = e.text
  return (
    i && typeof i != 'string' && (i = i.reduce((o, c) => (o.length > c.length ? o : c))),
    t + n.size / 2 + r.measureText(i).width
  )
}
function kN(e, t, n) {
  let r = e
  return (typeof t.text != 'string' && (r = G3(t, n)), r)
}
function G3(e, t) {
  const n = e.text ? e.text.length : 0
  return t * n
}
function _N(e, t) {
  return !!(
    ((e === 'mousemove' || e === 'mouseout') && (t.onHover || t.onLeave)) ||
    (t.onClick && (e === 'click' || e === 'mouseup'))
  )
}
var IN = {
  id: 'legend',
  _element: by,
  start(e, t, n) {
    const r = (e.legend = new by({ ctx: e.ctx, options: n, chart: e }))
    ;(vi.configure(e, r, n), vi.addBox(e, r))
  },
  stop(e) {
    ;(vi.removeBox(e, e.legend), delete e.legend)
  },
  beforeUpdate(e, t, n) {
    const r = e.legend
    ;(vi.configure(e, r, n), (r.options = n))
  },
  afterUpdate(e) {
    const t = e.legend
    ;(t.buildLabels(), t.adjustHitBoxes())
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event)
  },
  defaults: {
    display: !0,
    position: 'top',
    align: 'center',
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, n) {
      const r = t.datasetIndex,
        i = n.chart
      i.isDatasetVisible(r) ? (i.hide(r), (t.hidden = !0)) : (i.show(r), (t.hidden = !1))
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets,
          {
            labels: {
              usePointStyle: n,
              pointStyle: r,
              textAlign: i,
              color: o,
              useBorderRadius: c,
              borderRadius: h,
            },
          } = e.legend.options
        return e._getSortedDatasetMetas().map((f) => {
          const p = f.controller.getStyle(n ? 0 : void 0),
            y = on(p.borderWidth)
          return {
            text: t[f.index].label,
            fillStyle: p.backgroundColor,
            fontColor: o,
            hidden: !f.visible,
            lineCap: p.borderCapStyle,
            lineDash: p.borderDash,
            lineDashOffset: p.borderDashOffset,
            lineJoin: p.borderJoinStyle,
            lineWidth: (y.width + y.height) / 4,
            strokeStyle: p.borderColor,
            pointStyle: r || p.pointStyle,
            rotation: p.rotation,
            textAlign: i || p.textAlign,
            borderRadius: c && (h || p.borderRadius),
            datasetIndex: f.index,
          }
        }, this)
      },
    },
    title: { color: (e) => e.chart.options.color, display: !1, position: 'center', text: '' },
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith('on'),
    labels: { _scriptable: (e) => !['generateLabels', 'filter', 'sort'].includes(e) },
  },
}
const el = {
  average(e) {
    if (!e.length) return !1
    let t,
      n,
      r = new Set(),
      i = 0,
      o = 0
    for (t = 0, n = e.length; t < n; ++t) {
      const c = e[t].element
      if (c && c.hasValue()) {
        const h = c.tooltipPosition()
        ;(r.add(h.x), (i += h.y), ++o)
      }
    }
    return o === 0 || r.size === 0 ? !1 : { x: [...r].reduce((c, h) => c + h) / r.size, y: i / o }
  },
  nearest(e, t) {
    if (!e.length) return !1
    let n = t.x,
      r = t.y,
      i = Number.POSITIVE_INFINITY,
      o,
      c,
      h
    for (o = 0, c = e.length; o < c; ++o) {
      const f = e[o].element
      if (f && f.hasValue()) {
        const p = f.getCenterPoint(),
          y = cf(t, p)
        y < i && ((i = y), (h = f))
      }
    }
    if (h) {
      const f = h.tooltipPosition()
      ;((n = f.x), (r = f.y))
    }
    return { x: n, y: r }
  },
}
function xr(e, t) {
  return (t && (ct(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e)
}
function Pr(e) {
  return (typeof e == 'string' || e instanceof String) &&
    e.indexOf(`
`) > -1
    ? e.split(`
`)
    : e
}
function NN(e, t) {
  const { element: n, datasetIndex: r, index: i } = t,
    o = e.getDatasetMeta(r).controller,
    { label: c, value: h } = o.getLabelAndValue(i)
  return {
    chart: e,
    label: c,
    parsed: o.getParsed(i),
    raw: e.data.datasets[r].data[i],
    formattedValue: h,
    dataset: o.getDataset(),
    dataIndex: i,
    datasetIndex: r,
    element: n,
  }
}
function vy(e, t) {
  const n = e.chart.ctx,
    { body: r, footer: i, title: o } = e,
    { boxWidth: c, boxHeight: h } = t,
    f = Ht(t.bodyFont),
    p = Ht(t.titleFont),
    y = Ht(t.footerFont),
    w = o.length,
    x = i.length,
    E = r.length,
    S = on(t.padding)
  let k = S.height,
    P = 0,
    I = r.reduce((O, F) => O + F.before.length + F.lines.length + F.after.length, 0)
  if (
    ((I += e.beforeBody.length + e.afterBody.length),
    w && (k += w * p.lineHeight + (w - 1) * t.titleSpacing + t.titleMarginBottom),
    I)
  ) {
    const O = t.displayColors ? Math.max(h, f.lineHeight) : f.lineHeight
    k += E * O + (I - E) * f.lineHeight + (I - 1) * t.bodySpacing
  }
  x && (k += t.footerMarginTop + x * y.lineHeight + (x - 1) * t.footerSpacing)
  let R = 0
  const M = function (O) {
    P = Math.max(P, n.measureText(O).width + R)
  }
  return (
    n.save(),
    (n.font = p.string),
    ze(e.title, M),
    (n.font = f.string),
    ze(e.beforeBody.concat(e.afterBody), M),
    (R = t.displayColors ? c + 2 + t.boxPadding : 0),
    ze(r, (O) => {
      ;(ze(O.before, M), ze(O.lines, M), ze(O.after, M))
    }),
    (R = 0),
    (n.font = y.string),
    ze(e.footer, M),
    n.restore(),
    (P += S.width),
    { width: P, height: k }
  )
}
function TN(e, t) {
  const { y: n, height: r } = t
  return n < r / 2 ? 'top' : n > e.height - r / 2 ? 'bottom' : 'center'
}
function RN(e, t, n, r) {
  const { x: i, width: o } = r,
    c = n.caretSize + n.caretPadding
  if ((e === 'left' && i + o + c > t.width) || (e === 'right' && i - o - c < 0)) return !0
}
function MN(e, t, n, r) {
  const { x: i, width: o } = n,
    {
      width: c,
      chartArea: { left: h, right: f },
    } = e
  let p = 'center'
  return (
    r === 'center'
      ? (p = i <= (h + f) / 2 ? 'left' : 'right')
      : i <= o / 2
        ? (p = 'left')
        : i >= c - o / 2 && (p = 'right'),
    RN(p, e, t, n) && (p = 'center'),
    p
  )
}
function xy(e, t, n) {
  const r = n.yAlign || t.yAlign || TN(e, n)
  return { xAlign: n.xAlign || t.xAlign || MN(e, t, n, r), yAlign: r }
}
function PN(e, t) {
  let { x: n, width: r } = e
  return (t === 'right' ? (n -= r) : t === 'center' && (n -= r / 2), n)
}
function DN(e, t, n) {
  let { y: r, height: i } = e
  return (t === 'top' ? (r += n) : t === 'bottom' ? (r -= i + n) : (r -= i / 2), r)
}
function Ey(e, t, n, r) {
  const { caretSize: i, caretPadding: o, cornerRadius: c } = e,
    { xAlign: h, yAlign: f } = n,
    p = i + o,
    { topLeft: y, topRight: w, bottomLeft: x, bottomRight: E } = fs(c)
  let S = PN(t, h)
  const k = DN(t, f, p)
  return (
    f === 'center'
      ? h === 'left'
        ? (S += p)
        : h === 'right' && (S -= p)
      : h === 'left'
        ? (S -= Math.max(y, x) + i)
        : h === 'right' && (S += Math.max(w, E) + i),
    { x: Mn(S, 0, r.width - t.width), y: Mn(k, 0, r.height - t.height) }
  )
}
function Dc(e, t, n) {
  const r = on(n.padding)
  return t === 'center' ? e.x + e.width / 2 : t === 'right' ? e.x + e.width - r.right : e.x + r.left
}
function Cy(e) {
  return xr([], Pr(e))
}
function LN(e, t, n) {
  return Wi(e, { tooltip: t, tooltipItems: n, type: 'tooltip' })
}
function Sy(e, t) {
  const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks
  return n ? e.override(n) : e
}
const Y3 = {
  beforeTitle: Rr,
  title(e) {
    if (e.length > 0) {
      const t = e[0],
        n = t.chart.data.labels,
        r = n ? n.length : 0
      if (this && this.options && this.options.mode === 'dataset') return t.dataset.label || ''
      if (t.label) return t.label
      if (r > 0 && t.dataIndex < r) return n[t.dataIndex]
    }
    return ''
  },
  afterTitle: Rr,
  beforeBody: Rr,
  beforeLabel: Rr,
  label(e) {
    if (this && this.options && this.options.mode === 'dataset')
      return e.label + ': ' + e.formattedValue || e.formattedValue
    let t = e.dataset.label || ''
    t && (t += ': ')
    const n = e.formattedValue
    return (Oe(n) || (t += n), t)
  },
  labelColor(e) {
    const t = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex)
    return {
      borderColor: t.borderColor,
      backgroundColor: t.backgroundColor,
      borderWidth: t.borderWidth,
      borderDash: t.borderDash,
      borderDashOffset: t.borderDashOffset,
      borderRadius: 0,
    }
  },
  labelTextColor() {
    return this.options.bodyColor
  },
  labelPointStyle(e) {
    const t = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex)
    return { pointStyle: t.pointStyle, rotation: t.rotation }
  },
  afterLabel: Rr,
  afterBody: Rr,
  beforeFooter: Rr,
  footer: Rr,
  afterFooter: Rr,
}
function mn(e, t, n, r) {
  const i = e[t].call(n, r)
  return typeof i > 'u' ? Y3[t].call(n, r) : i
}
class mf extends zs {
  constructor(t) {
    ;(super(),
      (this.opacity = 0),
      (this._active = []),
      (this._eventPosition = void 0),
      (this._size = void 0),
      (this._cachedAnimations = void 0),
      (this._tooltipItems = []),
      (this.$animations = void 0),
      (this.$context = void 0),
      (this.chart = t.chart),
      (this.options = t.options),
      (this.dataPoints = void 0),
      (this.title = void 0),
      (this.beforeBody = void 0),
      (this.body = void 0),
      (this.afterBody = void 0),
      (this.footer = void 0),
      (this.xAlign = void 0),
      (this.yAlign = void 0),
      (this.x = void 0),
      (this.y = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this.caretX = void 0),
      (this.caretY = void 0),
      (this.labelColors = void 0),
      (this.labelPointStyles = void 0),
      (this.labelTextColors = void 0))
  }
  initialize(t) {
    ;((this.options = t), (this._cachedAnimations = void 0), (this.$context = void 0))
  }
  _resolveAnimations() {
    const t = this._cachedAnimations
    if (t) return t
    const n = this.chart,
      r = this.options.setContext(this.getContext()),
      i = r.enabled && n.options.animation && r.animations,
      o = new I3(this.chart, i)
    return (i._cacheable && (this._cachedAnimations = Object.freeze(o)), o)
  }
  getContext() {
    return this.$context || (this.$context = LN(this.chart.getContext(), this, this._tooltipItems))
  }
  getTitle(t, n) {
    const { callbacks: r } = n,
      i = mn(r, 'beforeTitle', this, t),
      o = mn(r, 'title', this, t),
      c = mn(r, 'afterTitle', this, t)
    let h = []
    return ((h = xr(h, Pr(i))), (h = xr(h, Pr(o))), (h = xr(h, Pr(c))), h)
  }
  getBeforeBody(t, n) {
    return Cy(mn(n.callbacks, 'beforeBody', this, t))
  }
  getBody(t, n) {
    const { callbacks: r } = n,
      i = []
    return (
      ze(t, (o) => {
        const c = { before: [], lines: [], after: [] },
          h = Sy(r, o)
        ;(xr(c.before, Pr(mn(h, 'beforeLabel', this, o))),
          xr(c.lines, mn(h, 'label', this, o)),
          xr(c.after, Pr(mn(h, 'afterLabel', this, o))),
          i.push(c))
      }),
      i
    )
  }
  getAfterBody(t, n) {
    return Cy(mn(n.callbacks, 'afterBody', this, t))
  }
  getFooter(t, n) {
    const { callbacks: r } = n,
      i = mn(r, 'beforeFooter', this, t),
      o = mn(r, 'footer', this, t),
      c = mn(r, 'afterFooter', this, t)
    let h = []
    return ((h = xr(h, Pr(i))), (h = xr(h, Pr(o))), (h = xr(h, Pr(c))), h)
  }
  _createItems(t) {
    const n = this._active,
      r = this.chart.data,
      i = [],
      o = [],
      c = []
    let h = [],
      f,
      p
    for (f = 0, p = n.length; f < p; ++f) h.push(NN(this.chart, n[f]))
    return (
      t.filter && (h = h.filter((y, w, x) => t.filter(y, w, x, r))),
      t.itemSort && (h = h.sort((y, w) => t.itemSort(y, w, r))),
      ze(h, (y) => {
        const w = Sy(t.callbacks, y)
        ;(i.push(mn(w, 'labelColor', this, y)),
          o.push(mn(w, 'labelPointStyle', this, y)),
          c.push(mn(w, 'labelTextColor', this, y)))
      }),
      (this.labelColors = i),
      (this.labelPointStyles = o),
      (this.labelTextColors = c),
      (this.dataPoints = h),
      h
    )
  }
  update(t, n) {
    const r = this.options.setContext(this.getContext()),
      i = this._active
    let o,
      c = []
    if (!i.length) this.opacity !== 0 && (o = { opacity: 0 })
    else {
      const h = el[r.position].call(this, i, this._eventPosition)
      ;((c = this._createItems(r)),
        (this.title = this.getTitle(c, r)),
        (this.beforeBody = this.getBeforeBody(c, r)),
        (this.body = this.getBody(c, r)),
        (this.afterBody = this.getAfterBody(c, r)),
        (this.footer = this.getFooter(c, r)))
      const f = (this._size = vy(this, r)),
        p = Object.assign({}, h, f),
        y = xy(this.chart, r, p),
        w = Ey(r, p, y, this.chart)
      ;((this.xAlign = y.xAlign),
        (this.yAlign = y.yAlign),
        (o = {
          opacity: 1,
          x: w.x,
          y: w.y,
          width: f.width,
          height: f.height,
          caretX: h.x,
          caretY: h.y,
        }))
    }
    ;((this._tooltipItems = c),
      (this.$context = void 0),
      o && this._resolveAnimations().update(this, o),
      t && r.external && r.external.call(this, { chart: this.chart, tooltip: this, replay: n }))
  }
  drawCaret(t, n, r, i) {
    const o = this.getCaretPosition(t, r, i)
    ;(n.lineTo(o.x1, o.y1), n.lineTo(o.x2, o.y2), n.lineTo(o.x3, o.y3))
  }
  getCaretPosition(t, n, r) {
    const { xAlign: i, yAlign: o } = this,
      { caretSize: c, cornerRadius: h } = r,
      { topLeft: f, topRight: p, bottomLeft: y, bottomRight: w } = fs(h),
      { x, y: E } = t,
      { width: S, height: k } = n
    let P, I, R, M, O, F
    return (
      o === 'center'
        ? ((O = E + k / 2),
          i === 'left'
            ? ((P = x), (I = P - c), (M = O + c), (F = O - c))
            : ((P = x + S), (I = P + c), (M = O - c), (F = O + c)),
          (R = P))
        : (i === 'left'
            ? (I = x + Math.max(f, y) + c)
            : i === 'right'
              ? (I = x + S - Math.max(p, w) - c)
              : (I = this.caretX),
          o === 'top'
            ? ((M = E), (O = M - c), (P = I - c), (R = I + c))
            : ((M = E + k), (O = M + c), (P = I + c), (R = I - c)),
          (F = M)),
      { x1: P, x2: I, x3: R, y1: M, y2: O, y3: F }
    )
  }
  drawTitle(t, n, r) {
    const i = this.title,
      o = i.length
    let c, h, f
    if (o) {
      const p = No(r.rtl, this.x, this.width)
      for (
        t.x = Dc(this, r.titleAlign, r),
          n.textAlign = p.textAlign(r.titleAlign),
          n.textBaseline = 'middle',
          c = Ht(r.titleFont),
          h = r.titleSpacing,
          n.fillStyle = r.titleColor,
          n.font = c.string,
          f = 0;
        f < o;
        ++f
      )
        (n.fillText(i[f], p.x(t.x), t.y + c.lineHeight / 2),
          (t.y += c.lineHeight + h),
          f + 1 === o && (t.y += r.titleMarginBottom - h))
    }
  }
  _drawColorBox(t, n, r, i, o) {
    const c = this.labelColors[r],
      h = this.labelPointStyles[r],
      { boxHeight: f, boxWidth: p } = o,
      y = Ht(o.bodyFont),
      w = Dc(this, 'left', o),
      x = i.x(w),
      E = f < y.lineHeight ? (y.lineHeight - f) / 2 : 0,
      S = n.y + E
    if (o.usePointStyle) {
      const k = {
          radius: Math.min(p, f) / 2,
          pointStyle: h.pointStyle,
          rotation: h.rotation,
          borderWidth: 1,
        },
        P = i.leftForLtr(x, p) + p / 2,
        I = S + f / 2
      ;((t.strokeStyle = o.multiKeyBackground),
        (t.fillStyle = o.multiKeyBackground),
        hf(t, k, P, I),
        (t.strokeStyle = c.borderColor),
        (t.fillStyle = c.backgroundColor),
        hf(t, k, P, I))
    } else {
      ;((t.lineWidth = Me(c.borderWidth)
        ? Math.max(...Object.values(c.borderWidth))
        : c.borderWidth || 1),
        (t.strokeStyle = c.borderColor),
        t.setLineDash(c.borderDash || []),
        (t.lineDashOffset = c.borderDashOffset || 0))
      const k = i.leftForLtr(x, p),
        P = i.leftForLtr(i.xPlus(x, 1), p - 2),
        I = fs(c.borderRadius)
      Object.values(I).some((R) => R !== 0)
        ? (t.beginPath(),
          (t.fillStyle = o.multiKeyBackground),
          Nl(t, { x: k, y: S, w: p, h: f, radius: I }),
          t.fill(),
          t.stroke(),
          (t.fillStyle = c.backgroundColor),
          t.beginPath(),
          Nl(t, { x: P, y: S + 1, w: p - 2, h: f - 2, radius: I }),
          t.fill())
        : ((t.fillStyle = o.multiKeyBackground),
          t.fillRect(k, S, p, f),
          t.strokeRect(k, S, p, f),
          (t.fillStyle = c.backgroundColor),
          t.fillRect(P, S + 1, p - 2, f - 2))
    }
    t.fillStyle = this.labelTextColors[r]
  }
  drawBody(t, n, r) {
    const { body: i } = this,
      {
        bodySpacing: o,
        bodyAlign: c,
        displayColors: h,
        boxHeight: f,
        boxWidth: p,
        boxPadding: y,
      } = r,
      w = Ht(r.bodyFont)
    let x = w.lineHeight,
      E = 0
    const S = No(r.rtl, this.x, this.width),
      k = function (U) {
        ;(n.fillText(U, S.x(t.x + E), t.y + x / 2), (t.y += x + o))
      },
      P = S.textAlign(c)
    let I, R, M, O, F, z, V
    for (
      n.textAlign = c,
        n.textBaseline = 'middle',
        n.font = w.string,
        t.x = Dc(this, P, r),
        n.fillStyle = r.bodyColor,
        ze(this.beforeBody, k),
        E = h && P !== 'right' ? (c === 'center' ? p / 2 + y : p + 2 + y) : 0,
        O = 0,
        z = i.length;
      O < z;
      ++O
    ) {
      for (
        I = i[O],
          R = this.labelTextColors[O],
          n.fillStyle = R,
          ze(I.before, k),
          M = I.lines,
          h && M.length && (this._drawColorBox(n, t, O, S, r), (x = Math.max(w.lineHeight, f))),
          F = 0,
          V = M.length;
        F < V;
        ++F
      )
        (k(M[F]), (x = w.lineHeight))
      ze(I.after, k)
    }
    ;((E = 0), (x = w.lineHeight), ze(this.afterBody, k), (t.y -= o))
  }
  drawFooter(t, n, r) {
    const i = this.footer,
      o = i.length
    let c, h
    if (o) {
      const f = No(r.rtl, this.x, this.width)
      for (
        t.x = Dc(this, r.footerAlign, r),
          t.y += r.footerMarginTop,
          n.textAlign = f.textAlign(r.footerAlign),
          n.textBaseline = 'middle',
          c = Ht(r.footerFont),
          n.fillStyle = r.footerColor,
          n.font = c.string,
          h = 0;
        h < o;
        ++h
      )
        (n.fillText(i[h], f.x(t.x), t.y + c.lineHeight / 2),
          (t.y += c.lineHeight + r.footerSpacing))
    }
  }
  drawBackground(t, n, r, i) {
    const { xAlign: o, yAlign: c } = this,
      { x: h, y: f } = t,
      { width: p, height: y } = r,
      { topLeft: w, topRight: x, bottomLeft: E, bottomRight: S } = fs(i.cornerRadius)
    ;((n.fillStyle = i.backgroundColor),
      (n.strokeStyle = i.borderColor),
      (n.lineWidth = i.borderWidth),
      n.beginPath(),
      n.moveTo(h + w, f),
      c === 'top' && this.drawCaret(t, n, r, i),
      n.lineTo(h + p - x, f),
      n.quadraticCurveTo(h + p, f, h + p, f + x),
      c === 'center' && o === 'right' && this.drawCaret(t, n, r, i),
      n.lineTo(h + p, f + y - S),
      n.quadraticCurveTo(h + p, f + y, h + p - S, f + y),
      c === 'bottom' && this.drawCaret(t, n, r, i),
      n.lineTo(h + E, f + y),
      n.quadraticCurveTo(h, f + y, h, f + y - E),
      c === 'center' && o === 'left' && this.drawCaret(t, n, r, i),
      n.lineTo(h, f + w),
      n.quadraticCurveTo(h, f, h + w, f),
      n.closePath(),
      n.fill(),
      i.borderWidth > 0 && n.stroke())
  }
  _updateAnimationTarget(t) {
    const n = this.chart,
      r = this.$animations,
      i = r && r.x,
      o = r && r.y
    if (i || o) {
      const c = el[t.position].call(this, this._active, this._eventPosition)
      if (!c) return
      const h = (this._size = vy(this, t)),
        f = Object.assign({}, c, this._size),
        p = xy(n, t, f),
        y = Ey(t, f, p, n)
      ;(i._to !== y.x || o._to !== y.y) &&
        ((this.xAlign = p.xAlign),
        (this.yAlign = p.yAlign),
        (this.width = h.width),
        (this.height = h.height),
        (this.caretX = c.x),
        (this.caretY = c.y),
        this._resolveAnimations().update(this, y))
    }
  }
  _willRender() {
    return !!this.opacity
  }
  draw(t) {
    const n = this.options.setContext(this.getContext())
    let r = this.opacity
    if (!r) return
    this._updateAnimationTarget(n)
    const i = { width: this.width, height: this.height },
      o = { x: this.x, y: this.y }
    r = Math.abs(r) < 0.001 ? 0 : r
    const c = on(n.padding),
      h =
        this.title.length ||
        this.beforeBody.length ||
        this.body.length ||
        this.afterBody.length ||
        this.footer.length
    n.enabled &&
      h &&
      (t.save(),
      (t.globalAlpha = r),
      this.drawBackground(o, t, i, n),
      E3(t, n.textDirection),
      (o.y += c.top),
      this.drawTitle(o, t, n),
      this.drawBody(o, t, n),
      this.drawFooter(o, t, n),
      C3(t, n.textDirection),
      t.restore())
  }
  getActiveElements() {
    return this._active || []
  }
  setActiveElements(t, n) {
    const r = this._active,
      i = t.map(({ datasetIndex: h, index: f }) => {
        const p = this.chart.getDatasetMeta(h)
        if (!p) throw new Error('Cannot find a dataset at index ' + h)
        return { datasetIndex: h, element: p.data[f], index: f }
      }),
      o = !Bu(r, i),
      c = this._positionChanged(i, n)
    ;(o || c) &&
      ((this._active = i),
      (this._eventPosition = n),
      (this._ignoreReplayEvents = !0),
      this.update(!0))
  }
  handleEvent(t, n, r = !0) {
    if (n && this._ignoreReplayEvents) return !1
    this._ignoreReplayEvents = !1
    const i = this.options,
      o = this._active || [],
      c = this._getActiveElements(t, o, n, r),
      h = this._positionChanged(c, t),
      f = n || !Bu(c, o) || h
    return (
      f &&
        ((this._active = c),
        (i.enabled || i.external) &&
          ((this._eventPosition = { x: t.x, y: t.y }), this.update(!0, n))),
      f
    )
  }
  _getActiveElements(t, n, r, i) {
    const o = this.options
    if (t.type === 'mouseout') return []
    if (!i)
      return n.filter(
        (h) =>
          this.chart.data.datasets[h.datasetIndex] &&
          this.chart.getDatasetMeta(h.datasetIndex).controller.getParsed(h.index) !== void 0
      )
    const c = this.chart.getElementsAtEventForMode(t, o.mode, o, r)
    return (o.reverse && c.reverse(), c)
  }
  _positionChanged(t, n) {
    const { caretX: r, caretY: i, options: o } = this,
      c = el[o.position].call(this, t, n)
    return c !== !1 && (r !== c.x || i !== c.y)
  }
}
ye(mf, 'positioners', el)
var Z3 = {
  id: 'tooltip',
  _element: mf,
  positioners: el,
  afterInit(e, t, n) {
    n && (e.tooltip = new mf({ chart: e, options: n }))
  },
  beforeUpdate(e, t, n) {
    e.tooltip && e.tooltip.initialize(n)
  },
  reset(e, t, n) {
    e.tooltip && e.tooltip.initialize(n)
  },
  afterDraw(e) {
    const t = e.tooltip
    if (t && t._willRender()) {
      const n = { tooltip: t }
      if (e.notifyPlugins('beforeTooltipDraw', { ...n, cancelable: !0 }) === !1) return
      ;(t.draw(e.ctx), e.notifyPlugins('afterTooltipDraw', n))
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const n = t.replay
      e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0)
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: 'average',
    backgroundColor: 'rgba(0,0,0,0.8)',
    titleColor: '#fff',
    titleFont: { weight: 'bold' },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: 'left',
    bodyColor: '#fff',
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: 'left',
    footerColor: '#fff',
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: { weight: 'bold' },
    footerAlign: 'left',
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: '#fff',
    displayColors: !0,
    boxPadding: 0,
    borderColor: 'rgba(0,0,0,0)',
    borderWidth: 0,
    animation: { duration: 400, easing: 'easeOutQuart' },
    animations: {
      numbers: { type: 'number', properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'] },
      opacity: { easing: 'linear', duration: 200 },
    },
    callbacks: Y3,
  },
  defaultRoutes: { bodyFont: 'font', footerFont: 'font', titleFont: 'font' },
  descriptors: {
    _scriptable: (e) => e !== 'filter' && e !== 'itemSort' && e !== 'external',
    _indexable: !1,
    callbacks: { _scriptable: !1, _indexable: !1 },
    animation: { _fallback: !1 },
    animations: { _fallback: 'animation' },
  },
  additionalOptionScopes: ['interaction'],
}
const ON = (e, t, n, r) => (
  typeof t == 'string'
    ? ((n = e.push(t) - 1), r.unshift({ index: n, label: t }))
    : isNaN(t) && (n = null),
  n
)
function BN(e, t, n, r) {
  const i = e.indexOf(t)
  if (i === -1) return ON(e, t, n, r)
  const o = e.lastIndexOf(t)
  return i !== o ? n : i
}
const FN = (e, t) => (e === null ? null : Mn(Math.round(e), 0, t))
function K3(e) {
  const t = this.getLabels()
  return e >= 0 && e < t.length ? t[e] : e
}
class yf extends $o {
  constructor(t) {
    ;(super(t), (this._startValue = void 0), (this._valueRange = 0), (this._addedLabels = []))
  }
  init(t) {
    const n = this._addedLabels
    if (n.length) {
      const r = this.getLabels()
      for (const { index: i, label: o } of n) r[i] === o && r.splice(i, 1)
      this._addedLabels = []
    }
    super.init(t)
  }
  parse(t, n) {
    if (Oe(t)) return null
    const r = this.getLabels()
    return (
      (n = isFinite(n) && r[n] === t ? n : BN(r, t, _e(n, t), this._addedLabels)),
      FN(n, r.length - 1)
    )
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds()
    let { min: r, max: i } = this.getMinMax(!0)
    ;(this.options.bounds === 'ticks' && (t || (r = 0), n || (i = this.getLabels().length - 1)),
      (this.min = r),
      (this.max = i))
  }
  buildTicks() {
    const t = this.min,
      n = this.max,
      r = this.options.offset,
      i = []
    let o = this.getLabels()
    ;((o = t === 0 && n === o.length - 1 ? o : o.slice(t, n + 1)),
      (this._valueRange = Math.max(o.length - (r ? 0 : 1), 1)),
      (this._startValue = this.min - (r ? 0.5 : 0)))
    for (let c = t; c <= n; c++) i.push({ value: c })
    return i
  }
  getLabelForValue(t) {
    return K3.call(this, t)
  }
  configure() {
    ;(super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels))
  }
  getPixelForValue(t) {
    return (
      typeof t != 'number' && (t = this.parse(t)),
      t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    )
  }
  getPixelForTick(t) {
    const n = this.ticks
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value)
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
  }
  getBasePixel() {
    return this.bottom
  }
}
;(ye(yf, 'id', 'category'), ye(yf, 'defaults', { ticks: { callback: K3 } }))
function jN(e, t) {
  const n = [],
    {
      bounds: r,
      step: i,
      min: o,
      max: c,
      precision: h,
      count: f,
      maxTicks: p,
      maxDigits: y,
      includeBounds: w,
    } = e,
    x = i || 1,
    E = p - 1,
    { min: S, max: k } = t,
    P = !Oe(o),
    I = !Oe(c),
    R = !Oe(f),
    M = (k - S) / (y + 1)
  let O = Cm((k - S) / E / x) * x,
    F,
    z,
    V,
    U
  if (O < 1e-14 && !P && !I) return [{ value: S }, { value: k }]
  ;((U = Math.ceil(k / O) - Math.floor(S / O)),
    U > E && (O = Cm((U * O) / E / x) * x),
    Oe(h) || ((F = Math.pow(10, h)), (O = Math.ceil(O * F) / F)),
    r === 'ticks' ? ((z = Math.floor(S / O) * O), (V = Math.ceil(k / O) * O)) : ((z = S), (V = k)),
    P && I && i && Qk((c - o) / i, O / 1e3)
      ? ((U = Math.round(Math.min((c - o) / O, p))), (O = (c - o) / U), (z = o), (V = c))
      : R
        ? ((z = P ? o : z), (V = I ? c : V), (U = f - 1), (O = (V - z) / U))
        : ((U = (V - z) / O),
          qa(U, Math.round(U), O / 1e3) ? (U = Math.round(U)) : (U = Math.ceil(U))))
  const Z = Math.max(Sm(O), Sm(z))
  ;((F = Math.pow(10, Oe(h) ? Z : h)), (z = Math.round(z * F) / F), (V = Math.round(V * F) / F))
  let J = 0
  for (
    P &&
    (w && z !== o
      ? (n.push({ value: o }),
        z < o && J++,
        qa(Math.round((z + J * O) * F) / F, o, Ay(o, M, e)) && J++)
      : z < o && J++);
    J < U;
    ++J
  ) {
    const oe = Math.round((z + J * O) * F) / F
    if (I && oe > c) break
    n.push({ value: oe })
  }
  return (
    I && w && V !== c
      ? n.length && qa(n[n.length - 1].value, c, Ay(c, M, e))
        ? (n[n.length - 1].value = c)
        : n.push({ value: c })
      : (!I || V === c) && n.push({ value: V }),
    n
  )
}
function Ay(e, t, { horizontal: n, minRotation: r }) {
  const i = yi(r),
    o = (n ? Math.sin(i) : Math.cos(i)) || 0.001,
    c = 0.75 * t * ('' + e).length
  return Math.min(t / o, c)
}
class wf extends $o {
  constructor(t) {
    ;(super(t),
      (this.start = void 0),
      (this.end = void 0),
      (this._startValue = void 0),
      (this._endValue = void 0),
      (this._valueRange = 0))
  }
  parse(t, n) {
    return Oe(t) || ((typeof t == 'number' || t instanceof Number) && !isFinite(+t)) ? null : +t
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options,
      { minDefined: n, maxDefined: r } = this.getUserBounds()
    let { min: i, max: o } = this
    const c = (f) => (i = n ? i : f),
      h = (f) => (o = r ? o : f)
    if (t) {
      const f = Nr(i),
        p = Nr(o)
      f < 0 && p < 0 ? h(0) : f > 0 && p > 0 && c(0)
    }
    if (i === o) {
      let f = o === 0 ? 1 : Math.abs(o * 0.05)
      ;(h(o + f), t || c(i - f))
    }
    ;((this.min = i), (this.max = o))
  }
  getTickLimit() {
    const t = this.options.ticks
    let { maxTicksLimit: n, stepSize: r } = t,
      i
    return (
      r
        ? ((i = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1),
          i > 1e3 &&
            (console.warn(
              `scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${i} ticks. Limiting to 1000.`
            ),
            (i = 1e3)))
        : ((i = this.computeTickLimit()), (n = n || 11)),
      n && (i = Math.min(n, i)),
      i
    )
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY
  }
  buildTicks() {
    const t = this.options,
      n = t.ticks
    let r = this.getTickLimit()
    r = Math.max(2, r)
    const i = {
        maxTicks: r,
        bounds: t.bounds,
        min: t.min,
        max: t.max,
        precision: n.precision,
        step: n.stepSize,
        count: n.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: n.minRotation || 0,
        includeBounds: n.includeBounds !== !1,
      },
      o = this._range || this,
      c = jN(i, o)
    return (
      t.bounds === 'ticks' && $k(c, this, 'value'),
      t.reverse
        ? (c.reverse(), (this.start = this.max), (this.end = this.min))
        : ((this.start = this.min), (this.end = this.max)),
      c
    )
  }
  configure() {
    const t = this.ticks
    let n = this.min,
      r = this.max
    if ((super.configure(), this.options.offset && t.length)) {
      const i = (r - n) / Math.max(t.length - 1, 1) / 2
      ;((n -= i), (r += i))
    }
    ;((this._startValue = n), (this._endValue = r), (this._valueRange = r - n))
  }
  getLabelForValue(t) {
    return f3(t, this.chart.options.locale, this.options.ticks.format)
  }
}
class bf extends wf {
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0)
    ;((this.min = Bt(t) ? t : 0), (this.max = Bt(n) ? n : 1), this.handleTickRangeOptions())
  }
  computeTickLimit() {
    const t = this.isHorizontal(),
      n = t ? this.width : this.height,
      r = yi(this.options.ticks.minRotation),
      i = (t ? Math.sin(r) : Math.cos(r)) || 0.001,
      o = this._resolveTickFontOptions(0)
    return Math.ceil(n / Math.min(40, o.lineHeight / i))
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange
  }
}
;(ye(bf, 'id', 'linear'), ye(bf, 'defaults', { ticks: { callback: cp.formatters.numeric } }))
function vf(e) {
  const t = e.ticks
  if (t.display && e.display) {
    const n = on(t.backdropPadding)
    return _e(t.font && t.font.size, bt.font.size) + n.height
  }
  return 0
}
function VN(e, t, n) {
  return ((n = ct(n) ? n : [n]), { w: b9(e, t.string, n), h: n.length * t.lineHeight })
}
function ky(e, t, n, r, i) {
  return e === r || e === i
    ? { start: t - n / 2, end: t + n / 2 }
    : e < r || e > i
      ? { start: t - n, end: t }
      : { start: t, end: t + n }
}
function UN(e) {
  const t = {
      l: e.left + e._padding.left,
      r: e.right - e._padding.right,
      t: e.top + e._padding.top,
      b: e.bottom - e._padding.bottom,
    },
    n = Object.assign({}, t),
    r = [],
    i = [],
    o = e._pointLabels.length,
    c = e.options.pointLabels,
    h = c.centerPointLabels ? Ot / o : 0
  for (let f = 0; f < o; f++) {
    const p = c.setContext(e.getPointLabelContext(f))
    i[f] = p.padding
    const y = e.getPointPosition(f, e.drawingArea + i[f], h),
      w = Ht(p.font),
      x = VN(e.ctx, w, e._pointLabels[f])
    r[f] = x
    const E = Nn(e.getIndexAngle(f) + h),
      S = Math.round(op(E)),
      k = ky(S, y.x, x.w, 0, 180),
      P = ky(S, y.y, x.h, 90, 270)
    WN(n, t, E, k, P)
  }
  ;(e.setCenterPoint(t.l - n.l, n.r - t.r, t.t - n.t, n.b - t.b),
    (e._pointLabelItems = XN(e, r, i)))
}
function WN(e, t, n, r, i) {
  const o = Math.abs(Math.sin(n)),
    c = Math.abs(Math.cos(n))
  let h = 0,
    f = 0
  ;(r.start < t.l
    ? ((h = (t.l - r.start) / o), (e.l = Math.min(e.l, t.l - h)))
    : r.end > t.r && ((h = (r.end - t.r) / o), (e.r = Math.max(e.r, t.r + h))),
    i.start < t.t
      ? ((f = (t.t - i.start) / c), (e.t = Math.min(e.t, t.t - f)))
      : i.end > t.b && ((f = (i.end - t.b) / c), (e.b = Math.max(e.b, t.b + f))))
}
function zN(e, t, n) {
  const r = e.drawingArea,
    { extra: i, additionalAngle: o, padding: c, size: h } = n,
    f = e.getPointPosition(t, r + i + c, o),
    p = Math.round(op(Nn(f.angle + Rn))),
    y = ZN(f.y, h.h, p),
    w = GN(p),
    x = YN(f.x, h.w, w)
  return { visible: !0, x: f.x, y, textAlign: w, left: x, top: y, right: x + h.w, bottom: y + h.h }
}
function HN(e, t) {
  if (!t) return !0
  const { left: n, top: r, right: i, bottom: o } = e
  return !(
    Vr({ x: n, y: r }, t) ||
    Vr({ x: n, y: o }, t) ||
    Vr({ x: i, y: r }, t) ||
    Vr({ x: i, y: o }, t)
  )
}
function XN(e, t, n) {
  const r = [],
    i = e._pointLabels.length,
    o = e.options,
    { centerPointLabels: c, display: h } = o.pointLabels,
    f = { extra: vf(o) / 2, additionalAngle: c ? Ot / i : 0 }
  let p
  for (let y = 0; y < i; y++) {
    ;((f.padding = n[y]), (f.size = t[y]))
    const w = zN(e, y, f)
    ;(r.push(w), h === 'auto' && ((w.visible = HN(w, p)), w.visible && (p = w)))
  }
  return r
}
function GN(e) {
  return e === 0 || e === 180 ? 'center' : e < 180 ? 'left' : 'right'
}
function YN(e, t, n) {
  return (n === 'right' ? (e -= t) : n === 'center' && (e -= t / 2), e)
}
function ZN(e, t, n) {
  return (n === 90 || n === 270 ? (e -= t / 2) : (n > 270 || n < 90) && (e -= t), e)
}
function KN(e, t, n) {
  const { left: r, top: i, right: o, bottom: c } = n,
    { backdropColor: h } = t
  if (!Oe(h)) {
    const f = fs(t.borderRadius),
      p = on(t.backdropPadding)
    e.fillStyle = h
    const y = r - p.left,
      w = i - p.top,
      x = o - r + p.width,
      E = c - i + p.height
    Object.values(f).some((S) => S !== 0)
      ? (e.beginPath(), Nl(e, { x: y, y: w, w: x, h: E, radius: f }), e.fill())
      : e.fillRect(y, w, x, E)
  }
}
function qN(e, t) {
  const {
    ctx: n,
    options: { pointLabels: r },
  } = e
  for (let i = t - 1; i >= 0; i--) {
    const o = e._pointLabelItems[i]
    if (!o.visible) continue
    const c = r.setContext(e.getPointLabelContext(i))
    KN(n, c, o)
    const h = Ht(c.font),
      { x: f, y: p, textAlign: y } = o
    Uo(n, e._pointLabels[i], f, p + h.lineHeight / 2, h, {
      color: c.color,
      textAlign: y,
      textBaseline: 'middle',
    })
  }
}
function q3(e, t, n, r) {
  const { ctx: i } = e
  if (n) i.arc(e.xCenter, e.yCenter, t, 0, Ln)
  else {
    let o = e.getPointPosition(0, t)
    i.moveTo(o.x, o.y)
    for (let c = 1; c < r; c++) ((o = e.getPointPosition(c, t)), i.lineTo(o.x, o.y))
  }
}
function QN(e, t, n, r, i) {
  const o = e.ctx,
    c = t.circular,
    { color: h, lineWidth: f } = t
  ;(!c && !r) ||
    !h ||
    !f ||
    n < 0 ||
    (o.save(),
    (o.strokeStyle = h),
    (o.lineWidth = f),
    o.setLineDash(i.dash || []),
    (o.lineDashOffset = i.dashOffset),
    o.beginPath(),
    q3(e, n, c, r),
    o.closePath(),
    o.stroke(),
    o.restore())
}
function $N(e, t, n) {
  return Wi(e, { label: n, index: t, type: 'pointLabel' })
}
class xo extends wf {
  constructor(t) {
    ;(super(t),
      (this.xCenter = void 0),
      (this.yCenter = void 0),
      (this.drawingArea = void 0),
      (this._pointLabels = []),
      (this._pointLabelItems = []))
  }
  setDimensions() {
    const t = (this._padding = on(vf(this.options) / 2)),
      n = (this.width = this.maxWidth - t.width),
      r = (this.height = this.maxHeight - t.height)
    ;((this.xCenter = Math.floor(this.left + n / 2 + t.left)),
      (this.yCenter = Math.floor(this.top + r / 2 + t.top)),
      (this.drawingArea = Math.floor(Math.min(n, r) / 2)))
  }
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!1)
    ;((this.min = Bt(t) && !isNaN(t) ? t : 0),
      (this.max = Bt(n) && !isNaN(n) ? n : 0),
      this.handleTickRangeOptions())
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / vf(this.options))
  }
  generateTickLabels(t) {
    ;(wf.prototype.generateTickLabels.call(this, t),
      (this._pointLabels = this.getLabels()
        .map((n, r) => {
          const i = Qe(this.options.pointLabels.callback, [n, r], this)
          return i || i === 0 ? i : ''
        })
        .filter((n, r) => this.chart.getDataVisibility(r))))
  }
  fit() {
    const t = this.options
    t.display && t.pointLabels.display ? UN(this) : this.setCenterPoint(0, 0, 0, 0)
  }
  setCenterPoint(t, n, r, i) {
    ;((this.xCenter += Math.floor((t - n) / 2)),
      (this.yCenter += Math.floor((r - i) / 2)),
      (this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, n, r, i))))
  }
  getIndexAngle(t) {
    const n = Ln / (this._pointLabels.length || 1),
      r = this.options.startAngle || 0
    return Nn(t * n + yi(r))
  }
  getDistanceFromCenterForValue(t) {
    if (Oe(t)) return NaN
    const n = this.drawingArea / (this.max - this.min)
    return this.options.reverse ? (this.max - t) * n : (t - this.min) * n
  }
  getValueForDistanceFromCenter(t) {
    if (Oe(t)) return NaN
    const n = t / (this.drawingArea / (this.max - this.min))
    return this.options.reverse ? this.max - n : this.min + n
  }
  getPointLabelContext(t) {
    const n = this._pointLabels || []
    if (t >= 0 && t < n.length) {
      const r = n[t]
      return $N(this.getContext(), t, r)
    }
  }
  getPointPosition(t, n, r = 0) {
    const i = this.getIndexAngle(t) - Rn + r
    return { x: Math.cos(i) * n + this.xCenter, y: Math.sin(i) * n + this.yCenter, angle: i }
  }
  getPointPositionForValue(t, n) {
    return this.getPointPosition(t, this.getDistanceFromCenterForValue(n))
  }
  getBasePosition(t) {
    return this.getPointPositionForValue(t || 0, this.getBaseValue())
  }
  getPointLabelPosition(t) {
    const { left: n, top: r, right: i, bottom: o } = this._pointLabelItems[t]
    return { left: n, top: r, right: i, bottom: o }
  }
  drawBackground() {
    const {
      backgroundColor: t,
      grid: { circular: n },
    } = this.options
    if (t) {
      const r = this.ctx
      ;(r.save(),
        r.beginPath(),
        q3(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length),
        r.closePath(),
        (r.fillStyle = t),
        r.fill(),
        r.restore())
    }
  }
  drawGrid() {
    const t = this.ctx,
      n = this.options,
      { angleLines: r, grid: i, border: o } = n,
      c = this._pointLabels.length
    let h, f, p
    if (
      (n.pointLabels.display && qN(this, c),
      i.display &&
        this.ticks.forEach((y, w) => {
          if (w !== 0 || (w === 0 && this.min < 0)) {
            f = this.getDistanceFromCenterForValue(y.value)
            const x = this.getContext(w),
              E = i.setContext(x),
              S = o.setContext(x)
            QN(this, E, f, c, S)
          }
        }),
      r.display)
    ) {
      for (t.save(), h = c - 1; h >= 0; h--) {
        const y = r.setContext(this.getPointLabelContext(h)),
          { color: w, lineWidth: x } = y
        !x ||
          !w ||
          ((t.lineWidth = x),
          (t.strokeStyle = w),
          t.setLineDash(y.borderDash),
          (t.lineDashOffset = y.borderDashOffset),
          (f = this.getDistanceFromCenterForValue(n.reverse ? this.min : this.max)),
          (p = this.getPointPosition(h, f)),
          t.beginPath(),
          t.moveTo(this.xCenter, this.yCenter),
          t.lineTo(p.x, p.y),
          t.stroke())
      }
      t.restore()
    }
  }
  drawBorder() {}
  drawLabels() {
    const t = this.ctx,
      n = this.options,
      r = n.ticks
    if (!r.display) return
    const i = this.getIndexAngle(0)
    let o, c
    ;(t.save(),
      t.translate(this.xCenter, this.yCenter),
      t.rotate(i),
      (t.textAlign = 'center'),
      (t.textBaseline = 'middle'),
      this.ticks.forEach((h, f) => {
        if (f === 0 && this.min >= 0 && !n.reverse) return
        const p = r.setContext(this.getContext(f)),
          y = Ht(p.font)
        if (((o = this.getDistanceFromCenterForValue(this.ticks[f].value)), p.showLabelBackdrop)) {
          ;((t.font = y.string),
            (c = t.measureText(h.label).width),
            (t.fillStyle = p.backdropColor))
          const w = on(p.backdropPadding)
          t.fillRect(-c / 2 - w.left, -o - y.size / 2 - w.top, c + w.width, y.size + w.height)
        }
        Uo(t, h.label, 0, -o, y, {
          color: p.color,
          strokeColor: p.textStrokeColor,
          strokeWidth: p.textStrokeWidth,
        })
      }),
      t.restore())
  }
  drawTitle() {}
}
;(ye(xo, 'id', 'radialLinear'),
  ye(xo, 'defaults', {
    display: !0,
    animate: !0,
    position: 'chartArea',
    angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 },
    grid: { circular: !1 },
    startAngle: 0,
    ticks: { showLabelBackdrop: !0, callback: cp.formatters.numeric },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: !0,
      font: { size: 10 },
      callback(e) {
        return e
      },
      padding: 5,
      centerPointLabels: !1,
    },
  }),
  ye(xo, 'defaultRoutes', {
    'angleLines.color': 'borderColor',
    'pointLabels.color': 'color',
    'ticks.color': 'color',
  }),
  ye(xo, 'descriptors', { angleLines: { _fallback: 'grid' } }))
const kh = {
    millisecond: { common: !0, size: 1, steps: 1e3 },
    second: { common: !0, size: 1e3, steps: 60 },
    minute: { common: !0, size: 6e4, steps: 60 },
    hour: { common: !0, size: 36e5, steps: 24 },
    day: { common: !0, size: 864e5, steps: 30 },
    week: { common: !1, size: 6048e5, steps: 4 },
    month: { common: !0, size: 2628e6, steps: 12 },
    quarter: { common: !1, size: 7884e6, steps: 4 },
    year: { common: !0, size: 3154e7 },
  },
  wn = Object.keys(kh)
function _y(e, t) {
  return e - t
}
function Iy(e, t) {
  if (Oe(t)) return null
  const n = e._adapter,
    { parser: r, round: i, isoWeekday: o } = e._parseOpts
  let c = t
  return (
    typeof r == 'function' && (c = r(c)),
    Bt(c) || (c = typeof r == 'string' ? n.parse(c, r) : n.parse(c)),
    c === null
      ? null
      : (i &&
          (c = i === 'week' && (Il(o) || o === !0) ? n.startOf(c, 'isoWeek', o) : n.startOf(c, i)),
        +c)
  )
}
function Ny(e, t, n, r) {
  const i = wn.length
  for (let o = wn.indexOf(e); o < i - 1; ++o) {
    const c = kh[wn[o]],
      h = c.steps ? c.steps : Number.MAX_SAFE_INTEGER
    if (c.common && Math.ceil((n - t) / (h * c.size)) <= r) return wn[o]
  }
  return wn[i - 1]
}
function JN(e, t, n, r, i) {
  for (let o = wn.length - 1; o >= wn.indexOf(n); o--) {
    const c = wn[o]
    if (kh[c].common && e._adapter.diff(i, r, c) >= t - 1) return c
  }
  return wn[n ? wn.indexOf(n) : 0]
}
function eT(e) {
  for (let t = wn.indexOf(e) + 1, n = wn.length; t < n; ++t) if (kh[wn[t]].common) return wn[t]
}
function Ty(e, t, n) {
  if (!n) e[t] = !0
  else if (n.length) {
    const { lo: r, hi: i } = ap(n, t),
      o = n[r] >= t ? n[r] : n[i]
    e[o] = !0
  }
}
function tT(e, t, n, r) {
  const i = e._adapter,
    o = +i.startOf(t[0].value, r),
    c = t[t.length - 1].value
  let h, f
  for (h = o; h <= c; h = +i.add(h, 1, r)) ((f = n[h]), f >= 0 && (t[f].major = !0))
  return t
}
function Ry(e, t, n) {
  const r = [],
    i = {},
    o = t.length
  let c, h
  for (c = 0; c < o; ++c) ((h = t[c]), (i[h] = c), r.push({ value: h, major: !1 }))
  return o === 0 || !n ? r : tT(e, r, i, n)
}
class zu extends $o {
  constructor(t) {
    ;(super(t),
      (this._cache = { data: [], labels: [], all: [] }),
      (this._unit = 'day'),
      (this._majorUnit = void 0),
      (this._offsets = {}),
      (this._normalized = !1),
      (this._parseOpts = void 0))
  }
  init(t, n = {}) {
    const r = t.time || (t.time = {}),
      i = (this._adapter = new L_._date(t.adapters.date))
    ;(i.init(n),
      Ka(r.displayFormats, i.formats()),
      (this._parseOpts = { parser: r.parser, round: r.round, isoWeekday: r.isoWeekday }),
      super.init(t),
      (this._normalized = n.normalized))
  }
  parse(t, n) {
    return t === void 0 ? null : Iy(this, t)
  }
  beforeLayout() {
    ;(super.beforeLayout(), (this._cache = { data: [], labels: [], all: [] }))
  }
  determineDataLimits() {
    const t = this.options,
      n = this._adapter,
      r = t.time.unit || 'day'
    let { min: i, max: o, minDefined: c, maxDefined: h } = this.getUserBounds()
    function f(p) {
      ;(!c && !isNaN(p.min) && (i = Math.min(i, p.min)),
        !h && !isNaN(p.max) && (o = Math.max(o, p.max)))
    }
    ;((!c || !h) &&
      (f(this._getLabelBounds()),
      (t.bounds !== 'ticks' || t.ticks.source !== 'labels') && f(this.getMinMax(!1))),
      (i = Bt(i) && !isNaN(i) ? i : +n.startOf(Date.now(), r)),
      (o = Bt(o) && !isNaN(o) ? o : +n.endOf(Date.now(), r) + 1),
      (this.min = Math.min(i, o - 1)),
      (this.max = Math.max(i + 1, o)))
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps()
    let n = Number.POSITIVE_INFINITY,
      r = Number.NEGATIVE_INFINITY
    return (t.length && ((n = t[0]), (r = t[t.length - 1])), { min: n, max: r })
  }
  buildTicks() {
    const t = this.options,
      n = t.time,
      r = t.ticks,
      i = r.source === 'labels' ? this.getLabelTimestamps() : this._generate()
    t.bounds === 'ticks' &&
      i.length &&
      ((this.min = this._userMin || i[0]), (this.max = this._userMax || i[i.length - 1]))
    const o = this.min,
      c = this.max,
      h = r9(i, o, c)
    return (
      (this._unit =
        n.unit ||
        (r.autoSkip
          ? Ny(n.minUnit, this.min, this.max, this._getLabelCapacity(o))
          : JN(this, h.length, n.minUnit, this.min, this.max))),
      (this._majorUnit = !r.major.enabled || this._unit === 'year' ? void 0 : eT(this._unit)),
      this.initOffsets(i),
      t.reverse && h.reverse(),
      Ry(this, h, this._majorUnit)
    )
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value))
  }
  initOffsets(t = []) {
    let n = 0,
      r = 0,
      i,
      o
    this.options.offset &&
      t.length &&
      ((i = this.getDecimalForValue(t[0])),
      t.length === 1 ? (n = 1 - i) : (n = (this.getDecimalForValue(t[1]) - i) / 2),
      (o = this.getDecimalForValue(t[t.length - 1])),
      t.length === 1 ? (r = o) : (r = (o - this.getDecimalForValue(t[t.length - 2])) / 2))
    const c = t.length < 3 ? 0.5 : 0.25
    ;((n = Mn(n, 0, c)),
      (r = Mn(r, 0, c)),
      (this._offsets = { start: n, end: r, factor: 1 / (n + 1 + r) }))
  }
  _generate() {
    const t = this._adapter,
      n = this.min,
      r = this.max,
      i = this.options,
      o = i.time,
      c = o.unit || Ny(o.minUnit, n, r, this._getLabelCapacity(n)),
      h = _e(i.ticks.stepSize, 1),
      f = c === 'week' ? o.isoWeekday : !1,
      p = Il(f) || f === !0,
      y = {}
    let w = n,
      x,
      E
    if (
      (p && (w = +t.startOf(w, 'isoWeek', f)),
      (w = +t.startOf(w, p ? 'day' : c)),
      t.diff(r, n, c) > 1e5 * h)
    )
      throw new Error(n + ' and ' + r + ' are too far apart with stepSize of ' + h + ' ' + c)
    const S = i.ticks.source === 'data' && this.getDataTimestamps()
    for (x = w, E = 0; x < r; x = +t.add(x, h, c), E++) Ty(y, x, S)
    return (
      (x === r || i.bounds === 'ticks' || E === 1) && Ty(y, x, S),
      Object.keys(y)
        .sort(_y)
        .map((k) => +k)
    )
  }
  getLabelForValue(t) {
    const n = this._adapter,
      r = this.options.time
    return r.tooltipFormat ? n.format(t, r.tooltipFormat) : n.format(t, r.displayFormats.datetime)
  }
  format(t, n) {
    const r = this.options.time.displayFormats,
      i = this._unit,
      o = n || r[i]
    return this._adapter.format(t, o)
  }
  _tickFormatFunction(t, n, r, i) {
    const o = this.options,
      c = o.ticks.callback
    if (c) return Qe(c, [t, n, r], this)
    const h = o.time.displayFormats,
      f = this._unit,
      p = this._majorUnit,
      y = f && h[f],
      w = p && h[p],
      x = r[n],
      E = p && w && x && x.major
    return this._adapter.format(t, i || (E ? w : y))
  }
  generateTickLabels(t) {
    let n, r, i
    for (n = 0, r = t.length; n < r; ++n)
      ((i = t[n]), (i.label = this._tickFormatFunction(i.value, n, t)))
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min)
  }
  getPixelForValue(t) {
    const n = this._offsets,
      r = this.getDecimalForValue(t)
    return this.getPixelForDecimal((n.start + r) * n.factor)
  }
  getValueForPixel(t) {
    const n = this._offsets,
      r = this.getDecimalForPixel(t) / n.factor - n.end
    return this.min + r * (this.max - this.min)
  }
  _getLabelSize(t) {
    const n = this.options.ticks,
      r = this.ctx.measureText(t).width,
      i = yi(this.isHorizontal() ? n.maxRotation : n.minRotation),
      o = Math.cos(i),
      c = Math.sin(i),
      h = this._resolveTickFontOptions(0).size
    return { w: r * o + h * c, h: r * c + h * o }
  }
  _getLabelCapacity(t) {
    const n = this.options.time,
      r = n.displayFormats,
      i = r[n.unit] || r.millisecond,
      o = this._tickFormatFunction(t, 0, Ry(this, [t], this._majorUnit), i),
      c = this._getLabelSize(o),
      h = Math.floor(this.isHorizontal() ? this.width / c.w : this.height / c.h) - 1
    return h > 0 ? h : 1
  }
  getDataTimestamps() {
    let t = this._cache.data || [],
      n,
      r
    if (t.length) return t
    const i = this.getMatchingVisibleMetas()
    if (this._normalized && i.length)
      return (this._cache.data = i[0].controller.getAllParsedValues(this))
    for (n = 0, r = i.length; n < r; ++n) t = t.concat(i[n].controller.getAllParsedValues(this))
    return (this._cache.data = this.normalize(t))
  }
  getLabelTimestamps() {
    const t = this._cache.labels || []
    let n, r
    if (t.length) return t
    const i = this.getLabels()
    for (n = 0, r = i.length; n < r; ++n) t.push(Iy(this, i[n]))
    return (this._cache.labels = this._normalized ? t : this.normalize(t))
  }
  normalize(t) {
    return c3(t.sort(_y))
  }
}
;(ye(zu, 'id', 'time'),
  ye(zu, 'defaults', {
    bounds: 'data',
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: 'millisecond',
      displayFormats: {},
    },
    ticks: { source: 'auto', callback: !1, major: { enabled: !1 } },
  }))
function Lc(e, t, n) {
  let r = 0,
    i = e.length - 1,
    o,
    c,
    h,
    f
  n
    ? (t >= e[r].pos && t <= e[i].pos && ({ lo: r, hi: i } = cs(e, 'pos', t)),
      ({ pos: o, time: h } = e[r]),
      ({ pos: c, time: f } = e[i]))
    : (t >= e[r].time && t <= e[i].time && ({ lo: r, hi: i } = cs(e, 'time', t)),
      ({ time: o, pos: h } = e[r]),
      ({ time: c, pos: f } = e[i]))
  const p = c - o
  return p ? h + ((f - h) * (t - o)) / p : h
}
class My extends zu {
  constructor(t) {
    ;(super(t), (this._table = []), (this._minPos = void 0), (this._tableRange = void 0))
  }
  initOffsets() {
    const t = this._getTimestampsForTable(),
      n = (this._table = this.buildLookupTable(t))
    ;((this._minPos = Lc(n, this.min)),
      (this._tableRange = Lc(n, this.max) - this._minPos),
      super.initOffsets(t))
  }
  buildLookupTable(t) {
    const { min: n, max: r } = this,
      i = [],
      o = []
    let c, h, f, p, y
    for (c = 0, h = t.length; c < h; ++c) ((p = t[c]), p >= n && p <= r && i.push(p))
    if (i.length < 2)
      return [
        { time: n, pos: 0 },
        { time: r, pos: 1 },
      ]
    for (c = 0, h = i.length; c < h; ++c)
      ((y = i[c + 1]),
        (f = i[c - 1]),
        (p = i[c]),
        Math.round((y + f) / 2) !== p && o.push({ time: p, pos: c / (h - 1) }))
    return o
  }
  _generate() {
    const t = this.min,
      n = this.max
    let r = super.getDataTimestamps()
    return (
      (!r.includes(t) || !r.length) && r.splice(0, 0, t),
      (!r.includes(n) || r.length === 1) && r.push(n),
      r.sort((i, o) => i - o)
    )
  }
  _getTimestampsForTable() {
    let t = this._cache.all || []
    if (t.length) return t
    const n = this.getDataTimestamps(),
      r = this.getLabelTimestamps()
    return (
      n.length && r.length ? (t = this.normalize(n.concat(r))) : (t = n.length ? n : r),
      (t = this._cache.all = t),
      t
    )
  }
  getDecimalForValue(t) {
    return (Lc(this._table, t) - this._minPos) / this._tableRange
  }
  getValueForPixel(t) {
    const n = this._offsets,
      r = this.getDecimalForPixel(t) / n.factor - n.end
    return Lc(this._table, r * this._tableRange + this._minPos, !0)
  }
}
;(ye(My, 'id', 'timeseries'), ye(My, 'defaults', zu.defaults))
const Q3 = 'label'
function Py(e, t) {
  typeof e == 'function' ? e(t) : e && (e.current = t)
}
function nT(e, t) {
  const n = e.options
  n && t && Object.assign(n, t)
}
function $3(e, t) {
  e.labels = t
}
function J3(e, t, n = Q3) {
  const r = []
  e.datasets = t.map((i) => {
    const o = e.datasets.find((c) => c[n] === i[n])
    return !o || !i.data || r.includes(o) ? { ...i } : (r.push(o), Object.assign(o, i), o)
  })
}
function rT(e, t = Q3) {
  const n = { labels: [], datasets: [] }
  return ($3(n, e.labels), J3(n, e.datasets, t), n)
}
function iT(e, t) {
  const {
      height: n = 150,
      width: r = 300,
      redraw: i = !1,
      datasetIdKey: o,
      type: c,
      data: h,
      options: f,
      plugins: p = [],
      fallbackContent: y,
      updateMode: w,
      ...x
    } = e,
    E = X.useRef(null),
    S = X.useRef(null),
    k = () => {
      E.current &&
        ((S.current = new Wl(E.current, {
          type: c,
          data: rT(h, o),
          options: f && { ...f },
          plugins: p,
        })),
        Py(t, S.current))
    },
    P = () => {
      ;(Py(t, null), S.current && (S.current.destroy(), (S.current = null)))
    }
  return (
    X.useEffect(() => {
      !i && S.current && f && nT(S.current, f)
    }, [i, f]),
    X.useEffect(() => {
      !i && S.current && $3(S.current.config.data, h.labels)
    }, [i, h.labels]),
    X.useEffect(() => {
      !i && S.current && h.datasets && J3(S.current.config.data, h.datasets, o)
    }, [i, h.datasets]),
    X.useEffect(() => {
      S.current && (i ? (P(), setTimeout(k)) : S.current.update(w))
    }, [i, f, h.labels, h.datasets, w]),
    X.useEffect(() => {
      S.current && (P(), setTimeout(k))
    }, [c]),
    X.useEffect(() => (k(), () => P()), []),
    N.jsx('canvas', { ref: E, role: 'img', height: n, width: r, ...x, children: y })
  )
}
const sT = X.forwardRef(iT)
function mp(e, t) {
  return (Wl.register(t), X.forwardRef((n, r) => N.jsx(sT, { ...n, ref: r, type: e })))
}
const oT = mp('line', Jc),
  aT = mp('bar', $c),
  eb = mp('radar', eu)
var lT = Object.defineProperty,
  Hu = Object.getOwnPropertySymbols,
  tb = Object.prototype.hasOwnProperty,
  nb = Object.prototype.propertyIsEnumerable,
  Dy = (e, t, n) =>
    t in e ? lT(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n),
  Ly = (e, t) => {
    for (var n in t || (t = {})) tb.call(t, n) && Dy(e, n, t[n])
    if (Hu) for (var n of Hu(t)) nb.call(t, n) && Dy(e, n, t[n])
    return e
  },
  cT = (e, t) => {
    var n = {}
    for (var r in e) tb.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r])
    if (e != null && Hu) for (var r of Hu(e)) t.indexOf(r) < 0 && nb.call(e, r) && (n[r] = e[r])
    return n
  }
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */ var Ss
;((e) => {
  const t = class {
    constructor(f, p, y, w) {
      if (
        ((this.version = f),
        (this.errorCorrectionLevel = p),
        (this.modules = []),
        (this.isFunction = []),
        f < t.MIN_VERSION || f > t.MAX_VERSION)
      )
        throw new RangeError('Version value out of range')
      if (w < -1 || w > 7) throw new RangeError('Mask value out of range')
      this.size = f * 4 + 17
      let x = []
      for (let S = 0; S < this.size; S++) x.push(!1)
      for (let S = 0; S < this.size; S++)
        (this.modules.push(x.slice()), this.isFunction.push(x.slice()))
      this.drawFunctionPatterns()
      const E = this.addEccAndInterleave(y)
      if ((this.drawCodewords(E), w == -1)) {
        let S = 1e9
        for (let k = 0; k < 8; k++) {
          ;(this.applyMask(k), this.drawFormatBits(k))
          const P = this.getPenaltyScore()
          ;(P < S && ((w = k), (S = P)), this.applyMask(k))
        }
      }
      ;(o(0 <= w && w <= 7),
        (this.mask = w),
        this.applyMask(w),
        this.drawFormatBits(w),
        (this.isFunction = []))
    }
    static encodeText(f, p) {
      const y = e.QrSegment.makeSegments(f)
      return t.encodeSegments(y, p)
    }
    static encodeBinary(f, p) {
      const y = e.QrSegment.makeBytes(f)
      return t.encodeSegments([y], p)
    }
    static encodeSegments(f, p, y = 1, w = 40, x = -1, E = !0) {
      if (!(t.MIN_VERSION <= y && y <= w && w <= t.MAX_VERSION) || x < -1 || x > 7)
        throw new RangeError('Invalid value')
      let S, k
      for (S = y; ; S++) {
        const M = t.getNumDataCodewords(S, p) * 8,
          O = h.getTotalBits(f, S)
        if (O <= M) {
          k = O
          break
        }
        if (S >= w) throw new RangeError('Data too long')
      }
      for (const M of [t.Ecc.MEDIUM, t.Ecc.QUARTILE, t.Ecc.HIGH])
        E && k <= t.getNumDataCodewords(S, M) * 8 && (p = M)
      let P = []
      for (const M of f) {
        ;(r(M.mode.modeBits, 4, P), r(M.numChars, M.mode.numCharCountBits(S), P))
        for (const O of M.getData()) P.push(O)
      }
      o(P.length == k)
      const I = t.getNumDataCodewords(S, p) * 8
      ;(o(P.length <= I),
        r(0, Math.min(4, I - P.length), P),
        r(0, (8 - (P.length % 8)) % 8, P),
        o(P.length % 8 == 0))
      for (let M = 236; P.length < I; M ^= 253) r(M, 8, P)
      let R = []
      for (; R.length * 8 < P.length; ) R.push(0)
      return (P.forEach((M, O) => (R[O >>> 3] |= M << (7 - (O & 7)))), new t(S, p, R, x))
    }
    getModule(f, p) {
      return 0 <= f && f < this.size && 0 <= p && p < this.size && this.modules[p][f]
    }
    getModules() {
      return this.modules
    }
    drawFunctionPatterns() {
      for (let y = 0; y < this.size; y++)
        (this.setFunctionModule(6, y, y % 2 == 0), this.setFunctionModule(y, 6, y % 2 == 0))
      ;(this.drawFinderPattern(3, 3),
        this.drawFinderPattern(this.size - 4, 3),
        this.drawFinderPattern(3, this.size - 4))
      const f = this.getAlignmentPatternPositions(),
        p = f.length
      for (let y = 0; y < p; y++)
        for (let w = 0; w < p; w++)
          (y == 0 && w == 0) ||
            (y == 0 && w == p - 1) ||
            (y == p - 1 && w == 0) ||
            this.drawAlignmentPattern(f[y], f[w])
      ;(this.drawFormatBits(0), this.drawVersion())
    }
    drawFormatBits(f) {
      const p = (this.errorCorrectionLevel.formatBits << 3) | f
      let y = p
      for (let x = 0; x < 10; x++) y = (y << 1) ^ ((y >>> 9) * 1335)
      const w = ((p << 10) | y) ^ 21522
      o(w >>> 15 == 0)
      for (let x = 0; x <= 5; x++) this.setFunctionModule(8, x, i(w, x))
      ;(this.setFunctionModule(8, 7, i(w, 6)),
        this.setFunctionModule(8, 8, i(w, 7)),
        this.setFunctionModule(7, 8, i(w, 8)))
      for (let x = 9; x < 15; x++) this.setFunctionModule(14 - x, 8, i(w, x))
      for (let x = 0; x < 8; x++) this.setFunctionModule(this.size - 1 - x, 8, i(w, x))
      for (let x = 8; x < 15; x++) this.setFunctionModule(8, this.size - 15 + x, i(w, x))
      this.setFunctionModule(8, this.size - 8, !0)
    }
    drawVersion() {
      if (this.version < 7) return
      let f = this.version
      for (let y = 0; y < 12; y++) f = (f << 1) ^ ((f >>> 11) * 7973)
      const p = (this.version << 12) | f
      o(p >>> 18 == 0)
      for (let y = 0; y < 18; y++) {
        const w = i(p, y),
          x = this.size - 11 + (y % 3),
          E = Math.floor(y / 3)
        ;(this.setFunctionModule(x, E, w), this.setFunctionModule(E, x, w))
      }
    }
    drawFinderPattern(f, p) {
      for (let y = -4; y <= 4; y++)
        for (let w = -4; w <= 4; w++) {
          const x = Math.max(Math.abs(w), Math.abs(y)),
            E = f + w,
            S = p + y
          0 <= E &&
            E < this.size &&
            0 <= S &&
            S < this.size &&
            this.setFunctionModule(E, S, x != 2 && x != 4)
        }
    }
    drawAlignmentPattern(f, p) {
      for (let y = -2; y <= 2; y++)
        for (let w = -2; w <= 2; w++)
          this.setFunctionModule(f + w, p + y, Math.max(Math.abs(w), Math.abs(y)) != 1)
    }
    setFunctionModule(f, p, y) {
      ;((this.modules[p][f] = y), (this.isFunction[p][f] = !0))
    }
    addEccAndInterleave(f) {
      const p = this.version,
        y = this.errorCorrectionLevel
      if (f.length != t.getNumDataCodewords(p, y)) throw new RangeError('Invalid argument')
      const w = t.NUM_ERROR_CORRECTION_BLOCKS[y.ordinal][p],
        x = t.ECC_CODEWORDS_PER_BLOCK[y.ordinal][p],
        E = Math.floor(t.getNumRawDataModules(p) / 8),
        S = w - (E % w),
        k = Math.floor(E / w)
      let P = []
      const I = t.reedSolomonComputeDivisor(x)
      for (let M = 0, O = 0; M < w; M++) {
        let F = f.slice(O, O + k - x + (M < S ? 0 : 1))
        O += F.length
        const z = t.reedSolomonComputeRemainder(F, I)
        ;(M < S && F.push(0), P.push(F.concat(z)))
      }
      let R = []
      for (let M = 0; M < P[0].length; M++)
        P.forEach((O, F) => {
          ;(M != k - x || F >= S) && R.push(O[M])
        })
      return (o(R.length == E), R)
    }
    drawCodewords(f) {
      if (f.length != Math.floor(t.getNumRawDataModules(this.version) / 8))
        throw new RangeError('Invalid argument')
      let p = 0
      for (let y = this.size - 1; y >= 1; y -= 2) {
        y == 6 && (y = 5)
        for (let w = 0; w < this.size; w++)
          for (let x = 0; x < 2; x++) {
            const E = y - x,
              S = (y + 1) & 2 ? w : this.size - 1 - w
            !this.isFunction[S][E] &&
              p < f.length * 8 &&
              ((this.modules[S][E] = i(f[p >>> 3], 7 - (p & 7))), p++)
          }
      }
      o(p == f.length * 8)
    }
    applyMask(f) {
      if (f < 0 || f > 7) throw new RangeError('Mask value out of range')
      for (let p = 0; p < this.size; p++)
        for (let y = 0; y < this.size; y++) {
          let w
          switch (f) {
            case 0:
              w = (y + p) % 2 == 0
              break
            case 1:
              w = p % 2 == 0
              break
            case 2:
              w = y % 3 == 0
              break
            case 3:
              w = (y + p) % 3 == 0
              break
            case 4:
              w = (Math.floor(y / 3) + Math.floor(p / 2)) % 2 == 0
              break
            case 5:
              w = ((y * p) % 2) + ((y * p) % 3) == 0
              break
            case 6:
              w = (((y * p) % 2) + ((y * p) % 3)) % 2 == 0
              break
            case 7:
              w = (((y + p) % 2) + ((y * p) % 3)) % 2 == 0
              break
            default:
              throw new Error('Unreachable')
          }
          !this.isFunction[p][y] && w && (this.modules[p][y] = !this.modules[p][y])
        }
    }
    getPenaltyScore() {
      let f = 0
      for (let x = 0; x < this.size; x++) {
        let E = !1,
          S = 0,
          k = [0, 0, 0, 0, 0, 0, 0]
        for (let P = 0; P < this.size; P++)
          this.modules[x][P] == E
            ? (S++, S == 5 ? (f += t.PENALTY_N1) : S > 5 && f++)
            : (this.finderPenaltyAddHistory(S, k),
              E || (f += this.finderPenaltyCountPatterns(k) * t.PENALTY_N3),
              (E = this.modules[x][P]),
              (S = 1))
        f += this.finderPenaltyTerminateAndCount(E, S, k) * t.PENALTY_N3
      }
      for (let x = 0; x < this.size; x++) {
        let E = !1,
          S = 0,
          k = [0, 0, 0, 0, 0, 0, 0]
        for (let P = 0; P < this.size; P++)
          this.modules[P][x] == E
            ? (S++, S == 5 ? (f += t.PENALTY_N1) : S > 5 && f++)
            : (this.finderPenaltyAddHistory(S, k),
              E || (f += this.finderPenaltyCountPatterns(k) * t.PENALTY_N3),
              (E = this.modules[P][x]),
              (S = 1))
        f += this.finderPenaltyTerminateAndCount(E, S, k) * t.PENALTY_N3
      }
      for (let x = 0; x < this.size - 1; x++)
        for (let E = 0; E < this.size - 1; E++) {
          const S = this.modules[x][E]
          S == this.modules[x][E + 1] &&
            S == this.modules[x + 1][E] &&
            S == this.modules[x + 1][E + 1] &&
            (f += t.PENALTY_N2)
        }
      let p = 0
      for (const x of this.modules) p = x.reduce((E, S) => E + (S ? 1 : 0), p)
      const y = this.size * this.size,
        w = Math.ceil(Math.abs(p * 20 - y * 10) / y) - 1
      return (o(0 <= w && w <= 9), (f += w * t.PENALTY_N4), o(0 <= f && f <= 2568888), f)
    }
    getAlignmentPatternPositions() {
      if (this.version == 1) return []
      {
        const f = Math.floor(this.version / 7) + 2,
          p = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (f * 2 - 2)) * 2
        let y = [6]
        for (let w = this.size - 7; y.length < f; w -= p) y.splice(1, 0, w)
        return y
      }
    }
    static getNumRawDataModules(f) {
      if (f < t.MIN_VERSION || f > t.MAX_VERSION)
        throw new RangeError('Version number out of range')
      let p = (16 * f + 128) * f + 64
      if (f >= 2) {
        const y = Math.floor(f / 7) + 2
        ;((p -= (25 * y - 10) * y - 55), f >= 7 && (p -= 36))
      }
      return (o(208 <= p && p <= 29648), p)
    }
    static getNumDataCodewords(f, p) {
      return (
        Math.floor(t.getNumRawDataModules(f) / 8) -
        t.ECC_CODEWORDS_PER_BLOCK[p.ordinal][f] * t.NUM_ERROR_CORRECTION_BLOCKS[p.ordinal][f]
      )
    }
    static reedSolomonComputeDivisor(f) {
      if (f < 1 || f > 255) throw new RangeError('Degree out of range')
      let p = []
      for (let w = 0; w < f - 1; w++) p.push(0)
      p.push(1)
      let y = 1
      for (let w = 0; w < f; w++) {
        for (let x = 0; x < p.length; x++)
          ((p[x] = t.reedSolomonMultiply(p[x], y)), x + 1 < p.length && (p[x] ^= p[x + 1]))
        y = t.reedSolomonMultiply(y, 2)
      }
      return p
    }
    static reedSolomonComputeRemainder(f, p) {
      let y = p.map((w) => 0)
      for (const w of f) {
        const x = w ^ y.shift()
        ;(y.push(0), p.forEach((E, S) => (y[S] ^= t.reedSolomonMultiply(E, x))))
      }
      return y
    }
    static reedSolomonMultiply(f, p) {
      if (f >>> 8 || p >>> 8) throw new RangeError('Byte out of range')
      let y = 0
      for (let w = 7; w >= 0; w--) ((y = (y << 1) ^ ((y >>> 7) * 285)), (y ^= ((p >>> w) & 1) * f))
      return (o(y >>> 8 == 0), y)
    }
    finderPenaltyCountPatterns(f) {
      const p = f[1]
      o(p <= this.size * 3)
      const y = p > 0 && f[2] == p && f[3] == p * 3 && f[4] == p && f[5] == p
      return (y && f[0] >= p * 4 && f[6] >= p ? 1 : 0) + (y && f[6] >= p * 4 && f[0] >= p ? 1 : 0)
    }
    finderPenaltyTerminateAndCount(f, p, y) {
      return (
        f && (this.finderPenaltyAddHistory(p, y), (p = 0)),
        (p += this.size),
        this.finderPenaltyAddHistory(p, y),
        this.finderPenaltyCountPatterns(y)
      )
    }
    finderPenaltyAddHistory(f, p) {
      ;(p[0] == 0 && (f += this.size), p.pop(), p.unshift(f))
    }
  }
  let n = t
  ;((n.MIN_VERSION = 1),
    (n.MAX_VERSION = 40),
    (n.PENALTY_N1 = 3),
    (n.PENALTY_N2 = 3),
    (n.PENALTY_N3 = 40),
    (n.PENALTY_N4 = 10),
    (n.ECC_CODEWORDS_PER_BLOCK = [
      [
        -1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28,
        30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
      ],
      [
        -1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28,
        28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
      ],
      [
        -1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30,
        30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
      ],
      [
        -1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24,
        30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
      ],
    ]),
    (n.NUM_ERROR_CORRECTION_BLOCKS = [
      [
        -1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13,
        14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25,
      ],
      [
        -1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21,
        23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49,
      ],
      [
        -1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29,
        34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68,
      ],
      [
        -1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32,
        35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81,
      ],
    ]),
    (e.QrCode = n))
  function r(f, p, y) {
    if (p < 0 || p > 31 || f >>> p) throw new RangeError('Value out of range')
    for (let w = p - 1; w >= 0; w--) y.push((f >>> w) & 1)
  }
  function i(f, p) {
    return ((f >>> p) & 1) != 0
  }
  function o(f) {
    if (!f) throw new Error('Assertion error')
  }
  const c = class {
    constructor(f, p, y) {
      if (((this.mode = f), (this.numChars = p), (this.bitData = y), p < 0))
        throw new RangeError('Invalid argument')
      this.bitData = y.slice()
    }
    static makeBytes(f) {
      let p = []
      for (const y of f) r(y, 8, p)
      return new c(c.Mode.BYTE, f.length, p)
    }
    static makeNumeric(f) {
      if (!c.isNumeric(f)) throw new RangeError('String contains non-numeric characters')
      let p = []
      for (let y = 0; y < f.length; ) {
        const w = Math.min(f.length - y, 3)
        ;(r(parseInt(f.substr(y, w), 10), w * 3 + 1, p), (y += w))
      }
      return new c(c.Mode.NUMERIC, f.length, p)
    }
    static makeAlphanumeric(f) {
      if (!c.isAlphanumeric(f))
        throw new RangeError('String contains unencodable characters in alphanumeric mode')
      let p = [],
        y
      for (y = 0; y + 2 <= f.length; y += 2) {
        let w = c.ALPHANUMERIC_CHARSET.indexOf(f.charAt(y)) * 45
        ;((w += c.ALPHANUMERIC_CHARSET.indexOf(f.charAt(y + 1))), r(w, 11, p))
      }
      return (
        y < f.length && r(c.ALPHANUMERIC_CHARSET.indexOf(f.charAt(y)), 6, p),
        new c(c.Mode.ALPHANUMERIC, f.length, p)
      )
    }
    static makeSegments(f) {
      return f == ''
        ? []
        : c.isNumeric(f)
          ? [c.makeNumeric(f)]
          : c.isAlphanumeric(f)
            ? [c.makeAlphanumeric(f)]
            : [c.makeBytes(c.toUtf8ByteArray(f))]
    }
    static makeEci(f) {
      let p = []
      if (f < 0) throw new RangeError('ECI assignment value out of range')
      if (f < 128) r(f, 8, p)
      else if (f < 16384) (r(2, 2, p), r(f, 14, p))
      else if (f < 1e6) (r(6, 3, p), r(f, 21, p))
      else throw new RangeError('ECI assignment value out of range')
      return new c(c.Mode.ECI, 0, p)
    }
    static isNumeric(f) {
      return c.NUMERIC_REGEX.test(f)
    }
    static isAlphanumeric(f) {
      return c.ALPHANUMERIC_REGEX.test(f)
    }
    getData() {
      return this.bitData.slice()
    }
    static getTotalBits(f, p) {
      let y = 0
      for (const w of f) {
        const x = w.mode.numCharCountBits(p)
        if (w.numChars >= 1 << x) return 1 / 0
        y += 4 + x + w.bitData.length
      }
      return y
    }
    static toUtf8ByteArray(f) {
      f = encodeURI(f)
      let p = []
      for (let y = 0; y < f.length; y++)
        f.charAt(y) != '%'
          ? p.push(f.charCodeAt(y))
          : (p.push(parseInt(f.substr(y + 1, 2), 16)), (y += 2))
      return p
    }
  }
  let h = c
  ;((h.NUMERIC_REGEX = /^[0-9]*$/),
    (h.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/),
    (h.ALPHANUMERIC_CHARSET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'),
    (e.QrSegment = h))
})(Ss || (Ss = {}))
;((e) => {
  ;((t) => {
    const n = class {
      constructor(i, o) {
        ;((this.ordinal = i), (this.formatBits = o))
      }
    }
    let r = n
    ;((r.LOW = new n(0, 1)),
      (r.MEDIUM = new n(1, 0)),
      (r.QUARTILE = new n(2, 3)),
      (r.HIGH = new n(3, 2)),
      (t.Ecc = r))
  })(e.QrCode || (e.QrCode = {}))
})(Ss || (Ss = {}))
;((e) => {
  ;((t) => {
    const n = class {
      constructor(i, o) {
        ;((this.modeBits = i), (this.numBitsCharCount = o))
      }
      numCharCountBits(i) {
        return this.numBitsCharCount[Math.floor((i + 7) / 17)]
      }
    }
    let r = n
    ;((r.NUMERIC = new n(1, [10, 12, 14])),
      (r.ALPHANUMERIC = new n(2, [9, 11, 13])),
      (r.BYTE = new n(4, [8, 16, 16])),
      (r.KANJI = new n(8, [8, 10, 12])),
      (r.ECI = new n(7, [0, 0, 0])),
      (t.Mode = r))
  })(e.QrSegment || (e.QrSegment = {}))
})(Ss || (Ss = {}))
var La = Ss
/**
 * @license qrcode.react
 * Copyright (c) Paul O'Shannessy
 * SPDX-License-Identifier: ISC
 */ var uT = {
    L: La.QrCode.Ecc.LOW,
    M: La.QrCode.Ecc.MEDIUM,
    Q: La.QrCode.Ecc.QUARTILE,
    H: La.QrCode.Ecc.HIGH,
  },
  hT = 128,
  dT = 'L',
  fT = '#FFFFFF',
  pT = '#000000',
  gT = !1,
  rb = 4,
  mT = 0.1
function yT(e, t = 0) {
  const n = []
  return (
    e.forEach(function (r, i) {
      let o = null
      r.forEach(function (c, h) {
        if (!c && o !== null) {
          ;(n.push(`M${o + t} ${i + t}h${h - o}v1H${o + t}z`), (o = null))
          return
        }
        if (h === r.length - 1) {
          if (!c) return
          o === null
            ? n.push(`M${h + t},${i + t} h1v1H${h + t}z`)
            : n.push(`M${o + t},${i + t} h${h + 1 - o}v1H${o + t}z`)
          return
        }
        c && o === null && (o = h)
      })
    }),
    n.join('')
  )
}
function wT(e, t) {
  return e
    .slice()
    .map((n, r) =>
      r < t.y || r >= t.y + t.h ? n : n.map((i, o) => (o < t.x || o >= t.x + t.w ? i : !1))
    )
}
function bT(e, t, n, r) {
  if (r == null) return null
  const i = n ? rb : 0,
    o = e.length + i * 2,
    c = Math.floor(t * mT),
    h = o / t,
    f = (r.width || c) * h,
    p = (r.height || c) * h,
    y = r.x == null ? e.length / 2 - f / 2 : r.x * h,
    w = r.y == null ? e.length / 2 - p / 2 : r.y * h
  let x = null
  if (r.excavate) {
    let E = Math.floor(y),
      S = Math.floor(w),
      k = Math.ceil(f + y - E),
      P = Math.ceil(p + w - S)
    x = { x: E, y: S, w: k, h: P }
  }
  return { x: y, y: w, h: p, w: f, excavation: x }
}
var vT = (function () {
  try {
    new Path2D().addPath(new Path2D())
  } catch {
    return !1
  }
  return !0
})()
function xT(e) {
  const t = e,
    {
      value: n,
      size: r = hT,
      level: i = dT,
      bgColor: o = fT,
      fgColor: c = pT,
      includeMargin: h = gT,
      style: f,
      imageSettings: p,
    } = t,
    y = cT(t, [
      'value',
      'size',
      'level',
      'bgColor',
      'fgColor',
      'includeMargin',
      'style',
      'imageSettings',
    ]),
    w = p == null ? void 0 : p.src,
    x = A.useRef(null),
    E = A.useRef(null),
    [S, k] = A.useState(!1)
  ;(A.useEffect(() => {
    if (x.current != null) {
      const R = x.current,
        M = R.getContext('2d')
      if (!M) return
      let O = La.QrCode.encodeText(n, uT[i]).getModules()
      const F = h ? rb : 0,
        z = O.length + F * 2,
        V = bT(O, r, h, p),
        U = E.current,
        Z = V != null && U !== null && U.complete && U.naturalHeight !== 0 && U.naturalWidth !== 0
      Z && V.excavation != null && (O = wT(O, V.excavation))
      const J = window.devicePixelRatio || 1
      R.height = R.width = r * J
      const oe = (r / z) * J
      ;(M.scale(oe, oe),
        (M.fillStyle = o),
        M.fillRect(0, 0, z, z),
        (M.fillStyle = c),
        vT
          ? M.fill(new Path2D(yT(O, F)))
          : O.forEach(function (re, ve) {
              re.forEach(function (Ie, H) {
                Ie && M.fillRect(H + F, ve + F, 1, 1)
              })
            }),
        Z && M.drawImage(U, V.x + F, V.y + F, V.w, V.h))
    }
  }),
    A.useEffect(() => {
      k(!1)
    }, [w]))
  const P = Ly({ height: r, width: r }, f)
  let I = null
  return (
    w != null &&
      (I = A.createElement('img', {
        src: w,
        key: w,
        style: { display: 'none' },
        onLoad: () => {
          k(!0)
        },
        ref: E,
      })),
    A.createElement(
      A.Fragment,
      null,
      A.createElement('canvas', Ly({ style: P, height: r, width: r, ref: x }, y)),
      I
    )
  )
}
Wl.register(xo, Ja, Ur, X3, Z3)
const ET = ['Presence', 'Strategy', 'Composure', 'Guidance'],
  Oy = {
    GREEN: {
      name: 'Calm Navigator',
      description: 'You move with steady composure and keep the room grounded in clarity.',
    },
    YELLOW: {
      name: 'Signal Catalyst',
      description: 'Your energy shapes momentum and keeps people focused on what matters.',
    },
    RED: {
      name: 'Edge Architect',
      description: 'You bring sharp intensity and strong direction when stakes rise.',
    },
  },
  CT = () => {
    const e = t3(),
      [t, n] = X.useState(null),
      [r, i] = X.useState(!1)
    return (
      X.useEffect(() => {
        e &&
          (async () => {
            try {
              const o = e3(e).split('|'),
                c = o.pop(),
                h = o.join('|')
              if (!c) {
                i(!0)
                return
              }
              if ((await tp(h)).slice(0, 8) !== c) {
                i(!0)
                return
              }
              n({
                band: o[3],
                dtiBase: Number(o[4]),
                dtiFinal: Number(o[5]),
                scores: { N: Number(o[6]), M: Number(o[7]), P: Number(o[8]), MD: Number(o[9]) },
                integrity: Number(o[10]),
                archetype: o[11],
              })
            } catch {
              i(!0)
            }
          })()
      }, [e]),
      N.jsxs('div', {
        className: 'mx-auto flex w-full max-w-5xl flex-col gap-8 px-6 py-16',
        children: [
          N.jsxs('div', {
            className:
              'flex items-center gap-3 text-sm uppercase tracking-[0.3em] text-emerald-200',
            children: [N.jsx(Qo, { size: 18 }), 'Vibe Prism Results'],
          }),
          !e &&
            N.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                N.jsx('h2', {
                  className: 'text-xl font-semibold',
                  children: 'No profile found yet',
                }),
                N.jsx('p', {
                  className: 'mt-2 text-sm text-slate-400',
                  children: 'Take the quiz to generate your vibe profile.',
                }),
                N.jsx(er, {
                  to: '/quiz',
                  className: 'button-primary mt-6',
                  children: 'Start the quiz',
                }),
              ],
            }),
          e &&
            !t &&
            !r &&
            N.jsx('div', { className: 'glass-panel p-6', children: 'Loading profile...' }),
          e && (t || r) && N.jsx(ST, { data: t, token: e, error: r }),
        ],
      })
    )
  },
  ST = ({ data: e, token: t, error: n }) => {
    if (n || !e)
      return N.jsxs('div', {
        className: 'glass-panel p-6',
        children: [
          N.jsx('p', {
            className: 'text-sm text-slate-400',
            children: 'Token validation failed. Please restore a valid profile.',
          }),
          N.jsx(er, { to: '/quiz', className: 'button-primary mt-4', children: 'Retake quiz' }),
        ],
      })
    const r = Oy[e.band] ?? Oy.GREEN,
      i = {
        labels: ET,
        datasets: [
          {
            label: 'Vibe',
            data: [e.scores.N, e.scores.M, e.scores.P, e.scores.MD],
            backgroundColor: 'rgba(16, 185, 129, 0.2)',
            borderColor: 'rgba(16, 185, 129, 0.7)',
            borderWidth: 2,
            pointBackgroundColor: 'rgba(16, 185, 129, 0.9)',
          },
        ],
      }
    return N.jsxs('div', {
      className: 'grid gap-8 lg:grid-cols-[1.1fr_0.9fr]',
      children: [
        N.jsxs(qn.div, {
          initial: { opacity: 0, scale: 0.98 },
          animate: { opacity: 1, scale: 1 },
          transition: { duration: 0.4 },
          className: 'glass-panel p-6',
          children: [
            N.jsxs('div', {
              className: 'flex items-center gap-3',
              children: [
                N.jsx(bh, { size: 24, className: 'text-emerald-300' }),
                N.jsxs('div', {
                  children: [
                    N.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                      children: 'Persona',
                    }),
                    N.jsx('h2', {
                      className: 'text-2xl font-semibold text-slate-50',
                      children: r.name,
                    }),
                  ],
                }),
              ],
            }),
            N.jsx('p', { className: 'mt-4 text-sm text-slate-300', children: r.description }),
            N.jsxs('div', {
              className: 'mt-6 grid gap-3 sm:grid-cols-3',
              children: [
                N.jsxs('div', {
                  className: 'rounded-xl border border-white/10 bg-slate-900/60 p-3',
                  children: [
                    N.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                      children: 'Momentum',
                    }),
                    N.jsx('p', {
                      className: 'mt-2 text-lg font-semibold text-slate-50',
                      children: e.dtiFinal,
                    }),
                  ],
                }),
                N.jsxs('div', {
                  className: 'rounded-xl border border-white/10 bg-slate-900/60 p-3',
                  children: [
                    N.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                      children: 'Integrity',
                    }),
                    N.jsx('p', {
                      className: 'mt-2 text-lg font-semibold text-slate-50',
                      children: e.integrity,
                    }),
                  ],
                }),
                N.jsxs('div', {
                  className: 'rounded-xl border border-white/10 bg-slate-900/60 p-3',
                  children: [
                    N.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                      children: 'Archetype',
                    }),
                    N.jsx('p', {
                      className: 'mt-2 text-sm font-semibold text-slate-50',
                      children: e.archetype,
                    }),
                  ],
                }),
              ],
            }),
            N.jsx('div', {
              className: 'mt-6 h-64',
              children: N.jsx(eb, {
                data: i,
                options: {
                  scales: {
                    r: {
                      ticks: { display: !1 },
                      grid: { color: 'rgba(148, 163, 184, 0.2)' },
                      pointLabels: { color: 'rgba(226, 232, 240, 0.8)' },
                      suggestedMin: 0,
                      suggestedMax: 100,
                    },
                  },
                  plugins: { legend: { display: !1 } },
                  animation: { duration: 800 },
                },
              }),
            }),
          ],
        }),
        N.jsxs('div', {
          className: 'flex flex-col gap-6',
          children: [
            N.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                N.jsx('h3', { className: 'text-lg font-semibold', children: 'Profile Readout' }),
                N.jsxs('p', {
                  className: 'mt-2 text-sm text-slate-400',
                  children: ['Base DTI: ', e.dtiBase, '  Final DTI: ', e.dtiFinal],
                }),
                N.jsxs('div', {
                  className: 'mt-4 grid gap-2 text-sm text-slate-300',
                  children: [
                    N.jsxs('div', {
                      className:
                        'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                      children: [
                        N.jsx('span', { children: 'Presence' }),
                        N.jsx('span', { children: e.scores.N }),
                      ],
                    }),
                    N.jsxs('div', {
                      className:
                        'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                      children: [
                        N.jsx('span', { children: 'Strategy' }),
                        N.jsx('span', { children: e.scores.M }),
                      ],
                    }),
                    N.jsxs('div', {
                      className:
                        'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                      children: [
                        N.jsx('span', { children: 'Composure' }),
                        N.jsx('span', { children: e.scores.P }),
                      ],
                    }),
                    N.jsxs('div', {
                      className:
                        'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                      children: [
                        N.jsx('span', { children: 'Guidance' }),
                        N.jsx('span', { children: e.scores.MD }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
            N.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                N.jsxs('div', {
                  className: 'flex items-center gap-3',
                  children: [
                    N.jsx(Vl, { size: 22, className: 'text-emerald-300' }),
                    N.jsxs('div', {
                      children: [
                        N.jsx('h3', {
                          className: 'text-lg font-semibold',
                          children: 'Private QR token',
                        }),
                        N.jsx('p', {
                          className: 'text-sm text-slate-400',
                          children: 'Store this token to restore your profile later.',
                        }),
                      ],
                    }),
                  ],
                }),
                N.jsx('div', {
                  className:
                    'mt-4 flex items-center justify-center rounded-xl border border-white/10 bg-slate-900/60 p-4',
                  children: N.jsx(xT, {
                    value: t,
                    size: 160,
                    bgColor: '#0f172a',
                    fgColor: '#e2e8f0',
                  }),
                }),
                N.jsxs('p', {
                  className: 'mt-4 text-xs text-slate-500',
                  children: ['Token preview: ', t.slice(0, 32), '...'],
                }),
              ],
            }),
            N.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                N.jsx('h3', {
                  className: 'text-lg font-semibold',
                  children: 'Need the full profile?',
                }),
                N.jsx('p', {
                  className: 'mt-2 text-sm text-slate-400',
                  children: 'Restore your profile with the secure decoder.',
                }),
                N.jsx(er, {
                  to: '/restore',
                  className: 'button-secondary mt-4',
                  children: 'Restore Profile',
                }),
              ],
            }),
            N.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                N.jsx('h3', { className: 'text-lg font-semibold', children: 'Next actions' }),
                N.jsx('ul', {
                  className: 'mt-3 space-y-2 text-sm text-slate-300',
                  children: [
                    'Save your QR token to a secure note.',
                    'Share the persona name with your team.',
                    'Use the decoder to review trait-level insights.',
                  ].map((o) => N.jsx('li', { className: 'list-item', children: o }, o)),
                }),
              ],
            }),
          ],
        }),
      ],
    })
  },
  AT = '55486423',
  kT = (e) => (e <= 0 ? 0 : Math.min(6e4, 3e3 * e * e)),
  _T = ({ onUnlock: e }) => {
    const [t, n] = X.useState(''),
      [r, i] = X.useState(0),
      [o, c] = X.useState(null),
      h = o !== null && o > Date.now(),
      f = X.useMemo(() => ''.repeat(t.length).padEnd(8, ''), [t]),
      p = (E) => {
        h || t.length >= 8 || n((S) => S + E)
      },
      y = () => {
        h || n((E) => E.slice(0, -1))
      },
      w = () => {
        h || n('')
      },
      x = () => {
        if (h || t.length < 8) return
        if (t === AT) {
          ;(sessionStorage.setItem('VP_DECODE_UNLOCK', '1'), e())
          return
        }
        const E = r + 1
        if ((i(E), n(''), E >= 3)) {
          const S = kT(E)
          ;(c(Date.now() + S), setTimeout(() => c(null), S + 200))
        }
      }
    return N.jsxs('div', {
      className: 'glass-panel p-6',
      children: [
        N.jsxs('div', {
          className: 'flex items-center gap-3',
          children: [
            N.jsx(xs, { size: 28, className: 'text-emerald-300' }),
            N.jsxs('div', {
              children: [
                N.jsx('p', {
                  className: 'text-sm uppercase tracking-[0.2em] text-slate-400',
                  children: 'Nexus Who Access',
                }),
                N.jsx('h2', { className: 'text-xl font-semibold', children: 'Enter 8-digit PIN' }),
              ],
            }),
          ],
        }),
        N.jsxs('div', {
          className:
            'mt-6 flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-4 py-3 text-lg tracking-[0.3em]',
          children: [
            N.jsx('span', { children: f }),
            h &&
              N.jsx('span', {
                className: 'text-xs uppercase tracking-[0.3em] text-rose-300',
                children: 'Locked',
              }),
          ],
        }),
        N.jsxs('div', {
          className: 'mt-6 grid grid-cols-3 gap-3',
          children: [
            ['1', '2', '3', '4', '5', '6', '7', '8', '9'].map((E) =>
              N.jsx(
                'button',
                {
                  type: 'button',
                  onClick: () => p(E),
                  className:
                    'rounded-xl border border-white/10 bg-white/5 py-3 text-lg font-semibold text-slate-100 transition hover:border-emerald-400/40',
                  children: E,
                },
                E
              )
            ),
            N.jsx('button', {
              type: 'button',
              onClick: w,
              className:
                'rounded-xl border border-white/10 bg-white/5 py-3 text-xs uppercase tracking-[0.3em] text-slate-400',
              children: 'Clear',
            }),
            N.jsx('button', {
              type: 'button',
              onClick: () => p('0'),
              className:
                'rounded-xl border border-white/10 bg-white/5 py-3 text-lg font-semibold text-slate-100 transition hover:border-emerald-400/40',
              children: '0',
            }),
            N.jsx('button', {
              type: 'button',
              onClick: y,
              className:
                'rounded-xl border border-white/10 bg-white/5 py-3 text-xs uppercase tracking-[0.3em] text-slate-400',
              children: 'Delete',
            }),
          ],
        }),
        N.jsxs('div', {
          className: 'mt-6 flex flex-wrap gap-3',
          children: [
            N.jsx('button', {
              type: 'button',
              onClick: x,
              className: 'button-primary',
              children: 'Unlock',
            }),
            r > 0 &&
              N.jsxs('span', {
                className: 'text-xs text-slate-400',
                children: ['Attempts: ', r, ' / 3'],
              }),
          ],
        }),
      ],
    })
  }
var le
;(function (e) {
  ;((e[(e.QR_CODE = 0)] = 'QR_CODE'),
    (e[(e.AZTEC = 1)] = 'AZTEC'),
    (e[(e.CODABAR = 2)] = 'CODABAR'),
    (e[(e.CODE_39 = 3)] = 'CODE_39'),
    (e[(e.CODE_93 = 4)] = 'CODE_93'),
    (e[(e.CODE_128 = 5)] = 'CODE_128'),
    (e[(e.DATA_MATRIX = 6)] = 'DATA_MATRIX'),
    (e[(e.MAXICODE = 7)] = 'MAXICODE'),
    (e[(e.ITF = 8)] = 'ITF'),
    (e[(e.EAN_13 = 9)] = 'EAN_13'),
    (e[(e.EAN_8 = 10)] = 'EAN_8'),
    (e[(e.PDF_417 = 11)] = 'PDF_417'),
    (e[(e.RSS_14 = 12)] = 'RSS_14'),
    (e[(e.RSS_EXPANDED = 13)] = 'RSS_EXPANDED'),
    (e[(e.UPC_A = 14)] = 'UPC_A'),
    (e[(e.UPC_E = 15)] = 'UPC_E'),
    (e[(e.UPC_EAN_EXTENSION = 16)] = 'UPC_EAN_EXTENSION'))
})(le || (le = {}))
var By = new Map([
    [le.QR_CODE, 'QR_CODE'],
    [le.AZTEC, 'AZTEC'],
    [le.CODABAR, 'CODABAR'],
    [le.CODE_39, 'CODE_39'],
    [le.CODE_93, 'CODE_93'],
    [le.CODE_128, 'CODE_128'],
    [le.DATA_MATRIX, 'DATA_MATRIX'],
    [le.MAXICODE, 'MAXICODE'],
    [le.ITF, 'ITF'],
    [le.EAN_13, 'EAN_13'],
    [le.EAN_8, 'EAN_8'],
    [le.PDF_417, 'PDF_417'],
    [le.RSS_14, 'RSS_14'],
    [le.RSS_EXPANDED, 'RSS_EXPANDED'],
    [le.UPC_A, 'UPC_A'],
    [le.UPC_E, 'UPC_E'],
    [le.UPC_EAN_EXTENSION, 'UPC_EAN_EXTENSION'],
  ]),
  Fy
;(function (e) {
  ;((e[(e.UNKNOWN = 0)] = 'UNKNOWN'), (e[(e.URL = 1)] = 'URL'))
})(Fy || (Fy = {}))
function IT(e) {
  return Object.values(le).includes(e)
}
var Xu
;(function (e) {
  ;((e[(e.SCAN_TYPE_CAMERA = 0)] = 'SCAN_TYPE_CAMERA'),
    (e[(e.SCAN_TYPE_FILE = 1)] = 'SCAN_TYPE_FILE'))
})(Xu || (Xu = {}))
var NT = (function () {
    function e() {}
    return (
      (e.GITHUB_PROJECT_URL = 'https://github.com/mebjas/html5-qrcode'),
      (e.SCAN_DEFAULT_FPS = 2),
      (e.DEFAULT_DISABLE_FLIP = !1),
      (e.DEFAULT_REMEMBER_LAST_CAMERA_USED = !0),
      (e.DEFAULT_SUPPORTED_SCAN_TYPE = [Xu.SCAN_TYPE_CAMERA, Xu.SCAN_TYPE_FILE]),
      e
    )
  })(),
  ib = (function () {
    function e(t, n) {
      ;((this.format = t), (this.formatName = n))
    }
    return (
      (e.prototype.toString = function () {
        return this.formatName
      }),
      (e.create = function (t) {
        if (!By.has(t)) throw ''.concat(t, ' not in html5QrcodeSupportedFormatsTextMap')
        return new e(t, By.get(t))
      }),
      e
    )
  })(),
  jy = (function () {
    function e() {}
    return (
      (e.createFromText = function (t) {
        var n = { text: t }
        return { decodedText: t, result: n }
      }),
      (e.createFromQrcodeResult = function (t) {
        return { decodedText: t.text, result: t }
      }),
      e
    )
  })(),
  xf
;(function (e) {
  ;((e[(e.UNKWOWN_ERROR = 0)] = 'UNKWOWN_ERROR'),
    (e[(e.IMPLEMENTATION_ERROR = 1)] = 'IMPLEMENTATION_ERROR'),
    (e[(e.NO_CODE_FOUND_ERROR = 2)] = 'NO_CODE_FOUND_ERROR'))
})(xf || (xf = {}))
var TT = (function () {
    function e() {}
    return (
      (e.createFrom = function (t) {
        return { errorMessage: t, type: xf.UNKWOWN_ERROR }
      }),
      e
    )
  })(),
  RT = (function () {
    function e(t) {
      this.verbose = t
    }
    return (
      (e.prototype.log = function (t) {
        this.verbose && console.log(t)
      }),
      (e.prototype.warn = function (t) {
        this.verbose && console.warn(t)
      }),
      (e.prototype.logError = function (t, n) {
        ;(this.verbose || n === !0) && console.error(t)
      }),
      (e.prototype.logErrors = function (t) {
        if (t.length === 0) throw 'Logger#logError called without arguments'
        this.verbose && console.error(t)
      }),
      e
    )
  })()
function Dr(e) {
  return typeof e > 'u' || e === null
}
var Eo = (function () {
    function e() {}
    return (
      (e.codeParseError = function (t) {
        return 'QR code parse error, error = '.concat(t)
      }),
      (e.errorGettingUserMedia = function (t) {
        return 'Error getting userMedia, error = '.concat(t)
      }),
      (e.onlyDeviceSupportedError = function () {
        return "The device doesn't support navigator.mediaDevices , only supported cameraIdOrConfig in this case is deviceId parameter (string)."
      }),
      (e.cameraStreamingNotSupported = function () {
        return 'Camera streaming not supported by the browser.'
      }),
      (e.unableToQuerySupportedDevices = function () {
        return 'Unable to query supported devices, unknown error.'
      }),
      (e.insecureContextCameraQueryError = function () {
        return 'Camera access is only supported in secure context like https or localhost.'
      }),
      (e.scannerPaused = function () {
        return 'Scanner paused'
      }),
      e
    )
  })(),
  sb = (function () {
    function e() {}
    return (
      (e.isMediaStreamConstraintsValid = function (t, n) {
        if (typeof t != 'object') {
          var r = typeof t
          return (
            n.logError(
              'videoConstraints should be of type object, the ' +
                'object passed is of type '.concat(r, '.'),
              !0
            ),
            !1
          )
        }
        for (
          var i = [
              'autoGainControl',
              'channelCount',
              'echoCancellation',
              'latency',
              'noiseSuppression',
              'sampleRate',
              'sampleSize',
              'volume',
            ],
            o = new Set(i),
            c = Object.keys(t),
            h = 0,
            f = c;
          h < f.length;
          h++
        ) {
          var p = f[h]
          if (o.has(p))
            return (n.logError(''.concat(p, ' is not supported videoConstaints.'), !0), !1)
        }
        return !0
      }),
      e
    )
  })(),
  Ef = { exports: {} }
;(function (e, t) {
  ;(function (n, r) {
    r(t)
  })(ha, function (n) {
    function r(_) {
      return _ == null
    }
    var i =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (_, s) {
          _.__proto__ = s
        }) ||
      function (_, s) {
        for (var a in s) s.hasOwnProperty(a) && (_[a] = s[a])
      }
    function o(_, s) {
      i(_, s)
      function a() {
        this.constructor = _
      }
      _.prototype = s === null ? Object.create(s) : ((a.prototype = s.prototype), new a())
    }
    function c(_, s) {
      var a = Object.setPrototypeOf
      a ? a(_, s) : (_.__proto__ = s)
    }
    function h(_, s) {
      s === void 0 && (s = _.constructor)
      var a = Error.captureStackTrace
      a && a(_, s)
    }
    var f = (function (_) {
      o(s, _)
      function s(a) {
        var l = this.constructor,
          u = _.call(this, a) || this
        return (
          Object.defineProperty(u, 'name', { value: l.name, enumerable: !1 }),
          c(u, l.prototype),
          h(u),
          u
        )
      }
      return s
    })(Error)
    class p extends f {
      constructor(s = void 0) {
        ;(super(s), (this.message = s))
      }
      getKind() {
        return this.constructor.kind
      }
    }
    p.kind = 'Exception'
    class y extends p {}
    y.kind = 'ArgumentException'
    class w extends p {}
    w.kind = 'IllegalArgumentException'
    class x {
      constructor(s) {
        if (((this.binarizer = s), s === null)) throw new w('Binarizer must be non-null.')
      }
      getWidth() {
        return this.binarizer.getWidth()
      }
      getHeight() {
        return this.binarizer.getHeight()
      }
      getBlackRow(s, a) {
        return this.binarizer.getBlackRow(s, a)
      }
      getBlackMatrix() {
        return (
          (this.matrix === null || this.matrix === void 0) &&
            (this.matrix = this.binarizer.getBlackMatrix()),
          this.matrix
        )
      }
      isCropSupported() {
        return this.binarizer.getLuminanceSource().isCropSupported()
      }
      crop(s, a, l, u) {
        const d = this.binarizer.getLuminanceSource().crop(s, a, l, u)
        return new x(this.binarizer.createBinarizer(d))
      }
      isRotateSupported() {
        return this.binarizer.getLuminanceSource().isRotateSupported()
      }
      rotateCounterClockwise() {
        const s = this.binarizer.getLuminanceSource().rotateCounterClockwise()
        return new x(this.binarizer.createBinarizer(s))
      }
      rotateCounterClockwise45() {
        const s = this.binarizer.getLuminanceSource().rotateCounterClockwise45()
        return new x(this.binarizer.createBinarizer(s))
      }
      toString() {
        try {
          return this.getBlackMatrix().toString()
        } catch {
          return ''
        }
      }
    }
    class E extends p {
      static getChecksumInstance() {
        return new E()
      }
    }
    E.kind = 'ChecksumException'
    class S {
      constructor(s) {
        this.source = s
      }
      getLuminanceSource() {
        return this.source
      }
      getWidth() {
        return this.source.getWidth()
      }
      getHeight() {
        return this.source.getHeight()
      }
    }
    class k {
      static arraycopy(s, a, l, u, d) {
        for (; d--; ) l[u++] = s[a++]
      }
      static currentTimeMillis() {
        return Date.now()
      }
    }
    class P extends p {}
    P.kind = 'IndexOutOfBoundsException'
    class I extends P {
      constructor(s = void 0, a = void 0) {
        ;(super(a), (this.index = s), (this.message = a))
      }
    }
    I.kind = 'ArrayIndexOutOfBoundsException'
    class R {
      static fill(s, a) {
        for (let l = 0, u = s.length; l < u; l++) s[l] = a
      }
      static fillWithin(s, a, l, u) {
        R.rangeCheck(s.length, a, l)
        for (let d = a; d < l; d++) s[d] = u
      }
      static rangeCheck(s, a, l) {
        if (a > l) throw new w('fromIndex(' + a + ') > toIndex(' + l + ')')
        if (a < 0) throw new I(a)
        if (l > s) throw new I(l)
      }
      static asList(...s) {
        return s
      }
      static create(s, a, l) {
        return Array.from({ length: s }).map((u) => Array.from({ length: a }).fill(l))
      }
      static createInt32Array(s, a, l) {
        return Array.from({ length: s }).map((u) => Int32Array.from({ length: a }).fill(l))
      }
      static equals(s, a) {
        if (!s || !a || !s.length || !a.length || s.length !== a.length) return !1
        for (let l = 0, u = s.length; l < u; l++) if (s[l] !== a[l]) return !1
        return !0
      }
      static hashCode(s) {
        if (s === null) return 0
        let a = 1
        for (const l of s) a = 31 * a + l
        return a
      }
      static fillUint8Array(s, a) {
        for (let l = 0; l !== s.length; l++) s[l] = a
      }
      static copyOf(s, a) {
        return s.slice(0, a)
      }
      static copyOfUint8Array(s, a) {
        if (s.length <= a) {
          const l = new Uint8Array(a)
          return (l.set(s), l)
        }
        return s.slice(0, a)
      }
      static copyOfRange(s, a, l) {
        const u = l - a,
          d = new Int32Array(u)
        return (k.arraycopy(s, a, d, 0, u), d)
      }
      static binarySearch(s, a, l) {
        l === void 0 && (l = R.numberComparator)
        let u = 0,
          d = s.length - 1
        for (; u <= d; ) {
          const g = (d + u) >> 1,
            m = l(a, s[g])
          if (m > 0) u = g + 1
          else if (m < 0) d = g - 1
          else return g
        }
        return -u - 1
      }
      static numberComparator(s, a) {
        return s - a
      }
    }
    class M {
      static numberOfTrailingZeros(s) {
        let a
        if (s === 0) return 32
        let l = 31
        return (
          (a = s << 16),
          a !== 0 && ((l -= 16), (s = a)),
          (a = s << 8),
          a !== 0 && ((l -= 8), (s = a)),
          (a = s << 4),
          a !== 0 && ((l -= 4), (s = a)),
          (a = s << 2),
          a !== 0 && ((l -= 2), (s = a)),
          l - ((s << 1) >>> 31)
        )
      }
      static numberOfLeadingZeros(s) {
        if (s === 0) return 32
        let a = 1
        return (
          s >>> 16 || ((a += 16), (s <<= 16)),
          s >>> 24 || ((a += 8), (s <<= 8)),
          s >>> 28 || ((a += 4), (s <<= 4)),
          s >>> 30 || ((a += 2), (s <<= 2)),
          (a -= s >>> 31),
          a
        )
      }
      static toHexString(s) {
        return s.toString(16)
      }
      static toBinaryString(s) {
        return String(parseInt(String(s), 2))
      }
      static bitCount(s) {
        return (
          (s = s - ((s >>> 1) & 1431655765)),
          (s = (s & 858993459) + ((s >>> 2) & 858993459)),
          (s = (s + (s >>> 4)) & 252645135),
          (s = s + (s >>> 8)),
          (s = s + (s >>> 16)),
          s & 63
        )
      }
      static truncDivision(s, a) {
        return Math.trunc(s / a)
      }
      static parseInt(s, a = void 0) {
        return parseInt(s, a)
      }
    }
    ;((M.MIN_VALUE_32_BITS = -2147483648), (M.MAX_VALUE = Number.MAX_SAFE_INTEGER))
    class O {
      constructor(s, a) {
        s === void 0
          ? ((this.size = 0), (this.bits = new Int32Array(1)))
          : ((this.size = s), a == null ? (this.bits = O.makeArray(s)) : (this.bits = a))
      }
      getSize() {
        return this.size
      }
      getSizeInBytes() {
        return Math.floor((this.size + 7) / 8)
      }
      ensureCapacity(s) {
        if (s > this.bits.length * 32) {
          const a = O.makeArray(s)
          ;(k.arraycopy(this.bits, 0, a, 0, this.bits.length), (this.bits = a))
        }
      }
      get(s) {
        return (this.bits[Math.floor(s / 32)] & (1 << (s & 31))) !== 0
      }
      set(s) {
        this.bits[Math.floor(s / 32)] |= 1 << (s & 31)
      }
      flip(s) {
        this.bits[Math.floor(s / 32)] ^= 1 << (s & 31)
      }
      getNextSet(s) {
        const a = this.size
        if (s >= a) return a
        const l = this.bits
        let u = Math.floor(s / 32),
          d = l[u]
        d &= ~((1 << (s & 31)) - 1)
        const g = l.length
        for (; d === 0; ) {
          if (++u === g) return a
          d = l[u]
        }
        const m = u * 32 + M.numberOfTrailingZeros(d)
        return m > a ? a : m
      }
      getNextUnset(s) {
        const a = this.size
        if (s >= a) return a
        const l = this.bits
        let u = Math.floor(s / 32),
          d = ~l[u]
        d &= ~((1 << (s & 31)) - 1)
        const g = l.length
        for (; d === 0; ) {
          if (++u === g) return a
          d = ~l[u]
        }
        const m = u * 32 + M.numberOfTrailingZeros(d)
        return m > a ? a : m
      }
      setBulk(s, a) {
        this.bits[Math.floor(s / 32)] = a
      }
      setRange(s, a) {
        if (a < s || s < 0 || a > this.size) throw new w()
        if (a === s) return
        a--
        const l = Math.floor(s / 32),
          u = Math.floor(a / 32),
          d = this.bits
        for (let g = l; g <= u; g++) {
          const m = g > l ? 0 : s & 31,
            b = (2 << (g < u ? 31 : a & 31)) - (1 << m)
          d[g] |= b
        }
      }
      clear() {
        const s = this.bits.length,
          a = this.bits
        for (let l = 0; l < s; l++) a[l] = 0
      }
      isRange(s, a, l) {
        if (a < s || s < 0 || a > this.size) throw new w()
        if (a === s) return !0
        a--
        const u = Math.floor(s / 32),
          d = Math.floor(a / 32),
          g = this.bits
        for (let m = u; m <= d; m++) {
          const b = m > u ? 0 : s & 31,
            v = ((2 << (m < d ? 31 : a & 31)) - (1 << b)) & 4294967295
          if ((g[m] & v) !== (l ? v : 0)) return !1
        }
        return !0
      }
      appendBit(s) {
        ;(this.ensureCapacity(this.size + 1),
          s && (this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 31)),
          this.size++)
      }
      appendBits(s, a) {
        if (a < 0 || a > 32) throw new w('Num bits must be between 0 and 32')
        this.ensureCapacity(this.size + a)
        for (let l = a; l > 0; l--) this.appendBit(((s >> (l - 1)) & 1) === 1)
      }
      appendBitArray(s) {
        const a = s.size
        this.ensureCapacity(this.size + a)
        for (let l = 0; l < a; l++) this.appendBit(s.get(l))
      }
      xor(s) {
        if (this.size !== s.size) throw new w("Sizes don't match")
        const a = this.bits
        for (let l = 0, u = a.length; l < u; l++) a[l] ^= s.bits[l]
      }
      toBytes(s, a, l, u) {
        for (let d = 0; d < u; d++) {
          let g = 0
          for (let m = 0; m < 8; m++) (this.get(s) && (g |= 1 << (7 - m)), s++)
          a[l + d] = g
        }
      }
      getBitArray() {
        return this.bits
      }
      reverse() {
        const s = new Int32Array(this.bits.length),
          a = Math.floor((this.size - 1) / 32),
          l = a + 1,
          u = this.bits
        for (let d = 0; d < l; d++) {
          let g = u[d]
          ;((g = ((g >> 1) & 1431655765) | ((g & 1431655765) << 1)),
            (g = ((g >> 2) & 858993459) | ((g & 858993459) << 2)),
            (g = ((g >> 4) & 252645135) | ((g & 252645135) << 4)),
            (g = ((g >> 8) & 16711935) | ((g & 16711935) << 8)),
            (g = ((g >> 16) & 65535) | ((g & 65535) << 16)),
            (s[a - d] = g))
        }
        if (this.size !== l * 32) {
          const d = l * 32 - this.size
          let g = s[0] >>> d
          for (let m = 1; m < l; m++) {
            const b = s[m]
            ;((g |= b << (32 - d)), (s[m - 1] = g), (g = b >>> d))
          }
          s[l - 1] = g
        }
        this.bits = s
      }
      static makeArray(s) {
        return new Int32Array(Math.floor((s + 31) / 32))
      }
      equals(s) {
        if (!(s instanceof O)) return !1
        const a = s
        return this.size === a.size && R.equals(this.bits, a.bits)
      }
      hashCode() {
        return 31 * this.size + R.hashCode(this.bits)
      }
      toString() {
        let s = ''
        for (let a = 0, l = this.size; a < l; a++)
          (a & 7 || (s += ' '), (s += this.get(a) ? 'X' : '.'))
        return s
      }
      clone() {
        return new O(this.size, this.bits.slice())
      }
    }
    var F
    ;(function (_) {
      ;((_[(_.OTHER = 0)] = 'OTHER'),
        (_[(_.PURE_BARCODE = 1)] = 'PURE_BARCODE'),
        (_[(_.POSSIBLE_FORMATS = 2)] = 'POSSIBLE_FORMATS'),
        (_[(_.TRY_HARDER = 3)] = 'TRY_HARDER'),
        (_[(_.CHARACTER_SET = 4)] = 'CHARACTER_SET'),
        (_[(_.ALLOWED_LENGTHS = 5)] = 'ALLOWED_LENGTHS'),
        (_[(_.ASSUME_CODE_39_CHECK_DIGIT = 6)] = 'ASSUME_CODE_39_CHECK_DIGIT'),
        (_[(_.ASSUME_GS1 = 7)] = 'ASSUME_GS1'),
        (_[(_.RETURN_CODABAR_START_END = 8)] = 'RETURN_CODABAR_START_END'),
        (_[(_.NEED_RESULT_POINT_CALLBACK = 9)] = 'NEED_RESULT_POINT_CALLBACK'),
        (_[(_.ALLOWED_EAN_EXTENSIONS = 10)] = 'ALLOWED_EAN_EXTENSIONS'))
    })(F || (F = {}))
    var z = F
    class V extends p {
      static getFormatInstance() {
        return new V()
      }
    }
    V.kind = 'FormatException'
    var U
    ;(function (_) {
      ;((_[(_.Cp437 = 0)] = 'Cp437'),
        (_[(_.ISO8859_1 = 1)] = 'ISO8859_1'),
        (_[(_.ISO8859_2 = 2)] = 'ISO8859_2'),
        (_[(_.ISO8859_3 = 3)] = 'ISO8859_3'),
        (_[(_.ISO8859_4 = 4)] = 'ISO8859_4'),
        (_[(_.ISO8859_5 = 5)] = 'ISO8859_5'),
        (_[(_.ISO8859_6 = 6)] = 'ISO8859_6'),
        (_[(_.ISO8859_7 = 7)] = 'ISO8859_7'),
        (_[(_.ISO8859_8 = 8)] = 'ISO8859_8'),
        (_[(_.ISO8859_9 = 9)] = 'ISO8859_9'),
        (_[(_.ISO8859_10 = 10)] = 'ISO8859_10'),
        (_[(_.ISO8859_11 = 11)] = 'ISO8859_11'),
        (_[(_.ISO8859_13 = 12)] = 'ISO8859_13'),
        (_[(_.ISO8859_14 = 13)] = 'ISO8859_14'),
        (_[(_.ISO8859_15 = 14)] = 'ISO8859_15'),
        (_[(_.ISO8859_16 = 15)] = 'ISO8859_16'),
        (_[(_.SJIS = 16)] = 'SJIS'),
        (_[(_.Cp1250 = 17)] = 'Cp1250'),
        (_[(_.Cp1251 = 18)] = 'Cp1251'),
        (_[(_.Cp1252 = 19)] = 'Cp1252'),
        (_[(_.Cp1256 = 20)] = 'Cp1256'),
        (_[(_.UnicodeBigUnmarked = 21)] = 'UnicodeBigUnmarked'),
        (_[(_.UTF8 = 22)] = 'UTF8'),
        (_[(_.ASCII = 23)] = 'ASCII'),
        (_[(_.Big5 = 24)] = 'Big5'),
        (_[(_.GB18030 = 25)] = 'GB18030'),
        (_[(_.EUC_KR = 26)] = 'EUC_KR'))
    })(U || (U = {}))
    class Z {
      constructor(s, a, l, ...u) {
        ;((this.valueIdentifier = s),
          (this.name = l),
          typeof a == 'number' ? (this.values = Int32Array.from([a])) : (this.values = a),
          (this.otherEncodingNames = u),
          Z.VALUE_IDENTIFIER_TO_ECI.set(s, this),
          Z.NAME_TO_ECI.set(l, this))
        const d = this.values
        for (let g = 0, m = d.length; g !== m; g++) {
          const b = d[g]
          Z.VALUES_TO_ECI.set(b, this)
        }
        for (const g of u) Z.NAME_TO_ECI.set(g, this)
      }
      getValueIdentifier() {
        return this.valueIdentifier
      }
      getName() {
        return this.name
      }
      getValue() {
        return this.values[0]
      }
      static getCharacterSetECIByValue(s) {
        if (s < 0 || s >= 900) throw new V('incorect value')
        const a = Z.VALUES_TO_ECI.get(s)
        if (a === void 0) throw new V('incorect value')
        return a
      }
      static getCharacterSetECIByName(s) {
        const a = Z.NAME_TO_ECI.get(s)
        if (a === void 0) throw new V('incorect value')
        return a
      }
      equals(s) {
        if (!(s instanceof Z)) return !1
        const a = s
        return this.getName() === a.getName()
      }
    }
    ;((Z.VALUE_IDENTIFIER_TO_ECI = new Map()),
      (Z.VALUES_TO_ECI = new Map()),
      (Z.NAME_TO_ECI = new Map()),
      (Z.Cp437 = new Z(U.Cp437, Int32Array.from([0, 2]), 'Cp437')),
      (Z.ISO8859_1 = new Z(
        U.ISO8859_1,
        Int32Array.from([1, 3]),
        'ISO-8859-1',
        'ISO88591',
        'ISO8859_1'
      )),
      (Z.ISO8859_2 = new Z(U.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2')),
      (Z.ISO8859_3 = new Z(U.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3')),
      (Z.ISO8859_4 = new Z(U.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4')),
      (Z.ISO8859_5 = new Z(U.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5')),
      (Z.ISO8859_6 = new Z(U.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6')),
      (Z.ISO8859_7 = new Z(U.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7')),
      (Z.ISO8859_8 = new Z(U.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8')),
      (Z.ISO8859_9 = new Z(U.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9')),
      (Z.ISO8859_10 = new Z(U.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10')),
      (Z.ISO8859_11 = new Z(U.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11')),
      (Z.ISO8859_13 = new Z(U.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13')),
      (Z.ISO8859_14 = new Z(U.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14')),
      (Z.ISO8859_15 = new Z(U.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15')),
      (Z.ISO8859_16 = new Z(U.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16')),
      (Z.SJIS = new Z(U.SJIS, 20, 'SJIS', 'Shift_JIS')),
      (Z.Cp1250 = new Z(U.Cp1250, 21, 'Cp1250', 'windows-1250')),
      (Z.Cp1251 = new Z(U.Cp1251, 22, 'Cp1251', 'windows-1251')),
      (Z.Cp1252 = new Z(U.Cp1252, 23, 'Cp1252', 'windows-1252')),
      (Z.Cp1256 = new Z(U.Cp1256, 24, 'Cp1256', 'windows-1256')),
      (Z.UnicodeBigUnmarked = new Z(
        U.UnicodeBigUnmarked,
        25,
        'UnicodeBigUnmarked',
        'UTF-16BE',
        'UnicodeBig'
      )),
      (Z.UTF8 = new Z(U.UTF8, 26, 'UTF8', 'UTF-8')),
      (Z.ASCII = new Z(U.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII')),
      (Z.Big5 = new Z(U.Big5, 28, 'Big5')),
      (Z.GB18030 = new Z(U.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK')),
      (Z.EUC_KR = new Z(U.EUC_KR, 30, 'EUC_KR', 'EUC-KR')))
    class J extends p {}
    J.kind = 'UnsupportedOperationException'
    class oe {
      static decode(s, a) {
        const l = this.encodingName(a)
        return this.customDecoder
          ? this.customDecoder(s, l)
          : typeof TextDecoder > 'u' || this.shouldDecodeOnFallback(l)
            ? this.decodeFallback(s, l)
            : new TextDecoder(l).decode(s)
      }
      static shouldDecodeOnFallback(s) {
        return !oe.isBrowser() && s === 'ISO-8859-1'
      }
      static encode(s, a) {
        const l = this.encodingName(a)
        return this.customEncoder
          ? this.customEncoder(s, l)
          : typeof TextEncoder > 'u'
            ? this.encodeFallback(s)
            : new TextEncoder().encode(s)
      }
      static isBrowser() {
        return typeof window < 'u' && {}.toString.call(window) === '[object Window]'
      }
      static encodingName(s) {
        return typeof s == 'string' ? s : s.getName()
      }
      static encodingCharacterSet(s) {
        return s instanceof Z ? s : Z.getCharacterSetECIByName(s)
      }
      static decodeFallback(s, a) {
        const l = this.encodingCharacterSet(a)
        if (oe.isDecodeFallbackSupported(l)) {
          let u = ''
          for (let d = 0, g = s.length; d < g; d++) {
            let m = s[d].toString(16)
            ;(m.length < 2 && (m = '0' + m), (u += '%' + m))
          }
          return decodeURIComponent(u)
        }
        if (l.equals(Z.UnicodeBigUnmarked))
          return String.fromCharCode.apply(null, new Uint16Array(s.buffer))
        throw new J(`Encoding ${this.encodingName(a)} not supported by fallback.`)
      }
      static isDecodeFallbackSupported(s) {
        return s.equals(Z.UTF8) || s.equals(Z.ISO8859_1) || s.equals(Z.ASCII)
      }
      static encodeFallback(s) {
        const a = btoa(unescape(encodeURIComponent(s))).split(''),
          l = []
        for (let u = 0; u < a.length; u++) l.push(a[u].charCodeAt(0))
        return new Uint8Array(l)
      }
    }
    class re {
      static castAsNonUtf8Char(s, a = null) {
        const l = a ? a.getName() : this.ISO88591
        return oe.decode(new Uint8Array([s]), l)
      }
      static guessEncoding(s, a) {
        if (a != null && a.get(z.CHARACTER_SET) !== void 0) return a.get(z.CHARACTER_SET).toString()
        const l = s.length
        let u = !0,
          d = !0,
          g = !0,
          m = 0,
          b = 0,
          v = 0,
          C = 0,
          T = 0,
          D = 0,
          B = 0,
          j = 0,
          W = 0,
          Y = 0,
          q = 0
        const ne = s.length > 3 && s[0] === 239 && s[1] === 187 && s[2] === 191
        for (let te = 0; te < l && (u || d || g); te++) {
          const $ = s[te] & 255
          ;(g &&
            (m > 0
              ? $ & 128
                ? m--
                : (g = !1)
              : $ & 128 &&
                ($ & 64
                  ? (m++, $ & 32 ? (m++, $ & 16 ? (m++, $ & 8 ? (g = !1) : C++) : v++) : b++)
                  : (g = !1))),
            u &&
              ($ > 127 && $ < 160
                ? (u = !1)
                : $ > 159 && ($ < 192 || $ === 215 || $ === 247) && q++),
            d &&
              (T > 0
                ? $ < 64 || $ === 127 || $ > 252
                  ? (d = !1)
                  : T--
                : $ === 128 || $ === 160 || $ > 239
                  ? (d = !1)
                  : $ > 160 && $ < 224
                    ? (D++, (j = 0), B++, B > W && (W = B))
                    : $ > 127
                      ? (T++, (B = 0), j++, j > Y && (Y = j))
                      : ((B = 0), (j = 0))))
        }
        return (
          g && m > 0 && (g = !1),
          d && T > 0 && (d = !1),
          g && (ne || b + v + C > 0)
            ? re.UTF8
            : d && (re.ASSUME_SHIFT_JIS || W >= 3 || Y >= 3)
              ? re.SHIFT_JIS
              : u && d
                ? (W === 2 && D === 2) || q * 10 >= l
                  ? re.SHIFT_JIS
                  : re.ISO88591
                : u
                  ? re.ISO88591
                  : d
                    ? re.SHIFT_JIS
                    : g
                      ? re.UTF8
                      : re.PLATFORM_DEFAULT_ENCODING
        )
      }
      static format(s, ...a) {
        let l = -1
        function u(g, m, b, v, C, T) {
          if (g === '%%') return '%'
          if (a[++l] === void 0) return
          g = v ? parseInt(v.substr(1)) : void 0
          let D = C ? parseInt(C.substr(1)) : void 0,
            B
          switch (T) {
            case 's':
              B = a[l]
              break
            case 'c':
              B = a[l][0]
              break
            case 'f':
              B = parseFloat(a[l]).toFixed(g)
              break
            case 'p':
              B = parseFloat(a[l]).toPrecision(g)
              break
            case 'e':
              B = parseFloat(a[l]).toExponential(g)
              break
            case 'x':
              B = parseInt(a[l]).toString(D || 16)
              break
            case 'd':
              B = parseFloat(parseInt(a[l], D || 10).toPrecision(g)).toFixed(0)
              break
          }
          B = typeof B == 'object' ? JSON.stringify(B) : (+B).toString(D)
          let j = parseInt(b),
            W = b && b[0] + '' == '0' ? '0' : ' '
          for (; B.length < j; ) B = m !== void 0 ? B + W : W + B
          return B
        }
        let d = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g
        return s.replace(d, u)
      }
      static getBytes(s, a) {
        return oe.encode(s, a)
      }
      static getCharCode(s, a = 0) {
        return s.charCodeAt(a)
      }
      static getCharAt(s) {
        return String.fromCharCode(s)
      }
    }
    ;((re.SHIFT_JIS = Z.SJIS.getName()),
      (re.GB2312 = 'GB2312'),
      (re.ISO88591 = Z.ISO8859_1.getName()),
      (re.EUC_JP = 'EUC_JP'),
      (re.UTF8 = Z.UTF8.getName()),
      (re.PLATFORM_DEFAULT_ENCODING = re.UTF8),
      (re.ASSUME_SHIFT_JIS = !1))
    class ve {
      constructor(s = '') {
        this.value = s
      }
      enableDecoding(s) {
        return ((this.encoding = s), this)
      }
      append(s) {
        return (
          typeof s == 'string'
            ? (this.value += s.toString())
            : this.encoding
              ? (this.value += re.castAsNonUtf8Char(s, this.encoding))
              : (this.value += String.fromCharCode(s)),
          this
        )
      }
      appendChars(s, a, l) {
        for (let u = a; a < a + l; u++) this.append(s[u])
        return this
      }
      length() {
        return this.value.length
      }
      charAt(s) {
        return this.value.charAt(s)
      }
      deleteCharAt(s) {
        this.value = this.value.substr(0, s) + this.value.substring(s + 1)
      }
      setCharAt(s, a) {
        this.value = this.value.substr(0, s) + a + this.value.substr(s + 1)
      }
      substring(s, a) {
        return this.value.substring(s, a)
      }
      setLengthToZero() {
        this.value = ''
      }
      toString() {
        return this.value
      }
      insert(s, a) {
        this.value = this.value.substr(0, s) + a + this.value.substr(s + a.length)
      }
    }
    class Ie {
      constructor(s, a, l, u) {
        if (
          ((this.width = s),
          (this.height = a),
          (this.rowSize = l),
          (this.bits = u),
          a == null && (a = s),
          (this.height = a),
          s < 1 || a < 1)
        )
          throw new w('Both dimensions must be greater than 0')
        ;(l == null && (l = Math.floor((s + 31) / 32)),
          (this.rowSize = l),
          u == null && (this.bits = new Int32Array(this.rowSize * this.height)))
      }
      static parseFromBooleanArray(s) {
        const a = s.length,
          l = s[0].length,
          u = new Ie(l, a)
        for (let d = 0; d < a; d++) {
          const g = s[d]
          for (let m = 0; m < l; m++) g[m] && u.set(m, d)
        }
        return u
      }
      static parseFromString(s, a, l) {
        if (s === null) throw new w('stringRepresentation cannot be null')
        const u = new Array(s.length)
        let d = 0,
          g = 0,
          m = -1,
          b = 0,
          v = 0
        for (; v < s.length; )
          if (
            s.charAt(v) ===
              `
` ||
            s.charAt(v) === '\r'
          ) {
            if (d > g) {
              if (m === -1) m = d - g
              else if (d - g !== m) throw new w('row lengths do not match')
              ;((g = d), b++)
            }
            v++
          } else if (s.substring(v, v + a.length) === a) ((v += a.length), (u[d] = !0), d++)
          else if (s.substring(v, v + l.length) === l) ((v += l.length), (u[d] = !1), d++)
          else throw new w('illegal character encountered: ' + s.substring(v))
        if (d > g) {
          if (m === -1) m = d - g
          else if (d - g !== m) throw new w('row lengths do not match')
          b++
        }
        const C = new Ie(m, b)
        for (let T = 0; T < d; T++) u[T] && C.set(Math.floor(T % m), Math.floor(T / m))
        return C
      }
      get(s, a) {
        const l = a * this.rowSize + Math.floor(s / 32)
        return ((this.bits[l] >>> (s & 31)) & 1) !== 0
      }
      set(s, a) {
        const l = a * this.rowSize + Math.floor(s / 32)
        this.bits[l] |= (1 << (s & 31)) & 4294967295
      }
      unset(s, a) {
        const l = a * this.rowSize + Math.floor(s / 32)
        this.bits[l] &= ~((1 << (s & 31)) & 4294967295)
      }
      flip(s, a) {
        const l = a * this.rowSize + Math.floor(s / 32)
        this.bits[l] ^= (1 << (s & 31)) & 4294967295
      }
      xor(s) {
        if (
          this.width !== s.getWidth() ||
          this.height !== s.getHeight() ||
          this.rowSize !== s.getRowSize()
        )
          throw new w('input matrix dimensions do not match')
        const a = new O(Math.floor(this.width / 32) + 1),
          l = this.rowSize,
          u = this.bits
        for (let d = 0, g = this.height; d < g; d++) {
          const m = d * l,
            b = s.getRow(d, a).getBitArray()
          for (let v = 0; v < l; v++) u[m + v] ^= b[v]
        }
      }
      clear() {
        const s = this.bits,
          a = s.length
        for (let l = 0; l < a; l++) s[l] = 0
      }
      setRegion(s, a, l, u) {
        if (a < 0 || s < 0) throw new w('Left and top must be nonnegative')
        if (u < 1 || l < 1) throw new w('Height and width must be at least 1')
        const d = s + l,
          g = a + u
        if (g > this.height || d > this.width) throw new w('The region must fit inside the matrix')
        const m = this.rowSize,
          b = this.bits
        for (let v = a; v < g; v++) {
          const C = v * m
          for (let T = s; T < d; T++) b[C + Math.floor(T / 32)] |= (1 << (T & 31)) & 4294967295
        }
      }
      getRow(s, a) {
        a == null || a.getSize() < this.width ? (a = new O(this.width)) : a.clear()
        const l = this.rowSize,
          u = this.bits,
          d = s * l
        for (let g = 0; g < l; g++) a.setBulk(g * 32, u[d + g])
        return a
      }
      setRow(s, a) {
        k.arraycopy(a.getBitArray(), 0, this.bits, s * this.rowSize, this.rowSize)
      }
      rotate180() {
        const s = this.getWidth(),
          a = this.getHeight()
        let l = new O(s),
          u = new O(s)
        for (let d = 0, g = Math.floor((a + 1) / 2); d < g; d++)
          ((l = this.getRow(d, l)),
            (u = this.getRow(a - 1 - d, u)),
            l.reverse(),
            u.reverse(),
            this.setRow(d, u),
            this.setRow(a - 1 - d, l))
      }
      getEnclosingRectangle() {
        const s = this.width,
          a = this.height,
          l = this.rowSize,
          u = this.bits
        let d = s,
          g = a,
          m = -1,
          b = -1
        for (let v = 0; v < a; v++)
          for (let C = 0; C < l; C++) {
            const T = u[v * l + C]
            if (T !== 0) {
              if ((v < g && (g = v), v > b && (b = v), C * 32 < d)) {
                let D = 0
                for (; !((T << (31 - D)) & 4294967295); ) D++
                C * 32 + D < d && (d = C * 32 + D)
              }
              if (C * 32 + 31 > m) {
                let D = 31
                for (; !(T >>> D); ) D--
                C * 32 + D > m && (m = C * 32 + D)
              }
            }
          }
        return m < d || b < g ? null : Int32Array.from([d, g, m - d + 1, b - g + 1])
      }
      getTopLeftOnBit() {
        const s = this.rowSize,
          a = this.bits
        let l = 0
        for (; l < a.length && a[l] === 0; ) l++
        if (l === a.length) return null
        const u = l / s
        let d = (l % s) * 32
        const g = a[l]
        let m = 0
        for (; !((g << (31 - m)) & 4294967295); ) m++
        return ((d += m), Int32Array.from([d, u]))
      }
      getBottomRightOnBit() {
        const s = this.rowSize,
          a = this.bits
        let l = a.length - 1
        for (; l >= 0 && a[l] === 0; ) l--
        if (l < 0) return null
        const u = Math.floor(l / s)
        let d = Math.floor(l % s) * 32
        const g = a[l]
        let m = 31
        for (; !(g >>> m); ) m--
        return ((d += m), Int32Array.from([d, u]))
      }
      getWidth() {
        return this.width
      }
      getHeight() {
        return this.height
      }
      getRowSize() {
        return this.rowSize
      }
      equals(s) {
        if (!(s instanceof Ie)) return !1
        const a = s
        return (
          this.width === a.width &&
          this.height === a.height &&
          this.rowSize === a.rowSize &&
          R.equals(this.bits, a.bits)
        )
      }
      hashCode() {
        let s = this.width
        return (
          (s = 31 * s + this.width),
          (s = 31 * s + this.height),
          (s = 31 * s + this.rowSize),
          (s = 31 * s + R.hashCode(this.bits)),
          s
        )
      }
      toString(
        s = 'X ',
        a = '  ',
        l = `
`
      ) {
        return this.buildToString(s, a, l)
      }
      buildToString(s, a, l) {
        let u = new ve()
        for (let d = 0, g = this.height; d < g; d++) {
          for (let m = 0, b = this.width; m < b; m++) u.append(this.get(m, d) ? s : a)
          u.append(l)
        }
        return u.toString()
      }
      clone() {
        return new Ie(this.width, this.height, this.rowSize, this.bits.slice())
      }
    }
    class H extends p {
      static getNotFoundInstance() {
        return new H()
      }
    }
    H.kind = 'NotFoundException'
    class xe extends S {
      constructor(s) {
        ;(super(s),
          (this.luminances = xe.EMPTY),
          (this.buckets = new Int32Array(xe.LUMINANCE_BUCKETS)))
      }
      getBlackRow(s, a) {
        const l = this.getLuminanceSource(),
          u = l.getWidth()
        ;(a == null || a.getSize() < u ? (a = new O(u)) : a.clear(), this.initArrays(u))
        const d = l.getRow(s, this.luminances),
          g = this.buckets
        for (let b = 0; b < u; b++) g[(d[b] & 255) >> xe.LUMINANCE_SHIFT]++
        const m = xe.estimateBlackPoint(g)
        if (u < 3) for (let b = 0; b < u; b++) (d[b] & 255) < m && a.set(b)
        else {
          let b = d[0] & 255,
            v = d[1] & 255
          for (let C = 1; C < u - 1; C++) {
            const T = d[C + 1] & 255
            ;((v * 4 - b - T) / 2 < m && a.set(C), (b = v), (v = T))
          }
        }
        return a
      }
      getBlackMatrix() {
        const s = this.getLuminanceSource(),
          a = s.getWidth(),
          l = s.getHeight(),
          u = new Ie(a, l)
        this.initArrays(a)
        const d = this.buckets
        for (let b = 1; b < 5; b++) {
          const v = Math.floor((l * b) / 5),
            C = s.getRow(v, this.luminances),
            T = Math.floor((a * 4) / 5)
          for (let D = Math.floor(a / 5); D < T; D++) {
            const B = C[D] & 255
            d[B >> xe.LUMINANCE_SHIFT]++
          }
        }
        const g = xe.estimateBlackPoint(d),
          m = s.getMatrix()
        for (let b = 0; b < l; b++) {
          const v = b * a
          for (let C = 0; C < a; C++) (m[v + C] & 255) < g && u.set(C, b)
        }
        return u
      }
      createBinarizer(s) {
        return new xe(s)
      }
      initArrays(s) {
        this.luminances.length < s && (this.luminances = new Uint8ClampedArray(s))
        const a = this.buckets
        for (let l = 0; l < xe.LUMINANCE_BUCKETS; l++) a[l] = 0
      }
      static estimateBlackPoint(s) {
        const a = s.length
        let l = 0,
          u = 0,
          d = 0
        for (let C = 0; C < a; C++) (s[C] > d && ((u = C), (d = s[C])), s[C] > l && (l = s[C]))
        let g = 0,
          m = 0
        for (let C = 0; C < a; C++) {
          const T = C - u,
            D = s[C] * T * T
          D > m && ((g = C), (m = D))
        }
        if (u > g) {
          const C = u
          ;((u = g), (g = C))
        }
        if (g - u <= a / 16) throw new H()
        let b = g - 1,
          v = -1
        for (let C = g - 1; C > u; C--) {
          const T = C - u,
            D = T * T * (g - C) * (l - s[C])
          D > v && ((b = C), (v = D))
        }
        return b << xe.LUMINANCE_SHIFT
      }
    }
    ;((xe.LUMINANCE_BITS = 5),
      (xe.LUMINANCE_SHIFT = 8 - xe.LUMINANCE_BITS),
      (xe.LUMINANCE_BUCKETS = 1 << xe.LUMINANCE_BITS),
      (xe.EMPTY = Uint8ClampedArray.from([0])))
    class ge extends xe {
      constructor(s) {
        ;(super(s), (this.matrix = null))
      }
      getBlackMatrix() {
        if (this.matrix !== null) return this.matrix
        const s = this.getLuminanceSource(),
          a = s.getWidth(),
          l = s.getHeight()
        if (a >= ge.MINIMUM_DIMENSION && l >= ge.MINIMUM_DIMENSION) {
          const u = s.getMatrix()
          let d = a >> ge.BLOCK_SIZE_POWER
          a & ge.BLOCK_SIZE_MASK && d++
          let g = l >> ge.BLOCK_SIZE_POWER
          l & ge.BLOCK_SIZE_MASK && g++
          const m = ge.calculateBlackPoints(u, d, g, a, l),
            b = new Ie(a, l)
          ;(ge.calculateThresholdForBlock(u, d, g, a, l, m, b), (this.matrix = b))
        } else this.matrix = super.getBlackMatrix()
        return this.matrix
      }
      createBinarizer(s) {
        return new ge(s)
      }
      static calculateThresholdForBlock(s, a, l, u, d, g, m) {
        const b = d - ge.BLOCK_SIZE,
          v = u - ge.BLOCK_SIZE
        for (let C = 0; C < l; C++) {
          let T = C << ge.BLOCK_SIZE_POWER
          T > b && (T = b)
          const D = ge.cap(C, 2, l - 3)
          for (let B = 0; B < a; B++) {
            let j = B << ge.BLOCK_SIZE_POWER
            j > v && (j = v)
            const W = ge.cap(B, 2, a - 3)
            let Y = 0
            for (let ne = -2; ne <= 2; ne++) {
              const te = g[D + ne]
              Y += te[W - 2] + te[W - 1] + te[W] + te[W + 1] + te[W + 2]
            }
            const q = Y / 25
            ge.thresholdBlock(s, j, T, q, u, m)
          }
        }
      }
      static cap(s, a, l) {
        return s < a ? a : s > l ? l : s
      }
      static thresholdBlock(s, a, l, u, d, g) {
        for (let m = 0, b = l * d + a; m < ge.BLOCK_SIZE; m++, b += d)
          for (let v = 0; v < ge.BLOCK_SIZE; v++) (s[b + v] & 255) <= u && g.set(a + v, l + m)
      }
      static calculateBlackPoints(s, a, l, u, d) {
        const g = d - ge.BLOCK_SIZE,
          m = u - ge.BLOCK_SIZE,
          b = new Array(l)
        for (let v = 0; v < l; v++) {
          b[v] = new Int32Array(a)
          let C = v << ge.BLOCK_SIZE_POWER
          C > g && (C = g)
          for (let T = 0; T < a; T++) {
            let D = T << ge.BLOCK_SIZE_POWER
            D > m && (D = m)
            let B = 0,
              j = 255,
              W = 0
            for (let q = 0, ne = C * u + D; q < ge.BLOCK_SIZE; q++, ne += u) {
              for (let te = 0; te < ge.BLOCK_SIZE; te++) {
                const $ = s[ne + te] & 255
                ;((B += $), $ < j && (j = $), $ > W && (W = $))
              }
              if (W - j > ge.MIN_DYNAMIC_RANGE)
                for (q++, ne += u; q < ge.BLOCK_SIZE; q++, ne += u)
                  for (let te = 0; te < ge.BLOCK_SIZE; te++) B += s[ne + te] & 255
            }
            let Y = B >> (ge.BLOCK_SIZE_POWER * 2)
            if (W - j <= ge.MIN_DYNAMIC_RANGE && ((Y = j / 2), v > 0 && T > 0)) {
              const q = (b[v - 1][T] + 2 * b[v][T - 1] + b[v - 1][T - 1]) / 4
              j < q && (Y = q)
            }
            b[v][T] = Y
          }
        }
        return b
      }
    }
    ;((ge.BLOCK_SIZE_POWER = 3),
      (ge.BLOCK_SIZE = 1 << ge.BLOCK_SIZE_POWER),
      (ge.BLOCK_SIZE_MASK = ge.BLOCK_SIZE - 1),
      (ge.MINIMUM_DIMENSION = ge.BLOCK_SIZE * 5),
      (ge.MIN_DYNAMIC_RANGE = 24))
    class se {
      constructor(s, a) {
        ;((this.width = s), (this.height = a))
      }
      getWidth() {
        return this.width
      }
      getHeight() {
        return this.height
      }
      isCropSupported() {
        return !1
      }
      crop(s, a, l, u) {
        throw new J('This luminance source does not support cropping.')
      }
      isRotateSupported() {
        return !1
      }
      rotateCounterClockwise() {
        throw new J('This luminance source does not support rotation by 90 degrees.')
      }
      rotateCounterClockwise45() {
        throw new J('This luminance source does not support rotation by 45 degrees.')
      }
      toString() {
        const s = new Uint8ClampedArray(this.width)
        let a = new ve()
        for (let l = 0; l < this.height; l++) {
          const u = this.getRow(l, s)
          for (let d = 0; d < this.width; d++) {
            const g = u[d] & 255
            let m
            ;(g < 64 ? (m = '#') : g < 128 ? (m = '+') : g < 192 ? (m = '.') : (m = ' '),
              a.append(m))
          }
          a.append(`
`)
        }
        return a.toString()
      }
    }
    class fe extends se {
      constructor(s) {
        ;(super(s.getWidth(), s.getHeight()), (this.delegate = s))
      }
      getRow(s, a) {
        const l = this.delegate.getRow(s, a),
          u = this.getWidth()
        for (let d = 0; d < u; d++) l[d] = 255 - (l[d] & 255)
        return l
      }
      getMatrix() {
        const s = this.delegate.getMatrix(),
          a = this.getWidth() * this.getHeight(),
          l = new Uint8ClampedArray(a)
        for (let u = 0; u < a; u++) l[u] = 255 - (s[u] & 255)
        return l
      }
      isCropSupported() {
        return this.delegate.isCropSupported()
      }
      crop(s, a, l, u) {
        return new fe(this.delegate.crop(s, a, l, u))
      }
      isRotateSupported() {
        return this.delegate.isRotateSupported()
      }
      invert() {
        return this.delegate
      }
      rotateCounterClockwise() {
        return new fe(this.delegate.rotateCounterClockwise())
      }
      rotateCounterClockwise45() {
        return new fe(this.delegate.rotateCounterClockwise45())
      }
    }
    class pe extends se {
      constructor(s) {
        ;(super(s.width, s.height),
          (this.canvas = s),
          (this.tempCanvasElement = null),
          (this.buffer = pe.makeBufferFromCanvasImageData(s)))
      }
      static makeBufferFromCanvasImageData(s) {
        const a = s.getContext('2d').getImageData(0, 0, s.width, s.height)
        return pe.toGrayscaleBuffer(a.data, s.width, s.height)
      }
      static toGrayscaleBuffer(s, a, l) {
        const u = new Uint8ClampedArray(a * l)
        for (let d = 0, g = 0, m = s.length; d < m; d += 4, g++) {
          let b
          if (s[d + 3] === 0) b = 255
          else {
            const v = s[d],
              C = s[d + 1],
              T = s[d + 2]
            b = (306 * v + 601 * C + 117 * T + 512) >> 10
          }
          u[g] = b
        }
        return u
      }
      getRow(s, a) {
        if (s < 0 || s >= this.getHeight()) throw new w('Requested row is outside the image: ' + s)
        const l = this.getWidth(),
          u = s * l
        return (
          a === null
            ? (a = this.buffer.slice(u, u + l))
            : (a.length < l && (a = new Uint8ClampedArray(l)), a.set(this.buffer.slice(u, u + l))),
          a
        )
      }
      getMatrix() {
        return this.buffer
      }
      isCropSupported() {
        return !0
      }
      crop(s, a, l, u) {
        return (super.crop(s, a, l, u), this)
      }
      isRotateSupported() {
        return !0
      }
      rotateCounterClockwise() {
        return (this.rotate(-90), this)
      }
      rotateCounterClockwise45() {
        return (this.rotate(-45), this)
      }
      getTempCanvasElement() {
        if (this.tempCanvasElement === null) {
          const s = this.canvas.ownerDocument.createElement('canvas')
          ;((s.width = this.canvas.width),
            (s.height = this.canvas.height),
            (this.tempCanvasElement = s))
        }
        return this.tempCanvasElement
      }
      rotate(s) {
        const a = this.getTempCanvasElement(),
          l = a.getContext('2d'),
          u = s * pe.DEGREE_TO_RADIANS,
          d = this.canvas.width,
          g = this.canvas.height,
          m = Math.ceil(Math.abs(Math.cos(u)) * d + Math.abs(Math.sin(u)) * g),
          b = Math.ceil(Math.abs(Math.sin(u)) * d + Math.abs(Math.cos(u)) * g)
        return (
          (a.width = m),
          (a.height = b),
          l.translate(m / 2, b / 2),
          l.rotate(u),
          l.drawImage(this.canvas, d / -2, g / -2),
          (this.buffer = pe.makeBufferFromCanvasImageData(a)),
          this
        )
      }
      invert() {
        return new fe(this)
      }
    }
    pe.DEGREE_TO_RADIANS = Math.PI / 180
    class We {
      constructor(s, a, l) {
        ;((this.deviceId = s),
          (this.label = a),
          (this.kind = 'videoinput'),
          (this.groupId = l || void 0))
      }
      toJSON() {
        return {
          kind: this.kind,
          groupId: this.groupId,
          deviceId: this.deviceId,
          label: this.label,
        }
      }
    }
    var Se =
      ((globalThis || ha || self || window || void 0) &&
        (globalThis || ha || self || window || void 0).__awaiter) ||
      function (_, s, a, l) {
        function u(d) {
          return d instanceof a
            ? d
            : new a(function (g) {
                g(d)
              })
        }
        return new (a || (a = Promise))(function (d, g) {
          function m(C) {
            try {
              v(l.next(C))
            } catch (T) {
              g(T)
            }
          }
          function b(C) {
            try {
              v(l.throw(C))
            } catch (T) {
              g(T)
            }
          }
          function v(C) {
            C.done ? d(C.value) : u(C.value).then(m, b)
          }
          v((l = l.apply(_, s || [])).next())
        })
      }
    class Tt {
      constructor(s, a = 500, l) {
        ;((this.reader = s),
          (this.timeBetweenScansMillis = a),
          (this._hints = l),
          (this._stopContinuousDecode = !1),
          (this._stopAsyncDecode = !1),
          (this._timeBetweenDecodingAttempts = 0))
      }
      get hasNavigator() {
        return typeof navigator < 'u'
      }
      get isMediaDevicesSuported() {
        return this.hasNavigator && !!navigator.mediaDevices
      }
      get canEnumerateDevices() {
        return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices)
      }
      get timeBetweenDecodingAttempts() {
        return this._timeBetweenDecodingAttempts
      }
      set timeBetweenDecodingAttempts(s) {
        this._timeBetweenDecodingAttempts = s < 0 ? 0 : s
      }
      set hints(s) {
        this._hints = s || null
      }
      get hints() {
        return this._hints
      }
      listVideoInputDevices() {
        return Se(this, void 0, void 0, function* () {
          if (!this.hasNavigator)
            throw new Error("Can't enumerate devices, navigator is not present.")
          if (!this.canEnumerateDevices)
            throw new Error("Can't enumerate devices, method not supported.")
          const s = yield navigator.mediaDevices.enumerateDevices(),
            a = []
          for (const l of s) {
            const u = l.kind === 'video' ? 'videoinput' : l.kind
            if (u !== 'videoinput') continue
            const d = l.deviceId || l.id,
              g = l.label || `Video device ${a.length + 1}`,
              m = l.groupId,
              b = { deviceId: d, label: g, kind: u, groupId: m }
            a.push(b)
          }
          return a
        })
      }
      getVideoInputDevices() {
        return Se(this, void 0, void 0, function* () {
          return (yield this.listVideoInputDevices()).map((s) => new We(s.deviceId, s.label))
        })
      }
      findDeviceById(s) {
        return Se(this, void 0, void 0, function* () {
          const a = yield this.listVideoInputDevices()
          return a ? a.find((l) => l.deviceId === s) : null
        })
      }
      decodeFromInputVideoDevice(s, a) {
        return Se(this, void 0, void 0, function* () {
          return yield this.decodeOnceFromVideoDevice(s, a)
        })
      }
      decodeOnceFromVideoDevice(s, a) {
        return Se(this, void 0, void 0, function* () {
          this.reset()
          let l
          s ? (l = { deviceId: { exact: s } }) : (l = { facingMode: 'environment' })
          const u = { video: l }
          return yield this.decodeOnceFromConstraints(u, a)
        })
      }
      decodeOnceFromConstraints(s, a) {
        return Se(this, void 0, void 0, function* () {
          const l = yield navigator.mediaDevices.getUserMedia(s)
          return yield this.decodeOnceFromStream(l, a)
        })
      }
      decodeOnceFromStream(s, a) {
        return Se(this, void 0, void 0, function* () {
          this.reset()
          const l = yield this.attachStreamToVideo(s, a)
          return yield this.decodeOnce(l)
        })
      }
      decodeFromInputVideoDeviceContinuously(s, a, l) {
        return Se(this, void 0, void 0, function* () {
          return yield this.decodeFromVideoDevice(s, a, l)
        })
      }
      decodeFromVideoDevice(s, a, l) {
        return Se(this, void 0, void 0, function* () {
          let u
          s ? (u = { deviceId: { exact: s } }) : (u = { facingMode: 'environment' })
          const d = { video: u }
          return yield this.decodeFromConstraints(d, a, l)
        })
      }
      decodeFromConstraints(s, a, l) {
        return Se(this, void 0, void 0, function* () {
          const u = yield navigator.mediaDevices.getUserMedia(s)
          return yield this.decodeFromStream(u, a, l)
        })
      }
      decodeFromStream(s, a, l) {
        return Se(this, void 0, void 0, function* () {
          this.reset()
          const u = yield this.attachStreamToVideo(s, a)
          return yield this.decodeContinuously(u, l)
        })
      }
      stopAsyncDecode() {
        this._stopAsyncDecode = !0
      }
      stopContinuousDecode() {
        this._stopContinuousDecode = !0
      }
      attachStreamToVideo(s, a) {
        return Se(this, void 0, void 0, function* () {
          const l = this.prepareVideoElement(a)
          return (
            this.addVideoSource(l, s),
            (this.videoElement = l),
            (this.stream = s),
            yield this.playVideoOnLoadAsync(l),
            l
          )
        })
      }
      playVideoOnLoadAsync(s) {
        return new Promise((a, l) => this.playVideoOnLoad(s, () => a()))
      }
      playVideoOnLoad(s, a) {
        ;((this.videoEndedListener = () => this.stopStreams()),
          (this.videoCanPlayListener = () => this.tryPlayVideo(s)),
          s.addEventListener('ended', this.videoEndedListener),
          s.addEventListener('canplay', this.videoCanPlayListener),
          s.addEventListener('playing', a),
          this.tryPlayVideo(s))
      }
      isVideoPlaying(s) {
        return s.currentTime > 0 && !s.paused && !s.ended && s.readyState > 2
      }
      tryPlayVideo(s) {
        return Se(this, void 0, void 0, function* () {
          if (this.isVideoPlaying(s)) {
            console.warn('Trying to play video that is already playing.')
            return
          }
          try {
            yield s.play()
          } catch {
            console.warn('It was not possible to play the video.')
          }
        })
      }
      getMediaElement(s, a) {
        const l = document.getElementById(s)
        if (!l) throw new y(`element with id '${s}' not found`)
        if (l.nodeName.toLowerCase() !== a.toLowerCase())
          throw new y(`element with id '${s}' must be an ${a} element`)
        return l
      }
      decodeFromImage(s, a) {
        if (!s && !a) throw new y('either imageElement with a src set or an url must be provided')
        return a && !s ? this.decodeFromImageUrl(a) : this.decodeFromImageElement(s)
      }
      decodeFromVideo(s, a) {
        if (!s && !a) throw new y('Either an element with a src set or an URL must be provided')
        return a && !s ? this.decodeFromVideoUrl(a) : this.decodeFromVideoElement(s)
      }
      decodeFromVideoContinuously(s, a, l) {
        if (s === void 0 && a === void 0)
          throw new y('Either an element with a src set or an URL must be provided')
        return a && !s
          ? this.decodeFromVideoUrlContinuously(a, l)
          : this.decodeFromVideoElementContinuously(s, l)
      }
      decodeFromImageElement(s) {
        if (!s) throw new y('An image element must be provided.')
        this.reset()
        const a = this.prepareImageElement(s)
        this.imageElement = a
        let l
        return (
          this.isImageLoaded(a)
            ? (l = this.decodeOnce(a, !1, !0))
            : (l = this._decodeOnLoadImage(a)),
          l
        )
      }
      decodeFromVideoElement(s) {
        const a = this._decodeFromVideoElementSetup(s)
        return this._decodeOnLoadVideo(a)
      }
      decodeFromVideoElementContinuously(s, a) {
        const l = this._decodeFromVideoElementSetup(s)
        return this._decodeOnLoadVideoContinuously(l, a)
      }
      _decodeFromVideoElementSetup(s) {
        if (!s) throw new y('A video element must be provided.')
        this.reset()
        const a = this.prepareVideoElement(s)
        return ((this.videoElement = a), a)
      }
      decodeFromImageUrl(s) {
        if (!s) throw new y('An URL must be provided.')
        this.reset()
        const a = this.prepareImageElement()
        this.imageElement = a
        const l = this._decodeOnLoadImage(a)
        return ((a.src = s), l)
      }
      decodeFromVideoUrl(s) {
        if (!s) throw new y('An URL must be provided.')
        this.reset()
        const a = this.prepareVideoElement(),
          l = this.decodeFromVideoElement(a)
        return ((a.src = s), l)
      }
      decodeFromVideoUrlContinuously(s, a) {
        if (!s) throw new y('An URL must be provided.')
        this.reset()
        const l = this.prepareVideoElement(),
          u = this.decodeFromVideoElementContinuously(l, a)
        return ((l.src = s), u)
      }
      _decodeOnLoadImage(s) {
        return new Promise((a, l) => {
          ;((this.imageLoadedListener = () => this.decodeOnce(s, !1, !0).then(a, l)),
            s.addEventListener('load', this.imageLoadedListener))
        })
      }
      _decodeOnLoadVideo(s) {
        return Se(this, void 0, void 0, function* () {
          return (yield this.playVideoOnLoadAsync(s), yield this.decodeOnce(s))
        })
      }
      _decodeOnLoadVideoContinuously(s, a) {
        return Se(this, void 0, void 0, function* () {
          ;(yield this.playVideoOnLoadAsync(s), this.decodeContinuously(s, a))
        })
      }
      isImageLoaded(s) {
        return !(!s.complete || s.naturalWidth === 0)
      }
      prepareImageElement(s) {
        let a
        return (
          typeof s > 'u' &&
            ((a = document.createElement('img')), (a.width = 200), (a.height = 200)),
          typeof s == 'string' && (a = this.getMediaElement(s, 'img')),
          s instanceof HTMLImageElement && (a = s),
          a
        )
      }
      prepareVideoElement(s) {
        let a
        return (
          !s &&
            typeof document < 'u' &&
            ((a = document.createElement('video')), (a.width = 200), (a.height = 200)),
          typeof s == 'string' && (a = this.getMediaElement(s, 'video')),
          s instanceof HTMLVideoElement && (a = s),
          a.setAttribute('autoplay', 'true'),
          a.setAttribute('muted', 'true'),
          a.setAttribute('playsinline', 'true'),
          a
        )
      }
      decodeOnce(s, a = !0, l = !0) {
        this._stopAsyncDecode = !1
        const u = (d, g) => {
          if (this._stopAsyncDecode) {
            ;(g(new H('Video stream has ended before any code could be detected.')),
              (this._stopAsyncDecode = void 0))
            return
          }
          try {
            const m = this.decode(s)
            d(m)
          } catch (m) {
            const b = a && m instanceof H,
              v = (m instanceof E || m instanceof V) && l
            if (b || v) return setTimeout(u, this._timeBetweenDecodingAttempts, d, g)
            g(m)
          }
        }
        return new Promise((d, g) => u(d, g))
      }
      decodeContinuously(s, a) {
        this._stopContinuousDecode = !1
        const l = () => {
          if (this._stopContinuousDecode) {
            this._stopContinuousDecode = void 0
            return
          }
          try {
            const u = this.decode(s)
            ;(a(u, null), setTimeout(l, this.timeBetweenScansMillis))
          } catch (u) {
            a(null, u)
            const d = u instanceof E || u instanceof V,
              g = u instanceof H
            ;(d || g) && setTimeout(l, this._timeBetweenDecodingAttempts)
          }
        }
        l()
      }
      decode(s) {
        const a = this.createBinaryBitmap(s)
        return this.decodeBitmap(a)
      }
      _isHTMLVideoElement(s) {
        return s.videoWidth !== 0
      }
      drawFrameOnCanvas(s, a, l) {
        ;(a ||
          (a = {
            sx: 0,
            sy: 0,
            sWidth: s.videoWidth,
            sHeight: s.videoHeight,
            dx: 0,
            dy: 0,
            dWidth: s.videoWidth,
            dHeight: s.videoHeight,
          }),
          l || (l = this.captureCanvasContext),
          l.drawImage(s, a.sx, a.sy, a.sWidth, a.sHeight, a.dx, a.dy, a.dWidth, a.dHeight))
      }
      drawImageOnCanvas(s, a, l = this.captureCanvasContext) {
        ;(a ||
          (a = {
            sx: 0,
            sy: 0,
            sWidth: s.naturalWidth,
            sHeight: s.naturalHeight,
            dx: 0,
            dy: 0,
            dWidth: s.naturalWidth,
            dHeight: s.naturalHeight,
          }),
          l || (l = this.captureCanvasContext),
          l.drawImage(s, a.sx, a.sy, a.sWidth, a.sHeight, a.dx, a.dy, a.dWidth, a.dHeight))
      }
      createBinaryBitmap(s) {
        ;(this.getCaptureCanvasContext(s),
          this._isHTMLVideoElement(s) ? this.drawFrameOnCanvas(s) : this.drawImageOnCanvas(s))
        const a = this.getCaptureCanvas(s),
          l = new pe(a),
          u = new ge(l)
        return new x(u)
      }
      getCaptureCanvasContext(s) {
        if (!this.captureCanvasContext) {
          const a = this.getCaptureCanvas(s).getContext('2d')
          this.captureCanvasContext = a
        }
        return this.captureCanvasContext
      }
      getCaptureCanvas(s) {
        if (!this.captureCanvas) {
          const a = this.createCaptureCanvas(s)
          this.captureCanvas = a
        }
        return this.captureCanvas
      }
      decodeBitmap(s) {
        return this.reader.decode(s, this._hints)
      }
      createCaptureCanvas(s) {
        if (typeof document > 'u') return (this._destroyCaptureCanvas(), null)
        const a = document.createElement('canvas')
        let l, u
        return (
          typeof s < 'u' &&
            (s instanceof HTMLVideoElement
              ? ((l = s.videoWidth), (u = s.videoHeight))
              : s instanceof HTMLImageElement &&
                ((l = s.naturalWidth || s.width), (u = s.naturalHeight || s.height))),
          (a.style.width = l + 'px'),
          (a.style.height = u + 'px'),
          (a.width = l),
          (a.height = u),
          a
        )
      }
      stopStreams() {
        ;(this.stream &&
          (this.stream.getVideoTracks().forEach((s) => s.stop()), (this.stream = void 0)),
          this._stopAsyncDecode === !1 && this.stopAsyncDecode(),
          this._stopContinuousDecode === !1 && this.stopContinuousDecode())
      }
      reset() {
        ;(this.stopStreams(),
          this._destroyVideoElement(),
          this._destroyImageElement(),
          this._destroyCaptureCanvas())
      }
      _destroyVideoElement() {
        this.videoElement &&
          (typeof this.videoEndedListener < 'u' &&
            this.videoElement.removeEventListener('ended', this.videoEndedListener),
          typeof this.videoPlayingEventListener < 'u' &&
            this.videoElement.removeEventListener('playing', this.videoPlayingEventListener),
          typeof this.videoCanPlayListener < 'u' &&
            this.videoElement.removeEventListener('loadedmetadata', this.videoCanPlayListener),
          this.cleanVideoSource(this.videoElement),
          (this.videoElement = void 0))
      }
      _destroyImageElement() {
        this.imageElement &&
          (this.imageLoadedListener !== void 0 &&
            this.imageElement.removeEventListener('load', this.imageLoadedListener),
          (this.imageElement.src = void 0),
          this.imageElement.removeAttribute('src'),
          (this.imageElement = void 0))
      }
      _destroyCaptureCanvas() {
        ;((this.captureCanvasContext = void 0), (this.captureCanvas = void 0))
      }
      addVideoSource(s, a) {
        try {
          s.srcObject = a
        } catch {
          s.src = URL.createObjectURL(a)
        }
      }
      cleanVideoSource(s) {
        try {
          s.srcObject = null
        } catch {
          s.src = ''
        }
        this.videoElement.removeAttribute('src')
      }
    }
    class Be {
      constructor(s, a, l = a == null ? 0 : 8 * a.length, u, d, g = k.currentTimeMillis()) {
        ;((this.text = s),
          (this.rawBytes = a),
          (this.numBits = l),
          (this.resultPoints = u),
          (this.format = d),
          (this.timestamp = g),
          (this.text = s),
          (this.rawBytes = a),
          l == null ? (this.numBits = a == null ? 0 : 8 * a.length) : (this.numBits = l),
          (this.resultPoints = u),
          (this.format = d),
          (this.resultMetadata = null),
          g == null ? (this.timestamp = k.currentTimeMillis()) : (this.timestamp = g))
      }
      getText() {
        return this.text
      }
      getRawBytes() {
        return this.rawBytes
      }
      getNumBits() {
        return this.numBits
      }
      getResultPoints() {
        return this.resultPoints
      }
      getBarcodeFormat() {
        return this.format
      }
      getResultMetadata() {
        return this.resultMetadata
      }
      putMetadata(s, a) {
        ;(this.resultMetadata === null && (this.resultMetadata = new Map()),
          this.resultMetadata.set(s, a))
      }
      putAllMetadata(s) {
        s !== null &&
          (this.resultMetadata === null
            ? (this.resultMetadata = s)
            : (this.resultMetadata = new Map(s)))
      }
      addResultPoints(s) {
        const a = this.resultPoints
        if (a === null) this.resultPoints = s
        else if (s !== null && s.length > 0) {
          const l = new Array(a.length + s.length)
          ;(k.arraycopy(a, 0, l, 0, a.length),
            k.arraycopy(s, 0, l, a.length, s.length),
            (this.resultPoints = l))
        }
      }
      getTimestamp() {
        return this.timestamp
      }
      toString() {
        return this.text
      }
    }
    var Sn
    ;(function (_) {
      ;((_[(_.AZTEC = 0)] = 'AZTEC'),
        (_[(_.CODABAR = 1)] = 'CODABAR'),
        (_[(_.CODE_39 = 2)] = 'CODE_39'),
        (_[(_.CODE_93 = 3)] = 'CODE_93'),
        (_[(_.CODE_128 = 4)] = 'CODE_128'),
        (_[(_.DATA_MATRIX = 5)] = 'DATA_MATRIX'),
        (_[(_.EAN_8 = 6)] = 'EAN_8'),
        (_[(_.EAN_13 = 7)] = 'EAN_13'),
        (_[(_.ITF = 8)] = 'ITF'),
        (_[(_.MAXICODE = 9)] = 'MAXICODE'),
        (_[(_.PDF_417 = 10)] = 'PDF_417'),
        (_[(_.QR_CODE = 11)] = 'QR_CODE'),
        (_[(_.RSS_14 = 12)] = 'RSS_14'),
        (_[(_.RSS_EXPANDED = 13)] = 'RSS_EXPANDED'),
        (_[(_.UPC_A = 14)] = 'UPC_A'),
        (_[(_.UPC_E = 15)] = 'UPC_E'),
        (_[(_.UPC_EAN_EXTENSION = 16)] = 'UPC_EAN_EXTENSION'))
    })(Sn || (Sn = {}))
    var ue = Sn,
      $r
    ;(function (_) {
      ;((_[(_.OTHER = 0)] = 'OTHER'),
        (_[(_.ORIENTATION = 1)] = 'ORIENTATION'),
        (_[(_.BYTE_SEGMENTS = 2)] = 'BYTE_SEGMENTS'),
        (_[(_.ERROR_CORRECTION_LEVEL = 3)] = 'ERROR_CORRECTION_LEVEL'),
        (_[(_.ISSUE_NUMBER = 4)] = 'ISSUE_NUMBER'),
        (_[(_.SUGGESTED_PRICE = 5)] = 'SUGGESTED_PRICE'),
        (_[(_.POSSIBLE_COUNTRY = 6)] = 'POSSIBLE_COUNTRY'),
        (_[(_.UPC_EAN_EXTENSION = 7)] = 'UPC_EAN_EXTENSION'),
        (_[(_.PDF417_EXTRA_METADATA = 8)] = 'PDF417_EXTRA_METADATA'),
        (_[(_.STRUCTURED_APPEND_SEQUENCE = 9)] = 'STRUCTURED_APPEND_SEQUENCE'),
        (_[(_.STRUCTURED_APPEND_PARITY = 10)] = 'STRUCTURED_APPEND_PARITY'))
    })($r || ($r = {}))
    var Rt = $r
    class Jo {
      constructor(s, a, l, u, d = -1, g = -1) {
        ;((this.rawBytes = s),
          (this.text = a),
          (this.byteSegments = l),
          (this.ecLevel = u),
          (this.structuredAppendSequenceNumber = d),
          (this.structuredAppendParity = g),
          (this.numBits = s == null ? 0 : 8 * s.length))
      }
      getRawBytes() {
        return this.rawBytes
      }
      getNumBits() {
        return this.numBits
      }
      setNumBits(s) {
        this.numBits = s
      }
      getText() {
        return this.text
      }
      getByteSegments() {
        return this.byteSegments
      }
      getECLevel() {
        return this.ecLevel
      }
      getErrorsCorrected() {
        return this.errorsCorrected
      }
      setErrorsCorrected(s) {
        this.errorsCorrected = s
      }
      getErasures() {
        return this.erasures
      }
      setErasures(s) {
        this.erasures = s
      }
      getOther() {
        return this.other
      }
      setOther(s) {
        this.other = s
      }
      hasStructuredAppend() {
        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0
      }
      getStructuredAppendParity() {
        return this.structuredAppendParity
      }
      getStructuredAppendSequenceNumber() {
        return this.structuredAppendSequenceNumber
      }
    }
    class ea {
      exp(s) {
        return this.expTable[s]
      }
      log(s) {
        if (s === 0) throw new w()
        return this.logTable[s]
      }
      static addOrSubtract(s, a) {
        return s ^ a
      }
    }
    class un {
      constructor(s, a) {
        if (a.length === 0) throw new w()
        this.field = s
        const l = a.length
        if (l > 1 && a[0] === 0) {
          let u = 1
          for (; u < l && a[u] === 0; ) u++
          u === l
            ? (this.coefficients = Int32Array.from([0]))
            : ((this.coefficients = new Int32Array(l - u)),
              k.arraycopy(a, u, this.coefficients, 0, this.coefficients.length))
        } else this.coefficients = a
      }
      getCoefficients() {
        return this.coefficients
      }
      getDegree() {
        return this.coefficients.length - 1
      }
      isZero() {
        return this.coefficients[0] === 0
      }
      getCoefficient(s) {
        return this.coefficients[this.coefficients.length - 1 - s]
      }
      evaluateAt(s) {
        if (s === 0) return this.getCoefficient(0)
        const a = this.coefficients
        let l
        if (s === 1) {
          l = 0
          for (let g = 0, m = a.length; g !== m; g++) {
            const b = a[g]
            l = ea.addOrSubtract(l, b)
          }
          return l
        }
        l = a[0]
        const u = a.length,
          d = this.field
        for (let g = 1; g < u; g++) l = ea.addOrSubtract(d.multiply(s, l), a[g])
        return l
      }
      addOrSubtract(s) {
        if (!this.field.equals(s.field))
          throw new w('GenericGFPolys do not have same GenericGF field')
        if (this.isZero()) return s
        if (s.isZero()) return this
        let a = this.coefficients,
          l = s.coefficients
        if (a.length > l.length) {
          const g = a
          ;((a = l), (l = g))
        }
        let u = new Int32Array(l.length)
        const d = l.length - a.length
        k.arraycopy(l, 0, u, 0, d)
        for (let g = d; g < l.length; g++) u[g] = ea.addOrSubtract(a[g - d], l[g])
        return new un(this.field, u)
      }
      multiply(s) {
        if (!this.field.equals(s.field))
          throw new w('GenericGFPolys do not have same GenericGF field')
        if (this.isZero() || s.isZero()) return this.field.getZero()
        const a = this.coefficients,
          l = a.length,
          u = s.coefficients,
          d = u.length,
          g = new Int32Array(l + d - 1),
          m = this.field
        for (let b = 0; b < l; b++) {
          const v = a[b]
          for (let C = 0; C < d; C++) g[b + C] = ea.addOrSubtract(g[b + C], m.multiply(v, u[C]))
        }
        return new un(m, g)
      }
      multiplyScalar(s) {
        if (s === 0) return this.field.getZero()
        if (s === 1) return this
        const a = this.coefficients.length,
          l = this.field,
          u = new Int32Array(a),
          d = this.coefficients
        for (let g = 0; g < a; g++) u[g] = l.multiply(d[g], s)
        return new un(l, u)
      }
      multiplyByMonomial(s, a) {
        if (s < 0) throw new w()
        if (a === 0) return this.field.getZero()
        const l = this.coefficients,
          u = l.length,
          d = new Int32Array(u + s),
          g = this.field
        for (let m = 0; m < u; m++) d[m] = g.multiply(l[m], a)
        return new un(g, d)
      }
      divide(s) {
        if (!this.field.equals(s.field))
          throw new w('GenericGFPolys do not have same GenericGF field')
        if (s.isZero()) throw new w('Divide by 0')
        const a = this.field
        let l = a.getZero(),
          u = this
        const d = s.getCoefficient(s.getDegree()),
          g = a.inverse(d)
        for (; u.getDegree() >= s.getDegree() && !u.isZero(); ) {
          const m = u.getDegree() - s.getDegree(),
            b = a.multiply(u.getCoefficient(u.getDegree()), g),
            v = s.multiplyByMonomial(m, b),
            C = a.buildMonomial(m, b)
          ;((l = l.addOrSubtract(C)), (u = u.addOrSubtract(v)))
        }
        return [l, u]
      }
      toString() {
        let s = ''
        for (let a = this.getDegree(); a >= 0; a--) {
          let l = this.getCoefficient(a)
          if (l !== 0) {
            if (
              (l < 0 ? ((s += ' - '), (l = -l)) : s.length > 0 && (s += ' + '), a === 0 || l !== 1)
            ) {
              const u = this.field.log(l)
              u === 0 ? (s += '1') : u === 1 ? (s += 'a') : ((s += 'a^'), (s += u))
            }
            a !== 0 && (a === 1 ? (s += 'x') : ((s += 'x^'), (s += a)))
          }
        }
        return s
      }
    }
    class zl extends p {}
    zl.kind = 'ArithmeticException'
    class Fe extends ea {
      constructor(s, a, l) {
        ;(super(), (this.primitive = s), (this.size = a), (this.generatorBase = l))
        const u = new Int32Array(a)
        let d = 1
        for (let m = 0; m < a; m++) ((u[m] = d), (d *= 2), d >= a && ((d ^= s), (d &= a - 1)))
        this.expTable = u
        const g = new Int32Array(a)
        for (let m = 0; m < a - 1; m++) g[u[m]] = m
        ;((this.logTable = g),
          (this.zero = new un(this, Int32Array.from([0]))),
          (this.one = new un(this, Int32Array.from([1]))))
      }
      getZero() {
        return this.zero
      }
      getOne() {
        return this.one
      }
      buildMonomial(s, a) {
        if (s < 0) throw new w()
        if (a === 0) return this.zero
        const l = new Int32Array(s + 1)
        return ((l[0] = a), new un(this, l))
      }
      inverse(s) {
        if (s === 0) throw new zl()
        return this.expTable[this.size - this.logTable[s] - 1]
      }
      multiply(s, a) {
        return s === 0 || a === 0
          ? 0
          : this.expTable[(this.logTable[s] + this.logTable[a]) % (this.size - 1)]
      }
      getSize() {
        return this.size
      }
      getGeneratorBase() {
        return this.generatorBase
      }
      toString() {
        return 'GF(0x' + M.toHexString(this.primitive) + ',' + this.size + ')'
      }
      equals(s) {
        return s === this
      }
    }
    ;((Fe.AZTEC_DATA_12 = new Fe(4201, 4096, 1)),
      (Fe.AZTEC_DATA_10 = new Fe(1033, 1024, 1)),
      (Fe.AZTEC_DATA_6 = new Fe(67, 64, 1)),
      (Fe.AZTEC_PARAM = new Fe(19, 16, 1)),
      (Fe.QR_CODE_FIELD_256 = new Fe(285, 256, 0)),
      (Fe.DATA_MATRIX_FIELD_256 = new Fe(301, 256, 1)),
      (Fe.AZTEC_DATA_8 = Fe.DATA_MATRIX_FIELD_256),
      (Fe.MAXICODE_FIELD_64 = Fe.AZTEC_DATA_6))
    class Hs extends p {}
    Hs.kind = 'ReedSolomonException'
    class dr extends p {}
    dr.kind = 'IllegalStateException'
    class ta {
      constructor(s) {
        this.field = s
      }
      decode(s, a) {
        const l = this.field,
          u = new un(l, s),
          d = new Int32Array(a)
        let g = !0
        for (let B = 0; B < a; B++) {
          const j = u.evaluateAt(l.exp(B + l.getGeneratorBase()))
          ;((d[d.length - 1 - B] = j), j !== 0 && (g = !1))
        }
        if (g) return
        const m = new un(l, d),
          b = this.runEuclideanAlgorithm(l.buildMonomial(a, 1), m, a),
          v = b[0],
          C = b[1],
          T = this.findErrorLocations(v),
          D = this.findErrorMagnitudes(C, T)
        for (let B = 0; B < T.length; B++) {
          const j = s.length - 1 - l.log(T[B])
          if (j < 0) throw new Hs('Bad error location')
          s[j] = Fe.addOrSubtract(s[j], D[B])
        }
      }
      runEuclideanAlgorithm(s, a, l) {
        if (s.getDegree() < a.getDegree()) {
          const B = s
          ;((s = a), (a = B))
        }
        const u = this.field
        let d = s,
          g = a,
          m = u.getZero(),
          b = u.getOne()
        for (; g.getDegree() >= ((l / 2) | 0); ) {
          let B = d,
            j = m
          if (((d = g), (m = b), d.isZero())) throw new Hs('r_{i-1} was zero')
          g = B
          let W = u.getZero()
          const Y = d.getCoefficient(d.getDegree()),
            q = u.inverse(Y)
          for (; g.getDegree() >= d.getDegree() && !g.isZero(); ) {
            const ne = g.getDegree() - d.getDegree(),
              te = u.multiply(g.getCoefficient(g.getDegree()), q)
            ;((W = W.addOrSubtract(u.buildMonomial(ne, te))),
              (g = g.addOrSubtract(d.multiplyByMonomial(ne, te))))
          }
          if (((b = W.multiply(m).addOrSubtract(j)), g.getDegree() >= d.getDegree()))
            throw new dr('Division algorithm failed to reduce polynomial?')
        }
        const v = b.getCoefficient(0)
        if (v === 0) throw new Hs('sigmaTilde(0) was zero')
        const C = u.inverse(v),
          T = b.multiplyScalar(C),
          D = g.multiplyScalar(C)
        return [T, D]
      }
      findErrorLocations(s) {
        const a = s.getDegree()
        if (a === 1) return Int32Array.from([s.getCoefficient(1)])
        const l = new Int32Array(a)
        let u = 0
        const d = this.field
        for (let g = 1; g < d.getSize() && u < a; g++)
          s.evaluateAt(g) === 0 && ((l[u] = d.inverse(g)), u++)
        if (u !== a) throw new Hs('Error locator degree does not match number of roots')
        return l
      }
      findErrorMagnitudes(s, a) {
        const l = a.length,
          u = new Int32Array(l),
          d = this.field
        for (let g = 0; g < l; g++) {
          const m = d.inverse(a[g])
          let b = 1
          for (let v = 0; v < l; v++)
            if (g !== v) {
              const C = d.multiply(a[v], m),
                T = C & 1 ? C & -2 : C | 1
              b = d.multiply(b, T)
            }
          ;((u[g] = d.multiply(s.evaluateAt(m), d.inverse(b))),
            d.getGeneratorBase() !== 0 && (u[g] = d.multiply(u[g], m)))
        }
        return u
      }
    }
    var Ft
    ;(function (_) {
      ;((_[(_.UPPER = 0)] = 'UPPER'),
        (_[(_.LOWER = 1)] = 'LOWER'),
        (_[(_.MIXED = 2)] = 'MIXED'),
        (_[(_.DIGIT = 3)] = 'DIGIT'),
        (_[(_.PUNCT = 4)] = 'PUNCT'),
        (_[(_.BINARY = 5)] = 'BINARY'))
    })(Ft || (Ft = {}))
    class Ke {
      decode(s) {
        this.ddata = s
        let a = s.getBits(),
          l = this.extractBits(a),
          u = this.correctBits(l),
          d = Ke.convertBoolArrayToByteArray(u),
          g = Ke.getEncodedData(u),
          m = new Jo(d, g, null, null)
        return (m.setNumBits(u.length), m)
      }
      static highLevelDecode(s) {
        return this.getEncodedData(s)
      }
      static getEncodedData(s) {
        let a = s.length,
          l = Ft.UPPER,
          u = Ft.UPPER,
          d = '',
          g = 0
        for (; g < a; )
          if (u === Ft.BINARY) {
            if (a - g < 5) break
            let m = Ke.readCode(s, g, 5)
            if (((g += 5), m === 0)) {
              if (a - g < 11) break
              ;((m = Ke.readCode(s, g, 11) + 31), (g += 11))
            }
            for (let b = 0; b < m; b++) {
              if (a - g < 8) {
                g = a
                break
              }
              const v = Ke.readCode(s, g, 8)
              ;((d += re.castAsNonUtf8Char(v)), (g += 8))
            }
            u = l
          } else {
            let m = u === Ft.DIGIT ? 4 : 5
            if (a - g < m) break
            let b = Ke.readCode(s, g, m)
            g += m
            let v = Ke.getCharacter(u, b)
            v.startsWith('CTRL_')
              ? ((l = u), (u = Ke.getTable(v.charAt(5))), v.charAt(6) === 'L' && (l = u))
              : ((d += v), (u = l))
          }
        return d
      }
      static getTable(s) {
        switch (s) {
          case 'L':
            return Ft.LOWER
          case 'P':
            return Ft.PUNCT
          case 'M':
            return Ft.MIXED
          case 'D':
            return Ft.DIGIT
          case 'B':
            return Ft.BINARY
          case 'U':
          default:
            return Ft.UPPER
        }
      }
      static getCharacter(s, a) {
        switch (s) {
          case Ft.UPPER:
            return Ke.UPPER_TABLE[a]
          case Ft.LOWER:
            return Ke.LOWER_TABLE[a]
          case Ft.MIXED:
            return Ke.MIXED_TABLE[a]
          case Ft.PUNCT:
            return Ke.PUNCT_TABLE[a]
          case Ft.DIGIT:
            return Ke.DIGIT_TABLE[a]
          default:
            throw new dr('Bad table')
        }
      }
      correctBits(s) {
        let a, l
        this.ddata.getNbLayers() <= 2
          ? ((l = 6), (a = Fe.AZTEC_DATA_6))
          : this.ddata.getNbLayers() <= 8
            ? ((l = 8), (a = Fe.AZTEC_DATA_8))
            : this.ddata.getNbLayers() <= 22
              ? ((l = 10), (a = Fe.AZTEC_DATA_10))
              : ((l = 12), (a = Fe.AZTEC_DATA_12))
        let u = this.ddata.getNbDatablocks(),
          d = s.length / l
        if (d < u) throw new V()
        let g = s.length % l,
          m = new Int32Array(d)
        for (let D = 0; D < d; D++, g += l) m[D] = Ke.readCode(s, g, l)
        try {
          new ta(a).decode(m, d - u)
        } catch (D) {
          throw new V(D)
        }
        let b = (1 << l) - 1,
          v = 0
        for (let D = 0; D < u; D++) {
          let B = m[D]
          if (B === 0 || B === b) throw new V()
          ;(B === 1 || B === b - 1) && v++
        }
        let C = new Array(u * l - v),
          T = 0
        for (let D = 0; D < u; D++) {
          let B = m[D]
          if (B === 1 || B === b - 1) (C.fill(B > 1, T, T + l - 1), (T += l - 1))
          else for (let j = l - 1; j >= 0; --j) C[T++] = (B & (1 << j)) !== 0
        }
        return C
      }
      extractBits(s) {
        let a = this.ddata.isCompact(),
          l = this.ddata.getNbLayers(),
          u = (a ? 11 : 14) + l * 4,
          d = new Int32Array(u),
          g = new Array(this.totalBitsInLayer(l, a))
        if (a) for (let m = 0; m < d.length; m++) d[m] = m
        else {
          let m = u + 1 + 2 * M.truncDivision(M.truncDivision(u, 2) - 1, 15),
            b = u / 2,
            v = M.truncDivision(m, 2)
          for (let C = 0; C < b; C++) {
            let T = C + M.truncDivision(C, 15)
            ;((d[b - C - 1] = v - T - 1), (d[b + C] = v + T + 1))
          }
        }
        for (let m = 0, b = 0; m < l; m++) {
          let v = (l - m) * 4 + (a ? 9 : 12),
            C = m * 2,
            T = u - 1 - C
          for (let D = 0; D < v; D++) {
            let B = D * 2
            for (let j = 0; j < 2; j++)
              ((g[b + B + j] = s.get(d[C + j], d[C + D])),
                (g[b + 2 * v + B + j] = s.get(d[C + D], d[T - j])),
                (g[b + 4 * v + B + j] = s.get(d[T - j], d[T - D])),
                (g[b + 6 * v + B + j] = s.get(d[T - D], d[C + j])))
          }
          b += v * 8
        }
        return g
      }
      static readCode(s, a, l) {
        let u = 0
        for (let d = a; d < a + l; d++) ((u <<= 1), s[d] && (u |= 1))
        return u
      }
      static readByte(s, a) {
        let l = s.length - a
        return l >= 8 ? Ke.readCode(s, a, 8) : Ke.readCode(s, a, l) << (8 - l)
      }
      static convertBoolArrayToByteArray(s) {
        let a = new Uint8Array((s.length + 7) / 8)
        for (let l = 0; l < a.length; l++) a[l] = Ke.readByte(s, 8 * l)
        return a
      }
      totalBitsInLayer(s, a) {
        return ((a ? 88 : 112) + 16 * s) * s
      }
    }
    ;((Ke.UPPER_TABLE = [
      'CTRL_PS',
      ' ',
      'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
      'CTRL_LL',
      'CTRL_ML',
      'CTRL_DL',
      'CTRL_BS',
    ]),
      (Ke.LOWER_TABLE = [
        'CTRL_PS',
        ' ',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'CTRL_US',
        'CTRL_ML',
        'CTRL_DL',
        'CTRL_BS',
      ]),
      (Ke.MIXED_TABLE = [
        'CTRL_PS',
        ' ',
        '\\1',
        '\\2',
        '\\3',
        '\\4',
        '\\5',
        '\\6',
        '\\7',
        '\b',
        '	',
        `
`,
        '\\13',
        '\f',
        '\r',
        '\\33',
        '\\34',
        '\\35',
        '\\36',
        '\\37',
        '@',
        '\\',
        '^',
        '_',
        '`',
        '|',
        '~',
        '\\177',
        'CTRL_LL',
        'CTRL_UL',
        'CTRL_PL',
        'CTRL_BS',
      ]),
      (Ke.PUNCT_TABLE = [
        '',
        '\r',
        `\r
`,
        '. ',
        ', ',
        ': ',
        '!',
        '"',
        '#',
        '$',
        '%',
        '&',
        "'",
        '(',
        ')',
        '*',
        '+',
        ',',
        '-',
        '.',
        '/',
        ':',
        ';',
        '<',
        '=',
        '>',
        '?',
        '[',
        ']',
        '{',
        '}',
        'CTRL_UL',
      ]),
      (Ke.DIGIT_TABLE = [
        'CTRL_PS',
        ' ',
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9',
        ',',
        '.',
        'CTRL_UL',
        'CTRL_US',
      ]))
    class Pe {
      constructor() {}
      static round(s) {
        return s === NaN
          ? 0
          : s <= Number.MIN_SAFE_INTEGER
            ? Number.MIN_SAFE_INTEGER
            : s >= Number.MAX_SAFE_INTEGER
              ? Number.MAX_SAFE_INTEGER
              : (s + (s < 0 ? -0.5 : 0.5)) | 0
      }
      static distance(s, a, l, u) {
        const d = s - l,
          g = a - u
        return Math.sqrt(d * d + g * g)
      }
      static sum(s) {
        let a = 0
        for (let l = 0, u = s.length; l !== u; l++) {
          const d = s[l]
          a += d
        }
        return a
      }
    }
    class Hl {
      static floatToIntBits(s) {
        return s
      }
    }
    Hl.MAX_VALUE = Number.MAX_SAFE_INTEGER
    class he {
      constructor(s, a) {
        ;((this.x = s), (this.y = a))
      }
      getX() {
        return this.x
      }
      getY() {
        return this.y
      }
      equals(s) {
        if (s instanceof he) {
          const a = s
          return this.x === a.x && this.y === a.y
        }
        return !1
      }
      hashCode() {
        return 31 * Hl.floatToIntBits(this.x) + Hl.floatToIntBits(this.y)
      }
      toString() {
        return '(' + this.x + ',' + this.y + ')'
      }
      static orderBestPatterns(s) {
        const a = this.distance(s[0], s[1]),
          l = this.distance(s[1], s[2]),
          u = this.distance(s[0], s[2])
        let d, g, m
        if (
          (l >= a && l >= u
            ? ((g = s[0]), (d = s[1]), (m = s[2]))
            : u >= l && u >= a
              ? ((g = s[1]), (d = s[0]), (m = s[2]))
              : ((g = s[2]), (d = s[0]), (m = s[1])),
          this.crossProductZ(d, g, m) < 0)
        ) {
          const b = d
          ;((d = m), (m = b))
        }
        ;((s[0] = d), (s[1] = g), (s[2] = m))
      }
      static distance(s, a) {
        return Pe.distance(s.x, s.y, a.x, a.y)
      }
      static crossProductZ(s, a, l) {
        const u = a.x,
          d = a.y
        return (l.x - u) * (s.y - d) - (l.y - d) * (s.x - u)
      }
    }
    class Xl {
      constructor(s, a) {
        ;((this.bits = s), (this.points = a))
      }
      getBits() {
        return this.bits
      }
      getPoints() {
        return this.points
      }
    }
    class wp extends Xl {
      constructor(s, a, l, u, d) {
        ;(super(s, a), (this.compact = l), (this.nbDatablocks = u), (this.nbLayers = d))
      }
      getNbLayers() {
        return this.nbLayers
      }
      getNbDatablocks() {
        return this.nbDatablocks
      }
      isCompact() {
        return this.compact
      }
    }
    class Tr {
      constructor(s, a, l, u) {
        ;((this.image = s),
          (this.height = s.getHeight()),
          (this.width = s.getWidth()),
          a == null && (a = Tr.INIT_SIZE),
          l == null && (l = (s.getWidth() / 2) | 0),
          u == null && (u = (s.getHeight() / 2) | 0))
        const d = (a / 2) | 0
        if (
          ((this.leftInit = l - d),
          (this.rightInit = l + d),
          (this.upInit = u - d),
          (this.downInit = u + d),
          this.upInit < 0 ||
            this.leftInit < 0 ||
            this.downInit >= this.height ||
            this.rightInit >= this.width)
        )
          throw new H()
      }
      detect() {
        let s = this.leftInit,
          a = this.rightInit,
          l = this.upInit,
          u = this.downInit,
          d = !1,
          g = !0,
          m = !1,
          b = !1,
          v = !1,
          C = !1,
          T = !1
        const D = this.width,
          B = this.height
        for (; g; ) {
          g = !1
          let j = !0
          for (; (j || !b) && a < D; )
            ((j = this.containsBlackPoint(l, u, a, !1)), j ? (a++, (g = !0), (b = !0)) : b || a++)
          if (a >= D) {
            d = !0
            break
          }
          let W = !0
          for (; (W || !v) && u < B; )
            ((W = this.containsBlackPoint(s, a, u, !0)), W ? (u++, (g = !0), (v = !0)) : v || u++)
          if (u >= B) {
            d = !0
            break
          }
          let Y = !0
          for (; (Y || !C) && s >= 0; )
            ((Y = this.containsBlackPoint(l, u, s, !1)), Y ? (s--, (g = !0), (C = !0)) : C || s--)
          if (s < 0) {
            d = !0
            break
          }
          let q = !0
          for (; (q || !T) && l >= 0; )
            ((q = this.containsBlackPoint(s, a, l, !0)), q ? (l--, (g = !0), (T = !0)) : T || l--)
          if (l < 0) {
            d = !0
            break
          }
          g && (m = !0)
        }
        if (!d && m) {
          const j = a - s
          let W = null
          for (let te = 1; W === null && te < j; te++)
            W = this.getBlackPointOnSegment(s, u - te, s + te, u)
          if (W == null) throw new H()
          let Y = null
          for (let te = 1; Y === null && te < j; te++)
            Y = this.getBlackPointOnSegment(s, l + te, s + te, l)
          if (Y == null) throw new H()
          let q = null
          for (let te = 1; q === null && te < j; te++)
            q = this.getBlackPointOnSegment(a, l + te, a - te, l)
          if (q == null) throw new H()
          let ne = null
          for (let te = 1; ne === null && te < j; te++)
            ne = this.getBlackPointOnSegment(a, u - te, a - te, u)
          if (ne == null) throw new H()
          return this.centerEdges(ne, W, q, Y)
        } else throw new H()
      }
      getBlackPointOnSegment(s, a, l, u) {
        const d = Pe.round(Pe.distance(s, a, l, u)),
          g = (l - s) / d,
          m = (u - a) / d,
          b = this.image
        for (let v = 0; v < d; v++) {
          const C = Pe.round(s + v * g),
            T = Pe.round(a + v * m)
          if (b.get(C, T)) return new he(C, T)
        }
        return null
      }
      centerEdges(s, a, l, u) {
        const d = s.getX(),
          g = s.getY(),
          m = a.getX(),
          b = a.getY(),
          v = l.getX(),
          C = l.getY(),
          T = u.getX(),
          D = u.getY(),
          B = Tr.CORR
        return d < this.width / 2
          ? [new he(T - B, D + B), new he(m + B, b + B), new he(v - B, C - B), new he(d + B, g - B)]
          : [new he(T + B, D + B), new he(m + B, b - B), new he(v - B, C + B), new he(d - B, g - B)]
      }
      containsBlackPoint(s, a, l, u) {
        const d = this.image
        if (u) {
          for (let g = s; g <= a; g++) if (d.get(g, l)) return !0
        } else for (let g = s; g <= a; g++) if (d.get(l, g)) return !0
        return !1
      }
    }
    ;((Tr.INIT_SIZE = 10), (Tr.CORR = 1))
    class _h {
      static checkAndNudgePoints(s, a) {
        const l = s.getWidth(),
          u = s.getHeight()
        let d = !0
        for (let g = 0; g < a.length && d; g += 2) {
          const m = Math.floor(a[g]),
            b = Math.floor(a[g + 1])
          if (m < -1 || m > l || b < -1 || b > u) throw new H()
          ;((d = !1),
            m === -1 ? ((a[g] = 0), (d = !0)) : m === l && ((a[g] = l - 1), (d = !0)),
            b === -1 ? ((a[g + 1] = 0), (d = !0)) : b === u && ((a[g + 1] = u - 1), (d = !0)))
        }
        d = !0
        for (let g = a.length - 2; g >= 0 && d; g -= 2) {
          const m = Math.floor(a[g]),
            b = Math.floor(a[g + 1])
          if (m < -1 || m > l || b < -1 || b > u) throw new H()
          ;((d = !1),
            m === -1 ? ((a[g] = 0), (d = !0)) : m === l && ((a[g] = l - 1), (d = !0)),
            b === -1 ? ((a[g + 1] = 0), (d = !0)) : b === u && ((a[g + 1] = u - 1), (d = !0)))
        }
      }
    }
    class tr {
      constructor(s, a, l, u, d, g, m, b, v) {
        ;((this.a11 = s),
          (this.a21 = a),
          (this.a31 = l),
          (this.a12 = u),
          (this.a22 = d),
          (this.a32 = g),
          (this.a13 = m),
          (this.a23 = b),
          (this.a33 = v))
      }
      static quadrilateralToQuadrilateral(s, a, l, u, d, g, m, b, v, C, T, D, B, j, W, Y) {
        const q = tr.quadrilateralToSquare(s, a, l, u, d, g, m, b)
        return tr.squareToQuadrilateral(v, C, T, D, B, j, W, Y).times(q)
      }
      transformPoints(s) {
        const a = s.length,
          l = this.a11,
          u = this.a12,
          d = this.a13,
          g = this.a21,
          m = this.a22,
          b = this.a23,
          v = this.a31,
          C = this.a32,
          T = this.a33
        for (let D = 0; D < a; D += 2) {
          const B = s[D],
            j = s[D + 1],
            W = d * B + b * j + T
          ;((s[D] = (l * B + g * j + v) / W), (s[D + 1] = (u * B + m * j + C) / W))
        }
      }
      transformPointsWithValues(s, a) {
        const l = this.a11,
          u = this.a12,
          d = this.a13,
          g = this.a21,
          m = this.a22,
          b = this.a23,
          v = this.a31,
          C = this.a32,
          T = this.a33,
          D = s.length
        for (let B = 0; B < D; B++) {
          const j = s[B],
            W = a[B],
            Y = d * j + b * W + T
          ;((s[B] = (l * j + g * W + v) / Y), (a[B] = (u * j + m * W + C) / Y))
        }
      }
      static squareToQuadrilateral(s, a, l, u, d, g, m, b) {
        const v = s - l + d - m,
          C = a - u + g - b
        if (v === 0 && C === 0) return new tr(l - s, d - l, s, u - a, g - u, a, 0, 0, 1)
        {
          const T = l - d,
            D = m - d,
            B = u - g,
            j = b - g,
            W = T * j - D * B,
            Y = (v * j - D * C) / W,
            q = (T * C - v * B) / W
          return new tr(l - s + Y * l, m - s + q * m, s, u - a + Y * u, b - a + q * b, a, Y, q, 1)
        }
      }
      static quadrilateralToSquare(s, a, l, u, d, g, m, b) {
        return tr.squareToQuadrilateral(s, a, l, u, d, g, m, b).buildAdjoint()
      }
      buildAdjoint() {
        return new tr(
          this.a22 * this.a33 - this.a23 * this.a32,
          this.a23 * this.a31 - this.a21 * this.a33,
          this.a21 * this.a32 - this.a22 * this.a31,
          this.a13 * this.a32 - this.a12 * this.a33,
          this.a11 * this.a33 - this.a13 * this.a31,
          this.a12 * this.a31 - this.a11 * this.a32,
          this.a12 * this.a23 - this.a13 * this.a22,
          this.a13 * this.a21 - this.a11 * this.a23,
          this.a11 * this.a22 - this.a12 * this.a21
        )
      }
      times(s) {
        return new tr(
          this.a11 * s.a11 + this.a21 * s.a12 + this.a31 * s.a13,
          this.a11 * s.a21 + this.a21 * s.a22 + this.a31 * s.a23,
          this.a11 * s.a31 + this.a21 * s.a32 + this.a31 * s.a33,
          this.a12 * s.a11 + this.a22 * s.a12 + this.a32 * s.a13,
          this.a12 * s.a21 + this.a22 * s.a22 + this.a32 * s.a23,
          this.a12 * s.a31 + this.a22 * s.a32 + this.a32 * s.a33,
          this.a13 * s.a11 + this.a23 * s.a12 + this.a33 * s.a13,
          this.a13 * s.a21 + this.a23 * s.a22 + this.a33 * s.a23,
          this.a13 * s.a31 + this.a23 * s.a32 + this.a33 * s.a33
        )
      }
    }
    class bp extends _h {
      sampleGrid(s, a, l, u, d, g, m, b, v, C, T, D, B, j, W, Y, q, ne, te) {
        const $ = tr.quadrilateralToQuadrilateral(u, d, g, m, b, v, C, T, D, B, j, W, Y, q, ne, te)
        return this.sampleGridWithTransform(s, a, l, $)
      }
      sampleGridWithTransform(s, a, l, u) {
        if (a <= 0 || l <= 0) throw new H()
        const d = new Ie(a, l),
          g = new Float32Array(2 * a)
        for (let m = 0; m < l; m++) {
          const b = g.length,
            v = m + 0.5
          for (let C = 0; C < b; C += 2) ((g[C] = C / 2 + 0.5), (g[C + 1] = v))
          ;(u.transformPoints(g), _h.checkAndNudgePoints(s, g))
          try {
            for (let C = 0; C < b; C += 2)
              s.get(Math.floor(g[C]), Math.floor(g[C + 1])) && d.set(C / 2, m)
          } catch {
            throw new H()
          }
        }
        return d
      }
    }
    class Jr {
      static setGridSampler(s) {
        Jr.gridSampler = s
      }
      static getInstance() {
        return Jr.gridSampler
      }
    }
    Jr.gridSampler = new bp()
    class tn {
      constructor(s, a) {
        ;((this.x = s), (this.y = a))
      }
      toResultPoint() {
        return new he(this.getX(), this.getY())
      }
      getX() {
        return this.x
      }
      getY() {
        return this.y
      }
    }
    class vp {
      constructor(s) {
        ;((this.EXPECTED_CORNER_BITS = new Int32Array([3808, 476, 2107, 1799])), (this.image = s))
      }
      detect() {
        return this.detectMirror(!1)
      }
      detectMirror(s) {
        let a = this.getMatrixCenter(),
          l = this.getBullsEyeCorners(a)
        if (s) {
          let g = l[0]
          ;((l[0] = l[2]), (l[2] = g))
        }
        this.extractParameters(l)
        let u = this.sampleGrid(
            this.image,
            l[this.shift % 4],
            l[(this.shift + 1) % 4],
            l[(this.shift + 2) % 4],
            l[(this.shift + 3) % 4]
          ),
          d = this.getMatrixCornerPoints(l)
        return new wp(u, d, this.compact, this.nbDataBlocks, this.nbLayers)
      }
      extractParameters(s) {
        if (
          !this.isValidPoint(s[0]) ||
          !this.isValidPoint(s[1]) ||
          !this.isValidPoint(s[2]) ||
          !this.isValidPoint(s[3])
        )
          throw new H()
        let a = 2 * this.nbCenterLayers,
          l = new Int32Array([
            this.sampleLine(s[0], s[1], a),
            this.sampleLine(s[1], s[2], a),
            this.sampleLine(s[2], s[3], a),
            this.sampleLine(s[3], s[0], a),
          ])
        this.shift = this.getRotation(l, a)
        let u = 0
        for (let g = 0; g < 4; g++) {
          let m = l[(this.shift + g) % 4]
          this.compact
            ? ((u <<= 7), (u += (m >> 1) & 127))
            : ((u <<= 10), (u += ((m >> 2) & 992) + ((m >> 1) & 31)))
        }
        let d = this.getCorrectedParameterData(u, this.compact)
        this.compact
          ? ((this.nbLayers = (d >> 6) + 1), (this.nbDataBlocks = (d & 63) + 1))
          : ((this.nbLayers = (d >> 11) + 1), (this.nbDataBlocks = (d & 2047) + 1))
      }
      getRotation(s, a) {
        let l = 0
        ;(s.forEach((u, d, g) => {
          let m = ((u >> (a - 2)) << 1) + (u & 1)
          l = (l << 3) + m
        }),
          (l = ((l & 1) << 11) + (l >> 1)))
        for (let u = 0; u < 4; u++) if (M.bitCount(l ^ this.EXPECTED_CORNER_BITS[u]) <= 2) return u
        throw new H()
      }
      getCorrectedParameterData(s, a) {
        let l, u
        a ? ((l = 7), (u = 2)) : ((l = 10), (u = 4))
        let d = l - u,
          g = new Int32Array(l)
        for (let b = l - 1; b >= 0; --b) ((g[b] = s & 15), (s >>= 4))
        try {
          new ta(Fe.AZTEC_PARAM).decode(g, d)
        } catch {
          throw new H()
        }
        let m = 0
        for (let b = 0; b < u; b++) m = (m << 4) + g[b]
        return m
      }
      getBullsEyeCorners(s) {
        let a = s,
          l = s,
          u = s,
          d = s,
          g = !0
        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
          let T = this.getFirstDifferent(a, g, 1, -1),
            D = this.getFirstDifferent(l, g, 1, 1),
            B = this.getFirstDifferent(u, g, -1, 1),
            j = this.getFirstDifferent(d, g, -1, -1)
          if (this.nbCenterLayers > 2) {
            let W =
              (this.distancePoint(j, T) * this.nbCenterLayers) /
              (this.distancePoint(d, a) * (this.nbCenterLayers + 2))
            if (W < 0.75 || W > 1.25 || !this.isWhiteOrBlackRectangle(T, D, B, j)) break
          }
          ;((a = T), (l = D), (u = B), (d = j), (g = !g))
        }
        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) throw new H()
        this.compact = this.nbCenterLayers === 5
        let m = new he(a.getX() + 0.5, a.getY() - 0.5),
          b = new he(l.getX() + 0.5, l.getY() + 0.5),
          v = new he(u.getX() - 0.5, u.getY() + 0.5),
          C = new he(d.getX() - 0.5, d.getY() - 0.5)
        return this.expandSquare([m, b, v, C], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers)
      }
      getMatrixCenter() {
        let s, a, l, u
        try {
          let m = new Tr(this.image).detect()
          ;((s = m[0]), (a = m[1]), (l = m[2]), (u = m[3]))
        } catch {
          let m = this.image.getWidth() / 2,
            b = this.image.getHeight() / 2
          ;((s = this.getFirstDifferent(new tn(m + 7, b - 7), !1, 1, -1).toResultPoint()),
            (a = this.getFirstDifferent(new tn(m + 7, b + 7), !1, 1, 1).toResultPoint()),
            (l = this.getFirstDifferent(new tn(m - 7, b + 7), !1, -1, 1).toResultPoint()),
            (u = this.getFirstDifferent(new tn(m - 7, b - 7), !1, -1, -1).toResultPoint()))
        }
        let d = Pe.round((s.getX() + u.getX() + a.getX() + l.getX()) / 4),
          g = Pe.round((s.getY() + u.getY() + a.getY() + l.getY()) / 4)
        try {
          let m = new Tr(this.image, 15, d, g).detect()
          ;((s = m[0]), (a = m[1]), (l = m[2]), (u = m[3]))
        } catch {
          ;((s = this.getFirstDifferent(new tn(d + 7, g - 7), !1, 1, -1).toResultPoint()),
            (a = this.getFirstDifferent(new tn(d + 7, g + 7), !1, 1, 1).toResultPoint()),
            (l = this.getFirstDifferent(new tn(d - 7, g + 7), !1, -1, 1).toResultPoint()),
            (u = this.getFirstDifferent(new tn(d - 7, g - 7), !1, -1, -1).toResultPoint()))
        }
        return (
          (d = Pe.round((s.getX() + u.getX() + a.getX() + l.getX()) / 4)),
          (g = Pe.round((s.getY() + u.getY() + a.getY() + l.getY()) / 4)),
          new tn(d, g)
        )
      }
      getMatrixCornerPoints(s) {
        return this.expandSquare(s, 2 * this.nbCenterLayers, this.getDimension())
      }
      sampleGrid(s, a, l, u, d) {
        let g = Jr.getInstance(),
          m = this.getDimension(),
          b = m / 2 - this.nbCenterLayers,
          v = m / 2 + this.nbCenterLayers
        return g.sampleGrid(
          s,
          m,
          m,
          b,
          b,
          v,
          b,
          v,
          v,
          b,
          v,
          a.getX(),
          a.getY(),
          l.getX(),
          l.getY(),
          u.getX(),
          u.getY(),
          d.getX(),
          d.getY()
        )
      }
      sampleLine(s, a, l) {
        let u = 0,
          d = this.distanceResultPoint(s, a),
          g = d / l,
          m = s.getX(),
          b = s.getY(),
          v = (g * (a.getX() - s.getX())) / d,
          C = (g * (a.getY() - s.getY())) / d
        for (let T = 0; T < l; T++)
          this.image.get(Pe.round(m + T * v), Pe.round(b + T * C)) && (u |= 1 << (l - T - 1))
        return u
      }
      isWhiteOrBlackRectangle(s, a, l, u) {
        let d = 3
        ;((s = new tn(s.getX() - d, s.getY() + d)),
          (a = new tn(a.getX() - d, a.getY() - d)),
          (l = new tn(l.getX() + d, l.getY() - d)),
          (u = new tn(u.getX() + d, u.getY() + d)))
        let g = this.getColor(u, s)
        if (g === 0) return !1
        let m = this.getColor(s, a)
        return m !== g || ((m = this.getColor(a, l)), m !== g)
          ? !1
          : ((m = this.getColor(l, u)), m === g)
      }
      getColor(s, a) {
        let l = this.distancePoint(s, a),
          u = (a.getX() - s.getX()) / l,
          d = (a.getY() - s.getY()) / l,
          g = 0,
          m = s.getX(),
          b = s.getY(),
          v = this.image.get(s.getX(), s.getY()),
          C = Math.ceil(l)
        for (let D = 0; D < C; D++)
          ((m += u), (b += d), this.image.get(Pe.round(m), Pe.round(b)) !== v && g++)
        let T = g / l
        return T > 0.1 && T < 0.9 ? 0 : T <= 0.1 === v ? 1 : -1
      }
      getFirstDifferent(s, a, l, u) {
        let d = s.getX() + l,
          g = s.getY() + u
        for (; this.isValid(d, g) && this.image.get(d, g) === a; ) ((d += l), (g += u))
        for (d -= l, g -= u; this.isValid(d, g) && this.image.get(d, g) === a; ) d += l
        for (d -= l; this.isValid(d, g) && this.image.get(d, g) === a; ) g += u
        return ((g -= u), new tn(d, g))
      }
      expandSquare(s, a, l) {
        let u = l / (2 * a),
          d = s[0].getX() - s[2].getX(),
          g = s[0].getY() - s[2].getY(),
          m = (s[0].getX() + s[2].getX()) / 2,
          b = (s[0].getY() + s[2].getY()) / 2,
          v = new he(m + u * d, b + u * g),
          C = new he(m - u * d, b - u * g)
        ;((d = s[1].getX() - s[3].getX()),
          (g = s[1].getY() - s[3].getY()),
          (m = (s[1].getX() + s[3].getX()) / 2),
          (b = (s[1].getY() + s[3].getY()) / 2))
        let T = new he(m + u * d, b + u * g),
          D = new he(m - u * d, b - u * g)
        return [v, T, C, D]
      }
      isValid(s, a) {
        return s >= 0 && s < this.image.getWidth() && a > 0 && a < this.image.getHeight()
      }
      isValidPoint(s) {
        let a = Pe.round(s.getX()),
          l = Pe.round(s.getY())
        return this.isValid(a, l)
      }
      distancePoint(s, a) {
        return Pe.distance(s.getX(), s.getY(), a.getX(), a.getY())
      }
      distanceResultPoint(s, a) {
        return Pe.distance(s.getX(), s.getY(), a.getX(), a.getY())
      }
      getDimension() {
        return this.compact
          ? 4 * this.nbLayers + 11
          : this.nbLayers <= 4
            ? 4 * this.nbLayers + 15
            : 4 * this.nbLayers + 2 * (M.truncDivision(this.nbLayers - 4, 8) + 1) + 15
      }
    }
    class Gl {
      decode(s, a = null) {
        let l = null,
          u = new vp(s.getBlackMatrix()),
          d = null,
          g = null
        try {
          let C = u.detectMirror(!1)
          ;((d = C.getPoints()), this.reportFoundResultPoints(a, d), (g = new Ke().decode(C)))
        } catch (C) {
          l = C
        }
        if (g == null)
          try {
            let C = u.detectMirror(!0)
            ;((d = C.getPoints()), this.reportFoundResultPoints(a, d), (g = new Ke().decode(C)))
          } catch (C) {
            throw l ?? C
          }
        let m = new Be(
            g.getText(),
            g.getRawBytes(),
            g.getNumBits(),
            d,
            ue.AZTEC,
            k.currentTimeMillis()
          ),
          b = g.getByteSegments()
        b != null && m.putMetadata(Rt.BYTE_SEGMENTS, b)
        let v = g.getECLevel()
        return (v != null && m.putMetadata(Rt.ERROR_CORRECTION_LEVEL, v), m)
      }
      reportFoundResultPoints(s, a) {
        if (s != null) {
          let l = s.get(z.NEED_RESULT_POINT_CALLBACK)
          l != null &&
            a.forEach((u, d, g) => {
              l.foundPossibleResultPoint(u)
            })
        }
      }
      reset() {}
    }
    class lb extends Tt {
      constructor(s = 500) {
        super(new Gl(), s)
      }
    }
    class Ct {
      decode(s, a) {
        try {
          return this.doDecode(s, a)
        } catch {
          if (a && a.get(z.TRY_HARDER) === !0 && s.isRotateSupported()) {
            const l = s.rotateCounterClockwise(),
              u = this.doDecode(l, a),
              d = u.getResultMetadata()
            let g = 270
            ;(d !== null && d.get(Rt.ORIENTATION) === !0 && (g = g + (d.get(Rt.ORIENTATION) % 360)),
              u.putMetadata(Rt.ORIENTATION, g))
            const m = u.getResultPoints()
            if (m !== null) {
              const b = l.getHeight()
              for (let v = 0; v < m.length; v++) m[v] = new he(b - m[v].getY() - 1, m[v].getX())
            }
            return u
          } else throw new H()
        }
      }
      reset() {}
      doDecode(s, a) {
        const l = s.getWidth(),
          u = s.getHeight()
        let d = new O(l)
        const g = a && a.get(z.TRY_HARDER) === !0,
          m = Math.max(1, u >> (g ? 8 : 5))
        let b
        g ? (b = u) : (b = 15)
        const v = Math.trunc(u / 2)
        for (let C = 0; C < b; C++) {
          const T = Math.trunc((C + 1) / 2),
            D = (C & 1) === 0,
            B = v + m * (D ? T : -T)
          if (B < 0 || B >= u) break
          try {
            d = s.getBlackRow(B, d)
          } catch {
            continue
          }
          for (let j = 0; j < 2; j++) {
            if (j === 1 && (d.reverse(), a && a.get(z.NEED_RESULT_POINT_CALLBACK) === !0)) {
              const W = new Map()
              ;(a.forEach((Y, q) => W.set(q, Y)), W.delete(z.NEED_RESULT_POINT_CALLBACK), (a = W))
            }
            try {
              const W = this.decodeRow(B, d, a)
              if (j === 1) {
                W.putMetadata(Rt.ORIENTATION, 180)
                const Y = W.getResultPoints()
                Y !== null &&
                  ((Y[0] = new he(l - Y[0].getX() - 1, Y[0].getY())),
                  (Y[1] = new he(l - Y[1].getX() - 1, Y[1].getY())))
              }
              return W
            } catch {}
          }
        }
        throw new H()
      }
      static recordPattern(s, a, l) {
        const u = l.length
        for (let v = 0; v < u; v++) l[v] = 0
        const d = s.getSize()
        if (a >= d) throw new H()
        let g = !s.get(a),
          m = 0,
          b = a
        for (; b < d; ) {
          if (s.get(b) !== g) l[m]++
          else {
            if (++m === u) break
            ;((l[m] = 1), (g = !g))
          }
          b++
        }
        if (!(m === u || (m === u - 1 && b === d))) throw new H()
      }
      static recordPatternInReverse(s, a, l) {
        let u = l.length,
          d = s.get(a)
        for (; a > 0 && u >= 0; ) s.get(--a) !== d && (u--, (d = !d))
        if (u >= 0) throw new H()
        Ct.recordPattern(s, a + 1, l)
      }
      static patternMatchVariance(s, a, l) {
        const u = s.length
        let d = 0,
          g = 0
        for (let v = 0; v < u; v++) ((d += s[v]), (g += a[v]))
        if (d < g) return Number.POSITIVE_INFINITY
        const m = d / g
        l *= m
        let b = 0
        for (let v = 0; v < u; v++) {
          const C = s[v],
            T = a[v] * m,
            D = C > T ? C - T : T - C
          if (D > l) return Number.POSITIVE_INFINITY
          b += D
        }
        return b / d
      }
    }
    class ie extends Ct {
      static findStartPattern(s) {
        const a = s.getSize(),
          l = s.getNextSet(0)
        let u = 0,
          d = Int32Array.from([0, 0, 0, 0, 0, 0]),
          g = l,
          m = !1
        const b = 6
        for (let v = l; v < a; v++)
          if (s.get(v) !== m) d[u]++
          else {
            if (u === b - 1) {
              let C = ie.MAX_AVG_VARIANCE,
                T = -1
              for (let D = ie.CODE_START_A; D <= ie.CODE_START_C; D++) {
                const B = Ct.patternMatchVariance(
                  d,
                  ie.CODE_PATTERNS[D],
                  ie.MAX_INDIVIDUAL_VARIANCE
                )
                B < C && ((C = B), (T = D))
              }
              if (T >= 0 && s.isRange(Math.max(0, g - (v - g) / 2), g, !1))
                return Int32Array.from([g, v, T])
              ;((g += d[0] + d[1]), (d = d.slice(2, d.length - 1)), (d[u - 1] = 0), (d[u] = 0), u--)
            } else u++
            ;((d[u] = 1), (m = !m))
          }
        throw new H()
      }
      static decodeCode(s, a, l) {
        Ct.recordPattern(s, l, a)
        let u = ie.MAX_AVG_VARIANCE,
          d = -1
        for (let g = 0; g < ie.CODE_PATTERNS.length; g++) {
          const m = ie.CODE_PATTERNS[g],
            b = this.patternMatchVariance(a, m, ie.MAX_INDIVIDUAL_VARIANCE)
          b < u && ((u = b), (d = g))
        }
        if (d >= 0) return d
        throw new H()
      }
      decodeRow(s, a, l) {
        const u = l && l.get(z.ASSUME_GS1) === !0,
          d = ie.findStartPattern(a),
          g = d[2]
        let m = 0
        const b = new Uint8Array(20)
        b[m++] = g
        let v
        switch (g) {
          case ie.CODE_START_A:
            v = ie.CODE_CODE_A
            break
          case ie.CODE_START_B:
            v = ie.CODE_CODE_B
            break
          case ie.CODE_START_C:
            v = ie.CODE_CODE_C
            break
          default:
            throw new V()
        }
        let C = !1,
          T = !1,
          D = '',
          B = d[0],
          j = d[1]
        const W = Int32Array.from([0, 0, 0, 0, 0, 0])
        let Y = 0,
          q = 0,
          ne = g,
          te = 0,
          $ = !0,
          Te = !1,
          Ce = !1
        for (; !C; ) {
          const Js = T
          switch (
            ((T = !1),
            (Y = q),
            (q = ie.decodeCode(a, W, j)),
            (b[m++] = q),
            q !== ie.CODE_STOP && ($ = !0),
            q !== ie.CODE_STOP && (te++, (ne += te * q)),
            (B = j),
            (j += W.reduce((Bb, Fb) => Bb + Fb, 0)),
            q)
          ) {
            case ie.CODE_START_A:
            case ie.CODE_START_B:
            case ie.CODE_START_C:
              throw new V()
          }
          switch (v) {
            case ie.CODE_CODE_A:
              if (q < 64)
                (Ce === Te
                  ? (D += String.fromCharCode(32 + q))
                  : (D += String.fromCharCode(32 + q + 128)),
                  (Ce = !1))
              else if (q < 96)
                (Ce === Te
                  ? (D += String.fromCharCode(q - 64))
                  : (D += String.fromCharCode(q + 64)),
                  (Ce = !1))
              else
                switch ((q !== ie.CODE_STOP && ($ = !1), q)) {
                  case ie.CODE_FNC_1:
                    u && (D.length === 0 ? (D += ']C1') : (D += ''))
                    break
                  case ie.CODE_FNC_2:
                  case ie.CODE_FNC_3:
                    break
                  case ie.CODE_FNC_4_A:
                    !Te && Ce
                      ? ((Te = !0), (Ce = !1))
                      : Te && Ce
                        ? ((Te = !1), (Ce = !1))
                        : (Ce = !0)
                    break
                  case ie.CODE_SHIFT:
                    ;((T = !0), (v = ie.CODE_CODE_B))
                    break
                  case ie.CODE_CODE_B:
                    v = ie.CODE_CODE_B
                    break
                  case ie.CODE_CODE_C:
                    v = ie.CODE_CODE_C
                    break
                  case ie.CODE_STOP:
                    C = !0
                    break
                }
              break
            case ie.CODE_CODE_B:
              if (q < 96)
                (Ce === Te
                  ? (D += String.fromCharCode(32 + q))
                  : (D += String.fromCharCode(32 + q + 128)),
                  (Ce = !1))
              else
                switch ((q !== ie.CODE_STOP && ($ = !1), q)) {
                  case ie.CODE_FNC_1:
                    u && (D.length === 0 ? (D += ']C1') : (D += ''))
                    break
                  case ie.CODE_FNC_2:
                  case ie.CODE_FNC_3:
                    break
                  case ie.CODE_FNC_4_B:
                    !Te && Ce
                      ? ((Te = !0), (Ce = !1))
                      : Te && Ce
                        ? ((Te = !1), (Ce = !1))
                        : (Ce = !0)
                    break
                  case ie.CODE_SHIFT:
                    ;((T = !0), (v = ie.CODE_CODE_A))
                    break
                  case ie.CODE_CODE_A:
                    v = ie.CODE_CODE_A
                    break
                  case ie.CODE_CODE_C:
                    v = ie.CODE_CODE_C
                    break
                  case ie.CODE_STOP:
                    C = !0
                    break
                }
              break
            case ie.CODE_CODE_C:
              if (q < 100) (q < 10 && (D += '0'), (D += q))
              else
                switch ((q !== ie.CODE_STOP && ($ = !1), q)) {
                  case ie.CODE_FNC_1:
                    u && (D.length === 0 ? (D += ']C1') : (D += ''))
                    break
                  case ie.CODE_CODE_A:
                    v = ie.CODE_CODE_A
                    break
                  case ie.CODE_CODE_B:
                    v = ie.CODE_CODE_B
                    break
                  case ie.CODE_STOP:
                    C = !0
                    break
                }
              break
          }
          Js && (v = v === ie.CODE_CODE_A ? ie.CODE_CODE_B : ie.CODE_CODE_A)
        }
        const pn = j - B
        if (((j = a.getNextUnset(j)), !a.isRange(j, Math.min(a.getSize(), j + (j - B) / 2), !1)))
          throw new H()
        if (((ne -= te * Y), ne % 103 !== Y)) throw new E()
        const rr = D.length
        if (rr === 0) throw new H()
        rr > 0 &&
          $ &&
          (v === ie.CODE_CODE_C ? (D = D.substring(0, rr - 2)) : (D = D.substring(0, rr - 1)))
        const gn = (d[1] + d[0]) / 2,
          Ze = B + pn / 2,
          Ut = b.length,
          An = new Uint8Array(Ut)
        for (let Js = 0; Js < Ut; Js++) An[Js] = b[Js]
        const $s = [new he(gn, s), new he(Ze, s)]
        return new Be(D, An, 0, $s, ue.CODE_128, new Date().getTime())
      }
    }
    ;((ie.CODE_PATTERNS = [
      Int32Array.from([2, 1, 2, 2, 2, 2]),
      Int32Array.from([2, 2, 2, 1, 2, 2]),
      Int32Array.from([2, 2, 2, 2, 2, 1]),
      Int32Array.from([1, 2, 1, 2, 2, 3]),
      Int32Array.from([1, 2, 1, 3, 2, 2]),
      Int32Array.from([1, 3, 1, 2, 2, 2]),
      Int32Array.from([1, 2, 2, 2, 1, 3]),
      Int32Array.from([1, 2, 2, 3, 1, 2]),
      Int32Array.from([1, 3, 2, 2, 1, 2]),
      Int32Array.from([2, 2, 1, 2, 1, 3]),
      Int32Array.from([2, 2, 1, 3, 1, 2]),
      Int32Array.from([2, 3, 1, 2, 1, 2]),
      Int32Array.from([1, 1, 2, 2, 3, 2]),
      Int32Array.from([1, 2, 2, 1, 3, 2]),
      Int32Array.from([1, 2, 2, 2, 3, 1]),
      Int32Array.from([1, 1, 3, 2, 2, 2]),
      Int32Array.from([1, 2, 3, 1, 2, 2]),
      Int32Array.from([1, 2, 3, 2, 2, 1]),
      Int32Array.from([2, 2, 3, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 3, 2]),
      Int32Array.from([2, 2, 1, 2, 3, 1]),
      Int32Array.from([2, 1, 3, 2, 1, 2]),
      Int32Array.from([2, 2, 3, 1, 1, 2]),
      Int32Array.from([3, 1, 2, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 2, 2, 2]),
      Int32Array.from([3, 2, 1, 1, 2, 2]),
      Int32Array.from([3, 2, 1, 2, 2, 1]),
      Int32Array.from([3, 1, 2, 2, 1, 2]),
      Int32Array.from([3, 2, 2, 1, 1, 2]),
      Int32Array.from([3, 2, 2, 2, 1, 1]),
      Int32Array.from([2, 1, 2, 1, 2, 3]),
      Int32Array.from([2, 1, 2, 3, 2, 1]),
      Int32Array.from([2, 3, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 1, 3, 2, 3]),
      Int32Array.from([1, 3, 1, 1, 2, 3]),
      Int32Array.from([1, 3, 1, 3, 2, 1]),
      Int32Array.from([1, 1, 2, 3, 1, 3]),
      Int32Array.from([1, 3, 2, 1, 1, 3]),
      Int32Array.from([1, 3, 2, 3, 1, 1]),
      Int32Array.from([2, 1, 1, 3, 1, 3]),
      Int32Array.from([2, 3, 1, 1, 1, 3]),
      Int32Array.from([2, 3, 1, 3, 1, 1]),
      Int32Array.from([1, 1, 2, 1, 3, 3]),
      Int32Array.from([1, 1, 2, 3, 3, 1]),
      Int32Array.from([1, 3, 2, 1, 3, 1]),
      Int32Array.from([1, 1, 3, 1, 2, 3]),
      Int32Array.from([1, 1, 3, 3, 2, 1]),
      Int32Array.from([1, 3, 3, 1, 2, 1]),
      Int32Array.from([3, 1, 3, 1, 2, 1]),
      Int32Array.from([2, 1, 1, 3, 3, 1]),
      Int32Array.from([2, 3, 1, 1, 3, 1]),
      Int32Array.from([2, 1, 3, 1, 1, 3]),
      Int32Array.from([2, 1, 3, 3, 1, 1]),
      Int32Array.from([2, 1, 3, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 2, 3]),
      Int32Array.from([3, 1, 1, 3, 2, 1]),
      Int32Array.from([3, 3, 1, 1, 2, 1]),
      Int32Array.from([3, 1, 2, 1, 1, 3]),
      Int32Array.from([3, 1, 2, 3, 1, 1]),
      Int32Array.from([3, 3, 2, 1, 1, 1]),
      Int32Array.from([3, 1, 4, 1, 1, 1]),
      Int32Array.from([2, 2, 1, 4, 1, 1]),
      Int32Array.from([4, 3, 1, 1, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 2, 4]),
      Int32Array.from([1, 1, 1, 4, 2, 2]),
      Int32Array.from([1, 2, 1, 1, 2, 4]),
      Int32Array.from([1, 2, 1, 4, 2, 1]),
      Int32Array.from([1, 4, 1, 1, 2, 2]),
      Int32Array.from([1, 4, 1, 2, 2, 1]),
      Int32Array.from([1, 1, 2, 2, 1, 4]),
      Int32Array.from([1, 1, 2, 4, 1, 2]),
      Int32Array.from([1, 2, 2, 1, 1, 4]),
      Int32Array.from([1, 2, 2, 4, 1, 1]),
      Int32Array.from([1, 4, 2, 1, 1, 2]),
      Int32Array.from([1, 4, 2, 2, 1, 1]),
      Int32Array.from([2, 4, 1, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 1, 4]),
      Int32Array.from([4, 1, 3, 1, 1, 1]),
      Int32Array.from([2, 4, 1, 1, 1, 2]),
      Int32Array.from([1, 3, 4, 1, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 4, 2]),
      Int32Array.from([1, 2, 1, 1, 4, 2]),
      Int32Array.from([1, 2, 1, 2, 4, 1]),
      Int32Array.from([1, 1, 4, 2, 1, 2]),
      Int32Array.from([1, 2, 4, 1, 1, 2]),
      Int32Array.from([1, 2, 4, 2, 1, 1]),
      Int32Array.from([4, 1, 1, 2, 1, 2]),
      Int32Array.from([4, 2, 1, 1, 1, 2]),
      Int32Array.from([4, 2, 1, 2, 1, 1]),
      Int32Array.from([2, 1, 2, 1, 4, 1]),
      Int32Array.from([2, 1, 4, 1, 2, 1]),
      Int32Array.from([4, 1, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 1, 1, 4, 3]),
      Int32Array.from([1, 1, 1, 3, 4, 1]),
      Int32Array.from([1, 3, 1, 1, 4, 1]),
      Int32Array.from([1, 1, 4, 1, 1, 3]),
      Int32Array.from([1, 1, 4, 3, 1, 1]),
      Int32Array.from([4, 1, 1, 1, 1, 3]),
      Int32Array.from([4, 1, 1, 3, 1, 1]),
      Int32Array.from([1, 1, 3, 1, 4, 1]),
      Int32Array.from([1, 1, 4, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 4, 1]),
      Int32Array.from([4, 1, 1, 1, 3, 1]),
      Int32Array.from([2, 1, 1, 4, 1, 2]),
      Int32Array.from([2, 1, 1, 2, 1, 4]),
      Int32Array.from([2, 1, 1, 2, 3, 2]),
      Int32Array.from([2, 3, 3, 1, 1, 1, 2]),
    ]),
      (ie.MAX_AVG_VARIANCE = 0.25),
      (ie.MAX_INDIVIDUAL_VARIANCE = 0.7),
      (ie.CODE_SHIFT = 98),
      (ie.CODE_CODE_C = 99),
      (ie.CODE_CODE_B = 100),
      (ie.CODE_CODE_A = 101),
      (ie.CODE_FNC_1 = 102),
      (ie.CODE_FNC_2 = 97),
      (ie.CODE_FNC_3 = 96),
      (ie.CODE_FNC_4_A = 101),
      (ie.CODE_FNC_4_B = 100),
      (ie.CODE_START_A = 103),
      (ie.CODE_START_B = 104),
      (ie.CODE_START_C = 105),
      (ie.CODE_STOP = 106))
    class At extends Ct {
      constructor(s = !1, a = !1) {
        ;(super(),
          (this.usingCheckDigit = s),
          (this.extendedMode = a),
          (this.decodeRowResult = ''),
          (this.counters = new Int32Array(9)))
      }
      decodeRow(s, a, l) {
        let u = this.counters
        ;(u.fill(0), (this.decodeRowResult = ''))
        let d = At.findAsteriskPattern(a, u),
          g = a.getNextSet(d[1]),
          m = a.getSize(),
          b,
          v
        do {
          At.recordPattern(a, g, u)
          let W = At.toNarrowWidePattern(u)
          if (W < 0) throw new H()
          ;((b = At.patternToChar(W)), (this.decodeRowResult += b), (v = g))
          for (let Y of u) g += Y
          g = a.getNextSet(g)
        } while (b !== '*')
        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1)
        let C = 0
        for (let W of u) C += W
        let T = g - v - C
        if (g !== m && T * 2 < C) throw new H()
        if (this.usingCheckDigit) {
          let W = this.decodeRowResult.length - 1,
            Y = 0
          for (let q = 0; q < W; q++)
            Y += At.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(q))
          if (this.decodeRowResult.charAt(W) !== At.ALPHABET_STRING.charAt(Y % 43)) throw new E()
          this.decodeRowResult = this.decodeRowResult.substring(0, W)
        }
        if (this.decodeRowResult.length === 0) throw new H()
        let D
        this.extendedMode
          ? (D = At.decodeExtended(this.decodeRowResult))
          : (D = this.decodeRowResult)
        let B = (d[1] + d[0]) / 2,
          j = v + C / 2
        return new Be(D, null, 0, [new he(B, s), new he(j, s)], ue.CODE_39, new Date().getTime())
      }
      static findAsteriskPattern(s, a) {
        let l = s.getSize(),
          u = s.getNextSet(0),
          d = 0,
          g = u,
          m = !1,
          b = a.length
        for (let v = u; v < l; v++)
          if (s.get(v) !== m) a[d]++
          else {
            if (d === b - 1) {
              if (
                this.toNarrowWidePattern(a) === At.ASTERISK_ENCODING &&
                s.isRange(Math.max(0, g - Math.floor((v - g) / 2)), g, !1)
              )
                return [g, v]
              ;((g += a[0] + a[1]), a.copyWithin(0, 2, 2 + d - 1), (a[d - 1] = 0), (a[d] = 0), d--)
            } else d++
            ;((a[d] = 1), (m = !m))
          }
        throw new H()
      }
      static toNarrowWidePattern(s) {
        let a = s.length,
          l = 0,
          u
        do {
          let d = 2147483647
          for (let b of s) b < d && b > l && (d = b)
          ;((l = d), (u = 0))
          let g = 0,
            m = 0
          for (let b = 0; b < a; b++) {
            let v = s[b]
            v > l && ((m |= 1 << (a - 1 - b)), u++, (g += v))
          }
          if (u === 3) {
            for (let b = 0; b < a && u > 0; b++) {
              let v = s[b]
              if (v > l && (u--, v * 2 >= g)) return -1
            }
            return m
          }
        } while (u > 3)
        return -1
      }
      static patternToChar(s) {
        for (let a = 0; a < At.CHARACTER_ENCODINGS.length; a++)
          if (At.CHARACTER_ENCODINGS[a] === s) return At.ALPHABET_STRING.charAt(a)
        if (s === At.ASTERISK_ENCODING) return '*'
        throw new H()
      }
      static decodeExtended(s) {
        let a = s.length,
          l = ''
        for (let u = 0; u < a; u++) {
          let d = s.charAt(u)
          if (d === '+' || d === '$' || d === '%' || d === '/') {
            let g = s.charAt(u + 1),
              m = '\0'
            switch (d) {
              case '+':
                if (g >= 'A' && g <= 'Z') m = String.fromCharCode(g.charCodeAt(0) + 32)
                else throw new V()
                break
              case '$':
                if (g >= 'A' && g <= 'Z') m = String.fromCharCode(g.charCodeAt(0) - 64)
                else throw new V()
                break
              case '%':
                if (g >= 'A' && g <= 'E') m = String.fromCharCode(g.charCodeAt(0) - 38)
                else if (g >= 'F' && g <= 'J') m = String.fromCharCode(g.charCodeAt(0) - 11)
                else if (g >= 'K' && g <= 'O') m = String.fromCharCode(g.charCodeAt(0) + 16)
                else if (g >= 'P' && g <= 'T') m = String.fromCharCode(g.charCodeAt(0) + 43)
                else if (g === 'U') m = '\0'
                else if (g === 'V') m = '@'
                else if (g === 'W') m = '`'
                else if (g === 'X' || g === 'Y' || g === 'Z') m = ''
                else throw new V()
                break
              case '/':
                if (g >= 'A' && g <= 'O') m = String.fromCharCode(g.charCodeAt(0) - 32)
                else if (g === 'Z') m = ':'
                else throw new V()
                break
            }
            ;((l += m), u++)
          } else l += d
        }
        return l
      }
    }
    ;((At.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%'),
      (At.CHARACTER_ENCODINGS = [
        52, 289, 97, 352, 49, 304, 112, 37, 292, 100, 265, 73, 328, 25, 280, 88, 13, 268, 76, 28,
        259, 67, 322, 19, 274, 82, 7, 262, 70, 22, 385, 193, 448, 145, 400, 208, 133, 388, 196, 168,
        162, 138, 42,
      ]),
      (At.ASTERISK_ENCODING = 148))
    class Ge extends Ct {
      constructor() {
        ;(super(...arguments), (this.narrowLineWidth = -1))
      }
      decodeRow(s, a, l) {
        let u = this.decodeStart(a),
          d = this.decodeEnd(a),
          g = new ve()
        Ge.decodeMiddle(a, u[1], d[0], g)
        let m = g.toString(),
          b = null
        ;(l != null && (b = l.get(z.ALLOWED_LENGTHS)),
          b == null && (b = Ge.DEFAULT_ALLOWED_LENGTHS))
        let v = m.length,
          C = !1,
          T = 0
        for (let B of b) {
          if (v === B) {
            C = !0
            break
          }
          B > T && (T = B)
        }
        if ((!C && v > T && (C = !0), !C)) throw new V()
        const D = [new he(u[1], s), new he(d[0], s)]
        return new Be(m, null, 0, D, ue.ITF, new Date().getTime())
      }
      static decodeMiddle(s, a, l, u) {
        let d = new Int32Array(10),
          g = new Int32Array(5),
          m = new Int32Array(5)
        for (d.fill(0), g.fill(0), m.fill(0); a < l; ) {
          Ct.recordPattern(s, a, d)
          for (let v = 0; v < 5; v++) {
            let C = 2 * v
            ;((g[v] = d[C]), (m[v] = d[C + 1]))
          }
          let b = Ge.decodeDigit(g)
          ;(u.append(b.toString()),
            (b = this.decodeDigit(m)),
            u.append(b.toString()),
            d.forEach(function (v) {
              a += v
            }))
        }
      }
      decodeStart(s) {
        let a = Ge.skipWhiteSpace(s),
          l = Ge.findGuardPattern(s, a, Ge.START_PATTERN)
        return ((this.narrowLineWidth = (l[1] - l[0]) / 4), this.validateQuietZone(s, l[0]), l)
      }
      validateQuietZone(s, a) {
        let l = this.narrowLineWidth * 10
        l = l < a ? l : a
        for (let u = a - 1; l > 0 && u >= 0 && !s.get(u); u--) l--
        if (l !== 0) throw new H()
      }
      static skipWhiteSpace(s) {
        const a = s.getSize(),
          l = s.getNextSet(0)
        if (l === a) throw new H()
        return l
      }
      decodeEnd(s) {
        s.reverse()
        try {
          let a = Ge.skipWhiteSpace(s),
            l
          try {
            l = Ge.findGuardPattern(s, a, Ge.END_PATTERN_REVERSED[0])
          } catch (d) {
            d instanceof H && (l = Ge.findGuardPattern(s, a, Ge.END_PATTERN_REVERSED[1]))
          }
          this.validateQuietZone(s, l[0])
          let u = l[0]
          return ((l[0] = s.getSize() - l[1]), (l[1] = s.getSize() - u), l)
        } finally {
          s.reverse()
        }
      }
      static findGuardPattern(s, a, l) {
        let u = l.length,
          d = new Int32Array(u),
          g = s.getSize(),
          m = !1,
          b = 0,
          v = a
        d.fill(0)
        for (let C = a; C < g; C++)
          if (s.get(C) !== m) d[b]++
          else {
            if (b === u - 1) {
              if (Ct.patternMatchVariance(d, l, Ge.MAX_INDIVIDUAL_VARIANCE) < Ge.MAX_AVG_VARIANCE)
                return [v, C]
              ;((v += d[0] + d[1]), k.arraycopy(d, 2, d, 0, b - 1), (d[b - 1] = 0), (d[b] = 0), b--)
            } else b++
            ;((d[b] = 1), (m = !m))
          }
        throw new H()
      }
      static decodeDigit(s) {
        let a = Ge.MAX_AVG_VARIANCE,
          l = -1,
          u = Ge.PATTERNS.length
        for (let d = 0; d < u; d++) {
          let g = Ge.PATTERNS[d],
            m = Ct.patternMatchVariance(s, g, Ge.MAX_INDIVIDUAL_VARIANCE)
          m < a ? ((a = m), (l = d)) : m === a && (l = -1)
        }
        if (l >= 0) return l % 10
        throw new H()
      }
    }
    ;((Ge.PATTERNS = [
      Int32Array.from([1, 1, 2, 2, 1]),
      Int32Array.from([2, 1, 1, 1, 2]),
      Int32Array.from([1, 2, 1, 1, 2]),
      Int32Array.from([2, 2, 1, 1, 1]),
      Int32Array.from([1, 1, 2, 1, 2]),
      Int32Array.from([2, 1, 2, 1, 1]),
      Int32Array.from([1, 2, 2, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 2]),
      Int32Array.from([2, 1, 1, 2, 1]),
      Int32Array.from([1, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 3, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 3]),
      Int32Array.from([1, 3, 1, 1, 3]),
      Int32Array.from([3, 3, 1, 1, 1]),
      Int32Array.from([1, 1, 3, 1, 3]),
      Int32Array.from([3, 1, 3, 1, 1]),
      Int32Array.from([1, 3, 3, 1, 1]),
      Int32Array.from([1, 1, 1, 3, 3]),
      Int32Array.from([3, 1, 1, 3, 1]),
      Int32Array.from([1, 3, 1, 3, 1]),
    ]),
      (Ge.MAX_AVG_VARIANCE = 0.38),
      (Ge.MAX_INDIVIDUAL_VARIANCE = 0.5),
      (Ge.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14]),
      (Ge.START_PATTERN = Int32Array.from([1, 1, 1, 1])),
      (Ge.END_PATTERN_REVERSED = [Int32Array.from([1, 1, 2]), Int32Array.from([1, 1, 3])]))
    class ft extends Ct {
      constructor() {
        ;(super(...arguments), (this.decodeRowStringBuffer = ''))
      }
      static findStartGuardPattern(s) {
        let a = !1,
          l,
          u = 0,
          d = Int32Array.from([0, 0, 0])
        for (; !a; ) {
          ;((d = Int32Array.from([0, 0, 0])),
            (l = ft.findGuardPattern(s, u, !1, this.START_END_PATTERN, d)))
          let g = l[0]
          u = l[1]
          let m = g - (u - g)
          m >= 0 && (a = s.isRange(m, g, !1))
        }
        return l
      }
      static checkChecksum(s) {
        return ft.checkStandardUPCEANChecksum(s)
      }
      static checkStandardUPCEANChecksum(s) {
        let a = s.length
        if (a === 0) return !1
        let l = parseInt(s.charAt(a - 1), 10)
        return ft.getStandardUPCEANChecksum(s.substring(0, a - 1)) === l
      }
      static getStandardUPCEANChecksum(s) {
        let a = s.length,
          l = 0
        for (let u = a - 1; u >= 0; u -= 2) {
          let d = s.charAt(u).charCodeAt(0) - 48
          if (d < 0 || d > 9) throw new V()
          l += d
        }
        l *= 3
        for (let u = a - 2; u >= 0; u -= 2) {
          let d = s.charAt(u).charCodeAt(0) - 48
          if (d < 0 || d > 9) throw new V()
          l += d
        }
        return (1e3 - l) % 10
      }
      static decodeEnd(s, a) {
        return ft.findGuardPattern(
          s,
          a,
          !1,
          ft.START_END_PATTERN,
          new Int32Array(ft.START_END_PATTERN.length).fill(0)
        )
      }
      static findGuardPatternWithoutCounters(s, a, l, u) {
        return this.findGuardPattern(s, a, l, u, new Int32Array(u.length))
      }
      static findGuardPattern(s, a, l, u, d) {
        let g = s.getSize()
        a = l ? s.getNextUnset(a) : s.getNextSet(a)
        let m = 0,
          b = a,
          v = u.length,
          C = l
        for (let T = a; T < g; T++)
          if (s.get(T) !== C) d[m]++
          else {
            if (m === v - 1) {
              if (Ct.patternMatchVariance(d, u, ft.MAX_INDIVIDUAL_VARIANCE) < ft.MAX_AVG_VARIANCE)
                return Int32Array.from([b, T])
              b += d[0] + d[1]
              let D = d.slice(2, d.length - 1)
              for (let B = 0; B < m - 1; B++) d[B] = D[B]
              ;((d[m - 1] = 0), (d[m] = 0), m--)
            } else m++
            ;((d[m] = 1), (C = !C))
          }
        throw new H()
      }
      static decodeDigit(s, a, l, u) {
        this.recordPattern(s, l, a)
        let d = this.MAX_AVG_VARIANCE,
          g = -1,
          m = u.length
        for (let b = 0; b < m; b++) {
          let v = u[b],
            C = Ct.patternMatchVariance(a, v, ft.MAX_INDIVIDUAL_VARIANCE)
          C < d && ((d = C), (g = b))
        }
        if (g >= 0) return g
        throw new H()
      }
    }
    ;((ft.MAX_AVG_VARIANCE = 0.48),
      (ft.MAX_INDIVIDUAL_VARIANCE = 0.7),
      (ft.START_END_PATTERN = Int32Array.from([1, 1, 1])),
      (ft.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1])),
      (ft.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1])),
      (ft.L_PATTERNS = [
        Int32Array.from([3, 2, 1, 1]),
        Int32Array.from([2, 2, 2, 1]),
        Int32Array.from([2, 1, 2, 2]),
        Int32Array.from([1, 4, 1, 1]),
        Int32Array.from([1, 1, 3, 2]),
        Int32Array.from([1, 2, 3, 1]),
        Int32Array.from([1, 1, 1, 4]),
        Int32Array.from([1, 3, 1, 2]),
        Int32Array.from([1, 2, 1, 3]),
        Int32Array.from([3, 1, 1, 2]),
      ]))
    class na {
      constructor() {
        ;((this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5]),
          (this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0])),
          (this.decodeRowStringBuffer = ''))
      }
      decodeRow(s, a, l) {
        let u = this.decodeRowStringBuffer,
          d = this.decodeMiddle(a, l, u),
          g = u.toString(),
          m = na.parseExtensionString(g),
          b = [new he((l[0] + l[1]) / 2, s), new he(d, s)],
          v = new Be(g, null, 0, b, ue.UPC_EAN_EXTENSION, new Date().getTime())
        return (m != null && v.putAllMetadata(m), v)
      }
      decodeMiddle(s, a, l) {
        let u = this.decodeMiddleCounters
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g = a[1],
          m = 0
        for (let v = 0; v < 5 && g < d; v++) {
          let C = ft.decodeDigit(s, u, g, ft.L_AND_G_PATTERNS)
          l += String.fromCharCode(48 + (C % 10))
          for (let T of u) g += T
          ;(C >= 10 && (m |= 1 << (4 - v)),
            v !== 4 && ((g = s.getNextSet(g)), (g = s.getNextUnset(g))))
        }
        if (l.length !== 5) throw new H()
        let b = this.determineCheckDigit(m)
        if (na.extensionChecksum(l.toString()) !== b) throw new H()
        return g
      }
      static extensionChecksum(s) {
        let a = s.length,
          l = 0
        for (let u = a - 2; u >= 0; u -= 2) l += s.charAt(u).charCodeAt(0) - 48
        l *= 3
        for (let u = a - 1; u >= 0; u -= 2) l += s.charAt(u).charCodeAt(0) - 48
        return ((l *= 3), l % 10)
      }
      determineCheckDigit(s) {
        for (let a = 0; a < 10; a++) if (s === this.CHECK_DIGIT_ENCODINGS[a]) return a
        throw new H()
      }
      static parseExtensionString(s) {
        if (s.length !== 5) return null
        let a = na.parseExtension5String(s)
        return a == null ? null : new Map([[Rt.SUGGESTED_PRICE, a]])
      }
      static parseExtension5String(s) {
        let a
        switch (s.charAt(0)) {
          case '0':
            a = ''
            break
          case '5':
            a = '$'
            break
          case '9':
            switch (s) {
              case '90000':
                return null
              case '99991':
                return '0.00'
              case '99990':
                return 'Used'
            }
            a = ''
            break
          default:
            a = ''
            break
        }
        let l = parseInt(s.substring(1)),
          u = (l / 100).toString(),
          d = l % 100,
          g = d < 10 ? '0' + d : d.toString()
        return a + u + '.' + g
      }
    }
    class Ih {
      constructor() {
        ;((this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0])),
          (this.decodeRowStringBuffer = ''))
      }
      decodeRow(s, a, l) {
        let u = this.decodeRowStringBuffer,
          d = this.decodeMiddle(a, l, u),
          g = u.toString(),
          m = Ih.parseExtensionString(g),
          b = [new he((l[0] + l[1]) / 2, s), new he(d, s)],
          v = new Be(g, null, 0, b, ue.UPC_EAN_EXTENSION, new Date().getTime())
        return (m != null && v.putAllMetadata(m), v)
      }
      decodeMiddle(s, a, l) {
        let u = this.decodeMiddleCounters
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g = a[1],
          m = 0
        for (let b = 0; b < 2 && g < d; b++) {
          let v = ft.decodeDigit(s, u, g, ft.L_AND_G_PATTERNS)
          l += String.fromCharCode(48 + (v % 10))
          for (let C of u) g += C
          ;(v >= 10 && (m |= 1 << (1 - b)),
            b !== 1 && ((g = s.getNextSet(g)), (g = s.getNextUnset(g))))
        }
        if (l.length !== 2) throw new H()
        if (parseInt(l.toString()) % 4 !== m) throw new H()
        return g
      }
      static parseExtensionString(s) {
        return s.length !== 2 ? null : new Map([[Rt.ISSUE_NUMBER, parseInt(s)]])
      }
    }
    class xp {
      static decodeRow(s, a, l) {
        let u = ft.findGuardPattern(
          a,
          l,
          !1,
          this.EXTENSION_START_PATTERN,
          new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0)
        )
        try {
          return new na().decodeRow(s, a, u)
        } catch {
          return new Ih().decodeRow(s, a, u)
        }
      }
    }
    xp.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2])
    class je extends ft {
      constructor() {
        ;(super(),
          (this.decodeRowStringBuffer = ''),
          (je.L_AND_G_PATTERNS = je.L_PATTERNS.map((s) => Int32Array.from(s))))
        for (let s = 10; s < 20; s++) {
          let a = je.L_PATTERNS[s - 10],
            l = new Int32Array(a.length)
          for (let u = 0; u < a.length; u++) l[u] = a[a.length - u - 1]
          je.L_AND_G_PATTERNS[s] = l
        }
      }
      decodeRow(s, a, l) {
        let u = je.findStartGuardPattern(a),
          d = l == null ? null : l.get(z.NEED_RESULT_POINT_CALLBACK)
        if (d != null) {
          const $ = new he((u[0] + u[1]) / 2, s)
          d.foundPossibleResultPoint($)
        }
        let g = this.decodeMiddle(a, u, this.decodeRowStringBuffer),
          m = g.rowOffset,
          b = g.resultString
        if (d != null) {
          const $ = new he(m, s)
          d.foundPossibleResultPoint($)
        }
        let v = this.decodeEnd(a, m)
        if (d != null) {
          const $ = new he((v[0] + v[1]) / 2, s)
          d.foundPossibleResultPoint($)
        }
        let C = v[1],
          T = C + (C - v[0])
        if (T >= a.getSize() || !a.isRange(C, T, !1)) throw new H()
        let D = b.toString()
        if (D.length < 8) throw new V()
        if (!je.checkChecksum(D)) throw new E()
        let B = (u[1] + u[0]) / 2,
          j = (v[1] + v[0]) / 2,
          W = this.getBarcodeFormat(),
          Y = [new he(B, s), new he(j, s)],
          q = new Be(D, null, 0, Y, W, new Date().getTime()),
          ne = 0
        try {
          let $ = xp.decodeRow(s, a, v[1])
          ;(q.putMetadata(Rt.UPC_EAN_EXTENSION, $.getText()),
            q.putAllMetadata($.getResultMetadata()),
            q.addResultPoints($.getResultPoints()),
            (ne = $.getText().length))
        } catch {}
        let te = l == null ? null : l.get(z.ALLOWED_EAN_EXTENSIONS)
        if (te != null) {
          let $ = !1
          for (let Te in te)
            if (ne.toString() === Te) {
              $ = !0
              break
            }
          if (!$) throw new H()
        }
        return q
      }
      decodeEnd(s, a) {
        return je.findGuardPattern(
          s,
          a,
          !1,
          je.START_END_PATTERN,
          new Int32Array(je.START_END_PATTERN.length).fill(0)
        )
      }
      static checkChecksum(s) {
        return je.checkStandardUPCEANChecksum(s)
      }
      static checkStandardUPCEANChecksum(s) {
        let a = s.length
        if (a === 0) return !1
        let l = parseInt(s.charAt(a - 1), 10)
        return je.getStandardUPCEANChecksum(s.substring(0, a - 1)) === l
      }
      static getStandardUPCEANChecksum(s) {
        let a = s.length,
          l = 0
        for (let u = a - 1; u >= 0; u -= 2) {
          let d = s.charAt(u).charCodeAt(0) - 48
          if (d < 0 || d > 9) throw new V()
          l += d
        }
        l *= 3
        for (let u = a - 2; u >= 0; u -= 2) {
          let d = s.charAt(u).charCodeAt(0) - 48
          if (d < 0 || d > 9) throw new V()
          l += d
        }
        return (1e3 - l) % 10
      }
    }
    class zi extends je {
      constructor() {
        ;(super(), (this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0])))
      }
      decodeMiddle(s, a, l) {
        let u = this.decodeMiddleCounters
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g = a[1],
          m = 0
        for (let b = 0; b < 6 && g < d; b++) {
          let v = je.decodeDigit(s, u, g, je.L_AND_G_PATTERNS)
          l += String.fromCharCode(48 + (v % 10))
          for (let C of u) g += C
          v >= 10 && (m |= 1 << (5 - b))
        }
        ;((l = zi.determineFirstDigit(l, m)),
          (g = je.findGuardPattern(
            s,
            g,
            !0,
            je.MIDDLE_PATTERN,
            new Int32Array(je.MIDDLE_PATTERN.length).fill(0)
          )[1]))
        for (let b = 0; b < 6 && g < d; b++) {
          let v = je.decodeDigit(s, u, g, je.L_PATTERNS)
          l += String.fromCharCode(48 + v)
          for (let C of u) g += C
        }
        return { rowOffset: g, resultString: l }
      }
      getBarcodeFormat() {
        return ue.EAN_13
      }
      static determineFirstDigit(s, a) {
        for (let l = 0; l < 10; l++)
          if (a === this.FIRST_DIGIT_ENCODINGS[l]) return ((s = String.fromCharCode(48 + l) + s), s)
        throw new H()
      }
    }
    zi.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]
    class Ep extends je {
      constructor() {
        ;(super(), (this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0])))
      }
      decodeMiddle(s, a, l) {
        const u = this.decodeMiddleCounters
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g = a[1]
        for (let m = 0; m < 4 && g < d; m++) {
          let b = je.decodeDigit(s, u, g, je.L_PATTERNS)
          l += String.fromCharCode(48 + b)
          for (let v of u) g += v
        }
        g = je.findGuardPattern(
          s,
          g,
          !0,
          je.MIDDLE_PATTERN,
          new Int32Array(je.MIDDLE_PATTERN.length).fill(0)
        )[1]
        for (let m = 0; m < 4 && g < d; m++) {
          let b = je.decodeDigit(s, u, g, je.L_PATTERNS)
          l += String.fromCharCode(48 + b)
          for (let v of u) g += v
        }
        return { rowOffset: g, resultString: l }
      }
      getBarcodeFormat() {
        return ue.EAN_8
      }
    }
    class Cp extends je {
      constructor() {
        ;(super(...arguments), (this.ean13Reader = new zi()))
      }
      getBarcodeFormat() {
        return ue.UPC_A
      }
      decode(s, a) {
        return this.maybeReturnResult(this.ean13Reader.decode(s))
      }
      decodeRow(s, a, l) {
        return this.maybeReturnResult(this.ean13Reader.decodeRow(s, a, l))
      }
      decodeMiddle(s, a, l) {
        return this.ean13Reader.decodeMiddle(s, a, l)
      }
      maybeReturnResult(s) {
        let a = s.getText()
        if (a.charAt(0) === '0') {
          let l = new Be(a.substring(1), null, null, s.getResultPoints(), ue.UPC_A)
          return (s.getResultMetadata() != null && l.putAllMetadata(s.getResultMetadata()), l)
        } else throw new H()
      }
      reset() {
        this.ean13Reader.reset()
      }
    }
    class nr extends je {
      constructor() {
        ;(super(), (this.decodeMiddleCounters = new Int32Array(4)))
      }
      decodeMiddle(s, a, l) {
        const u = this.decodeMiddleCounters.map((v) => v)
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        const d = s.getSize()
        let g = a[1],
          m = 0
        for (let v = 0; v < 6 && g < d; v++) {
          const C = nr.decodeDigit(s, u, g, nr.L_AND_G_PATTERNS)
          l += String.fromCharCode(48 + (C % 10))
          for (let T of u) g += T
          C >= 10 && (m |= 1 << (5 - v))
        }
        let b = nr.determineNumSysAndCheckDigit(l, m)
        return { rowOffset: g, resultString: b }
      }
      decodeEnd(s, a) {
        return nr.findGuardPatternWithoutCounters(s, a, !0, nr.MIDDLE_END_PATTERN)
      }
      checkChecksum(s) {
        return je.checkChecksum(nr.convertUPCEtoUPCA(s))
      }
      static determineNumSysAndCheckDigit(s, a) {
        for (let l = 0; l <= 1; l++)
          for (let u = 0; u < 10; u++)
            if (a === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[l][u]) {
              let d = String.fromCharCode(48 + l),
                g = String.fromCharCode(48 + u)
              return d + s + g
            }
        throw H.getNotFoundInstance()
      }
      getBarcodeFormat() {
        return ue.UPC_E
      }
      static convertUPCEtoUPCA(s) {
        const a = s
            .slice(1, 7)
            .split('')
            .map((d) => d.charCodeAt(0)),
          l = new ve()
        l.append(s.charAt(0))
        let u = a[5]
        switch (u) {
          case 0:
          case 1:
          case 2:
            ;(l.appendChars(a, 0, 2), l.append(u), l.append('0000'), l.appendChars(a, 2, 3))
            break
          case 3:
            ;(l.appendChars(a, 0, 3), l.append('00000'), l.appendChars(a, 3, 2))
            break
          case 4:
            ;(l.appendChars(a, 0, 4), l.append('00000'), l.append(a[4]))
            break
          default:
            ;(l.appendChars(a, 0, 5), l.append('0000'), l.append(u))
            break
        }
        return (s.length >= 8 && l.append(s.charAt(7)), l.toString())
      }
    }
    ;((nr.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1])),
      (nr.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
        Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]),
        Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 26]),
      ]))
    class Nh extends Ct {
      constructor(s) {
        super()
        let a = s == null ? null : s.get(z.POSSIBLE_FORMATS),
          l = []
        ;(r(a)
          ? (l.push(new zi()), l.push(new Cp()), l.push(new Ep()), l.push(new nr()))
          : (a.indexOf(ue.EAN_13) > -1 && l.push(new zi()),
            a.indexOf(ue.UPC_A) > -1 && l.push(new Cp()),
            a.indexOf(ue.EAN_8) > -1 && l.push(new Ep()),
            a.indexOf(ue.UPC_E) > -1 && l.push(new nr())),
          (this.readers = l))
      }
      decodeRow(s, a, l) {
        for (let u of this.readers)
          try {
            const d = u.decodeRow(s, a, l),
              g = d.getBarcodeFormat() === ue.EAN_13 && d.getText().charAt(0) === '0',
              m = l == null ? null : l.get(z.POSSIBLE_FORMATS),
              b = m == null || m.includes(ue.UPC_A)
            if (g && b) {
              const v = d.getRawBytes(),
                C = new Be(
                  d.getText().substring(1),
                  v,
                  v ? v.length : null,
                  d.getResultPoints(),
                  ue.UPC_A
                )
              return (C.putAllMetadata(d.getResultMetadata()), C)
            }
            return d
          } catch {}
        throw new H()
      }
      reset() {
        for (let s of this.readers) s.reset()
      }
    }
    class Yt extends Ct {
      constructor() {
        ;(super(),
          (this.decodeFinderCounters = new Int32Array(4)),
          (this.dataCharacterCounters = new Int32Array(8)),
          (this.oddRoundingErrors = new Array(4)),
          (this.evenRoundingErrors = new Array(4)),
          (this.oddCounts = new Array(this.dataCharacterCounters.length / 2)),
          (this.evenCounts = new Array(this.dataCharacterCounters.length / 2)))
      }
      getDecodeFinderCounters() {
        return this.decodeFinderCounters
      }
      getDataCharacterCounters() {
        return this.dataCharacterCounters
      }
      getOddRoundingErrors() {
        return this.oddRoundingErrors
      }
      getEvenRoundingErrors() {
        return this.evenRoundingErrors
      }
      getOddCounts() {
        return this.oddCounts
      }
      getEvenCounts() {
        return this.evenCounts
      }
      parseFinderValue(s, a) {
        for (let l = 0; l < a.length; l++)
          if (Ct.patternMatchVariance(s, a[l], Yt.MAX_INDIVIDUAL_VARIANCE) < Yt.MAX_AVG_VARIANCE)
            return l
        throw new H()
      }
      static count(s) {
        return Pe.sum(new Int32Array(s))
      }
      static increment(s, a) {
        let l = 0,
          u = a[0]
        for (let d = 1; d < s.length; d++) a[d] > u && ((u = a[d]), (l = d))
        s[l]++
      }
      static decrement(s, a) {
        let l = 0,
          u = a[0]
        for (let d = 1; d < s.length; d++) a[d] < u && ((u = a[d]), (l = d))
        s[l]--
      }
      static isFinderPattern(s) {
        let a = s[0] + s[1],
          l = a + s[2] + s[3],
          u = a / l
        if (u >= Yt.MIN_FINDER_PATTERN_RATIO && u <= Yt.MAX_FINDER_PATTERN_RATIO) {
          let d = Number.MAX_SAFE_INTEGER,
            g = Number.MIN_SAFE_INTEGER
          for (let m of s) (m > g && (g = m), m < d && (d = m))
          return g < 10 * d
        }
        return !1
      }
    }
    ;((Yt.MAX_AVG_VARIANCE = 0.2),
      (Yt.MAX_INDIVIDUAL_VARIANCE = 0.45),
      (Yt.MIN_FINDER_PATTERN_RATIO = 9.5 / 12),
      (Yt.MAX_FINDER_PATTERN_RATIO = 12.5 / 14))
    class Xs {
      constructor(s, a) {
        ;((this.value = s), (this.checksumPortion = a))
      }
      getValue() {
        return this.value
      }
      getChecksumPortion() {
        return this.checksumPortion
      }
      toString() {
        return this.value + '(' + this.checksumPortion + ')'
      }
      equals(s) {
        if (!(s instanceof Xs)) return !1
        const a = s
        return this.value === a.value && this.checksumPortion === a.checksumPortion
      }
      hashCode() {
        return this.value ^ this.checksumPortion
      }
    }
    class Yl {
      constructor(s, a, l, u, d) {
        ;((this.value = s),
          (this.startEnd = a),
          (this.value = s),
          (this.startEnd = a),
          (this.resultPoints = new Array()),
          this.resultPoints.push(new he(l, d)),
          this.resultPoints.push(new he(u, d)))
      }
      getValue() {
        return this.value
      }
      getStartEnd() {
        return this.startEnd
      }
      getResultPoints() {
        return this.resultPoints
      }
      equals(s) {
        if (!(s instanceof Yl)) return !1
        const a = s
        return this.value === a.value
      }
      hashCode() {
        return this.value
      }
    }
    class fr {
      constructor() {}
      static getRSSvalue(s, a, l) {
        let u = 0
        for (let b of s) u += b
        let d = 0,
          g = 0,
          m = s.length
        for (let b = 0; b < m - 1; b++) {
          let v
          for (v = 1, g |= 1 << b; v < s[b]; v++, g &= ~(1 << b)) {
            let C = fr.combins(u - v - 1, m - b - 2)
            if (
              (l &&
                g === 0 &&
                u - v - (m - b - 1) >= m - b - 1 &&
                (C -= fr.combins(u - v - (m - b), m - b - 2)),
              m - b - 1 > 1)
            ) {
              let T = 0
              for (let D = u - v - (m - b - 2); D > a; D--)
                T += fr.combins(u - v - D - 1, m - b - 3)
              C -= T * (m - 1 - b)
            } else u - v > a && C--
            d += C
          }
          u -= v
        }
        return d
      }
      static combins(s, a) {
        let l, u
        s - a > a ? ((u = a), (l = s - a)) : ((u = s - a), (l = a))
        let d = 1,
          g = 1
        for (let m = s; m > l; m--) ((d *= m), g <= u && ((d /= g), g++))
        for (; g <= u; ) ((d /= g), g++)
        return d
      }
    }
    class cb {
      static buildBitArray(s) {
        let a = s.length * 2 - 1
        s[s.length - 1].getRightChar() == null && (a -= 1)
        let l = 12 * a,
          u = new O(l),
          d = 0,
          g = s[0].getRightChar().getValue()
        for (let m = 11; m >= 0; --m) (g & (1 << m) && u.set(d), d++)
        for (let m = 1; m < s.length; ++m) {
          let b = s[m],
            v = b.getLeftChar().getValue()
          for (let C = 11; C >= 0; --C) (v & (1 << C) && u.set(d), d++)
          if (b.getRightChar() != null) {
            let C = b.getRightChar().getValue()
            for (let T = 11; T >= 0; --T) (C & (1 << T) && u.set(d), d++)
          }
        }
        return u
      }
    }
    class Hi {
      constructor(s, a) {
        a ? (this.decodedInformation = null) : ((this.finished = s), (this.decodedInformation = a))
      }
      getDecodedInformation() {
        return this.decodedInformation
      }
      isFinished() {
        return this.finished
      }
    }
    class Th {
      constructor(s) {
        this.newPosition = s
      }
      getNewPosition() {
        return this.newPosition
      }
    }
    class hn extends Th {
      constructor(s, a) {
        ;(super(s), (this.value = a))
      }
      getValue() {
        return this.value
      }
      isFNC1() {
        return this.value === hn.FNC1
      }
    }
    hn.FNC1 = '$'
    class Xi extends Th {
      constructor(s, a, l) {
        ;(super(s),
          l
            ? ((this.remaining = !0), (this.remainingValue = this.remainingValue))
            : ((this.remaining = !1), (this.remainingValue = 0)),
          (this.newString = a))
      }
      getNewString() {
        return this.newString
      }
      isRemaining() {
        return this.remaining
      }
      getRemainingValue() {
        return this.remainingValue
      }
    }
    class Vn extends Th {
      constructor(s, a, l) {
        if ((super(s), a < 0 || a > 10 || l < 0 || l > 10)) throw new V()
        ;((this.firstDigit = a), (this.secondDigit = l))
      }
      getFirstDigit() {
        return this.firstDigit
      }
      getSecondDigit() {
        return this.secondDigit
      }
      getValue() {
        return this.firstDigit * 10 + this.secondDigit
      }
      isFirstDigitFNC1() {
        return this.firstDigit === Vn.FNC1
      }
      isSecondDigitFNC1() {
        return this.secondDigit === Vn.FNC1
      }
      isAnyFNC1() {
        return this.firstDigit === Vn.FNC1 || this.secondDigit === Vn.FNC1
      }
    }
    Vn.FNC1 = 10
    class ae {
      constructor() {}
      static parseFieldsInGeneralPurpose(s) {
        if (!s) return null
        if (s.length < 2) throw new H()
        let a = s.substring(0, 2)
        for (let d of ae.TWO_DIGIT_DATA_LENGTH)
          if (d[0] === a)
            return d[1] === ae.VARIABLE_LENGTH
              ? ae.processVariableAI(2, d[2], s)
              : ae.processFixedAI(2, d[1], s)
        if (s.length < 3) throw new H()
        let l = s.substring(0, 3)
        for (let d of ae.THREE_DIGIT_DATA_LENGTH)
          if (d[0] === l)
            return d[1] === ae.VARIABLE_LENGTH
              ? ae.processVariableAI(3, d[2], s)
              : ae.processFixedAI(3, d[1], s)
        for (let d of ae.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH)
          if (d[0] === l)
            return d[1] === ae.VARIABLE_LENGTH
              ? ae.processVariableAI(4, d[2], s)
              : ae.processFixedAI(4, d[1], s)
        if (s.length < 4) throw new H()
        let u = s.substring(0, 4)
        for (let d of ae.FOUR_DIGIT_DATA_LENGTH)
          if (d[0] === u)
            return d[1] === ae.VARIABLE_LENGTH
              ? ae.processVariableAI(4, d[2], s)
              : ae.processFixedAI(4, d[1], s)
        throw new H()
      }
      static processFixedAI(s, a, l) {
        if (l.length < s) throw new H()
        let u = l.substring(0, s)
        if (l.length < s + a) throw new H()
        let d = l.substring(s, s + a),
          g = l.substring(s + a),
          m = '(' + u + ')' + d,
          b = ae.parseFieldsInGeneralPurpose(g)
        return b == null ? m : m + b
      }
      static processVariableAI(s, a, l) {
        let u = l.substring(0, s),
          d
        l.length < s + a ? (d = l.length) : (d = s + a)
        let g = l.substring(s, d),
          m = l.substring(d),
          b = '(' + u + ')' + g,
          v = ae.parseFieldsInGeneralPurpose(m)
        return v == null ? b : b + v
      }
    }
    ;((ae.VARIABLE_LENGTH = []),
      (ae.TWO_DIGIT_DATA_LENGTH = [
        ['00', 18],
        ['01', 14],
        ['02', 14],
        ['10', ae.VARIABLE_LENGTH, 20],
        ['11', 6],
        ['12', 6],
        ['13', 6],
        ['15', 6],
        ['17', 6],
        ['20', 2],
        ['21', ae.VARIABLE_LENGTH, 20],
        ['22', ae.VARIABLE_LENGTH, 29],
        ['30', ae.VARIABLE_LENGTH, 8],
        ['37', ae.VARIABLE_LENGTH, 8],
        ['90', ae.VARIABLE_LENGTH, 30],
        ['91', ae.VARIABLE_LENGTH, 30],
        ['92', ae.VARIABLE_LENGTH, 30],
        ['93', ae.VARIABLE_LENGTH, 30],
        ['94', ae.VARIABLE_LENGTH, 30],
        ['95', ae.VARIABLE_LENGTH, 30],
        ['96', ae.VARIABLE_LENGTH, 30],
        ['97', ae.VARIABLE_LENGTH, 3],
        ['98', ae.VARIABLE_LENGTH, 30],
        ['99', ae.VARIABLE_LENGTH, 30],
      ]),
      (ae.THREE_DIGIT_DATA_LENGTH = [
        ['240', ae.VARIABLE_LENGTH, 30],
        ['241', ae.VARIABLE_LENGTH, 30],
        ['242', ae.VARIABLE_LENGTH, 6],
        ['250', ae.VARIABLE_LENGTH, 30],
        ['251', ae.VARIABLE_LENGTH, 30],
        ['253', ae.VARIABLE_LENGTH, 17],
        ['254', ae.VARIABLE_LENGTH, 20],
        ['400', ae.VARIABLE_LENGTH, 30],
        ['401', ae.VARIABLE_LENGTH, 30],
        ['402', 17],
        ['403', ae.VARIABLE_LENGTH, 30],
        ['410', 13],
        ['411', 13],
        ['412', 13],
        ['413', 13],
        ['414', 13],
        ['420', ae.VARIABLE_LENGTH, 20],
        ['421', ae.VARIABLE_LENGTH, 15],
        ['422', 3],
        ['423', ae.VARIABLE_LENGTH, 15],
        ['424', 3],
        ['425', 3],
        ['426', 3],
      ]),
      (ae.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
        ['310', 6],
        ['311', 6],
        ['312', 6],
        ['313', 6],
        ['314', 6],
        ['315', 6],
        ['316', 6],
        ['320', 6],
        ['321', 6],
        ['322', 6],
        ['323', 6],
        ['324', 6],
        ['325', 6],
        ['326', 6],
        ['327', 6],
        ['328', 6],
        ['329', 6],
        ['330', 6],
        ['331', 6],
        ['332', 6],
        ['333', 6],
        ['334', 6],
        ['335', 6],
        ['336', 6],
        ['340', 6],
        ['341', 6],
        ['342', 6],
        ['343', 6],
        ['344', 6],
        ['345', 6],
        ['346', 6],
        ['347', 6],
        ['348', 6],
        ['349', 6],
        ['350', 6],
        ['351', 6],
        ['352', 6],
        ['353', 6],
        ['354', 6],
        ['355', 6],
        ['356', 6],
        ['357', 6],
        ['360', 6],
        ['361', 6],
        ['362', 6],
        ['363', 6],
        ['364', 6],
        ['365', 6],
        ['366', 6],
        ['367', 6],
        ['368', 6],
        ['369', 6],
        ['390', ae.VARIABLE_LENGTH, 15],
        ['391', ae.VARIABLE_LENGTH, 18],
        ['392', ae.VARIABLE_LENGTH, 15],
        ['393', ae.VARIABLE_LENGTH, 18],
        ['703', ae.VARIABLE_LENGTH, 30],
      ]),
      (ae.FOUR_DIGIT_DATA_LENGTH = [
        ['7001', 13],
        ['7002', ae.VARIABLE_LENGTH, 30],
        ['7003', 10],
        ['8001', 14],
        ['8002', ae.VARIABLE_LENGTH, 20],
        ['8003', ae.VARIABLE_LENGTH, 30],
        ['8004', ae.VARIABLE_LENGTH, 30],
        ['8005', 6],
        ['8006', 18],
        ['8007', ae.VARIABLE_LENGTH, 30],
        ['8008', ae.VARIABLE_LENGTH, 12],
        ['8018', 18],
        ['8020', ae.VARIABLE_LENGTH, 25],
        ['8100', 6],
        ['8101', 10],
        ['8102', 2],
        ['8110', ae.VARIABLE_LENGTH, 70],
        ['8200', ae.VARIABLE_LENGTH, 70],
      ]))
    class Gs {
      constructor(s) {
        ;((this.buffer = new ve()), (this.information = s))
      }
      decodeAllCodes(s, a) {
        let l = a,
          u = null
        do {
          let d = this.decodeGeneralPurposeField(l, u),
            g = ae.parseFieldsInGeneralPurpose(d.getNewString())
          if (
            (g != null && s.append(g),
            d.isRemaining() ? (u = '' + d.getRemainingValue()) : (u = null),
            l === d.getNewPosition())
          )
            break
          l = d.getNewPosition()
        } while (!0)
        return s.toString()
      }
      isStillNumeric(s) {
        if (s + 7 > this.information.getSize()) return s + 4 <= this.information.getSize()
        for (let a = s; a < s + 3; ++a) if (this.information.get(a)) return !0
        return this.information.get(s + 3)
      }
      decodeNumeric(s) {
        if (s + 7 > this.information.getSize()) {
          let d = this.extractNumericValueFromBitArray(s, 4)
          return d === 0
            ? new Vn(this.information.getSize(), Vn.FNC1, Vn.FNC1)
            : new Vn(this.information.getSize(), d - 1, Vn.FNC1)
        }
        let a = this.extractNumericValueFromBitArray(s, 7),
          l = (a - 8) / 11,
          u = (a - 8) % 11
        return new Vn(s + 7, l, u)
      }
      extractNumericValueFromBitArray(s, a) {
        return Gs.extractNumericValueFromBitArray(this.information, s, a)
      }
      static extractNumericValueFromBitArray(s, a, l) {
        let u = 0
        for (let d = 0; d < l; ++d) s.get(a + d) && (u |= 1 << (l - d - 1))
        return u
      }
      decodeGeneralPurposeField(s, a) {
        ;(this.buffer.setLengthToZero(),
          a != null && this.buffer.append(a),
          this.current.setPosition(s))
        let l = this.parseBlocks()
        return l != null && l.isRemaining()
          ? new Xi(this.current.getPosition(), this.buffer.toString(), l.getRemainingValue())
          : new Xi(this.current.getPosition(), this.buffer.toString())
      }
      parseBlocks() {
        let s, a
        do {
          let l = this.current.getPosition()
          if (
            (this.current.isAlpha()
              ? ((a = this.parseAlphaBlock()), (s = a.isFinished()))
              : this.current.isIsoIec646()
                ? ((a = this.parseIsoIec646Block()), (s = a.isFinished()))
                : ((a = this.parseNumericBlock()), (s = a.isFinished())),
            l === this.current.getPosition() && !s)
          )
            break
        } while (!s)
        return a.getDecodedInformation()
      }
      parseNumericBlock() {
        for (; this.isStillNumeric(this.current.getPosition()); ) {
          let s = this.decodeNumeric(this.current.getPosition())
          if ((this.current.setPosition(s.getNewPosition()), s.isFirstDigitFNC1())) {
            let a
            return (
              s.isSecondDigitFNC1()
                ? (a = new Xi(this.current.getPosition(), this.buffer.toString()))
                : (a = new Xi(
                    this.current.getPosition(),
                    this.buffer.toString(),
                    s.getSecondDigit()
                  )),
              new Hi(!0, a)
            )
          }
          if ((this.buffer.append(s.getFirstDigit()), s.isSecondDigitFNC1())) {
            let a = new Xi(this.current.getPosition(), this.buffer.toString())
            return new Hi(!0, a)
          }
          this.buffer.append(s.getSecondDigit())
        }
        return (
          this.isNumericToAlphaNumericLatch(this.current.getPosition()) &&
            (this.current.setAlpha(), this.current.incrementPosition(4)),
          new Hi(!1)
        )
      }
      parseIsoIec646Block() {
        for (; this.isStillIsoIec646(this.current.getPosition()); ) {
          let s = this.decodeIsoIec646(this.current.getPosition())
          if ((this.current.setPosition(s.getNewPosition()), s.isFNC1())) {
            let a = new Xi(this.current.getPosition(), this.buffer.toString())
            return new Hi(!0, a)
          }
          this.buffer.append(s.getValue())
        }
        return (
          this.isAlphaOr646ToNumericLatch(this.current.getPosition())
            ? (this.current.incrementPosition(3), this.current.setNumeric())
            : this.isAlphaTo646ToAlphaLatch(this.current.getPosition()) &&
              (this.current.getPosition() + 5 < this.information.getSize()
                ? this.current.incrementPosition(5)
                : this.current.setPosition(this.information.getSize()),
              this.current.setAlpha()),
          new Hi(!1)
        )
      }
      parseAlphaBlock() {
        for (; this.isStillAlpha(this.current.getPosition()); ) {
          let s = this.decodeAlphanumeric(this.current.getPosition())
          if ((this.current.setPosition(s.getNewPosition()), s.isFNC1())) {
            let a = new Xi(this.current.getPosition(), this.buffer.toString())
            return new Hi(!0, a)
          }
          this.buffer.append(s.getValue())
        }
        return (
          this.isAlphaOr646ToNumericLatch(this.current.getPosition())
            ? (this.current.incrementPosition(3), this.current.setNumeric())
            : this.isAlphaTo646ToAlphaLatch(this.current.getPosition()) &&
              (this.current.getPosition() + 5 < this.information.getSize()
                ? this.current.incrementPosition(5)
                : this.current.setPosition(this.information.getSize()),
              this.current.setIsoIec646()),
          new Hi(!1)
        )
      }
      isStillIsoIec646(s) {
        if (s + 5 > this.information.getSize()) return !1
        let a = this.extractNumericValueFromBitArray(s, 5)
        if (a >= 5 && a < 16) return !0
        if (s + 7 > this.information.getSize()) return !1
        let l = this.extractNumericValueFromBitArray(s, 7)
        if (l >= 64 && l < 116) return !0
        if (s + 8 > this.information.getSize()) return !1
        let u = this.extractNumericValueFromBitArray(s, 8)
        return u >= 232 && u < 253
      }
      decodeIsoIec646(s) {
        let a = this.extractNumericValueFromBitArray(s, 5)
        if (a === 15) return new hn(s + 5, hn.FNC1)
        if (a >= 5 && a < 15) return new hn(s + 5, '0' + (a - 5))
        let l = this.extractNumericValueFromBitArray(s, 7)
        if (l >= 64 && l < 90) return new hn(s + 7, '' + (l + 1))
        if (l >= 90 && l < 116) return new hn(s + 7, '' + (l + 7))
        let u = this.extractNumericValueFromBitArray(s, 8),
          d
        switch (u) {
          case 232:
            d = '!'
            break
          case 233:
            d = '"'
            break
          case 234:
            d = '%'
            break
          case 235:
            d = '&'
            break
          case 236:
            d = "'"
            break
          case 237:
            d = '('
            break
          case 238:
            d = ')'
            break
          case 239:
            d = '*'
            break
          case 240:
            d = '+'
            break
          case 241:
            d = ','
            break
          case 242:
            d = '-'
            break
          case 243:
            d = '.'
            break
          case 244:
            d = '/'
            break
          case 245:
            d = ':'
            break
          case 246:
            d = ';'
            break
          case 247:
            d = '<'
            break
          case 248:
            d = '='
            break
          case 249:
            d = '>'
            break
          case 250:
            d = '?'
            break
          case 251:
            d = '_'
            break
          case 252:
            d = ' '
            break
          default:
            throw new V()
        }
        return new hn(s + 8, d)
      }
      isStillAlpha(s) {
        if (s + 5 > this.information.getSize()) return !1
        let a = this.extractNumericValueFromBitArray(s, 5)
        if (a >= 5 && a < 16) return !0
        if (s + 6 > this.information.getSize()) return !1
        let l = this.extractNumericValueFromBitArray(s, 6)
        return l >= 16 && l < 63
      }
      decodeAlphanumeric(s) {
        let a = this.extractNumericValueFromBitArray(s, 5)
        if (a === 15) return new hn(s + 5, hn.FNC1)
        if (a >= 5 && a < 15) return new hn(s + 5, '0' + (a - 5))
        let l = this.extractNumericValueFromBitArray(s, 6)
        if (l >= 32 && l < 58) return new hn(s + 6, '' + (l + 33))
        let u
        switch (l) {
          case 58:
            u = '*'
            break
          case 59:
            u = ','
            break
          case 60:
            u = '-'
            break
          case 61:
            u = '.'
            break
          case 62:
            u = '/'
            break
          default:
            throw new dr('Decoding invalid alphanumeric value: ' + l)
        }
        return new hn(s + 6, u)
      }
      isAlphaTo646ToAlphaLatch(s) {
        if (s + 1 > this.information.getSize()) return !1
        for (let a = 0; a < 5 && a + s < this.information.getSize(); ++a)
          if (a === 2) {
            if (!this.information.get(s + 2)) return !1
          } else if (this.information.get(s + a)) return !1
        return !0
      }
      isAlphaOr646ToNumericLatch(s) {
        if (s + 3 > this.information.getSize()) return !1
        for (let a = s; a < s + 3; ++a) if (this.information.get(a)) return !1
        return !0
      }
      isNumericToAlphaNumericLatch(s) {
        if (s + 1 > this.information.getSize()) return !1
        for (let a = 0; a < 4 && a + s < this.information.getSize(); ++a)
          if (this.information.get(s + a)) return !1
        return !0
      }
    }
    class Rh {
      constructor(s) {
        ;((this.information = s), (this.generalDecoder = new Gs(s)))
      }
      getInformation() {
        return this.information
      }
      getGeneralDecoder() {
        return this.generalDecoder
      }
    }
    class dn extends Rh {
      constructor(s) {
        super(s)
      }
      encodeCompressedGtin(s, a) {
        s.append('(01)')
        let l = s.length()
        ;(s.append('9'), this.encodeCompressedGtinWithoutAI(s, a, l))
      }
      encodeCompressedGtinWithoutAI(s, a, l) {
        for (let u = 0; u < 4; ++u) {
          let d = this.getGeneralDecoder().extractNumericValueFromBitArray(a + 10 * u, 10)
          ;(d / 100 === 0 && s.append('0'), d / 10 === 0 && s.append('0'), s.append(d))
        }
        dn.appendCheckDigit(s, l)
      }
      static appendCheckDigit(s, a) {
        let l = 0
        for (let u = 0; u < 13; u++) {
          let d = s.charAt(u + a).charCodeAt(0) - 48
          l += u & 1 ? d : 3 * d
        }
        ;((l = 10 - (l % 10)), l === 10 && (l = 0), s.append(l))
      }
    }
    dn.GTIN_SIZE = 40
    class Ys extends dn {
      constructor(s) {
        super(s)
      }
      parseInformation() {
        let s = new ve()
        s.append('(01)')
        let a = s.length(),
          l = this.getGeneralDecoder().extractNumericValueFromBitArray(Ys.HEADER_SIZE, 4)
        return (
          s.append(l),
          this.encodeCompressedGtinWithoutAI(s, Ys.HEADER_SIZE + 4, a),
          this.getGeneralDecoder().decodeAllCodes(s, Ys.HEADER_SIZE + 44)
        )
      }
    }
    Ys.HEADER_SIZE = 4
    class Zl extends Rh {
      constructor(s) {
        super(s)
      }
      parseInformation() {
        let s = new ve()
        return this.getGeneralDecoder().decodeAllCodes(s, Zl.HEADER_SIZE)
      }
    }
    Zl.HEADER_SIZE = 5
    class Kl extends dn {
      constructor(s) {
        super(s)
      }
      encodeCompressedWeight(s, a, l) {
        let u = this.getGeneralDecoder().extractNumericValueFromBitArray(a, l)
        this.addWeightCode(s, u)
        let d = this.checkWeight(u),
          g = 1e5
        for (let m = 0; m < 5; ++m) (d / g === 0 && s.append('0'), (g /= 10))
        s.append(d)
      }
    }
    class pr extends Kl {
      constructor(s) {
        super(s)
      }
      parseInformation() {
        if (this.getInformation().getSize() != pr.HEADER_SIZE + Kl.GTIN_SIZE + pr.WEIGHT_SIZE)
          throw new H()
        let s = new ve()
        return (
          this.encodeCompressedGtin(s, pr.HEADER_SIZE),
          this.encodeCompressedWeight(s, pr.HEADER_SIZE + Kl.GTIN_SIZE, pr.WEIGHT_SIZE),
          s.toString()
        )
      }
    }
    ;((pr.HEADER_SIZE = 5), (pr.WEIGHT_SIZE = 15))
    class ub extends pr {
      constructor(s) {
        super(s)
      }
      addWeightCode(s, a) {
        s.append('(3103)')
      }
      checkWeight(s) {
        return s
      }
    }
    class hb extends pr {
      constructor(s) {
        super(s)
      }
      addWeightCode(s, a) {
        a < 1e4 ? s.append('(3202)') : s.append('(3203)')
      }
      checkWeight(s) {
        return s < 1e4 ? s : s - 1e4
      }
    }
    class gr extends dn {
      constructor(s) {
        super(s)
      }
      parseInformation() {
        if (this.getInformation().getSize() < gr.HEADER_SIZE + dn.GTIN_SIZE) throw new H()
        let s = new ve()
        this.encodeCompressedGtin(s, gr.HEADER_SIZE)
        let a = this.getGeneralDecoder().extractNumericValueFromBitArray(
          gr.HEADER_SIZE + dn.GTIN_SIZE,
          gr.LAST_DIGIT_SIZE
        )
        ;(s.append('(392'), s.append(a), s.append(')'))
        let l = this.getGeneralDecoder().decodeGeneralPurposeField(
          gr.HEADER_SIZE + dn.GTIN_SIZE + gr.LAST_DIGIT_SIZE,
          null
        )
        return (s.append(l.getNewString()), s.toString())
      }
    }
    ;((gr.HEADER_SIZE = 8), (gr.LAST_DIGIT_SIZE = 2))
    class nn extends dn {
      constructor(s) {
        super(s)
      }
      parseInformation() {
        if (this.getInformation().getSize() < nn.HEADER_SIZE + dn.GTIN_SIZE) throw new H()
        let s = new ve()
        this.encodeCompressedGtin(s, nn.HEADER_SIZE)
        let a = this.getGeneralDecoder().extractNumericValueFromBitArray(
          nn.HEADER_SIZE + dn.GTIN_SIZE,
          nn.LAST_DIGIT_SIZE
        )
        ;(s.append('(393'), s.append(a), s.append(')'))
        let l = this.getGeneralDecoder().extractNumericValueFromBitArray(
          nn.HEADER_SIZE + dn.GTIN_SIZE + nn.LAST_DIGIT_SIZE,
          nn.FIRST_THREE_DIGITS_SIZE
        )
        ;(l / 100 == 0 && s.append('0'), l / 10 == 0 && s.append('0'), s.append(l))
        let u = this.getGeneralDecoder().decodeGeneralPurposeField(
          nn.HEADER_SIZE + dn.GTIN_SIZE + nn.LAST_DIGIT_SIZE + nn.FIRST_THREE_DIGITS_SIZE,
          null
        )
        return (s.append(u.getNewString()), s.toString())
      }
    }
    ;((nn.HEADER_SIZE = 8), (nn.LAST_DIGIT_SIZE = 2), (nn.FIRST_THREE_DIGITS_SIZE = 10))
    class it extends Kl {
      constructor(s, a, l) {
        ;(super(s), (this.dateCode = l), (this.firstAIdigits = a))
      }
      parseInformation() {
        if (
          this.getInformation().getSize() !=
          it.HEADER_SIZE + it.GTIN_SIZE + it.WEIGHT_SIZE + it.DATE_SIZE
        )
          throw new H()
        let s = new ve()
        return (
          this.encodeCompressedGtin(s, it.HEADER_SIZE),
          this.encodeCompressedWeight(s, it.HEADER_SIZE + it.GTIN_SIZE, it.WEIGHT_SIZE),
          this.encodeCompressedDate(s, it.HEADER_SIZE + it.GTIN_SIZE + it.WEIGHT_SIZE),
          s.toString()
        )
      }
      encodeCompressedDate(s, a) {
        let l = this.getGeneralDecoder().extractNumericValueFromBitArray(a, it.DATE_SIZE)
        if (l == 38400) return
        ;(s.append('('), s.append(this.dateCode), s.append(')'))
        let u = l % 32
        l /= 32
        let d = (l % 12) + 1
        l /= 12
        let g = l
        ;(g / 10 == 0 && s.append('0'),
          s.append(g),
          d / 10 == 0 && s.append('0'),
          s.append(d),
          u / 10 == 0 && s.append('0'),
          s.append(u))
      }
      addWeightCode(s, a) {
        ;(s.append('('), s.append(this.firstAIdigits), s.append(a / 1e5), s.append(')'))
      }
      checkWeight(s) {
        return s % 1e5
      }
    }
    ;((it.HEADER_SIZE = 8), (it.WEIGHT_SIZE = 20), (it.DATE_SIZE = 16))
    function Sp(_) {
      try {
        if (_.get(1)) return new Ys(_)
        if (!_.get(2)) return new Zl(_)
        switch (Gs.extractNumericValueFromBitArray(_, 1, 4)) {
          case 4:
            return new ub(_)
          case 5:
            return new hb(_)
        }
        switch (Gs.extractNumericValueFromBitArray(_, 1, 5)) {
          case 12:
            return new gr(_)
          case 13:
            return new nn(_)
        }
        switch (Gs.extractNumericValueFromBitArray(_, 1, 7)) {
          case 56:
            return new it(_, '310', '11')
          case 57:
            return new it(_, '320', '11')
          case 58:
            return new it(_, '310', '13')
          case 59:
            return new it(_, '320', '13')
          case 60:
            return new it(_, '310', '15')
          case 61:
            return new it(_, '320', '15')
          case 62:
            return new it(_, '310', '17')
          case 63:
            return new it(_, '320', '17')
        }
      } catch (s) {
        throw (console.log(s), new dr('unknown decoder: ' + _))
      }
    }
    class ei {
      constructor(s, a, l, u) {
        ;((this.leftchar = s), (this.rightchar = a), (this.finderpattern = l), (this.maybeLast = u))
      }
      mayBeLast() {
        return this.maybeLast
      }
      getLeftChar() {
        return this.leftchar
      }
      getRightChar() {
        return this.rightchar
      }
      getFinderPattern() {
        return this.finderpattern
      }
      mustBeLast() {
        return this.rightchar == null
      }
      toString() {
        return (
          '[ ' +
          this.leftchar +
          ', ' +
          this.rightchar +
          ' : ' +
          (this.finderpattern == null ? 'null' : this.finderpattern.getValue()) +
          ' ]'
        )
      }
      static equals(s, a) {
        return s instanceof ei
          ? ei.equalsOrNull(s.leftchar, a.leftchar) &&
              ei.equalsOrNull(s.rightchar, a.rightchar) &&
              ei.equalsOrNull(s.finderpattern, a.finderpattern)
          : !1
      }
      static equalsOrNull(s, a) {
        return s === null ? a === null : ei.equals(s, a)
      }
      hashCode() {
        return this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue()
      }
    }
    class Mh {
      constructor(s, a, l) {
        ;((this.pairs = s), (this.rowNumber = a), (this.wasReversed = l))
      }
      getPairs() {
        return this.pairs
      }
      getRowNumber() {
        return this.rowNumber
      }
      isReversed() {
        return this.wasReversed
      }
      isEquivalent(s) {
        return this.checkEqualitity(this, s)
      }
      toString() {
        return '{ ' + this.pairs + ' }'
      }
      equals(s, a) {
        return s instanceof Mh ? this.checkEqualitity(s, a) && s.wasReversed === a.wasReversed : !1
      }
      checkEqualitity(s, a) {
        if (!s || !a) return
        let l
        return (
          s.forEach((u, d) => {
            a.forEach((g) => {
              u.getLeftChar().getValue() === g.getLeftChar().getValue() &&
                u.getRightChar().getValue() === g.getRightChar().getValue() &&
                u.getFinderPatter().getValue() === g.getFinderPatter().getValue() &&
                (l = !0)
            })
          }),
          l
        )
      }
    }
    class Q extends Yt {
      constructor(s) {
        ;(super(...arguments),
          (this.pairs = new Array(Q.MAX_PAIRS)),
          (this.rows = new Array()),
          (this.startEnd = [2]),
          (this.verbose = s === !0))
      }
      decodeRow(s, a, l) {
        ;((this.pairs.length = 0), (this.startFromEven = !1))
        try {
          return Q.constructResult(this.decodeRow2pairs(s, a))
        } catch (u) {
          this.verbose && console.log(u)
        }
        return (
          (this.pairs.length = 0),
          (this.startFromEven = !0),
          Q.constructResult(this.decodeRow2pairs(s, a))
        )
      }
      reset() {
        ;((this.pairs.length = 0), (this.rows.length = 0))
      }
      decodeRow2pairs(s, a) {
        let l = !1
        for (; !l; )
          try {
            this.pairs.push(this.retrieveNextPair(a, this.pairs, s))
          } catch (d) {
            if (d instanceof H) {
              if (!this.pairs.length) throw new H()
              l = !0
            }
          }
        if (this.checkChecksum()) return this.pairs
        let u
        if ((this.rows.length ? (u = !0) : (u = !1), this.storeRow(s, !1), u)) {
          let d = this.checkRowsBoolean(!1)
          if (d != null || ((d = this.checkRowsBoolean(!0)), d != null)) return d
        }
        throw new H()
      }
      checkRowsBoolean(s) {
        if (this.rows.length > 25) return ((this.rows.length = 0), null)
        ;((this.pairs.length = 0), s && (this.rows = this.rows.reverse()))
        let a = null
        try {
          a = this.checkRows(new Array(), 0)
        } catch (l) {
          this.verbose && console.log(l)
        }
        return (s && (this.rows = this.rows.reverse()), a)
      }
      checkRows(s, a) {
        for (let l = a; l < this.rows.length; l++) {
          let u = this.rows[l]
          this.pairs.length = 0
          for (let g of s) this.pairs.push(g.getPairs())
          if ((this.pairs.push(u.getPairs()), !Q.isValidSequence(this.pairs))) continue
          if (this.checkChecksum()) return this.pairs
          let d = new Array(s)
          d.push(u)
          try {
            return this.checkRows(d, l + 1)
          } catch (g) {
            this.verbose && console.log(g)
          }
        }
        throw new H()
      }
      static isValidSequence(s) {
        for (let a of Q.FINDER_PATTERN_SEQUENCES) {
          if (s.length > a.length) continue
          let l = !0
          for (let u = 0; u < s.length; u++)
            if (s[u].getFinderPattern().getValue() != a[u]) {
              l = !1
              break
            }
          if (l) return !0
        }
        return !1
      }
      storeRow(s, a) {
        let l = 0,
          u = !1,
          d = !1
        for (; l < this.rows.length; ) {
          let g = this.rows[l]
          if (g.getRowNumber() > s) {
            d = g.isEquivalent(this.pairs)
            break
          }
          ;((u = g.isEquivalent(this.pairs)), l++)
        }
        d ||
          u ||
          Q.isPartialRow(this.pairs, this.rows) ||
          (this.rows.push(l, new Mh(this.pairs, s, a)),
          this.removePartialRows(this.pairs, this.rows))
      }
      removePartialRows(s, a) {
        for (let l of a)
          if (l.getPairs().length !== s.length) {
            for (let u of l.getPairs()) for (let d of s) if (ei.equals(u, d)) break
          }
      }
      static isPartialRow(s, a) {
        for (let l of a) {
          let u = !0
          for (let d of s) {
            let g = !1
            for (let m of l.getPairs())
              if (d.equals(m)) {
                g = !0
                break
              }
            if (!g) {
              u = !1
              break
            }
          }
          if (u) return !0
        }
        return !1
      }
      getRows() {
        return this.rows
      }
      static constructResult(s) {
        let a = cb.buildBitArray(s),
          l = Sp(a).parseInformation(),
          u = s[0].getFinderPattern().getResultPoints(),
          d = s[s.length - 1].getFinderPattern().getResultPoints(),
          g = [u[0], u[1], d[0], d[1]]
        return new Be(l, null, null, g, ue.RSS_EXPANDED, null)
      }
      checkChecksum() {
        let s = this.pairs.get(0),
          a = s.getLeftChar(),
          l = s.getRightChar()
        if (l == null) return !1
        let u = l.getChecksumPortion(),
          d = 2
        for (let g = 1; g < this.pairs.size(); ++g) {
          let m = this.pairs.get(g)
          ;((u += m.getLeftChar().getChecksumPortion()), d++)
          let b = m.getRightChar()
          b != null && ((u += b.getChecksumPortion()), d++)
        }
        return ((u %= 211), 211 * (d - 4) + u == a.getValue())
      }
      static getNextSecondBar(s, a) {
        let l
        return (
          s.get(a)
            ? ((l = s.getNextUnset(a)), (l = s.getNextSet(l)))
            : ((l = s.getNextSet(a)), (l = s.getNextUnset(l))),
          l
        )
      }
      retrieveNextPair(s, a, l) {
        let u = a.length % 2 == 0
        this.startFromEven && (u = !u)
        let d,
          g = !0,
          m = -1
        do
          (this.findNextPair(s, a, m),
            (d = this.parseFoundFinderPattern(s, l, u)),
            d == null ? (m = Q.getNextSecondBar(s, this.startEnd[0])) : (g = !1))
        while (g)
        let b = this.decodeDataCharacter(s, d, u, !0)
        if (!this.isEmptyPair(a) && a[a.length - 1].mustBeLast()) throw new H()
        let v
        try {
          v = this.decodeDataCharacter(s, d, u, !1)
        } catch (C) {
          ;((v = null), this.verbose && console.log(C))
        }
        return new ei(b, v, d, !0)
      }
      isEmptyPair(s) {
        return s.length === 0
      }
      findNextPair(s, a, l) {
        let u = this.getDecodeFinderCounters()
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g
        l >= 0
          ? (g = l)
          : this.isEmptyPair(a)
            ? (g = 0)
            : (g = a[a.length - 1].getFinderPattern().getStartEnd()[1])
        let m = a.length % 2 != 0
        this.startFromEven && (m = !m)
        let b = !1
        for (; g < d && ((b = !s.get(g)), !!b); ) g++
        let v = 0,
          C = g
        for (let T = g; T < d; T++)
          if (s.get(T) != b) u[v]++
          else {
            if (v == 3) {
              if ((m && Q.reverseCounters(u), Q.isFinderPattern(u))) {
                ;((this.startEnd[0] = C), (this.startEnd[1] = T))
                return
              }
              ;(m && Q.reverseCounters(u),
                (C += u[0] + u[1]),
                (u[0] = u[2]),
                (u[1] = u[3]),
                (u[2] = 0),
                (u[3] = 0),
                v--)
            } else v++
            ;((u[v] = 1), (b = !b))
          }
        throw new H()
      }
      static reverseCounters(s) {
        let a = s.length
        for (let l = 0; l < a / 2; ++l) {
          let u = s[l]
          ;((s[l] = s[a - l - 1]), (s[a - l - 1] = u))
        }
      }
      parseFoundFinderPattern(s, a, l) {
        let u, d, g
        if (l) {
          let v = this.startEnd[0] - 1
          for (; v >= 0 && !s.get(v); ) v--
          ;(v++, (u = this.startEnd[0] - v), (d = v), (g = this.startEnd[1]))
        } else
          ((d = this.startEnd[0]),
            (g = s.getNextUnset(this.startEnd[1] + 1)),
            (u = g - this.startEnd[1]))
        let m = this.getDecodeFinderCounters()
        ;(k.arraycopy(m, 0, m, 1, m.length - 1), (m[0] = u))
        let b
        try {
          b = this.parseFinderValue(m, Q.FINDER_PATTERNS)
        } catch {
          return null
        }
        return new Yl(b, [d, g], d, g, a)
      }
      decodeDataCharacter(s, a, l, u) {
        let d = this.getDataCharacterCounters()
        for (let Ze = 0; Ze < d.length; Ze++) d[Ze] = 0
        if (u) Q.recordPatternInReverse(s, a.getStartEnd()[0], d)
        else {
          Q.recordPattern(s, a.getStartEnd()[1], d)
          for (let Ze = 0, Ut = d.length - 1; Ze < Ut; Ze++, Ut--) {
            let An = d[Ze]
            ;((d[Ze] = d[Ut]), (d[Ut] = An))
          }
        }
        let g = 17,
          m = Pe.sum(new Int32Array(d)) / g,
          b = (a.getStartEnd()[1] - a.getStartEnd()[0]) / 15
        if (Math.abs(m - b) / b > 0.3) throw new H()
        let v = this.getOddCounts(),
          C = this.getEvenCounts(),
          T = this.getOddRoundingErrors(),
          D = this.getEvenRoundingErrors()
        for (let Ze = 0; Ze < d.length; Ze++) {
          let Ut = (1 * d[Ze]) / m,
            An = Ut + 0.5
          if (An < 1) {
            if (Ut < 0.3) throw new H()
            An = 1
          } else if (An > 8) {
            if (Ut > 8.7) throw new H()
            An = 8
          }
          let $s = Ze / 2
          Ze & 1 ? ((C[$s] = An), (D[$s] = Ut - An)) : ((v[$s] = An), (T[$s] = Ut - An))
        }
        this.adjustOddEvenCounts(g)
        let B = 4 * a.getValue() + (l ? 0 : 2) + (u ? 0 : 1) - 1,
          j = 0,
          W = 0
        for (let Ze = v.length - 1; Ze >= 0; Ze--) {
          if (Q.isNotA1left(a, l, u)) {
            let Ut = Q.WEIGHTS[B][2 * Ze]
            W += v[Ze] * Ut
          }
          j += v[Ze]
        }
        let Y = 0
        for (let Ze = C.length - 1; Ze >= 0; Ze--)
          if (Q.isNotA1left(a, l, u)) {
            let Ut = Q.WEIGHTS[B][2 * Ze + 1]
            Y += C[Ze] * Ut
          }
        let q = W + Y
        if (j & 1 || j > 13 || j < 4) throw new H()
        let ne = (13 - j) / 2,
          te = Q.SYMBOL_WIDEST[ne],
          $ = 9 - te,
          Te = fr.getRSSvalue(v, te, !0),
          Ce = fr.getRSSvalue(C, $, !1),
          pn = Q.EVEN_TOTAL_SUBSET[ne],
          rr = Q.GSUM[ne],
          gn = Te * pn + Ce + rr
        return new Xs(gn, q)
      }
      static isNotA1left(s, a, l) {
        return !(s.getValue() == 0 && a && l)
      }
      adjustOddEvenCounts(s) {
        let a = Pe.sum(new Int32Array(this.getOddCounts())),
          l = Pe.sum(new Int32Array(this.getEvenCounts())),
          u = !1,
          d = !1
        a > 13 ? (d = !0) : a < 4 && (u = !0)
        let g = !1,
          m = !1
        l > 13 ? (m = !0) : l < 4 && (g = !0)
        let b = a + l - s,
          v = (a & 1) == 1,
          C = (l & 1) == 0
        if (b == 1)
          if (v) {
            if (C) throw new H()
            d = !0
          } else {
            if (!C) throw new H()
            m = !0
          }
        else if (b == -1)
          if (v) {
            if (C) throw new H()
            u = !0
          } else {
            if (!C) throw new H()
            g = !0
          }
        else if (b == 0) {
          if (v) {
            if (!C) throw new H()
            a < l ? ((u = !0), (m = !0)) : ((d = !0), (g = !0))
          } else if (C) throw new H()
        } else throw new H()
        if (u) {
          if (d) throw new H()
          Q.increment(this.getOddCounts(), this.getOddRoundingErrors())
        }
        if ((d && Q.decrement(this.getOddCounts(), this.getOddRoundingErrors()), g)) {
          if (m) throw new H()
          Q.increment(this.getEvenCounts(), this.getOddRoundingErrors())
        }
        m && Q.decrement(this.getEvenCounts(), this.getEvenRoundingErrors())
      }
    }
    ;((Q.SYMBOL_WIDEST = [7, 5, 4, 3, 1]),
      (Q.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204]),
      (Q.GSUM = [0, 348, 1388, 2948, 3988]),
      (Q.FINDER_PATTERNS = [
        Int32Array.from([1, 8, 4, 1]),
        Int32Array.from([3, 6, 4, 1]),
        Int32Array.from([3, 4, 6, 1]),
        Int32Array.from([3, 2, 8, 1]),
        Int32Array.from([2, 6, 5, 1]),
        Int32Array.from([2, 2, 9, 1]),
      ]),
      (Q.WEIGHTS = [
        [1, 3, 9, 27, 81, 32, 96, 77],
        [20, 60, 180, 118, 143, 7, 21, 63],
        [189, 145, 13, 39, 117, 140, 209, 205],
        [193, 157, 49, 147, 19, 57, 171, 91],
        [62, 186, 136, 197, 169, 85, 44, 132],
        [185, 133, 188, 142, 4, 12, 36, 108],
        [113, 128, 173, 97, 80, 29, 87, 50],
        [150, 28, 84, 41, 123, 158, 52, 156],
        [46, 138, 203, 187, 139, 206, 196, 166],
        [76, 17, 51, 153, 37, 111, 122, 155],
        [43, 129, 176, 106, 107, 110, 119, 146],
        [16, 48, 144, 10, 30, 90, 59, 177],
        [109, 116, 137, 200, 178, 112, 125, 164],
        [70, 210, 208, 202, 184, 130, 179, 115],
        [134, 191, 151, 31, 93, 68, 204, 190],
        [148, 22, 66, 198, 172, 94, 71, 2],
        [6, 18, 54, 162, 64, 192, 154, 40],
        [120, 149, 25, 75, 14, 42, 126, 167],
        [79, 26, 78, 23, 69, 207, 199, 175],
        [103, 98, 83, 38, 114, 131, 182, 124],
        [161, 61, 183, 127, 170, 88, 53, 159],
        [55, 165, 73, 8, 24, 72, 5, 15],
        [45, 135, 194, 160, 58, 174, 100, 89],
      ]),
      (Q.FINDER_PAT_A = 0),
      (Q.FINDER_PAT_B = 1),
      (Q.FINDER_PAT_C = 2),
      (Q.FINDER_PAT_D = 3),
      (Q.FINDER_PAT_E = 4),
      (Q.FINDER_PAT_F = 5),
      (Q.FINDER_PATTERN_SEQUENCES = [
        [Q.FINDER_PAT_A, Q.FINDER_PAT_A],
        [Q.FINDER_PAT_A, Q.FINDER_PAT_B, Q.FINDER_PAT_B],
        [Q.FINDER_PAT_A, Q.FINDER_PAT_C, Q.FINDER_PAT_B, Q.FINDER_PAT_D],
        [Q.FINDER_PAT_A, Q.FINDER_PAT_E, Q.FINDER_PAT_B, Q.FINDER_PAT_D, Q.FINDER_PAT_C],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_F,
        ],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_F,
          Q.FINDER_PAT_F,
        ],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_D,
        ],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_E,
        ],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_F,
          Q.FINDER_PAT_F,
        ],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_F,
          Q.FINDER_PAT_F,
        ],
      ]),
      (Q.MAX_PAIRS = 11))
    class db extends Xs {
      constructor(s, a, l) {
        ;(super(s, a), (this.count = 0), (this.finderPattern = l))
      }
      getFinderPattern() {
        return this.finderPattern
      }
      getCount() {
        return this.count
      }
      incrementCount() {
        this.count++
      }
    }
    class pt extends Yt {
      constructor() {
        ;(super(...arguments), (this.possibleLeftPairs = []), (this.possibleRightPairs = []))
      }
      decodeRow(s, a, l) {
        const u = this.decodePair(a, !1, s, l)
        ;(pt.addOrTally(this.possibleLeftPairs, u), a.reverse())
        let d = this.decodePair(a, !0, s, l)
        ;(pt.addOrTally(this.possibleRightPairs, d), a.reverse())
        for (let g of this.possibleLeftPairs)
          if (g.getCount() > 1) {
            for (let m of this.possibleRightPairs)
              if (m.getCount() > 1 && pt.checkChecksum(g, m)) return pt.constructResult(g, m)
          }
        throw new H()
      }
      static addOrTally(s, a) {
        if (a == null) return
        let l = !1
        for (let u of s)
          if (u.getValue() === a.getValue()) {
            ;(u.incrementCount(), (l = !0))
            break
          }
        l || s.push(a)
      }
      reset() {
        ;((this.possibleLeftPairs.length = 0), (this.possibleRightPairs.length = 0))
      }
      static constructResult(s, a) {
        let l = 4537077 * s.getValue() + a.getValue(),
          u = new String(l).toString(),
          d = new ve()
        for (let v = 13 - u.length; v > 0; v--) d.append('0')
        d.append(u)
        let g = 0
        for (let v = 0; v < 13; v++) {
          let C = d.charAt(v).charCodeAt(0) - 48
          g += v & 1 ? C : 3 * C
        }
        ;((g = 10 - (g % 10)), g === 10 && (g = 0), d.append(g.toString()))
        let m = s.getFinderPattern().getResultPoints(),
          b = a.getFinderPattern().getResultPoints()
        return new Be(
          d.toString(),
          null,
          0,
          [m[0], m[1], b[0], b[1]],
          ue.RSS_14,
          new Date().getTime()
        )
      }
      static checkChecksum(s, a) {
        let l = (s.getChecksumPortion() + 16 * a.getChecksumPortion()) % 79,
          u = 9 * s.getFinderPattern().getValue() + a.getFinderPattern().getValue()
        return (u > 72 && u--, u > 8 && u--, l === u)
      }
      decodePair(s, a, l, u) {
        try {
          let d = this.findFinderPattern(s, a),
            g = this.parseFoundFinderPattern(s, l, a, d),
            m = u == null ? null : u.get(z.NEED_RESULT_POINT_CALLBACK)
          if (m != null) {
            let C = (d[0] + d[1]) / 2
            ;(a && (C = s.getSize() - 1 - C), m.foundPossibleResultPoint(new he(C, l)))
          }
          let b = this.decodeDataCharacter(s, g, !0),
            v = this.decodeDataCharacter(s, g, !1)
          return new db(
            1597 * b.getValue() + v.getValue(),
            b.getChecksumPortion() + 4 * v.getChecksumPortion(),
            g
          )
        } catch {
          return null
        }
      }
      decodeDataCharacter(s, a, l) {
        let u = this.getDataCharacterCounters()
        for (let Y = 0; Y < u.length; Y++) u[Y] = 0
        if (l) Ct.recordPatternInReverse(s, a.getStartEnd()[0], u)
        else {
          Ct.recordPattern(s, a.getStartEnd()[1] + 1, u)
          for (let Y = 0, q = u.length - 1; Y < q; Y++, q--) {
            let ne = u[Y]
            ;((u[Y] = u[q]), (u[q] = ne))
          }
        }
        let d = l ? 16 : 15,
          g = Pe.sum(new Int32Array(u)) / d,
          m = this.getOddCounts(),
          b = this.getEvenCounts(),
          v = this.getOddRoundingErrors(),
          C = this.getEvenRoundingErrors()
        for (let Y = 0; Y < u.length; Y++) {
          let q = u[Y] / g,
            ne = Math.floor(q + 0.5)
          ne < 1 ? (ne = 1) : ne > 8 && (ne = 8)
          let te = Math.floor(Y / 2)
          Y & 1 ? ((b[te] = ne), (C[te] = q - ne)) : ((m[te] = ne), (v[te] = q - ne))
        }
        this.adjustOddEvenCounts(l, d)
        let T = 0,
          D = 0
        for (let Y = m.length - 1; Y >= 0; Y--) ((D *= 9), (D += m[Y]), (T += m[Y]))
        let B = 0,
          j = 0
        for (let Y = b.length - 1; Y >= 0; Y--) ((B *= 9), (B += b[Y]), (j += b[Y]))
        let W = D + 3 * B
        if (l) {
          if (T & 1 || T > 12 || T < 4) throw new H()
          let Y = (12 - T) / 2,
            q = pt.OUTSIDE_ODD_WIDEST[Y],
            ne = 9 - q,
            te = fr.getRSSvalue(m, q, !1),
            $ = fr.getRSSvalue(b, ne, !0),
            Te = pt.OUTSIDE_EVEN_TOTAL_SUBSET[Y],
            Ce = pt.OUTSIDE_GSUM[Y]
          return new Xs(te * Te + $ + Ce, W)
        } else {
          if (j & 1 || j > 10 || j < 4) throw new H()
          let Y = (10 - j) / 2,
            q = pt.INSIDE_ODD_WIDEST[Y],
            ne = 9 - q,
            te = fr.getRSSvalue(m, q, !0),
            $ = fr.getRSSvalue(b, ne, !1),
            Te = pt.INSIDE_ODD_TOTAL_SUBSET[Y],
            Ce = pt.INSIDE_GSUM[Y]
          return new Xs($ * Te + te + Ce, W)
        }
      }
      findFinderPattern(s, a) {
        let l = this.getDecodeFinderCounters()
        ;((l[0] = 0), (l[1] = 0), (l[2] = 0), (l[3] = 0))
        let u = s.getSize(),
          d = !1,
          g = 0
        for (; g < u && ((d = !s.get(g)), a !== d); ) g++
        let m = 0,
          b = g
        for (let v = g; v < u; v++)
          if (s.get(v) !== d) l[m]++
          else {
            if (m === 3) {
              if (Yt.isFinderPattern(l)) return [b, v]
              ;((b += l[0] + l[1]), (l[0] = l[2]), (l[1] = l[3]), (l[2] = 0), (l[3] = 0), m--)
            } else m++
            ;((l[m] = 1), (d = !d))
          }
        throw new H()
      }
      parseFoundFinderPattern(s, a, l, u) {
        let d = s.get(u[0]),
          g = u[0] - 1
        for (; g >= 0 && d !== s.get(g); ) g--
        g++
        const m = u[0] - g,
          b = this.getDecodeFinderCounters(),
          v = new Int32Array(b.length)
        ;(k.arraycopy(b, 0, v, 1, b.length - 1), (v[0] = m))
        const C = this.parseFinderValue(v, pt.FINDER_PATTERNS)
        let T = g,
          D = u[1]
        return (
          l && ((T = s.getSize() - 1 - T), (D = s.getSize() - 1 - D)),
          new Yl(C, [g, u[1]], T, D, a)
        )
      }
      adjustOddEvenCounts(s, a) {
        let l = Pe.sum(new Int32Array(this.getOddCounts())),
          u = Pe.sum(new Int32Array(this.getEvenCounts())),
          d = !1,
          g = !1,
          m = !1,
          b = !1
        s
          ? (l > 12 ? (g = !0) : l < 4 && (d = !0), u > 12 ? (b = !0) : u < 4 && (m = !0))
          : (l > 11 ? (g = !0) : l < 5 && (d = !0), u > 10 ? (b = !0) : u < 4 && (m = !0))
        let v = l + u - a,
          C = (l & 1) === (s ? 1 : 0),
          T = (u & 1) === 1
        if (v === 1)
          if (C) {
            if (T) throw new H()
            g = !0
          } else {
            if (!T) throw new H()
            b = !0
          }
        else if (v === -1)
          if (C) {
            if (T) throw new H()
            d = !0
          } else {
            if (!T) throw new H()
            m = !0
          }
        else if (v === 0) {
          if (C) {
            if (!T) throw new H()
            l < u ? ((d = !0), (b = !0)) : ((g = !0), (m = !0))
          } else if (T) throw new H()
        } else throw new H()
        if (d) {
          if (g) throw new H()
          Yt.increment(this.getOddCounts(), this.getOddRoundingErrors())
        }
        if ((g && Yt.decrement(this.getOddCounts(), this.getOddRoundingErrors()), m)) {
          if (b) throw new H()
          Yt.increment(this.getEvenCounts(), this.getOddRoundingErrors())
        }
        b && Yt.decrement(this.getEvenCounts(), this.getEvenRoundingErrors())
      }
    }
    ;((pt.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126]),
      (pt.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81]),
      (pt.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715]),
      (pt.INSIDE_GSUM = [0, 336, 1036, 1516]),
      (pt.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1]),
      (pt.INSIDE_ODD_WIDEST = [2, 4, 6, 8]),
      (pt.FINDER_PATTERNS = [
        Int32Array.from([3, 8, 2, 1]),
        Int32Array.from([3, 5, 5, 1]),
        Int32Array.from([3, 3, 7, 1]),
        Int32Array.from([3, 1, 9, 1]),
        Int32Array.from([2, 7, 4, 1]),
        Int32Array.from([2, 5, 6, 1]),
        Int32Array.from([2, 3, 8, 1]),
        Int32Array.from([1, 5, 7, 1]),
        Int32Array.from([1, 3, 9, 1]),
      ]))
    class Zs extends Ct {
      constructor(s, a) {
        ;(super(), (this.readers = []), (this.verbose = a === !0))
        const l = s ? s.get(z.POSSIBLE_FORMATS) : null,
          u = s && s.get(z.ASSUME_CODE_39_CHECK_DIGIT) !== void 0
        l
          ? ((l.includes(ue.EAN_13) ||
              l.includes(ue.UPC_A) ||
              l.includes(ue.EAN_8) ||
              l.includes(ue.UPC_E)) &&
              this.readers.push(new Nh(s)),
            l.includes(ue.CODE_39) && this.readers.push(new At(u)),
            l.includes(ue.CODE_128) && this.readers.push(new ie()),
            l.includes(ue.ITF) && this.readers.push(new Ge()),
            l.includes(ue.RSS_14) && this.readers.push(new pt()),
            l.includes(ue.RSS_EXPANDED) && this.readers.push(new Q(this.verbose)))
          : (this.readers.push(new Nh(s)),
            this.readers.push(new At()),
            this.readers.push(new Nh(s)),
            this.readers.push(new ie()),
            this.readers.push(new Ge()),
            this.readers.push(new pt()),
            this.readers.push(new Q(this.verbose)))
      }
      decodeRow(s, a, l) {
        for (let u = 0; u < this.readers.length; u++)
          try {
            return this.readers[u].decodeRow(s, a, l)
          } catch {}
        throw new H()
      }
      reset() {
        this.readers.forEach((s) => s.reset())
      }
    }
    class fb extends Tt {
      constructor(s = 500, a) {
        super(new Zs(a), s, a)
      }
    }
    class Ue {
      constructor(s, a, l) {
        ;((this.ecCodewords = s), (this.ecBlocks = [a]), l && this.ecBlocks.push(l))
      }
      getECCodewords() {
        return this.ecCodewords
      }
      getECBlocks() {
        return this.ecBlocks
      }
    }
    class Ve {
      constructor(s, a) {
        ;((this.count = s), (this.dataCodewords = a))
      }
      getCount() {
        return this.count
      }
      getDataCodewords() {
        return this.dataCodewords
      }
    }
    class Re {
      constructor(s, a, l, u, d, g) {
        ;((this.versionNumber = s),
          (this.symbolSizeRows = a),
          (this.symbolSizeColumns = l),
          (this.dataRegionSizeRows = u),
          (this.dataRegionSizeColumns = d),
          (this.ecBlocks = g))
        let m = 0
        const b = g.getECCodewords(),
          v = g.getECBlocks()
        for (let C of v) m += C.getCount() * (C.getDataCodewords() + b)
        this.totalCodewords = m
      }
      getVersionNumber() {
        return this.versionNumber
      }
      getSymbolSizeRows() {
        return this.symbolSizeRows
      }
      getSymbolSizeColumns() {
        return this.symbolSizeColumns
      }
      getDataRegionSizeRows() {
        return this.dataRegionSizeRows
      }
      getDataRegionSizeColumns() {
        return this.dataRegionSizeColumns
      }
      getTotalCodewords() {
        return this.totalCodewords
      }
      getECBlocks() {
        return this.ecBlocks
      }
      static getVersionForDimensions(s, a) {
        if (s & 1 || a & 1) throw new V()
        for (let l of Re.VERSIONS) if (l.symbolSizeRows === s && l.symbolSizeColumns === a) return l
        throw new V()
      }
      toString() {
        return '' + this.versionNumber
      }
      static buildVersions() {
        return [
          new Re(1, 10, 10, 8, 8, new Ue(5, new Ve(1, 3))),
          new Re(2, 12, 12, 10, 10, new Ue(7, new Ve(1, 5))),
          new Re(3, 14, 14, 12, 12, new Ue(10, new Ve(1, 8))),
          new Re(4, 16, 16, 14, 14, new Ue(12, new Ve(1, 12))),
          new Re(5, 18, 18, 16, 16, new Ue(14, new Ve(1, 18))),
          new Re(6, 20, 20, 18, 18, new Ue(18, new Ve(1, 22))),
          new Re(7, 22, 22, 20, 20, new Ue(20, new Ve(1, 30))),
          new Re(8, 24, 24, 22, 22, new Ue(24, new Ve(1, 36))),
          new Re(9, 26, 26, 24, 24, new Ue(28, new Ve(1, 44))),
          new Re(10, 32, 32, 14, 14, new Ue(36, new Ve(1, 62))),
          new Re(11, 36, 36, 16, 16, new Ue(42, new Ve(1, 86))),
          new Re(12, 40, 40, 18, 18, new Ue(48, new Ve(1, 114))),
          new Re(13, 44, 44, 20, 20, new Ue(56, new Ve(1, 144))),
          new Re(14, 48, 48, 22, 22, new Ue(68, new Ve(1, 174))),
          new Re(15, 52, 52, 24, 24, new Ue(42, new Ve(2, 102))),
          new Re(16, 64, 64, 14, 14, new Ue(56, new Ve(2, 140))),
          new Re(17, 72, 72, 16, 16, new Ue(36, new Ve(4, 92))),
          new Re(18, 80, 80, 18, 18, new Ue(48, new Ve(4, 114))),
          new Re(19, 88, 88, 20, 20, new Ue(56, new Ve(4, 144))),
          new Re(20, 96, 96, 22, 22, new Ue(68, new Ve(4, 174))),
          new Re(21, 104, 104, 24, 24, new Ue(56, new Ve(6, 136))),
          new Re(22, 120, 120, 18, 18, new Ue(68, new Ve(6, 175))),
          new Re(23, 132, 132, 20, 20, new Ue(62, new Ve(8, 163))),
          new Re(24, 144, 144, 22, 22, new Ue(62, new Ve(8, 156), new Ve(2, 155))),
          new Re(25, 8, 18, 6, 16, new Ue(7, new Ve(1, 5))),
          new Re(26, 8, 32, 6, 14, new Ue(11, new Ve(1, 10))),
          new Re(27, 12, 26, 10, 24, new Ue(14, new Ve(1, 16))),
          new Re(28, 12, 36, 10, 16, new Ue(18, new Ve(1, 22))),
          new Re(29, 16, 36, 14, 16, new Ue(24, new Ve(1, 32))),
          new Re(30, 16, 48, 14, 22, new Ue(28, new Ve(1, 49))),
        ]
      }
    }
    Re.VERSIONS = Re.buildVersions()
    class Ph {
      constructor(s) {
        const a = s.getHeight()
        if (a < 8 || a > 144 || a & 1) throw new V()
        ;((this.version = Ph.readVersion(s)),
          (this.mappingBitMatrix = this.extractDataRegion(s)),
          (this.readMappingMatrix = new Ie(
            this.mappingBitMatrix.getWidth(),
            this.mappingBitMatrix.getHeight()
          )))
      }
      getVersion() {
        return this.version
      }
      static readVersion(s) {
        const a = s.getHeight(),
          l = s.getWidth()
        return Re.getVersionForDimensions(a, l)
      }
      readCodewords() {
        const s = new Int8Array(this.version.getTotalCodewords())
        let a = 0,
          l = 4,
          u = 0
        const d = this.mappingBitMatrix.getHeight(),
          g = this.mappingBitMatrix.getWidth()
        let m = !1,
          b = !1,
          v = !1,
          C = !1
        do
          if (l === d && u === 0 && !m)
            ((s[a++] = this.readCorner1(d, g) & 255), (l -= 2), (u += 2), (m = !0))
          else if (l === d - 2 && u === 0 && g & 3 && !b)
            ((s[a++] = this.readCorner2(d, g) & 255), (l -= 2), (u += 2), (b = !0))
          else if (l === d + 4 && u === 2 && !(g & 7) && !v)
            ((s[a++] = this.readCorner3(d, g) & 255), (l -= 2), (u += 2), (v = !0))
          else if (l === d - 2 && u === 0 && (g & 7) === 4 && !C)
            ((s[a++] = this.readCorner4(d, g) & 255), (l -= 2), (u += 2), (C = !0))
          else {
            do
              (l < d &&
                u >= 0 &&
                !this.readMappingMatrix.get(u, l) &&
                (s[a++] = this.readUtah(l, u, d, g) & 255),
                (l -= 2),
                (u += 2))
            while (l >= 0 && u < g)
            ;((l += 1), (u += 3))
            do
              (l >= 0 &&
                u < g &&
                !this.readMappingMatrix.get(u, l) &&
                (s[a++] = this.readUtah(l, u, d, g) & 255),
                (l += 2),
                (u -= 2))
            while (l < d && u >= 0)
            ;((l += 3), (u += 1))
          }
        while (l < d || u < g)
        if (a !== this.version.getTotalCodewords()) throw new V()
        return s
      }
      readModule(s, a, l, u) {
        return (
          s < 0 && ((s += l), (a += 4 - ((l + 4) & 7))),
          a < 0 && ((a += u), (s += 4 - ((u + 4) & 7))),
          this.readMappingMatrix.set(a, s),
          this.mappingBitMatrix.get(a, s)
        )
      }
      readUtah(s, a, l, u) {
        let d = 0
        return (
          this.readModule(s - 2, a - 2, l, u) && (d |= 1),
          (d <<= 1),
          this.readModule(s - 2, a - 1, l, u) && (d |= 1),
          (d <<= 1),
          this.readModule(s - 1, a - 2, l, u) && (d |= 1),
          (d <<= 1),
          this.readModule(s - 1, a - 1, l, u) && (d |= 1),
          (d <<= 1),
          this.readModule(s - 1, a, l, u) && (d |= 1),
          (d <<= 1),
          this.readModule(s, a - 2, l, u) && (d |= 1),
          (d <<= 1),
          this.readModule(s, a - 1, l, u) && (d |= 1),
          (d <<= 1),
          this.readModule(s, a, l, u) && (d |= 1),
          d
        )
      }
      readCorner1(s, a) {
        let l = 0
        return (
          this.readModule(s - 1, 0, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(s - 1, 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(s - 1, 2, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 2, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(1, a - 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(2, a - 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(3, a - 1, s, a) && (l |= 1),
          l
        )
      }
      readCorner2(s, a) {
        let l = 0
        return (
          this.readModule(s - 3, 0, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(s - 2, 0, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(s - 1, 0, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 4, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 3, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 2, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(1, a - 1, s, a) && (l |= 1),
          l
        )
      }
      readCorner3(s, a) {
        let l = 0
        return (
          this.readModule(s - 1, 0, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(s - 1, a - 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 3, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 2, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(1, a - 3, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(1, a - 2, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(1, a - 1, s, a) && (l |= 1),
          l
        )
      }
      readCorner4(s, a) {
        let l = 0
        return (
          this.readModule(s - 3, 0, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(s - 2, 0, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(s - 1, 0, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 2, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(0, a - 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(1, a - 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(2, a - 1, s, a) && (l |= 1),
          (l <<= 1),
          this.readModule(3, a - 1, s, a) && (l |= 1),
          l
        )
      }
      extractDataRegion(s) {
        const a = this.version.getSymbolSizeRows(),
          l = this.version.getSymbolSizeColumns()
        if (s.getHeight() !== a) throw new w('Dimension of bitMatrix must match the version size')
        const u = this.version.getDataRegionSizeRows(),
          d = this.version.getDataRegionSizeColumns(),
          g = (a / u) | 0,
          m = (l / d) | 0,
          b = g * u,
          v = m * d,
          C = new Ie(v, b)
        for (let T = 0; T < g; ++T) {
          const D = T * u
          for (let B = 0; B < m; ++B) {
            const j = B * d
            for (let W = 0; W < u; ++W) {
              const Y = T * (u + 2) + 1 + W,
                q = D + W
              for (let ne = 0; ne < d; ++ne) {
                const te = B * (d + 2) + 1 + ne
                if (s.get(te, Y)) {
                  const $ = j + ne
                  C.set($, q)
                }
              }
            }
          }
        }
        return C
      }
    }
    class Dh {
      constructor(s, a) {
        ;((this.numDataCodewords = s), (this.codewords = a))
      }
      static getDataBlocks(s, a) {
        const l = a.getECBlocks()
        let u = 0
        const d = l.getECBlocks()
        for (let j of d) u += j.getCount()
        const g = new Array(u)
        let m = 0
        for (let j of d)
          for (let W = 0; W < j.getCount(); W++) {
            const Y = j.getDataCodewords(),
              q = l.getECCodewords() + Y
            g[m++] = new Dh(Y, new Uint8Array(q))
          }
        const b = g[0].codewords.length - l.getECCodewords(),
          v = b - 1
        let C = 0
        for (let j = 0; j < v; j++) for (let W = 0; W < m; W++) g[W].codewords[j] = s[C++]
        const T = a.getVersionNumber() === 24,
          D = T ? 8 : m
        for (let j = 0; j < D; j++) g[j].codewords[b - 1] = s[C++]
        const B = g[0].codewords.length
        for (let j = b; j < B; j++)
          for (let W = 0; W < m; W++) {
            const Y = T ? (W + 8) % m : W,
              q = T && Y > 7 ? j - 1 : j
            g[Y].codewords[q] = s[C++]
          }
        if (C !== s.length) throw new w()
        return g
      }
      getNumDataCodewords() {
        return this.numDataCodewords
      }
      getCodewords() {
        return this.codewords
      }
    }
    class Lh {
      constructor(s) {
        ;((this.bytes = s), (this.byteOffset = 0), (this.bitOffset = 0))
      }
      getBitOffset() {
        return this.bitOffset
      }
      getByteOffset() {
        return this.byteOffset
      }
      readBits(s) {
        if (s < 1 || s > 32 || s > this.available()) throw new w('' + s)
        let a = 0,
          l = this.bitOffset,
          u = this.byteOffset
        const d = this.bytes
        if (l > 0) {
          const g = 8 - l,
            m = s < g ? s : g,
            b = g - m,
            v = (255 >> (8 - m)) << b
          ;((a = (d[u] & v) >> b), (s -= m), (l += m), l === 8 && ((l = 0), u++))
        }
        if (s > 0) {
          for (; s >= 8; ) ((a = (a << 8) | (d[u] & 255)), u++, (s -= 8))
          if (s > 0) {
            const g = 8 - s,
              m = (255 >> g) << g
            ;((a = (a << s) | ((d[u] & m) >> g)), (l += s))
          }
        }
        return ((this.bitOffset = l), (this.byteOffset = u), a)
      }
      available() {
        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset
      }
    }
    var kt
    ;(function (_) {
      ;((_[(_.PAD_ENCODE = 0)] = 'PAD_ENCODE'),
        (_[(_.ASCII_ENCODE = 1)] = 'ASCII_ENCODE'),
        (_[(_.C40_ENCODE = 2)] = 'C40_ENCODE'),
        (_[(_.TEXT_ENCODE = 3)] = 'TEXT_ENCODE'),
        (_[(_.ANSIX12_ENCODE = 4)] = 'ANSIX12_ENCODE'),
        (_[(_.EDIFACT_ENCODE = 5)] = 'EDIFACT_ENCODE'),
        (_[(_.BASE256_ENCODE = 6)] = 'BASE256_ENCODE'))
    })(kt || (kt = {}))
    class ti {
      static decode(s) {
        const a = new Lh(s),
          l = new ve(),
          u = new ve(),
          d = new Array()
        let g = kt.ASCII_ENCODE
        do
          if (g === kt.ASCII_ENCODE) g = this.decodeAsciiSegment(a, l, u)
          else {
            switch (g) {
              case kt.C40_ENCODE:
                this.decodeC40Segment(a, l)
                break
              case kt.TEXT_ENCODE:
                this.decodeTextSegment(a, l)
                break
              case kt.ANSIX12_ENCODE:
                this.decodeAnsiX12Segment(a, l)
                break
              case kt.EDIFACT_ENCODE:
                this.decodeEdifactSegment(a, l)
                break
              case kt.BASE256_ENCODE:
                this.decodeBase256Segment(a, l, d)
                break
              default:
                throw new V()
            }
            g = kt.ASCII_ENCODE
          }
        while (g !== kt.PAD_ENCODE && a.available() > 0)
        return (
          u.length() > 0 && l.append(u.toString()),
          new Jo(s, l.toString(), d.length === 0 ? null : d, null)
        )
      }
      static decodeAsciiSegment(s, a, l) {
        let u = !1
        do {
          let d = s.readBits(8)
          if (d === 0) throw new V()
          if (d <= 128)
            return (u && (d += 128), a.append(String.fromCharCode(d - 1)), kt.ASCII_ENCODE)
          if (d === 129) return kt.PAD_ENCODE
          if (d <= 229) {
            const g = d - 130
            ;(g < 10 && a.append('0'), a.append('' + g))
          } else
            switch (d) {
              case 230:
                return kt.C40_ENCODE
              case 231:
                return kt.BASE256_ENCODE
              case 232:
                a.append('')
                break
              case 233:
              case 234:
                break
              case 235:
                u = !0
                break
              case 236:
                ;(a.append('[)>05'), l.insert(0, ''))
                break
              case 237:
                ;(a.append('[)>06'), l.insert(0, ''))
                break
              case 238:
                return kt.ANSIX12_ENCODE
              case 239:
                return kt.TEXT_ENCODE
              case 240:
                return kt.EDIFACT_ENCODE
              case 241:
                break
              default:
                if (d !== 254 || s.available() !== 0) throw new V()
                break
            }
        } while (s.available() > 0)
        return kt.ASCII_ENCODE
      }
      static decodeC40Segment(s, a) {
        let l = !1
        const u = []
        let d = 0
        do {
          if (s.available() === 8) return
          const g = s.readBits(8)
          if (g === 254) return
          this.parseTwoBytes(g, s.readBits(8), u)
          for (let m = 0; m < 3; m++) {
            const b = u[m]
            switch (d) {
              case 0:
                if (b < 3) d = b + 1
                else if (b < this.C40_BASIC_SET_CHARS.length) {
                  const v = this.C40_BASIC_SET_CHARS[b]
                  l ? (a.append(String.fromCharCode(v.charCodeAt(0) + 128)), (l = !1)) : a.append(v)
                } else throw new V()
                break
              case 1:
                ;(l
                  ? (a.append(String.fromCharCode(b + 128)), (l = !1))
                  : a.append(String.fromCharCode(b)),
                  (d = 0))
                break
              case 2:
                if (b < this.C40_SHIFT2_SET_CHARS.length) {
                  const v = this.C40_SHIFT2_SET_CHARS[b]
                  l ? (a.append(String.fromCharCode(v.charCodeAt(0) + 128)), (l = !1)) : a.append(v)
                } else
                  switch (b) {
                    case 27:
                      a.append('')
                      break
                    case 30:
                      l = !0
                      break
                    default:
                      throw new V()
                  }
                d = 0
                break
              case 3:
                ;(l
                  ? (a.append(String.fromCharCode(b + 224)), (l = !1))
                  : a.append(String.fromCharCode(b + 96)),
                  (d = 0))
                break
              default:
                throw new V()
            }
          }
        } while (s.available() > 0)
      }
      static decodeTextSegment(s, a) {
        let l = !1,
          u = [],
          d = 0
        do {
          if (s.available() === 8) return
          const g = s.readBits(8)
          if (g === 254) return
          this.parseTwoBytes(g, s.readBits(8), u)
          for (let m = 0; m < 3; m++) {
            const b = u[m]
            switch (d) {
              case 0:
                if (b < 3) d = b + 1
                else if (b < this.TEXT_BASIC_SET_CHARS.length) {
                  const v = this.TEXT_BASIC_SET_CHARS[b]
                  l ? (a.append(String.fromCharCode(v.charCodeAt(0) + 128)), (l = !1)) : a.append(v)
                } else throw new V()
                break
              case 1:
                ;(l
                  ? (a.append(String.fromCharCode(b + 128)), (l = !1))
                  : a.append(String.fromCharCode(b)),
                  (d = 0))
                break
              case 2:
                if (b < this.TEXT_SHIFT2_SET_CHARS.length) {
                  const v = this.TEXT_SHIFT2_SET_CHARS[b]
                  l ? (a.append(String.fromCharCode(v.charCodeAt(0) + 128)), (l = !1)) : a.append(v)
                } else
                  switch (b) {
                    case 27:
                      a.append('')
                      break
                    case 30:
                      l = !0
                      break
                    default:
                      throw new V()
                  }
                d = 0
                break
              case 3:
                if (b < this.TEXT_SHIFT3_SET_CHARS.length) {
                  const v = this.TEXT_SHIFT3_SET_CHARS[b]
                  ;(l
                    ? (a.append(String.fromCharCode(v.charCodeAt(0) + 128)), (l = !1))
                    : a.append(v),
                    (d = 0))
                } else throw new V()
                break
              default:
                throw new V()
            }
          }
        } while (s.available() > 0)
      }
      static decodeAnsiX12Segment(s, a) {
        const l = []
        do {
          if (s.available() === 8) return
          const u = s.readBits(8)
          if (u === 254) return
          this.parseTwoBytes(u, s.readBits(8), l)
          for (let d = 0; d < 3; d++) {
            const g = l[d]
            switch (g) {
              case 0:
                a.append('\r')
                break
              case 1:
                a.append('*')
                break
              case 2:
                a.append('>')
                break
              case 3:
                a.append(' ')
                break
              default:
                if (g < 14) a.append(String.fromCharCode(g + 44))
                else if (g < 40) a.append(String.fromCharCode(g + 51))
                else throw new V()
                break
            }
          }
        } while (s.available() > 0)
      }
      static parseTwoBytes(s, a, l) {
        let u = (s << 8) + a - 1,
          d = Math.floor(u / 1600)
        ;((l[0] = d), (u -= d * 1600), (d = Math.floor(u / 40)), (l[1] = d), (l[2] = u - d * 40))
      }
      static decodeEdifactSegment(s, a) {
        do {
          if (s.available() <= 16) return
          for (let l = 0; l < 4; l++) {
            let u = s.readBits(6)
            if (u === 31) {
              const d = 8 - s.getBitOffset()
              d !== 8 && s.readBits(d)
              return
            }
            ;(u & 32 || (u |= 64), a.append(String.fromCharCode(u)))
          }
        } while (s.available() > 0)
      }
      static decodeBase256Segment(s, a, l) {
        let u = 1 + s.getByteOffset()
        const d = this.unrandomize255State(s.readBits(8), u++)
        let g
        if (
          (d === 0
            ? (g = (s.available() / 8) | 0)
            : d < 250
              ? (g = d)
              : (g = 250 * (d - 249) + this.unrandomize255State(s.readBits(8), u++)),
          g < 0)
        )
          throw new V()
        const m = new Uint8Array(g)
        for (let b = 0; b < g; b++) {
          if (s.available() < 8) throw new V()
          m[b] = this.unrandomize255State(s.readBits(8), u++)
        }
        l.push(m)
        try {
          a.append(oe.decode(m, re.ISO88591))
        } catch (b) {
          throw new dr('Platform does not support required encoding: ' + b.message)
        }
      }
      static unrandomize255State(s, a) {
        const l = ((149 * a) % 255) + 1,
          u = s - l
        return u >= 0 ? u : u + 256
      }
    }
    ;((ti.C40_BASIC_SET_CHARS = [
      '*',
      '*',
      '*',
      ' ',
      '0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
    ]),
      (ti.C40_SHIFT2_SET_CHARS = [
        '!',
        '"',
        '#',
        '$',
        '%',
        '&',
        "'",
        '(',
        ')',
        '*',
        '+',
        ',',
        '-',
        '.',
        '/',
        ':',
        ';',
        '<',
        '=',
        '>',
        '?',
        '@',
        '[',
        '\\',
        ']',
        '^',
        '_',
      ]),
      (ti.TEXT_BASIC_SET_CHARS = [
        '*',
        '*',
        '*',
        ' ',
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
      ]),
      (ti.TEXT_SHIFT2_SET_CHARS = ti.C40_SHIFT2_SET_CHARS),
      (ti.TEXT_SHIFT3_SET_CHARS = [
        '`',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        '{',
        '|',
        '}',
        '~',
        '',
      ]))
    class pb {
      constructor() {
        this.rsDecoder = new ta(Fe.DATA_MATRIX_FIELD_256)
      }
      decode(s) {
        const a = new Ph(s),
          l = a.getVersion(),
          u = a.readCodewords(),
          d = Dh.getDataBlocks(u, l)
        let g = 0
        for (let v of d) g += v.getNumDataCodewords()
        const m = new Uint8Array(g),
          b = d.length
        for (let v = 0; v < b; v++) {
          const C = d[v],
            T = C.getCodewords(),
            D = C.getNumDataCodewords()
          this.correctErrors(T, D)
          for (let B = 0; B < D; B++) m[B * b + v] = T[B]
        }
        return ti.decode(m)
      }
      correctErrors(s, a) {
        const l = new Int32Array(s)
        try {
          this.rsDecoder.decode(l, s.length - a)
        } catch {
          throw new E()
        }
        for (let u = 0; u < a; u++) s[u] = l[u]
      }
    }
    class vt {
      constructor(s) {
        ;((this.image = s), (this.rectangleDetector = new Tr(this.image)))
      }
      detect() {
        const s = this.rectangleDetector.detect()
        let a = this.detectSolid1(s)
        if (((a = this.detectSolid2(a)), (a[3] = this.correctTopRight(a)), !a[3])) throw new H()
        a = this.shiftToModuleCenter(a)
        const l = a[0],
          u = a[1],
          d = a[2],
          g = a[3]
        let m = this.transitionsBetween(l, g) + 1,
          b = this.transitionsBetween(d, g) + 1
        ;((m & 1) === 1 && (m += 1),
          (b & 1) === 1 && (b += 1),
          4 * m < 7 * b && 4 * b < 7 * m && (m = b = Math.max(m, b)))
        let v = vt.sampleGrid(this.image, l, u, d, g, m, b)
        return new Xl(v, [l, u, d, g])
      }
      static shiftPoint(s, a, l) {
        let u = (a.getX() - s.getX()) / (l + 1),
          d = (a.getY() - s.getY()) / (l + 1)
        return new he(s.getX() + u, s.getY() + d)
      }
      static moveAway(s, a, l) {
        let u = s.getX(),
          d = s.getY()
        return (u < a ? (u -= 1) : (u += 1), d < l ? (d -= 1) : (d += 1), new he(u, d))
      }
      detectSolid1(s) {
        let a = s[0],
          l = s[1],
          u = s[3],
          d = s[2],
          g = this.transitionsBetween(a, l),
          m = this.transitionsBetween(l, u),
          b = this.transitionsBetween(u, d),
          v = this.transitionsBetween(d, a),
          C = g,
          T = [d, a, l, u]
        return (
          C > m && ((C = m), (T[0] = a), (T[1] = l), (T[2] = u), (T[3] = d)),
          C > b && ((C = b), (T[0] = l), (T[1] = u), (T[2] = d), (T[3] = a)),
          C > v && ((T[0] = u), (T[1] = d), (T[2] = a), (T[3] = l)),
          T
        )
      }
      detectSolid2(s) {
        let a = s[0],
          l = s[1],
          u = s[2],
          d = s[3],
          g = this.transitionsBetween(a, d),
          m = vt.shiftPoint(l, u, (g + 1) * 4),
          b = vt.shiftPoint(u, l, (g + 1) * 4),
          v = this.transitionsBetween(m, a),
          C = this.transitionsBetween(b, d)
        return (
          v < C
            ? ((s[0] = a), (s[1] = l), (s[2] = u), (s[3] = d))
            : ((s[0] = l), (s[1] = u), (s[2] = d), (s[3] = a)),
          s
        )
      }
      correctTopRight(s) {
        let a = s[0],
          l = s[1],
          u = s[2],
          d = s[3],
          g = this.transitionsBetween(a, d),
          m = this.transitionsBetween(l, d),
          b = vt.shiftPoint(a, l, (m + 1) * 4),
          v = vt.shiftPoint(u, l, (g + 1) * 4)
        ;((g = this.transitionsBetween(b, d)), (m = this.transitionsBetween(v, d)))
        let C = new he(
            d.getX() + (u.getX() - l.getX()) / (g + 1),
            d.getY() + (u.getY() - l.getY()) / (g + 1)
          ),
          T = new he(
            d.getX() + (a.getX() - l.getX()) / (m + 1),
            d.getY() + (a.getY() - l.getY()) / (m + 1)
          )
        if (!this.isValid(C)) return this.isValid(T) ? T : null
        if (!this.isValid(T)) return C
        let D = this.transitionsBetween(b, C) + this.transitionsBetween(v, C),
          B = this.transitionsBetween(b, T) + this.transitionsBetween(v, T)
        return D > B ? C : T
      }
      shiftToModuleCenter(s) {
        let a = s[0],
          l = s[1],
          u = s[2],
          d = s[3],
          g = this.transitionsBetween(a, d) + 1,
          m = this.transitionsBetween(u, d) + 1,
          b = vt.shiftPoint(a, l, m * 4),
          v = vt.shiftPoint(u, l, g * 4)
        ;((g = this.transitionsBetween(b, d) + 1),
          (m = this.transitionsBetween(v, d) + 1),
          (g & 1) === 1 && (g += 1),
          (m & 1) === 1 && (m += 1))
        let C = (a.getX() + l.getX() + u.getX() + d.getX()) / 4,
          T = (a.getY() + l.getY() + u.getY() + d.getY()) / 4
        ;((a = vt.moveAway(a, C, T)),
          (l = vt.moveAway(l, C, T)),
          (u = vt.moveAway(u, C, T)),
          (d = vt.moveAway(d, C, T)))
        let D, B
        return (
          (b = vt.shiftPoint(a, l, m * 4)),
          (b = vt.shiftPoint(b, d, g * 4)),
          (D = vt.shiftPoint(l, a, m * 4)),
          (D = vt.shiftPoint(D, u, g * 4)),
          (v = vt.shiftPoint(u, d, m * 4)),
          (v = vt.shiftPoint(v, l, g * 4)),
          (B = vt.shiftPoint(d, u, m * 4)),
          (B = vt.shiftPoint(B, a, g * 4)),
          [b, D, v, B]
        )
      }
      isValid(s) {
        return (
          s.getX() >= 0 &&
          s.getX() < this.image.getWidth() &&
          s.getY() > 0 &&
          s.getY() < this.image.getHeight()
        )
      }
      static sampleGrid(s, a, l, u, d, g, m) {
        return Jr.getInstance().sampleGrid(
          s,
          g,
          m,
          0.5,
          0.5,
          g - 0.5,
          0.5,
          g - 0.5,
          m - 0.5,
          0.5,
          m - 0.5,
          a.getX(),
          a.getY(),
          d.getX(),
          d.getY(),
          u.getX(),
          u.getY(),
          l.getX(),
          l.getY()
        )
      }
      transitionsBetween(s, a) {
        let l = Math.trunc(s.getX()),
          u = Math.trunc(s.getY()),
          d = Math.trunc(a.getX()),
          g = Math.trunc(a.getY()),
          m = Math.abs(g - u) > Math.abs(d - l)
        if (m) {
          let W = l
          ;((l = u), (u = W), (W = d), (d = g), (g = W))
        }
        let b = Math.abs(d - l),
          v = Math.abs(g - u),
          C = -b / 2,
          T = u < g ? 1 : -1,
          D = l < d ? 1 : -1,
          B = 0,
          j = this.image.get(m ? u : l, m ? l : u)
        for (let W = l, Y = u; W !== d; W += D) {
          let q = this.image.get(m ? Y : W, m ? W : Y)
          if ((q !== j && (B++, (j = q)), (C += v), C > 0)) {
            if (Y === g) break
            ;((Y += T), (C -= b))
          }
        }
        return B
      }
    }
    class ni {
      constructor() {
        this.decoder = new pb()
      }
      decode(s, a = null) {
        let l, u
        if (a != null && a.has(z.PURE_BARCODE)) {
          const v = ni.extractPureBits(s.getBlackMatrix())
          ;((l = this.decoder.decode(v)), (u = ni.NO_POINTS))
        } else {
          const v = new vt(s.getBlackMatrix()).detect()
          ;((l = this.decoder.decode(v.getBits())), (u = v.getPoints()))
        }
        const d = l.getRawBytes(),
          g = new Be(l.getText(), d, 8 * d.length, u, ue.DATA_MATRIX, k.currentTimeMillis()),
          m = l.getByteSegments()
        m != null && g.putMetadata(Rt.BYTE_SEGMENTS, m)
        const b = l.getECLevel()
        return (b != null && g.putMetadata(Rt.ERROR_CORRECTION_LEVEL, b), g)
      }
      reset() {}
      static extractPureBits(s) {
        const a = s.getTopLeftOnBit(),
          l = s.getBottomRightOnBit()
        if (a == null || l == null) throw new H()
        const u = this.moduleSize(a, s)
        let d = a[1]
        const g = l[1]
        let m = a[0]
        const b = (l[0] - m + 1) / u,
          v = (g - d + 1) / u
        if (b <= 0 || v <= 0) throw new H()
        const C = u / 2
        ;((d += C), (m += C))
        const T = new Ie(b, v)
        for (let D = 0; D < v; D++) {
          const B = d + D * u
          for (let j = 0; j < b; j++) s.get(m + j * u, B) && T.set(j, D)
        }
        return T
      }
      static moduleSize(s, a) {
        const l = a.getWidth()
        let u = s[0]
        const d = s[1]
        for (; u < l && a.get(u, d); ) u++
        if (u === l) throw new H()
        const g = u - s[0]
        if (g === 0) throw new H()
        return g
      }
    }
    ni.NO_POINTS = []
    class gb extends Tt {
      constructor(s = 500) {
        super(new ni(), s)
      }
    }
    var Ks
    ;(function (_) {
      ;((_[(_.L = 0)] = 'L'), (_[(_.M = 1)] = 'M'), (_[(_.Q = 2)] = 'Q'), (_[(_.H = 3)] = 'H'))
    })(Ks || (Ks = {}))
    class qe {
      constructor(s, a, l) {
        ;((this.value = s),
          (this.stringValue = a),
          (this.bits = l),
          qe.FOR_BITS.set(l, this),
          qe.FOR_VALUE.set(s, this))
      }
      getValue() {
        return this.value
      }
      getBits() {
        return this.bits
      }
      static fromString(s) {
        switch (s) {
          case 'L':
            return qe.L
          case 'M':
            return qe.M
          case 'Q':
            return qe.Q
          case 'H':
            return qe.H
          default:
            throw new y(s + 'not available')
        }
      }
      toString() {
        return this.stringValue
      }
      equals(s) {
        if (!(s instanceof qe)) return !1
        const a = s
        return this.value === a.value
      }
      static forBits(s) {
        if (s < 0 || s >= qe.FOR_BITS.size) throw new w()
        return qe.FOR_BITS.get(s)
      }
    }
    ;((qe.FOR_BITS = new Map()),
      (qe.FOR_VALUE = new Map()),
      (qe.L = new qe(Ks.L, 'L', 1)),
      (qe.M = new qe(Ks.M, 'M', 0)),
      (qe.Q = new qe(Ks.Q, 'Q', 3)),
      (qe.H = new qe(Ks.H, 'H', 2)))
    class Zt {
      constructor(s) {
        ;((this.errorCorrectionLevel = qe.forBits((s >> 3) & 3)), (this.dataMask = s & 7))
      }
      static numBitsDiffering(s, a) {
        return M.bitCount(s ^ a)
      }
      static decodeFormatInformation(s, a) {
        const l = Zt.doDecodeFormatInformation(s, a)
        return l !== null
          ? l
          : Zt.doDecodeFormatInformation(s ^ Zt.FORMAT_INFO_MASK_QR, a ^ Zt.FORMAT_INFO_MASK_QR)
      }
      static doDecodeFormatInformation(s, a) {
        let l = Number.MAX_SAFE_INTEGER,
          u = 0
        for (const d of Zt.FORMAT_INFO_DECODE_LOOKUP) {
          const g = d[0]
          if (g === s || g === a) return new Zt(d[1])
          let m = Zt.numBitsDiffering(s, g)
          ;(m < l && ((u = d[1]), (l = m)),
            s !== a && ((m = Zt.numBitsDiffering(a, g)), m < l && ((u = d[1]), (l = m))))
        }
        return l <= 3 ? new Zt(u) : null
      }
      getErrorCorrectionLevel() {
        return this.errorCorrectionLevel
      }
      getDataMask() {
        return this.dataMask
      }
      hashCode() {
        return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask
      }
      equals(s) {
        if (!(s instanceof Zt)) return !1
        const a = s
        return this.errorCorrectionLevel === a.errorCorrectionLevel && this.dataMask === a.dataMask
      }
    }
    ;((Zt.FORMAT_INFO_MASK_QR = 21522),
      (Zt.FORMAT_INFO_DECODE_LOOKUP = [
        Int32Array.from([21522, 0]),
        Int32Array.from([20773, 1]),
        Int32Array.from([24188, 2]),
        Int32Array.from([23371, 3]),
        Int32Array.from([17913, 4]),
        Int32Array.from([16590, 5]),
        Int32Array.from([20375, 6]),
        Int32Array.from([19104, 7]),
        Int32Array.from([30660, 8]),
        Int32Array.from([29427, 9]),
        Int32Array.from([32170, 10]),
        Int32Array.from([30877, 11]),
        Int32Array.from([26159, 12]),
        Int32Array.from([25368, 13]),
        Int32Array.from([27713, 14]),
        Int32Array.from([26998, 15]),
        Int32Array.from([5769, 16]),
        Int32Array.from([5054, 17]),
        Int32Array.from([7399, 18]),
        Int32Array.from([6608, 19]),
        Int32Array.from([1890, 20]),
        Int32Array.from([597, 21]),
        Int32Array.from([3340, 22]),
        Int32Array.from([2107, 23]),
        Int32Array.from([13663, 24]),
        Int32Array.from([12392, 25]),
        Int32Array.from([16177, 26]),
        Int32Array.from([14854, 27]),
        Int32Array.from([9396, 28]),
        Int32Array.from([8579, 29]),
        Int32Array.from([11994, 30]),
        Int32Array.from([11245, 31]),
      ]))
    class G {
      constructor(s, ...a) {
        ;((this.ecCodewordsPerBlock = s), (this.ecBlocks = a))
      }
      getECCodewordsPerBlock() {
        return this.ecCodewordsPerBlock
      }
      getNumBlocks() {
        let s = 0
        const a = this.ecBlocks
        for (const l of a) s += l.getCount()
        return s
      }
      getTotalECCodewords() {
        return this.ecCodewordsPerBlock * this.getNumBlocks()
      }
      getECBlocks() {
        return this.ecBlocks
      }
    }
    class L {
      constructor(s, a) {
        ;((this.count = s), (this.dataCodewords = a))
      }
      getCount() {
        return this.count
      }
      getDataCodewords() {
        return this.dataCodewords
      }
    }
    class de {
      constructor(s, a, ...l) {
        ;((this.versionNumber = s), (this.alignmentPatternCenters = a), (this.ecBlocks = l))
        let u = 0
        const d = l[0].getECCodewordsPerBlock(),
          g = l[0].getECBlocks()
        for (const m of g) u += m.getCount() * (m.getDataCodewords() + d)
        this.totalCodewords = u
      }
      getVersionNumber() {
        return this.versionNumber
      }
      getAlignmentPatternCenters() {
        return this.alignmentPatternCenters
      }
      getTotalCodewords() {
        return this.totalCodewords
      }
      getDimensionForVersion() {
        return 17 + 4 * this.versionNumber
      }
      getECBlocksForLevel(s) {
        return this.ecBlocks[s.getValue()]
      }
      static getProvisionalVersionForDimension(s) {
        if (s % 4 !== 1) throw new V()
        try {
          return this.getVersionForNumber((s - 17) / 4)
        } catch {
          throw new V()
        }
      }
      static getVersionForNumber(s) {
        if (s < 1 || s > 40) throw new w()
        return de.VERSIONS[s - 1]
      }
      static decodeVersionInformation(s) {
        let a = Number.MAX_SAFE_INTEGER,
          l = 0
        for (let u = 0; u < de.VERSION_DECODE_INFO.length; u++) {
          const d = de.VERSION_DECODE_INFO[u]
          if (d === s) return de.getVersionForNumber(u + 7)
          const g = Zt.numBitsDiffering(s, d)
          g < a && ((l = u + 7), (a = g))
        }
        return a <= 3 ? de.getVersionForNumber(l) : null
      }
      buildFunctionPattern() {
        const s = this.getDimensionForVersion(),
          a = new Ie(s)
        ;(a.setRegion(0, 0, 9, 9), a.setRegion(s - 8, 0, 8, 9), a.setRegion(0, s - 8, 9, 8))
        const l = this.alignmentPatternCenters.length
        for (let u = 0; u < l; u++) {
          const d = this.alignmentPatternCenters[u] - 2
          for (let g = 0; g < l; g++)
            (u === 0 && (g === 0 || g === l - 1)) ||
              (u === l - 1 && g === 0) ||
              a.setRegion(this.alignmentPatternCenters[g] - 2, d, 5, 5)
        }
        return (
          a.setRegion(6, 9, 1, s - 17),
          a.setRegion(9, 6, s - 17, 1),
          this.versionNumber > 6 && (a.setRegion(s - 11, 0, 3, 6), a.setRegion(0, s - 11, 6, 3)),
          a
        )
      }
      toString() {
        return '' + this.versionNumber
      }
    }
    ;((de.VERSION_DECODE_INFO = Int32Array.from([
      31892, 34236, 39577, 42195, 48118, 51042, 55367, 58893, 63784, 68472, 70749, 76311, 79154,
      84390, 87683, 92361, 96236, 102084, 102881, 110507, 110734, 117786, 119615, 126325, 127568,
      133589, 136944, 141498, 145311, 150283, 152622, 158308, 161089, 167017,
    ])),
      (de.VERSIONS = [
        new de(
          1,
          new Int32Array(0),
          new G(7, new L(1, 19)),
          new G(10, new L(1, 16)),
          new G(13, new L(1, 13)),
          new G(17, new L(1, 9))
        ),
        new de(
          2,
          Int32Array.from([6, 18]),
          new G(10, new L(1, 34)),
          new G(16, new L(1, 28)),
          new G(22, new L(1, 22)),
          new G(28, new L(1, 16))
        ),
        new de(
          3,
          Int32Array.from([6, 22]),
          new G(15, new L(1, 55)),
          new G(26, new L(1, 44)),
          new G(18, new L(2, 17)),
          new G(22, new L(2, 13))
        ),
        new de(
          4,
          Int32Array.from([6, 26]),
          new G(20, new L(1, 80)),
          new G(18, new L(2, 32)),
          new G(26, new L(2, 24)),
          new G(16, new L(4, 9))
        ),
        new de(
          5,
          Int32Array.from([6, 30]),
          new G(26, new L(1, 108)),
          new G(24, new L(2, 43)),
          new G(18, new L(2, 15), new L(2, 16)),
          new G(22, new L(2, 11), new L(2, 12))
        ),
        new de(
          6,
          Int32Array.from([6, 34]),
          new G(18, new L(2, 68)),
          new G(16, new L(4, 27)),
          new G(24, new L(4, 19)),
          new G(28, new L(4, 15))
        ),
        new de(
          7,
          Int32Array.from([6, 22, 38]),
          new G(20, new L(2, 78)),
          new G(18, new L(4, 31)),
          new G(18, new L(2, 14), new L(4, 15)),
          new G(26, new L(4, 13), new L(1, 14))
        ),
        new de(
          8,
          Int32Array.from([6, 24, 42]),
          new G(24, new L(2, 97)),
          new G(22, new L(2, 38), new L(2, 39)),
          new G(22, new L(4, 18), new L(2, 19)),
          new G(26, new L(4, 14), new L(2, 15))
        ),
        new de(
          9,
          Int32Array.from([6, 26, 46]),
          new G(30, new L(2, 116)),
          new G(22, new L(3, 36), new L(2, 37)),
          new G(20, new L(4, 16), new L(4, 17)),
          new G(24, new L(4, 12), new L(4, 13))
        ),
        new de(
          10,
          Int32Array.from([6, 28, 50]),
          new G(18, new L(2, 68), new L(2, 69)),
          new G(26, new L(4, 43), new L(1, 44)),
          new G(24, new L(6, 19), new L(2, 20)),
          new G(28, new L(6, 15), new L(2, 16))
        ),
        new de(
          11,
          Int32Array.from([6, 30, 54]),
          new G(20, new L(4, 81)),
          new G(30, new L(1, 50), new L(4, 51)),
          new G(28, new L(4, 22), new L(4, 23)),
          new G(24, new L(3, 12), new L(8, 13))
        ),
        new de(
          12,
          Int32Array.from([6, 32, 58]),
          new G(24, new L(2, 92), new L(2, 93)),
          new G(22, new L(6, 36), new L(2, 37)),
          new G(26, new L(4, 20), new L(6, 21)),
          new G(28, new L(7, 14), new L(4, 15))
        ),
        new de(
          13,
          Int32Array.from([6, 34, 62]),
          new G(26, new L(4, 107)),
          new G(22, new L(8, 37), new L(1, 38)),
          new G(24, new L(8, 20), new L(4, 21)),
          new G(22, new L(12, 11), new L(4, 12))
        ),
        new de(
          14,
          Int32Array.from([6, 26, 46, 66]),
          new G(30, new L(3, 115), new L(1, 116)),
          new G(24, new L(4, 40), new L(5, 41)),
          new G(20, new L(11, 16), new L(5, 17)),
          new G(24, new L(11, 12), new L(5, 13))
        ),
        new de(
          15,
          Int32Array.from([6, 26, 48, 70]),
          new G(22, new L(5, 87), new L(1, 88)),
          new G(24, new L(5, 41), new L(5, 42)),
          new G(30, new L(5, 24), new L(7, 25)),
          new G(24, new L(11, 12), new L(7, 13))
        ),
        new de(
          16,
          Int32Array.from([6, 26, 50, 74]),
          new G(24, new L(5, 98), new L(1, 99)),
          new G(28, new L(7, 45), new L(3, 46)),
          new G(24, new L(15, 19), new L(2, 20)),
          new G(30, new L(3, 15), new L(13, 16))
        ),
        new de(
          17,
          Int32Array.from([6, 30, 54, 78]),
          new G(28, new L(1, 107), new L(5, 108)),
          new G(28, new L(10, 46), new L(1, 47)),
          new G(28, new L(1, 22), new L(15, 23)),
          new G(28, new L(2, 14), new L(17, 15))
        ),
        new de(
          18,
          Int32Array.from([6, 30, 56, 82]),
          new G(30, new L(5, 120), new L(1, 121)),
          new G(26, new L(9, 43), new L(4, 44)),
          new G(28, new L(17, 22), new L(1, 23)),
          new G(28, new L(2, 14), new L(19, 15))
        ),
        new de(
          19,
          Int32Array.from([6, 30, 58, 86]),
          new G(28, new L(3, 113), new L(4, 114)),
          new G(26, new L(3, 44), new L(11, 45)),
          new G(26, new L(17, 21), new L(4, 22)),
          new G(26, new L(9, 13), new L(16, 14))
        ),
        new de(
          20,
          Int32Array.from([6, 34, 62, 90]),
          new G(28, new L(3, 107), new L(5, 108)),
          new G(26, new L(3, 41), new L(13, 42)),
          new G(30, new L(15, 24), new L(5, 25)),
          new G(28, new L(15, 15), new L(10, 16))
        ),
        new de(
          21,
          Int32Array.from([6, 28, 50, 72, 94]),
          new G(28, new L(4, 116), new L(4, 117)),
          new G(26, new L(17, 42)),
          new G(28, new L(17, 22), new L(6, 23)),
          new G(30, new L(19, 16), new L(6, 17))
        ),
        new de(
          22,
          Int32Array.from([6, 26, 50, 74, 98]),
          new G(28, new L(2, 111), new L(7, 112)),
          new G(28, new L(17, 46)),
          new G(30, new L(7, 24), new L(16, 25)),
          new G(24, new L(34, 13))
        ),
        new de(
          23,
          Int32Array.from([6, 30, 54, 78, 102]),
          new G(30, new L(4, 121), new L(5, 122)),
          new G(28, new L(4, 47), new L(14, 48)),
          new G(30, new L(11, 24), new L(14, 25)),
          new G(30, new L(16, 15), new L(14, 16))
        ),
        new de(
          24,
          Int32Array.from([6, 28, 54, 80, 106]),
          new G(30, new L(6, 117), new L(4, 118)),
          new G(28, new L(6, 45), new L(14, 46)),
          new G(30, new L(11, 24), new L(16, 25)),
          new G(30, new L(30, 16), new L(2, 17))
        ),
        new de(
          25,
          Int32Array.from([6, 32, 58, 84, 110]),
          new G(26, new L(8, 106), new L(4, 107)),
          new G(28, new L(8, 47), new L(13, 48)),
          new G(30, new L(7, 24), new L(22, 25)),
          new G(30, new L(22, 15), new L(13, 16))
        ),
        new de(
          26,
          Int32Array.from([6, 30, 58, 86, 114]),
          new G(28, new L(10, 114), new L(2, 115)),
          new G(28, new L(19, 46), new L(4, 47)),
          new G(28, new L(28, 22), new L(6, 23)),
          new G(30, new L(33, 16), new L(4, 17))
        ),
        new de(
          27,
          Int32Array.from([6, 34, 62, 90, 118]),
          new G(30, new L(8, 122), new L(4, 123)),
          new G(28, new L(22, 45), new L(3, 46)),
          new G(30, new L(8, 23), new L(26, 24)),
          new G(30, new L(12, 15), new L(28, 16))
        ),
        new de(
          28,
          Int32Array.from([6, 26, 50, 74, 98, 122]),
          new G(30, new L(3, 117), new L(10, 118)),
          new G(28, new L(3, 45), new L(23, 46)),
          new G(30, new L(4, 24), new L(31, 25)),
          new G(30, new L(11, 15), new L(31, 16))
        ),
        new de(
          29,
          Int32Array.from([6, 30, 54, 78, 102, 126]),
          new G(30, new L(7, 116), new L(7, 117)),
          new G(28, new L(21, 45), new L(7, 46)),
          new G(30, new L(1, 23), new L(37, 24)),
          new G(30, new L(19, 15), new L(26, 16))
        ),
        new de(
          30,
          Int32Array.from([6, 26, 52, 78, 104, 130]),
          new G(30, new L(5, 115), new L(10, 116)),
          new G(28, new L(19, 47), new L(10, 48)),
          new G(30, new L(15, 24), new L(25, 25)),
          new G(30, new L(23, 15), new L(25, 16))
        ),
        new de(
          31,
          Int32Array.from([6, 30, 56, 82, 108, 134]),
          new G(30, new L(13, 115), new L(3, 116)),
          new G(28, new L(2, 46), new L(29, 47)),
          new G(30, new L(42, 24), new L(1, 25)),
          new G(30, new L(23, 15), new L(28, 16))
        ),
        new de(
          32,
          Int32Array.from([6, 34, 60, 86, 112, 138]),
          new G(30, new L(17, 115)),
          new G(28, new L(10, 46), new L(23, 47)),
          new G(30, new L(10, 24), new L(35, 25)),
          new G(30, new L(19, 15), new L(35, 16))
        ),
        new de(
          33,
          Int32Array.from([6, 30, 58, 86, 114, 142]),
          new G(30, new L(17, 115), new L(1, 116)),
          new G(28, new L(14, 46), new L(21, 47)),
          new G(30, new L(29, 24), new L(19, 25)),
          new G(30, new L(11, 15), new L(46, 16))
        ),
        new de(
          34,
          Int32Array.from([6, 34, 62, 90, 118, 146]),
          new G(30, new L(13, 115), new L(6, 116)),
          new G(28, new L(14, 46), new L(23, 47)),
          new G(30, new L(44, 24), new L(7, 25)),
          new G(30, new L(59, 16), new L(1, 17))
        ),
        new de(
          35,
          Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
          new G(30, new L(12, 121), new L(7, 122)),
          new G(28, new L(12, 47), new L(26, 48)),
          new G(30, new L(39, 24), new L(14, 25)),
          new G(30, new L(22, 15), new L(41, 16))
        ),
        new de(
          36,
          Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
          new G(30, new L(6, 121), new L(14, 122)),
          new G(28, new L(6, 47), new L(34, 48)),
          new G(30, new L(46, 24), new L(10, 25)),
          new G(30, new L(2, 15), new L(64, 16))
        ),
        new de(
          37,
          Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
          new G(30, new L(17, 122), new L(4, 123)),
          new G(28, new L(29, 46), new L(14, 47)),
          new G(30, new L(49, 24), new L(10, 25)),
          new G(30, new L(24, 15), new L(46, 16))
        ),
        new de(
          38,
          Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
          new G(30, new L(4, 122), new L(18, 123)),
          new G(28, new L(13, 46), new L(32, 47)),
          new G(30, new L(48, 24), new L(14, 25)),
          new G(30, new L(42, 15), new L(32, 16))
        ),
        new de(
          39,
          Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
          new G(30, new L(20, 117), new L(4, 118)),
          new G(28, new L(40, 47), new L(7, 48)),
          new G(30, new L(43, 24), new L(22, 25)),
          new G(30, new L(10, 15), new L(67, 16))
        ),
        new de(
          40,
          Int32Array.from([6, 30, 58, 86, 114, 142, 170]),
          new G(30, new L(19, 118), new L(6, 119)),
          new G(28, new L(18, 47), new L(31, 48)),
          new G(30, new L(34, 24), new L(34, 25)),
          new G(30, new L(20, 15), new L(61, 16))
        ),
      ]))
    var Mt
    ;(function (_) {
      ;((_[(_.DATA_MASK_000 = 0)] = 'DATA_MASK_000'),
        (_[(_.DATA_MASK_001 = 1)] = 'DATA_MASK_001'),
        (_[(_.DATA_MASK_010 = 2)] = 'DATA_MASK_010'),
        (_[(_.DATA_MASK_011 = 3)] = 'DATA_MASK_011'),
        (_[(_.DATA_MASK_100 = 4)] = 'DATA_MASK_100'),
        (_[(_.DATA_MASK_101 = 5)] = 'DATA_MASK_101'),
        (_[(_.DATA_MASK_110 = 6)] = 'DATA_MASK_110'),
        (_[(_.DATA_MASK_111 = 7)] = 'DATA_MASK_111'))
    })(Mt || (Mt = {}))
    class Un {
      constructor(s, a) {
        ;((this.value = s), (this.isMasked = a))
      }
      unmaskBitMatrix(s, a) {
        for (let l = 0; l < a; l++) for (let u = 0; u < a; u++) this.isMasked(l, u) && s.flip(u, l)
      }
    }
    Un.values = new Map([
      [Mt.DATA_MASK_000, new Un(Mt.DATA_MASK_000, (_, s) => ((_ + s) & 1) === 0)],
      [Mt.DATA_MASK_001, new Un(Mt.DATA_MASK_001, (_, s) => (_ & 1) === 0)],
      [Mt.DATA_MASK_010, new Un(Mt.DATA_MASK_010, (_, s) => s % 3 === 0)],
      [Mt.DATA_MASK_011, new Un(Mt.DATA_MASK_011, (_, s) => (_ + s) % 3 === 0)],
      [
        Mt.DATA_MASK_100,
        new Un(Mt.DATA_MASK_100, (_, s) => ((Math.floor(_ / 2) + Math.floor(s / 3)) & 1) === 0),
      ],
      [Mt.DATA_MASK_101, new Un(Mt.DATA_MASK_101, (_, s) => (_ * s) % 6 === 0)],
      [Mt.DATA_MASK_110, new Un(Mt.DATA_MASK_110, (_, s) => (_ * s) % 6 < 3)],
      [Mt.DATA_MASK_111, new Un(Mt.DATA_MASK_111, (_, s) => ((_ + s + ((_ * s) % 3)) & 1) === 0)],
    ])
    class mb {
      constructor(s) {
        const a = s.getHeight()
        if (a < 21 || (a & 3) !== 1) throw new V()
        this.bitMatrix = s
      }
      readFormatInformation() {
        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== void 0)
          return this.parsedFormatInfo
        let s = 0
        for (let d = 0; d < 6; d++) s = this.copyBit(d, 8, s)
        ;((s = this.copyBit(7, 8, s)), (s = this.copyBit(8, 8, s)), (s = this.copyBit(8, 7, s)))
        for (let d = 5; d >= 0; d--) s = this.copyBit(8, d, s)
        const a = this.bitMatrix.getHeight()
        let l = 0
        const u = a - 7
        for (let d = a - 1; d >= u; d--) l = this.copyBit(8, d, l)
        for (let d = a - 8; d < a; d++) l = this.copyBit(d, 8, l)
        if (
          ((this.parsedFormatInfo = Zt.decodeFormatInformation(s, l)),
          this.parsedFormatInfo !== null)
        )
          return this.parsedFormatInfo
        throw new V()
      }
      readVersion() {
        if (this.parsedVersion !== null && this.parsedVersion !== void 0) return this.parsedVersion
        const s = this.bitMatrix.getHeight(),
          a = Math.floor((s - 17) / 4)
        if (a <= 6) return de.getVersionForNumber(a)
        let l = 0
        const u = s - 11
        for (let g = 5; g >= 0; g--) for (let m = s - 9; m >= u; m--) l = this.copyBit(m, g, l)
        let d = de.decodeVersionInformation(l)
        if (d !== null && d.getDimensionForVersion() === s) return ((this.parsedVersion = d), d)
        l = 0
        for (let g = 5; g >= 0; g--) for (let m = s - 9; m >= u; m--) l = this.copyBit(g, m, l)
        if (((d = de.decodeVersionInformation(l)), d !== null && d.getDimensionForVersion() === s))
          return ((this.parsedVersion = d), d)
        throw new V()
      }
      copyBit(s, a, l) {
        return (this.isMirror ? this.bitMatrix.get(a, s) : this.bitMatrix.get(s, a))
          ? (l << 1) | 1
          : l << 1
      }
      readCodewords() {
        const s = this.readFormatInformation(),
          a = this.readVersion(),
          l = Un.values.get(s.getDataMask()),
          u = this.bitMatrix.getHeight()
        l.unmaskBitMatrix(this.bitMatrix, u)
        const d = a.buildFunctionPattern()
        let g = !0
        const m = new Uint8Array(a.getTotalCodewords())
        let b = 0,
          v = 0,
          C = 0
        for (let T = u - 1; T > 0; T -= 2) {
          T === 6 && T--
          for (let D = 0; D < u; D++) {
            const B = g ? u - 1 - D : D
            for (let j = 0; j < 2; j++)
              d.get(T - j, B) ||
                (C++,
                (v <<= 1),
                this.bitMatrix.get(T - j, B) && (v |= 1),
                C === 8 && ((m[b++] = v), (C = 0), (v = 0)))
          }
          g = !g
        }
        if (b !== a.getTotalCodewords()) throw new V()
        return m
      }
      remask() {
        if (this.parsedFormatInfo === null) return
        const s = Un.values[this.parsedFormatInfo.getDataMask()],
          a = this.bitMatrix.getHeight()
        s.unmaskBitMatrix(this.bitMatrix, a)
      }
      setMirror(s) {
        ;((this.parsedVersion = null), (this.parsedFormatInfo = null), (this.isMirror = s))
      }
      mirror() {
        const s = this.bitMatrix
        for (let a = 0, l = s.getWidth(); a < l; a++)
          for (let u = a + 1, d = s.getHeight(); u < d; u++)
            s.get(a, u) !== s.get(u, a) && (s.flip(u, a), s.flip(a, u))
      }
    }
    class Oh {
      constructor(s, a) {
        ;((this.numDataCodewords = s), (this.codewords = a))
      }
      static getDataBlocks(s, a, l) {
        if (s.length !== a.getTotalCodewords()) throw new w()
        const u = a.getECBlocksForLevel(l)
        let d = 0
        const g = u.getECBlocks()
        for (const j of g) d += j.getCount()
        const m = new Array(d)
        let b = 0
        for (const j of g)
          for (let W = 0; W < j.getCount(); W++) {
            const Y = j.getDataCodewords(),
              q = u.getECCodewordsPerBlock() + Y
            m[b++] = new Oh(Y, new Uint8Array(q))
          }
        const v = m[0].codewords.length
        let C = m.length - 1
        for (; C >= 0 && m[C].codewords.length !== v; ) C--
        C++
        const T = v - u.getECCodewordsPerBlock()
        let D = 0
        for (let j = 0; j < T; j++) for (let W = 0; W < b; W++) m[W].codewords[j] = s[D++]
        for (let j = C; j < b; j++) m[j].codewords[T] = s[D++]
        const B = m[0].codewords.length
        for (let j = T; j < B; j++)
          for (let W = 0; W < b; W++) {
            const Y = W < C ? j : j + 1
            m[W].codewords[Y] = s[D++]
          }
        return m
      }
      getNumDataCodewords() {
        return this.numDataCodewords
      }
      getCodewords() {
        return this.codewords
      }
    }
    var Wn
    ;(function (_) {
      ;((_[(_.TERMINATOR = 0)] = 'TERMINATOR'),
        (_[(_.NUMERIC = 1)] = 'NUMERIC'),
        (_[(_.ALPHANUMERIC = 2)] = 'ALPHANUMERIC'),
        (_[(_.STRUCTURED_APPEND = 3)] = 'STRUCTURED_APPEND'),
        (_[(_.BYTE = 4)] = 'BYTE'),
        (_[(_.ECI = 5)] = 'ECI'),
        (_[(_.KANJI = 6)] = 'KANJI'),
        (_[(_.FNC1_FIRST_POSITION = 7)] = 'FNC1_FIRST_POSITION'),
        (_[(_.FNC1_SECOND_POSITION = 8)] = 'FNC1_SECOND_POSITION'),
        (_[(_.HANZI = 9)] = 'HANZI'))
    })(Wn || (Wn = {}))
    class me {
      constructor(s, a, l, u) {
        ;((this.value = s),
          (this.stringValue = a),
          (this.characterCountBitsForVersions = l),
          (this.bits = u),
          me.FOR_BITS.set(u, this),
          me.FOR_VALUE.set(s, this))
      }
      static forBits(s) {
        const a = me.FOR_BITS.get(s)
        if (a === void 0) throw new w()
        return a
      }
      getCharacterCountBits(s) {
        const a = s.getVersionNumber()
        let l
        return (
          a <= 9 ? (l = 0) : a <= 26 ? (l = 1) : (l = 2),
          this.characterCountBitsForVersions[l]
        )
      }
      getValue() {
        return this.value
      }
      getBits() {
        return this.bits
      }
      equals(s) {
        if (!(s instanceof me)) return !1
        const a = s
        return this.value === a.value
      }
      toString() {
        return this.stringValue
      }
    }
    ;((me.FOR_BITS = new Map()),
      (me.FOR_VALUE = new Map()),
      (me.TERMINATOR = new me(Wn.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0)),
      (me.NUMERIC = new me(Wn.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 1)),
      (me.ALPHANUMERIC = new me(Wn.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 2)),
      (me.STRUCTURED_APPEND = new me(
        Wn.STRUCTURED_APPEND,
        'STRUCTURED_APPEND',
        Int32Array.from([0, 0, 0]),
        3
      )),
      (me.BYTE = new me(Wn.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 4)),
      (me.ECI = new me(Wn.ECI, 'ECI', Int32Array.from([0, 0, 0]), 7)),
      (me.KANJI = new me(Wn.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 8)),
      (me.FNC1_FIRST_POSITION = new me(
        Wn.FNC1_FIRST_POSITION,
        'FNC1_FIRST_POSITION',
        Int32Array.from([0, 0, 0]),
        5
      )),
      (me.FNC1_SECOND_POSITION = new me(
        Wn.FNC1_SECOND_POSITION,
        'FNC1_SECOND_POSITION',
        Int32Array.from([0, 0, 0]),
        9
      )),
      (me.HANZI = new me(Wn.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 13)))
    class ot {
      static decode(s, a, l, u) {
        const d = new Lh(s)
        let g = new ve()
        const m = new Array()
        let b = -1,
          v = -1
        try {
          let C = null,
            T = !1,
            D
          do {
            if (d.available() < 4) D = me.TERMINATOR
            else {
              const B = d.readBits(4)
              D = me.forBits(B)
            }
            switch (D) {
              case me.TERMINATOR:
                break
              case me.FNC1_FIRST_POSITION:
              case me.FNC1_SECOND_POSITION:
                T = !0
                break
              case me.STRUCTURED_APPEND:
                if (d.available() < 16) throw new V()
                ;((b = d.readBits(8)), (v = d.readBits(8)))
                break
              case me.ECI:
                const B = ot.parseECIValue(d)
                if (((C = Z.getCharacterSetECIByValue(B)), C === null)) throw new V()
                break
              case me.HANZI:
                const j = d.readBits(4),
                  W = d.readBits(D.getCharacterCountBits(a))
                j === ot.GB2312_SUBSET && ot.decodeHanziSegment(d, g, W)
                break
              default:
                const Y = d.readBits(D.getCharacterCountBits(a))
                switch (D) {
                  case me.NUMERIC:
                    ot.decodeNumericSegment(d, g, Y)
                    break
                  case me.ALPHANUMERIC:
                    ot.decodeAlphanumericSegment(d, g, Y, T)
                    break
                  case me.BYTE:
                    ot.decodeByteSegment(d, g, Y, C, m, u)
                    break
                  case me.KANJI:
                    ot.decodeKanjiSegment(d, g, Y)
                    break
                  default:
                    throw new V()
                }
                break
            }
          } while (D !== me.TERMINATOR)
        } catch {
          throw new V()
        }
        return new Jo(
          s,
          g.toString(),
          m.length === 0 ? null : m,
          l === null ? null : l.toString(),
          b,
          v
        )
      }
      static decodeHanziSegment(s, a, l) {
        if (l * 13 > s.available()) throw new V()
        const u = new Uint8Array(2 * l)
        let d = 0
        for (; l > 0; ) {
          const g = s.readBits(13)
          let m = (((g / 96) << 8) & 4294967295) | g % 96
          ;(m < 959 ? (m += 41377) : (m += 42657),
            (u[d] = (m >> 8) & 255),
            (u[d + 1] = m & 255),
            (d += 2),
            l--)
        }
        try {
          a.append(oe.decode(u, re.GB2312))
        } catch (g) {
          throw new V(g)
        }
      }
      static decodeKanjiSegment(s, a, l) {
        if (l * 13 > s.available()) throw new V()
        const u = new Uint8Array(2 * l)
        let d = 0
        for (; l > 0; ) {
          const g = s.readBits(13)
          let m = (((g / 192) << 8) & 4294967295) | g % 192
          ;(m < 7936 ? (m += 33088) : (m += 49472), (u[d] = m >> 8), (u[d + 1] = m), (d += 2), l--)
        }
        try {
          a.append(oe.decode(u, re.SHIFT_JIS))
        } catch (g) {
          throw new V(g)
        }
      }
      static decodeByteSegment(s, a, l, u, d, g) {
        if (8 * l > s.available()) throw new V()
        const m = new Uint8Array(l)
        for (let v = 0; v < l; v++) m[v] = s.readBits(8)
        let b
        u === null ? (b = re.guessEncoding(m, g)) : (b = u.getName())
        try {
          a.append(oe.decode(m, b))
        } catch (v) {
          throw new V(v)
        }
        d.push(m)
      }
      static toAlphaNumericChar(s) {
        if (s >= ot.ALPHANUMERIC_CHARS.length) throw new V()
        return ot.ALPHANUMERIC_CHARS[s]
      }
      static decodeAlphanumericSegment(s, a, l, u) {
        const d = a.length()
        for (; l > 1; ) {
          if (s.available() < 11) throw new V()
          const g = s.readBits(11)
          ;(a.append(ot.toAlphaNumericChar(Math.floor(g / 45))),
            a.append(ot.toAlphaNumericChar(g % 45)),
            (l -= 2))
        }
        if (l === 1) {
          if (s.available() < 6) throw new V()
          a.append(ot.toAlphaNumericChar(s.readBits(6)))
        }
        if (u)
          for (let g = d; g < a.length(); g++)
            a.charAt(g) === '%' &&
              (g < a.length() - 1 && a.charAt(g + 1) === '%'
                ? a.deleteCharAt(g + 1)
                : a.setCharAt(g, ''))
      }
      static decodeNumericSegment(s, a, l) {
        for (; l >= 3; ) {
          if (s.available() < 10) throw new V()
          const u = s.readBits(10)
          if (u >= 1e3) throw new V()
          ;(a.append(ot.toAlphaNumericChar(Math.floor(u / 100))),
            a.append(ot.toAlphaNumericChar(Math.floor(u / 10) % 10)),
            a.append(ot.toAlphaNumericChar(u % 10)),
            (l -= 3))
        }
        if (l === 2) {
          if (s.available() < 7) throw new V()
          const u = s.readBits(7)
          if (u >= 100) throw new V()
          ;(a.append(ot.toAlphaNumericChar(Math.floor(u / 10))),
            a.append(ot.toAlphaNumericChar(u % 10)))
        } else if (l === 1) {
          if (s.available() < 4) throw new V()
          const u = s.readBits(4)
          if (u >= 10) throw new V()
          a.append(ot.toAlphaNumericChar(u))
        }
      }
      static parseECIValue(s) {
        const a = s.readBits(8)
        if (!(a & 128)) return a & 127
        if ((a & 192) === 128) {
          const l = s.readBits(8)
          return (((a & 63) << 8) & 4294967295) | l
        }
        if ((a & 224) === 192) {
          const l = s.readBits(16)
          return (((a & 31) << 16) & 4294967295) | l
        }
        throw new V()
      }
    }
    ;((ot.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'),
      (ot.GB2312_SUBSET = 1))
    class Ap {
      constructor(s) {
        this.mirrored = s
      }
      isMirrored() {
        return this.mirrored
      }
      applyMirroredCorrection(s) {
        if (!this.mirrored || s === null || s.length < 3) return
        const a = s[0]
        ;((s[0] = s[2]), (s[2] = a))
      }
    }
    class yb {
      constructor() {
        this.rsDecoder = new ta(Fe.QR_CODE_FIELD_256)
      }
      decodeBooleanArray(s, a) {
        return this.decodeBitMatrix(Ie.parseFromBooleanArray(s), a)
      }
      decodeBitMatrix(s, a) {
        const l = new mb(s)
        let u = null
        try {
          return this.decodeBitMatrixParser(l, a)
        } catch (d) {
          u = d
        }
        try {
          ;(l.remask(), l.setMirror(!0), l.readVersion(), l.readFormatInformation(), l.mirror())
          const d = this.decodeBitMatrixParser(l, a)
          return (d.setOther(new Ap(!0)), d)
        } catch (d) {
          throw u !== null ? u : d
        }
      }
      decodeBitMatrixParser(s, a) {
        const l = s.readVersion(),
          u = s.readFormatInformation().getErrorCorrectionLevel(),
          d = s.readCodewords(),
          g = Oh.getDataBlocks(d, l, u)
        let m = 0
        for (const C of g) m += C.getNumDataCodewords()
        const b = new Uint8Array(m)
        let v = 0
        for (const C of g) {
          const T = C.getCodewords(),
            D = C.getNumDataCodewords()
          this.correctErrors(T, D)
          for (let B = 0; B < D; B++) b[v++] = T[B]
        }
        return ot.decode(b, l, u, a)
      }
      correctErrors(s, a) {
        const l = new Int32Array(s)
        try {
          this.rsDecoder.decode(l, s.length - a)
        } catch {
          throw new E()
        }
        for (let u = 0; u < a; u++) s[u] = l[u]
      }
    }
    class Bh extends he {
      constructor(s, a, l) {
        ;(super(s, a), (this.estimatedModuleSize = l))
      }
      aboutEquals(s, a, l) {
        if (Math.abs(a - this.getY()) <= s && Math.abs(l - this.getX()) <= s) {
          const u = Math.abs(s - this.estimatedModuleSize)
          return u <= 1 || u <= this.estimatedModuleSize
        }
        return !1
      }
      combineEstimate(s, a, l) {
        const u = (this.getX() + a) / 2,
          d = (this.getY() + s) / 2,
          g = (this.estimatedModuleSize + l) / 2
        return new Bh(u, d, g)
      }
    }
    class ql {
      constructor(s, a, l, u, d, g, m) {
        ;((this.image = s),
          (this.startX = a),
          (this.startY = l),
          (this.width = u),
          (this.height = d),
          (this.moduleSize = g),
          (this.resultPointCallback = m),
          (this.possibleCenters = []),
          (this.crossCheckStateCount = new Int32Array(3)))
      }
      find() {
        const s = this.startX,
          a = this.height,
          l = this.width,
          u = s + l,
          d = this.startY + a / 2,
          g = new Int32Array(3),
          m = this.image
        for (let b = 0; b < a; b++) {
          const v = d + (b & 1 ? -Math.floor((b + 1) / 2) : Math.floor((b + 1) / 2))
          ;((g[0] = 0), (g[1] = 0), (g[2] = 0))
          let C = s
          for (; C < u && !m.get(C, v); ) C++
          let T = 0
          for (; C < u; ) {
            if (m.get(C, v))
              if (T === 1) g[1]++
              else if (T === 2) {
                if (this.foundPatternCross(g)) {
                  const D = this.handlePossibleCenter(g, v, C)
                  if (D !== null) return D
                }
                ;((g[0] = g[2]), (g[1] = 1), (g[2] = 0), (T = 1))
              } else g[++T]++
            else (T === 1 && T++, g[T]++)
            C++
          }
          if (this.foundPatternCross(g)) {
            const D = this.handlePossibleCenter(g, v, u)
            if (D !== null) return D
          }
        }
        if (this.possibleCenters.length !== 0) return this.possibleCenters[0]
        throw new H()
      }
      static centerFromEnd(s, a) {
        return a - s[2] - s[1] / 2
      }
      foundPatternCross(s) {
        const a = this.moduleSize,
          l = a / 2
        for (let u = 0; u < 3; u++) if (Math.abs(a - s[u]) >= l) return !1
        return !0
      }
      crossCheckVertical(s, a, l, u) {
        const d = this.image,
          g = d.getHeight(),
          m = this.crossCheckStateCount
        ;((m[0] = 0), (m[1] = 0), (m[2] = 0))
        let b = s
        for (; b >= 0 && d.get(a, b) && m[1] <= l; ) (m[1]++, b--)
        if (b < 0 || m[1] > l) return NaN
        for (; b >= 0 && !d.get(a, b) && m[0] <= l; ) (m[0]++, b--)
        if (m[0] > l) return NaN
        for (b = s + 1; b < g && d.get(a, b) && m[1] <= l; ) (m[1]++, b++)
        if (b === g || m[1] > l) return NaN
        for (; b < g && !d.get(a, b) && m[2] <= l; ) (m[2]++, b++)
        if (m[2] > l) return NaN
        const v = m[0] + m[1] + m[2]
        return 5 * Math.abs(v - u) >= 2 * u
          ? NaN
          : this.foundPatternCross(m)
            ? ql.centerFromEnd(m, b)
            : NaN
      }
      handlePossibleCenter(s, a, l) {
        const u = s[0] + s[1] + s[2],
          d = ql.centerFromEnd(s, l),
          g = this.crossCheckVertical(a, d, 2 * s[1], u)
        if (!isNaN(g)) {
          const m = (s[0] + s[1] + s[2]) / 3
          for (const v of this.possibleCenters)
            if (v.aboutEquals(m, g, d)) return v.combineEstimate(g, d, m)
          const b = new Bh(d, g, m)
          ;(this.possibleCenters.push(b),
            this.resultPointCallback !== null &&
              this.resultPointCallback !== void 0 &&
              this.resultPointCallback.foundPossibleResultPoint(b))
        }
        return null
      }
    }
    class Fh extends he {
      constructor(s, a, l, u) {
        ;(super(s, a),
          (this.estimatedModuleSize = l),
          (this.count = u),
          u === void 0 && (this.count = 1))
      }
      getEstimatedModuleSize() {
        return this.estimatedModuleSize
      }
      getCount() {
        return this.count
      }
      aboutEquals(s, a, l) {
        if (Math.abs(a - this.getY()) <= s && Math.abs(l - this.getX()) <= s) {
          const u = Math.abs(s - this.estimatedModuleSize)
          return u <= 1 || u <= this.estimatedModuleSize
        }
        return !1
      }
      combineEstimate(s, a, l) {
        const u = this.count + 1,
          d = (this.count * this.getX() + a) / u,
          g = (this.count * this.getY() + s) / u,
          m = (this.count * this.estimatedModuleSize + l) / u
        return new Fh(d, g, m, u)
      }
    }
    class wb {
      constructor(s) {
        ;((this.bottomLeft = s[0]), (this.topLeft = s[1]), (this.topRight = s[2]))
      }
      getBottomLeft() {
        return this.bottomLeft
      }
      getTopLeft() {
        return this.topLeft
      }
      getTopRight() {
        return this.topRight
      }
    }
    class Pt {
      constructor(s, a) {
        ;((this.image = s),
          (this.resultPointCallback = a),
          (this.possibleCenters = []),
          (this.crossCheckStateCount = new Int32Array(5)),
          (this.resultPointCallback = a))
      }
      getImage() {
        return this.image
      }
      getPossibleCenters() {
        return this.possibleCenters
      }
      find(s) {
        const a = s != null && s.get(z.TRY_HARDER) !== void 0,
          l = s != null && s.get(z.PURE_BARCODE) !== void 0,
          u = this.image,
          d = u.getHeight(),
          g = u.getWidth()
        let m = Math.floor((3 * d) / (4 * Pt.MAX_MODULES))
        ;(m < Pt.MIN_SKIP || a) && (m = Pt.MIN_SKIP)
        let b = !1
        const v = new Int32Array(5)
        for (let T = m - 1; T < d && !b; T += m) {
          ;((v[0] = 0), (v[1] = 0), (v[2] = 0), (v[3] = 0), (v[4] = 0))
          let D = 0
          for (let B = 0; B < g; B++)
            if (u.get(B, T)) ((D & 1) === 1 && D++, v[D]++)
            else if (D & 1) v[D]++
            else if (D === 4)
              if (Pt.foundPatternCross(v)) {
                if (this.handlePossibleCenter(v, T, B, l) === !0)
                  if (((m = 2), this.hasSkipped === !0)) b = this.haveMultiplyConfirmedCenters()
                  else {
                    const j = this.findRowSkip()
                    j > v[2] && ((T += j - v[2] - m), (B = g - 1))
                  }
                else {
                  ;((v[0] = v[2]), (v[1] = v[3]), (v[2] = v[4]), (v[3] = 1), (v[4] = 0), (D = 3))
                  continue
                }
                ;((D = 0), (v[0] = 0), (v[1] = 0), (v[2] = 0), (v[3] = 0), (v[4] = 0))
              } else ((v[0] = v[2]), (v[1] = v[3]), (v[2] = v[4]), (v[3] = 1), (v[4] = 0), (D = 3))
            else v[++D]++
          Pt.foundPatternCross(v) &&
            this.handlePossibleCenter(v, T, g, l) === !0 &&
            ((m = v[0]), this.hasSkipped && (b = this.haveMultiplyConfirmedCenters()))
        }
        const C = this.selectBestPatterns()
        return (he.orderBestPatterns(C), new wb(C))
      }
      static centerFromEnd(s, a) {
        return a - s[4] - s[3] - s[2] / 2
      }
      static foundPatternCross(s) {
        let a = 0
        for (let d = 0; d < 5; d++) {
          const g = s[d]
          if (g === 0) return !1
          a += g
        }
        if (a < 7) return !1
        const l = a / 7,
          u = l / 2
        return (
          Math.abs(l - s[0]) < u &&
          Math.abs(l - s[1]) < u &&
          Math.abs(3 * l - s[2]) < 3 * u &&
          Math.abs(l - s[3]) < u &&
          Math.abs(l - s[4]) < u
        )
      }
      getCrossCheckStateCount() {
        const s = this.crossCheckStateCount
        return ((s[0] = 0), (s[1] = 0), (s[2] = 0), (s[3] = 0), (s[4] = 0), s)
      }
      crossCheckDiagonal(s, a, l, u) {
        const d = this.getCrossCheckStateCount()
        let g = 0
        const m = this.image
        for (; s >= g && a >= g && m.get(a - g, s - g); ) (d[2]++, g++)
        if (s < g || a < g) return !1
        for (; s >= g && a >= g && !m.get(a - g, s - g) && d[1] <= l; ) (d[1]++, g++)
        if (s < g || a < g || d[1] > l) return !1
        for (; s >= g && a >= g && m.get(a - g, s - g) && d[0] <= l; ) (d[0]++, g++)
        if (d[0] > l) return !1
        const b = m.getHeight(),
          v = m.getWidth()
        for (g = 1; s + g < b && a + g < v && m.get(a + g, s + g); ) (d[2]++, g++)
        if (s + g >= b || a + g >= v) return !1
        for (; s + g < b && a + g < v && !m.get(a + g, s + g) && d[3] < l; ) (d[3]++, g++)
        if (s + g >= b || a + g >= v || d[3] >= l) return !1
        for (; s + g < b && a + g < v && m.get(a + g, s + g) && d[4] < l; ) (d[4]++, g++)
        if (d[4] >= l) return !1
        const C = d[0] + d[1] + d[2] + d[3] + d[4]
        return Math.abs(C - u) < 2 * u && Pt.foundPatternCross(d)
      }
      crossCheckVertical(s, a, l, u) {
        const d = this.image,
          g = d.getHeight(),
          m = this.getCrossCheckStateCount()
        let b = s
        for (; b >= 0 && d.get(a, b); ) (m[2]++, b--)
        if (b < 0) return NaN
        for (; b >= 0 && !d.get(a, b) && m[1] <= l; ) (m[1]++, b--)
        if (b < 0 || m[1] > l) return NaN
        for (; b >= 0 && d.get(a, b) && m[0] <= l; ) (m[0]++, b--)
        if (m[0] > l) return NaN
        for (b = s + 1; b < g && d.get(a, b); ) (m[2]++, b++)
        if (b === g) return NaN
        for (; b < g && !d.get(a, b) && m[3] < l; ) (m[3]++, b++)
        if (b === g || m[3] >= l) return NaN
        for (; b < g && d.get(a, b) && m[4] < l; ) (m[4]++, b++)
        if (m[4] >= l) return NaN
        const v = m[0] + m[1] + m[2] + m[3] + m[4]
        return 5 * Math.abs(v - u) >= 2 * u
          ? NaN
          : Pt.foundPatternCross(m)
            ? Pt.centerFromEnd(m, b)
            : NaN
      }
      crossCheckHorizontal(s, a, l, u) {
        const d = this.image,
          g = d.getWidth(),
          m = this.getCrossCheckStateCount()
        let b = s
        for (; b >= 0 && d.get(b, a); ) (m[2]++, b--)
        if (b < 0) return NaN
        for (; b >= 0 && !d.get(b, a) && m[1] <= l; ) (m[1]++, b--)
        if (b < 0 || m[1] > l) return NaN
        for (; b >= 0 && d.get(b, a) && m[0] <= l; ) (m[0]++, b--)
        if (m[0] > l) return NaN
        for (b = s + 1; b < g && d.get(b, a); ) (m[2]++, b++)
        if (b === g) return NaN
        for (; b < g && !d.get(b, a) && m[3] < l; ) (m[3]++, b++)
        if (b === g || m[3] >= l) return NaN
        for (; b < g && d.get(b, a) && m[4] < l; ) (m[4]++, b++)
        if (m[4] >= l) return NaN
        const v = m[0] + m[1] + m[2] + m[3] + m[4]
        return 5 * Math.abs(v - u) >= u
          ? NaN
          : Pt.foundPatternCross(m)
            ? Pt.centerFromEnd(m, b)
            : NaN
      }
      handlePossibleCenter(s, a, l, u) {
        const d = s[0] + s[1] + s[2] + s[3] + s[4]
        let g = Pt.centerFromEnd(s, l),
          m = this.crossCheckVertical(a, Math.floor(g), s[2], d)
        if (
          !isNaN(m) &&
          ((g = this.crossCheckHorizontal(Math.floor(g), Math.floor(m), s[2], d)),
          !isNaN(g) && (!u || this.crossCheckDiagonal(Math.floor(m), Math.floor(g), s[2], d)))
        ) {
          const b = d / 7
          let v = !1
          const C = this.possibleCenters
          for (let T = 0, D = C.length; T < D; T++) {
            const B = C[T]
            if (B.aboutEquals(b, m, g)) {
              ;((C[T] = B.combineEstimate(m, g, b)), (v = !0))
              break
            }
          }
          if (!v) {
            const T = new Fh(g, m, b)
            ;(C.push(T),
              this.resultPointCallback !== null &&
                this.resultPointCallback !== void 0 &&
                this.resultPointCallback.foundPossibleResultPoint(T))
          }
          return !0
        }
        return !1
      }
      findRowSkip() {
        if (this.possibleCenters.length <= 1) return 0
        let s = null
        for (const a of this.possibleCenters)
          if (a.getCount() >= Pt.CENTER_QUORUM)
            if (s == null) s = a
            else
              return (
                (this.hasSkipped = !0),
                Math.floor((Math.abs(s.getX() - a.getX()) - Math.abs(s.getY() - a.getY())) / 2)
              )
        return 0
      }
      haveMultiplyConfirmedCenters() {
        let s = 0,
          a = 0
        const l = this.possibleCenters.length
        for (const g of this.possibleCenters)
          g.getCount() >= Pt.CENTER_QUORUM && (s++, (a += g.getEstimatedModuleSize()))
        if (s < 3) return !1
        const u = a / l
        let d = 0
        for (const g of this.possibleCenters) d += Math.abs(g.getEstimatedModuleSize() - u)
        return d <= 0.05 * a
      }
      selectBestPatterns() {
        const s = this.possibleCenters.length
        if (s < 3) throw new H()
        const a = this.possibleCenters
        let l
        if (s > 3) {
          let u = 0,
            d = 0
          for (const b of this.possibleCenters) {
            const v = b.getEstimatedModuleSize()
            ;((u += v), (d += v * v))
          }
          l = u / s
          let g = Math.sqrt(d / s - l * l)
          a.sort((b, v) => {
            const C = Math.abs(v.getEstimatedModuleSize() - l),
              T = Math.abs(b.getEstimatedModuleSize() - l)
            return C < T ? -1 : C > T ? 1 : 0
          })
          const m = Math.max(0.2 * l, g)
          for (let b = 0; b < a.length && a.length > 3; b++) {
            const v = a[b]
            Math.abs(v.getEstimatedModuleSize() - l) > m && (a.splice(b, 1), b--)
          }
        }
        if (a.length > 3) {
          let u = 0
          for (const d of a) u += d.getEstimatedModuleSize()
          ;((l = u / a.length),
            a.sort((d, g) => {
              if (g.getCount() === d.getCount()) {
                const m = Math.abs(g.getEstimatedModuleSize() - l),
                  b = Math.abs(d.getEstimatedModuleSize() - l)
                return m < b ? 1 : m > b ? -1 : 0
              } else return g.getCount() - d.getCount()
            }),
            a.splice(3))
        }
        return [a[0], a[1], a[2]]
      }
    }
    ;((Pt.CENTER_QUORUM = 2), (Pt.MIN_SKIP = 3), (Pt.MAX_MODULES = 57))
    class ra {
      constructor(s) {
        this.image = s
      }
      getImage() {
        return this.image
      }
      getResultPointCallback() {
        return this.resultPointCallback
      }
      detect(s) {
        this.resultPointCallback = s == null ? null : s.get(z.NEED_RESULT_POINT_CALLBACK)
        const a = new Pt(this.image, this.resultPointCallback).find(s)
        return this.processFinderPatternInfo(a)
      }
      processFinderPatternInfo(s) {
        const a = s.getTopLeft(),
          l = s.getTopRight(),
          u = s.getBottomLeft(),
          d = this.calculateModuleSize(a, l, u)
        if (d < 1) throw new H('No pattern found in proccess finder.')
        const g = ra.computeDimension(a, l, u, d),
          m = de.getProvisionalVersionForDimension(g),
          b = m.getDimensionForVersion() - 7
        let v = null
        if (m.getAlignmentPatternCenters().length > 0) {
          const B = l.getX() - a.getX() + u.getX(),
            j = l.getY() - a.getY() + u.getY(),
            W = 1 - 3 / b,
            Y = Math.floor(a.getX() + W * (B - a.getX())),
            q = Math.floor(a.getY() + W * (j - a.getY()))
          for (let ne = 4; ne <= 16; ne <<= 1)
            try {
              v = this.findAlignmentInRegion(d, Y, q, ne)
              break
            } catch (te) {
              if (!(te instanceof H)) throw te
            }
        }
        const C = ra.createTransform(a, l, u, v, g),
          T = ra.sampleGrid(this.image, C, g)
        let D
        return (v === null ? (D = [u, a, l]) : (D = [u, a, l, v]), new Xl(T, D))
      }
      static createTransform(s, a, l, u, d) {
        const g = d - 3.5
        let m, b, v, C
        return (
          u !== null
            ? ((m = u.getX()), (b = u.getY()), (v = g - 3), (C = v))
            : ((m = a.getX() - s.getX() + l.getX()),
              (b = a.getY() - s.getY() + l.getY()),
              (v = g),
              (C = g)),
          tr.quadrilateralToQuadrilateral(
            3.5,
            3.5,
            g,
            3.5,
            v,
            C,
            3.5,
            g,
            s.getX(),
            s.getY(),
            a.getX(),
            a.getY(),
            m,
            b,
            l.getX(),
            l.getY()
          )
        )
      }
      static sampleGrid(s, a, l) {
        return Jr.getInstance().sampleGridWithTransform(s, l, l, a)
      }
      static computeDimension(s, a, l, u) {
        const d = Pe.round(he.distance(s, a) / u),
          g = Pe.round(he.distance(s, l) / u)
        let m = Math.floor((d + g) / 2) + 7
        switch (m & 3) {
          case 0:
            m++
            break
          case 2:
            m--
            break
          case 3:
            throw new H('Dimensions could be not found.')
        }
        return m
      }
      calculateModuleSize(s, a, l) {
        return (this.calculateModuleSizeOneWay(s, a) + this.calculateModuleSizeOneWay(s, l)) / 2
      }
      calculateModuleSizeOneWay(s, a) {
        const l = this.sizeOfBlackWhiteBlackRunBothWays(
            Math.floor(s.getX()),
            Math.floor(s.getY()),
            Math.floor(a.getX()),
            Math.floor(a.getY())
          ),
          u = this.sizeOfBlackWhiteBlackRunBothWays(
            Math.floor(a.getX()),
            Math.floor(a.getY()),
            Math.floor(s.getX()),
            Math.floor(s.getY())
          )
        return isNaN(l) ? u / 7 : isNaN(u) ? l / 7 : (l + u) / 14
      }
      sizeOfBlackWhiteBlackRunBothWays(s, a, l, u) {
        let d = this.sizeOfBlackWhiteBlackRun(s, a, l, u),
          g = 1,
          m = s - (l - s)
        m < 0
          ? ((g = s / (s - m)), (m = 0))
          : m >= this.image.getWidth() &&
            ((g = (this.image.getWidth() - 1 - s) / (m - s)), (m = this.image.getWidth() - 1))
        let b = Math.floor(a - (u - a) * g)
        return (
          (g = 1),
          b < 0
            ? ((g = a / (a - b)), (b = 0))
            : b >= this.image.getHeight() &&
              ((g = (this.image.getHeight() - 1 - a) / (b - a)), (b = this.image.getHeight() - 1)),
          (m = Math.floor(s + (m - s) * g)),
          (d += this.sizeOfBlackWhiteBlackRun(s, a, m, b)),
          d - 1
        )
      }
      sizeOfBlackWhiteBlackRun(s, a, l, u) {
        const d = Math.abs(u - a) > Math.abs(l - s)
        if (d) {
          let B = s
          ;((s = a), (a = B), (B = l), (l = u), (u = B))
        }
        const g = Math.abs(l - s),
          m = Math.abs(u - a)
        let b = -g / 2
        const v = s < l ? 1 : -1,
          C = a < u ? 1 : -1
        let T = 0
        const D = l + v
        for (let B = s, j = a; B !== D; B += v) {
          const W = d ? j : B,
            Y = d ? B : j
          if ((T === 1) === this.image.get(W, Y)) {
            if (T === 2) return Pe.distance(B, j, s, a)
            T++
          }
          if (((b += m), b > 0)) {
            if (j === u) break
            ;((j += C), (b -= g))
          }
        }
        return T === 2 ? Pe.distance(l + v, u, s, a) : NaN
      }
      findAlignmentInRegion(s, a, l, u) {
        const d = Math.floor(u * s),
          g = Math.max(0, a - d),
          m = Math.min(this.image.getWidth() - 1, a + d)
        if (m - g < s * 3) throw new H('Alignment top exceeds estimated module size.')
        const b = Math.max(0, l - d),
          v = Math.min(this.image.getHeight() - 1, l + d)
        if (v - b < s * 3) throw new H('Alignment bottom exceeds estimated module size.')
        return new ql(this.image, g, b, m - g, v - b, s, this.resultPointCallback).find()
      }
    }
    class ri {
      constructor() {
        this.decoder = new yb()
      }
      getDecoder() {
        return this.decoder
      }
      decode(s, a) {
        let l, u
        if (a != null && a.get(z.PURE_BARCODE) !== void 0) {
          const b = ri.extractPureBits(s.getBlackMatrix())
          ;((l = this.decoder.decodeBitMatrix(b, a)), (u = ri.NO_POINTS))
        } else {
          const b = new ra(s.getBlackMatrix()).detect(a)
          ;((l = this.decoder.decodeBitMatrix(b.getBits(), a)), (u = b.getPoints()))
        }
        l.getOther() instanceof Ap && l.getOther().applyMirroredCorrection(u)
        const d = new Be(l.getText(), l.getRawBytes(), void 0, u, ue.QR_CODE, void 0),
          g = l.getByteSegments()
        g !== null && d.putMetadata(Rt.BYTE_SEGMENTS, g)
        const m = l.getECLevel()
        return (
          m !== null && d.putMetadata(Rt.ERROR_CORRECTION_LEVEL, m),
          l.hasStructuredAppend() &&
            (d.putMetadata(Rt.STRUCTURED_APPEND_SEQUENCE, l.getStructuredAppendSequenceNumber()),
            d.putMetadata(Rt.STRUCTURED_APPEND_PARITY, l.getStructuredAppendParity())),
          d
        )
      }
      reset() {}
      static extractPureBits(s) {
        const a = s.getTopLeftOnBit(),
          l = s.getBottomRightOnBit()
        if (a === null || l === null) throw new H()
        const u = this.moduleSize(a, s)
        let d = a[1],
          g = l[1],
          m = a[0],
          b = l[0]
        if (m >= b || d >= g) throw new H()
        if (g - d !== b - m && ((b = m + (g - d)), b >= s.getWidth())) throw new H()
        const v = Math.round((b - m + 1) / u),
          C = Math.round((g - d + 1) / u)
        if (v <= 0 || C <= 0) throw new H()
        if (C !== v) throw new H()
        const T = Math.floor(u / 2)
        ;((d += T), (m += T))
        const D = m + Math.floor((v - 1) * u) - b
        if (D > 0) {
          if (D > T) throw new H()
          m -= D
        }
        const B = d + Math.floor((C - 1) * u) - g
        if (B > 0) {
          if (B > T) throw new H()
          d -= B
        }
        const j = new Ie(v, C)
        for (let W = 0; W < C; W++) {
          const Y = d + Math.floor(W * u)
          for (let q = 0; q < v; q++) s.get(m + Math.floor(q * u), Y) && j.set(q, W)
        }
        return j
      }
      static moduleSize(s, a) {
        const l = a.getHeight(),
          u = a.getWidth()
        let d = s[0],
          g = s[1],
          m = !0,
          b = 0
        for (; d < u && g < l; ) {
          if (m !== a.get(d, g)) {
            if (++b === 5) break
            m = !m
          }
          ;(d++, g++)
        }
        if (d === u || g === l) throw new H()
        return (d - s[0]) / 7
      }
    }
    ri.NO_POINTS = new Array()
    class Ee {
      PDF417Common() {}
      static getBitCountSum(s) {
        return Pe.sum(s)
      }
      static toIntArray(s) {
        if (s == null || !s.length) return Ee.EMPTY_INT_ARRAY
        const a = new Int32Array(s.length)
        let l = 0
        for (const u of s) a[l++] = u
        return a
      }
      static getCodeword(s) {
        const a = R.binarySearch(Ee.SYMBOL_TABLE, s & 262143)
        return a < 0 ? -1 : (Ee.CODEWORD_TABLE[a] - 1) % Ee.NUMBER_OF_CODEWORDS
      }
    }
    ;((Ee.NUMBER_OF_CODEWORDS = 929),
      (Ee.MAX_CODEWORDS_IN_BARCODE = Ee.NUMBER_OF_CODEWORDS - 1),
      (Ee.MIN_ROWS_IN_BARCODE = 3),
      (Ee.MAX_ROWS_IN_BARCODE = 90),
      (Ee.MODULES_IN_CODEWORD = 17),
      (Ee.MODULES_IN_STOP_PATTERN = 18),
      (Ee.BARS_IN_MODULE = 8),
      (Ee.EMPTY_INT_ARRAY = new Int32Array([])),
      (Ee.SYMBOL_TABLE = Int32Array.from([
        66142, 66170, 66206, 66236, 66290, 66292, 66350, 66382, 66396, 66454, 66470, 66476, 66594,
        66600, 66614, 66626, 66628, 66632, 66640, 66654, 66662, 66668, 66682, 66690, 66718, 66720,
        66748, 66758, 66776, 66798, 66802, 66804, 66820, 66824, 66832, 66846, 66848, 66876, 66880,
        66936, 66950, 66956, 66968, 66992, 67006, 67022, 67036, 67042, 67044, 67048, 67062, 67118,
        67150, 67164, 67214, 67228, 67256, 67294, 67322, 67350, 67366, 67372, 67398, 67404, 67416,
        67438, 67474, 67476, 67490, 67492, 67496, 67510, 67618, 67624, 67650, 67656, 67664, 67678,
        67686, 67692, 67706, 67714, 67716, 67728, 67742, 67744, 67772, 67782, 67788, 67800, 67822,
        67826, 67828, 67842, 67848, 67870, 67872, 67900, 67904, 67960, 67974, 67992, 68016, 68030,
        68046, 68060, 68066, 68068, 68072, 68086, 68104, 68112, 68126, 68128, 68156, 68160, 68216,
        68336, 68358, 68364, 68376, 68400, 68414, 68448, 68476, 68494, 68508, 68536, 68546, 68548,
        68552, 68560, 68574, 68582, 68588, 68654, 68686, 68700, 68706, 68708, 68712, 68726, 68750,
        68764, 68792, 68802, 68804, 68808, 68816, 68830, 68838, 68844, 68858, 68878, 68892, 68920,
        68976, 68990, 68994, 68996, 69e3, 69008, 69022, 69024, 69052, 69062, 69068, 69080, 69102,
        69106, 69108, 69142, 69158, 69164, 69190, 69208, 69230, 69254, 69260, 69272, 69296, 69310,
        69326, 69340, 69386, 69394, 69396, 69410, 69416, 69430, 69442, 69444, 69448, 69456, 69470,
        69478, 69484, 69554, 69556, 69666, 69672, 69698, 69704, 69712, 69726, 69754, 69762, 69764,
        69776, 69790, 69792, 69820, 69830, 69836, 69848, 69870, 69874, 69876, 69890, 69918, 69920,
        69948, 69952, 70008, 70022, 70040, 70064, 70078, 70094, 70108, 70114, 70116, 70120, 70134,
        70152, 70174, 70176, 70264, 70384, 70412, 70448, 70462, 70496, 70524, 70542, 70556, 70584,
        70594, 70600, 70608, 70622, 70630, 70636, 70664, 70672, 70686, 70688, 70716, 70720, 70776,
        70896, 71136, 71180, 71192, 71216, 71230, 71264, 71292, 71360, 71416, 71452, 71480, 71536,
        71550, 71554, 71556, 71560, 71568, 71582, 71584, 71612, 71622, 71628, 71640, 71662, 71726,
        71732, 71758, 71772, 71778, 71780, 71784, 71798, 71822, 71836, 71864, 71874, 71880, 71888,
        71902, 71910, 71916, 71930, 71950, 71964, 71992, 72048, 72062, 72066, 72068, 72080, 72094,
        72096, 72124, 72134, 72140, 72152, 72174, 72178, 72180, 72206, 72220, 72248, 72304, 72318,
        72416, 72444, 72456, 72464, 72478, 72480, 72508, 72512, 72568, 72588, 72600, 72624, 72638,
        72654, 72668, 72674, 72676, 72680, 72694, 72726, 72742, 72748, 72774, 72780, 72792, 72814,
        72838, 72856, 72880, 72894, 72910, 72924, 72930, 72932, 72936, 72950, 72966, 72972, 72984,
        73008, 73022, 73056, 73084, 73102, 73116, 73144, 73156, 73160, 73168, 73182, 73190, 73196,
        73210, 73226, 73234, 73236, 73250, 73252, 73256, 73270, 73282, 73284, 73296, 73310, 73318,
        73324, 73346, 73348, 73352, 73360, 73374, 73376, 73404, 73414, 73420, 73432, 73454, 73498,
        73518, 73522, 73524, 73550, 73564, 73570, 73572, 73576, 73590, 73800, 73822, 73858, 73860,
        73872, 73886, 73888, 73916, 73944, 73970, 73972, 73992, 74014, 74016, 74044, 74048, 74104,
        74118, 74136, 74160, 74174, 74210, 74212, 74216, 74230, 74244, 74256, 74270, 74272, 74360,
        74480, 74502, 74508, 74544, 74558, 74592, 74620, 74638, 74652, 74680, 74690, 74696, 74704,
        74726, 74732, 74782, 74784, 74812, 74992, 75232, 75288, 75326, 75360, 75388, 75456, 75512,
        75576, 75632, 75646, 75650, 75652, 75664, 75678, 75680, 75708, 75718, 75724, 75736, 75758,
        75808, 75836, 75840, 75896, 76016, 76256, 76736, 76824, 76848, 76862, 76896, 76924, 76992,
        77048, 77296, 77340, 77368, 77424, 77438, 77536, 77564, 77572, 77576, 77584, 77600, 77628,
        77632, 77688, 77702, 77708, 77720, 77744, 77758, 77774, 77788, 77870, 77902, 77916, 77922,
        77928, 77966, 77980, 78008, 78018, 78024, 78032, 78046, 78060, 78074, 78094, 78136, 78192,
        78206, 78210, 78212, 78224, 78238, 78240, 78268, 78278, 78284, 78296, 78322, 78324, 78350,
        78364, 78448, 78462, 78560, 78588, 78600, 78622, 78624, 78652, 78656, 78712, 78726, 78744,
        78768, 78782, 78798, 78812, 78818, 78820, 78824, 78838, 78862, 78876, 78904, 78960, 78974,
        79072, 79100, 79296, 79352, 79368, 79376, 79390, 79392, 79420, 79424, 79480, 79600, 79628,
        79640, 79664, 79678, 79712, 79740, 79772, 79800, 79810, 79812, 79816, 79824, 79838, 79846,
        79852, 79894, 79910, 79916, 79942, 79948, 79960, 79982, 79988, 80006, 80024, 80048, 80062,
        80078, 80092, 80098, 80100, 80104, 80134, 80140, 80176, 80190, 80224, 80252, 80270, 80284,
        80312, 80328, 80336, 80350, 80358, 80364, 80378, 80390, 80396, 80408, 80432, 80446, 80480,
        80508, 80576, 80632, 80654, 80668, 80696, 80752, 80766, 80776, 80784, 80798, 80800, 80828,
        80844, 80856, 80878, 80882, 80884, 80914, 80916, 80930, 80932, 80936, 80950, 80962, 80968,
        80976, 80990, 80998, 81004, 81026, 81028, 81040, 81054, 81056, 81084, 81094, 81100, 81112,
        81134, 81154, 81156, 81160, 81168, 81182, 81184, 81212, 81216, 81272, 81286, 81292, 81304,
        81328, 81342, 81358, 81372, 81380, 81384, 81398, 81434, 81454, 81458, 81460, 81486, 81500,
        81506, 81508, 81512, 81526, 81550, 81564, 81592, 81602, 81604, 81608, 81616, 81630, 81638,
        81644, 81702, 81708, 81722, 81734, 81740, 81752, 81774, 81778, 81780, 82050, 82078, 82080,
        82108, 82180, 82184, 82192, 82206, 82208, 82236, 82240, 82296, 82316, 82328, 82352, 82366,
        82402, 82404, 82408, 82440, 82448, 82462, 82464, 82492, 82496, 82552, 82672, 82694, 82700,
        82712, 82736, 82750, 82784, 82812, 82830, 82882, 82884, 82888, 82896, 82918, 82924, 82952,
        82960, 82974, 82976, 83004, 83008, 83064, 83184, 83424, 83468, 83480, 83504, 83518, 83552,
        83580, 83648, 83704, 83740, 83768, 83824, 83838, 83842, 83844, 83848, 83856, 83872, 83900,
        83910, 83916, 83928, 83950, 83984, 84e3, 84028, 84032, 84088, 84208, 84448, 84928, 85040,
        85054, 85088, 85116, 85184, 85240, 85488, 85560, 85616, 85630, 85728, 85756, 85764, 85768,
        85776, 85790, 85792, 85820, 85824, 85880, 85894, 85900, 85912, 85936, 85966, 85980, 86048,
        86080, 86136, 86256, 86496, 86976, 88160, 88188, 88256, 88312, 88560, 89056, 89200, 89214,
        89312, 89340, 89536, 89592, 89608, 89616, 89632, 89664, 89720, 89840, 89868, 89880, 89904,
        89952, 89980, 89998, 90012, 90040, 90190, 90204, 90254, 90268, 90296, 90306, 90308, 90312,
        90334, 90382, 90396, 90424, 90480, 90494, 90500, 90504, 90512, 90526, 90528, 90556, 90566,
        90572, 90584, 90610, 90612, 90638, 90652, 90680, 90736, 90750, 90848, 90876, 90884, 90888,
        90896, 90910, 90912, 90940, 90944, 91e3, 91014, 91020, 91032, 91056, 91070, 91086, 91100,
        91106, 91108, 91112, 91126, 91150, 91164, 91192, 91248, 91262, 91360, 91388, 91584, 91640,
        91664, 91678, 91680, 91708, 91712, 91768, 91888, 91928, 91952, 91966, 92e3, 92028, 92046,
        92060, 92088, 92098, 92100, 92104, 92112, 92126, 92134, 92140, 92188, 92216, 92272, 92384,
        92412, 92608, 92664, 93168, 93200, 93214, 93216, 93244, 93248, 93304, 93424, 93664, 93720,
        93744, 93758, 93792, 93820, 93888, 93944, 93980, 94008, 94064, 94078, 94084, 94088, 94096,
        94110, 94112, 94140, 94150, 94156, 94168, 94246, 94252, 94278, 94284, 94296, 94318, 94342,
        94348, 94360, 94384, 94398, 94414, 94428, 94440, 94470, 94476, 94488, 94512, 94526, 94560,
        94588, 94606, 94620, 94648, 94658, 94660, 94664, 94672, 94686, 94694, 94700, 94714, 94726,
        94732, 94744, 94768, 94782, 94816, 94844, 94912, 94968, 94990, 95004, 95032, 95088, 95102,
        95112, 95120, 95134, 95136, 95164, 95180, 95192, 95214, 95218, 95220, 95244, 95256, 95280,
        95294, 95328, 95356, 95424, 95480, 95728, 95758, 95772, 95800, 95856, 95870, 95968, 95996,
        96008, 96016, 96030, 96032, 96060, 96064, 96120, 96152, 96176, 96190, 96220, 96226, 96228,
        96232, 96290, 96292, 96296, 96310, 96322, 96324, 96328, 96336, 96350, 96358, 96364, 96386,
        96388, 96392, 96400, 96414, 96416, 96444, 96454, 96460, 96472, 96494, 96498, 96500, 96514,
        96516, 96520, 96528, 96542, 96544, 96572, 96576, 96632, 96646, 96652, 96664, 96688, 96702,
        96718, 96732, 96738, 96740, 96744, 96758, 96772, 96776, 96784, 96798, 96800, 96828, 96832,
        96888, 97008, 97030, 97036, 97048, 97072, 97086, 97120, 97148, 97166, 97180, 97208, 97220,
        97224, 97232, 97246, 97254, 97260, 97326, 97330, 97332, 97358, 97372, 97378, 97380, 97384,
        97398, 97422, 97436, 97464, 97474, 97476, 97480, 97488, 97502, 97510, 97516, 97550, 97564,
        97592, 97648, 97666, 97668, 97672, 97680, 97694, 97696, 97724, 97734, 97740, 97752, 97774,
        97830, 97836, 97850, 97862, 97868, 97880, 97902, 97906, 97908, 97926, 97932, 97944, 97968,
        97998, 98012, 98018, 98020, 98024, 98038, 98618, 98674, 98676, 98838, 98854, 98874, 98892,
        98904, 98926, 98930, 98932, 98968, 99006, 99042, 99044, 99048, 99062, 99166, 99194, 99246,
        99286, 99350, 99366, 99372, 99386, 99398, 99416, 99438, 99442, 99444, 99462, 99504, 99518,
        99534, 99548, 99554, 99556, 99560, 99574, 99590, 99596, 99608, 99632, 99646, 99680, 99708,
        99726, 99740, 99768, 99778, 99780, 99784, 99792, 99806, 99814, 99820, 99834, 99858, 99860,
        99874, 99880, 99894, 99906, 99920, 99934, 99962, 99970, 99972, 99976, 99984, 99998, 1e5,
        100028, 100038, 100044, 100056, 100078, 100082, 100084, 100142, 100174, 100188, 100246,
        100262, 100268, 100306, 100308, 100390, 100396, 100410, 100422, 100428, 100440, 100462,
        100466, 100468, 100486, 100504, 100528, 100542, 100558, 100572, 100578, 100580, 100584,
        100598, 100620, 100656, 100670, 100704, 100732, 100750, 100792, 100802, 100808, 100816,
        100830, 100838, 100844, 100858, 100888, 100912, 100926, 100960, 100988, 101056, 101112,
        101148, 101176, 101232, 101246, 101250, 101252, 101256, 101264, 101278, 101280, 101308,
        101318, 101324, 101336, 101358, 101362, 101364, 101410, 101412, 101416, 101430, 101442,
        101448, 101456, 101470, 101478, 101498, 101506, 101508, 101520, 101534, 101536, 101564,
        101580, 101618, 101620, 101636, 101640, 101648, 101662, 101664, 101692, 101696, 101752,
        101766, 101784, 101838, 101858, 101860, 101864, 101934, 101938, 101940, 101966, 101980,
        101986, 101988, 101992, 102030, 102044, 102072, 102082, 102084, 102088, 102096, 102138,
        102166, 102182, 102188, 102214, 102220, 102232, 102254, 102282, 102290, 102292, 102306,
        102308, 102312, 102326, 102444, 102458, 102470, 102476, 102488, 102514, 102516, 102534,
        102552, 102576, 102590, 102606, 102620, 102626, 102632, 102646, 102662, 102668, 102704,
        102718, 102752, 102780, 102798, 102812, 102840, 102850, 102856, 102864, 102878, 102886,
        102892, 102906, 102936, 102974, 103008, 103036, 103104, 103160, 103224, 103280, 103294,
        103298, 103300, 103312, 103326, 103328, 103356, 103366, 103372, 103384, 103406, 103410,
        103412, 103472, 103486, 103520, 103548, 103616, 103672, 103920, 103992, 104048, 104062,
        104160, 104188, 104194, 104196, 104200, 104208, 104224, 104252, 104256, 104312, 104326,
        104332, 104344, 104368, 104382, 104398, 104412, 104418, 104420, 104424, 104482, 104484,
        104514, 104520, 104528, 104542, 104550, 104570, 104578, 104580, 104592, 104606, 104608,
        104636, 104652, 104690, 104692, 104706, 104712, 104734, 104736, 104764, 104768, 104824,
        104838, 104856, 104910, 104930, 104932, 104936, 104968, 104976, 104990, 104992, 105020,
        105024, 105080, 105200, 105240, 105278, 105312, 105372, 105410, 105412, 105416, 105424,
        105446, 105518, 105524, 105550, 105564, 105570, 105572, 105576, 105614, 105628, 105656,
        105666, 105672, 105680, 105702, 105722, 105742, 105756, 105784, 105840, 105854, 105858,
        105860, 105864, 105872, 105888, 105932, 105970, 105972, 106006, 106022, 106028, 106054,
        106060, 106072, 106100, 106118, 106124, 106136, 106160, 106174, 106190, 106210, 106212,
        106216, 106250, 106258, 106260, 106274, 106276, 106280, 106306, 106308, 106312, 106320,
        106334, 106348, 106394, 106414, 106418, 106420, 106566, 106572, 106610, 106612, 106630,
        106636, 106648, 106672, 106686, 106722, 106724, 106728, 106742, 106758, 106764, 106776,
        106800, 106814, 106848, 106876, 106894, 106908, 106936, 106946, 106948, 106952, 106960,
        106974, 106982, 106988, 107032, 107056, 107070, 107104, 107132, 107200, 107256, 107292,
        107320, 107376, 107390, 107394, 107396, 107400, 107408, 107422, 107424, 107452, 107462,
        107468, 107480, 107502, 107506, 107508, 107544, 107568, 107582, 107616, 107644, 107712,
        107768, 108016, 108060, 108088, 108144, 108158, 108256, 108284, 108290, 108292, 108296,
        108304, 108318, 108320, 108348, 108352, 108408, 108422, 108428, 108440, 108464, 108478,
        108494, 108508, 108514, 108516, 108520, 108592, 108640, 108668, 108736, 108792, 109040,
        109536, 109680, 109694, 109792, 109820, 110016, 110072, 110084, 110088, 110096, 110112,
        110140, 110144, 110200, 110320, 110342, 110348, 110360, 110384, 110398, 110432, 110460,
        110478, 110492, 110520, 110532, 110536, 110544, 110558, 110658, 110686, 110714, 110722,
        110724, 110728, 110736, 110750, 110752, 110780, 110796, 110834, 110836, 110850, 110852,
        110856, 110864, 110878, 110880, 110908, 110912, 110968, 110982, 111e3, 111054, 111074,
        111076, 111080, 111108, 111112, 111120, 111134, 111136, 111164, 111168, 111224, 111344,
        111372, 111422, 111456, 111516, 111554, 111556, 111560, 111568, 111590, 111632, 111646,
        111648, 111676, 111680, 111736, 111856, 112096, 112152, 112224, 112252, 112320, 112440,
        112514, 112516, 112520, 112528, 112542, 112544, 112588, 112686, 112718, 112732, 112782,
        112796, 112824, 112834, 112836, 112840, 112848, 112870, 112890, 112910, 112924, 112952,
        113008, 113022, 113026, 113028, 113032, 113040, 113054, 113056, 113100, 113138, 113140,
        113166, 113180, 113208, 113264, 113278, 113376, 113404, 113416, 113424, 113440, 113468,
        113472, 113560, 113614, 113634, 113636, 113640, 113686, 113702, 113708, 113734, 113740,
        113752, 113778, 113780, 113798, 113804, 113816, 113840, 113854, 113870, 113890, 113892,
        113896, 113926, 113932, 113944, 113968, 113982, 114016, 114044, 114076, 114114, 114116,
        114120, 114128, 114150, 114170, 114194, 114196, 114210, 114212, 114216, 114242, 114244,
        114248, 114256, 114270, 114278, 114306, 114308, 114312, 114320, 114334, 114336, 114364,
        114380, 114420, 114458, 114478, 114482, 114484, 114510, 114524, 114530, 114532, 114536,
        114842, 114866, 114868, 114970, 114994, 114996, 115042, 115044, 115048, 115062, 115130,
        115226, 115250, 115252, 115278, 115292, 115298, 115300, 115304, 115318, 115342, 115394,
        115396, 115400, 115408, 115422, 115430, 115436, 115450, 115478, 115494, 115514, 115526,
        115532, 115570, 115572, 115738, 115758, 115762, 115764, 115790, 115804, 115810, 115812,
        115816, 115830, 115854, 115868, 115896, 115906, 115912, 115920, 115934, 115942, 115948,
        115962, 115996, 116024, 116080, 116094, 116098, 116100, 116104, 116112, 116126, 116128,
        116156, 116166, 116172, 116184, 116206, 116210, 116212, 116246, 116262, 116268, 116282,
        116294, 116300, 116312, 116334, 116338, 116340, 116358, 116364, 116376, 116400, 116414,
        116430, 116444, 116450, 116452, 116456, 116498, 116500, 116514, 116520, 116534, 116546,
        116548, 116552, 116560, 116574, 116582, 116588, 116602, 116654, 116694, 116714, 116762,
        116782, 116786, 116788, 116814, 116828, 116834, 116836, 116840, 116854, 116878, 116892,
        116920, 116930, 116936, 116944, 116958, 116966, 116972, 116986, 117006, 117048, 117104,
        117118, 117122, 117124, 117136, 117150, 117152, 117180, 117190, 117196, 117208, 117230,
        117234, 117236, 117304, 117360, 117374, 117472, 117500, 117506, 117508, 117512, 117520,
        117536, 117564, 117568, 117624, 117638, 117644, 117656, 117680, 117694, 117710, 117724,
        117730, 117732, 117736, 117750, 117782, 117798, 117804, 117818, 117830, 117848, 117874,
        117876, 117894, 117936, 117950, 117966, 117986, 117988, 117992, 118022, 118028, 118040,
        118064, 118078, 118112, 118140, 118172, 118210, 118212, 118216, 118224, 118238, 118246,
        118266, 118306, 118312, 118338, 118352, 118366, 118374, 118394, 118402, 118404, 118408,
        118416, 118430, 118432, 118460, 118476, 118514, 118516, 118574, 118578, 118580, 118606,
        118620, 118626, 118628, 118632, 118678, 118694, 118700, 118730, 118738, 118740, 118830,
        118834, 118836, 118862, 118876, 118882, 118884, 118888, 118902, 118926, 118940, 118968,
        118978, 118980, 118984, 118992, 119006, 119014, 119020, 119034, 119068, 119096, 119152,
        119166, 119170, 119172, 119176, 119184, 119198, 119200, 119228, 119238, 119244, 119256,
        119278, 119282, 119284, 119324, 119352, 119408, 119422, 119520, 119548, 119554, 119556,
        119560, 119568, 119582, 119584, 119612, 119616, 119672, 119686, 119692, 119704, 119728,
        119742, 119758, 119772, 119778, 119780, 119784, 119798, 119920, 119934, 120032, 120060,
        120256, 120312, 120324, 120328, 120336, 120352, 120384, 120440, 120560, 120582, 120588,
        120600, 120624, 120638, 120672, 120700, 120718, 120732, 120760, 120770, 120772, 120776,
        120784, 120798, 120806, 120812, 120870, 120876, 120890, 120902, 120908, 120920, 120946,
        120948, 120966, 120972, 120984, 121008, 121022, 121038, 121058, 121060, 121064, 121078,
        121100, 121112, 121136, 121150, 121184, 121212, 121244, 121282, 121284, 121288, 121296,
        121318, 121338, 121356, 121368, 121392, 121406, 121440, 121468, 121536, 121592, 121656,
        121730, 121732, 121736, 121744, 121758, 121760, 121804, 121842, 121844, 121890, 121922,
        121924, 121928, 121936, 121950, 121958, 121978, 121986, 121988, 121992, 122e3, 122014,
        122016, 122044, 122060, 122098, 122100, 122116, 122120, 122128, 122142, 122144, 122172,
        122176, 122232, 122246, 122264, 122318, 122338, 122340, 122344, 122414, 122418, 122420,
        122446, 122460, 122466, 122468, 122472, 122510, 122524, 122552, 122562, 122564, 122568,
        122576, 122598, 122618, 122646, 122662, 122668, 122694, 122700, 122712, 122738, 122740,
        122762, 122770, 122772, 122786, 122788, 122792, 123018, 123026, 123028, 123042, 123044,
        123048, 123062, 123098, 123146, 123154, 123156, 123170, 123172, 123176, 123190, 123202,
        123204, 123208, 123216, 123238, 123244, 123258, 123290, 123314, 123316, 123402, 123410,
        123412, 123426, 123428, 123432, 123446, 123458, 123464, 123472, 123486, 123494, 123500,
        123514, 123522, 123524, 123528, 123536, 123552, 123580, 123590, 123596, 123608, 123630,
        123634, 123636, 123674, 123698, 123700, 123740, 123746, 123748, 123752, 123834, 123914,
        123922, 123924, 123938, 123944, 123958, 123970, 123976, 123984, 123998, 124006, 124012,
        124026, 124034, 124036, 124048, 124062, 124064, 124092, 124102, 124108, 124120, 124142,
        124146, 124148, 124162, 124164, 124168, 124176, 124190, 124192, 124220, 124224, 124280,
        124294, 124300, 124312, 124336, 124350, 124366, 124380, 124386, 124388, 124392, 124406,
        124442, 124462, 124466, 124468, 124494, 124508, 124514, 124520, 124558, 124572, 124600,
        124610, 124612, 124616, 124624, 124646, 124666, 124694, 124710, 124716, 124730, 124742,
        124748, 124760, 124786, 124788, 124818, 124820, 124834, 124836, 124840, 124854, 124946,
        124948, 124962, 124964, 124968, 124982, 124994, 124996, 125e3, 125008, 125022, 125030,
        125036, 125050, 125058, 125060, 125064, 125072, 125086, 125088, 125116, 125126, 125132,
        125144, 125166, 125170, 125172, 125186, 125188, 125192, 125200, 125216, 125244, 125248,
        125304, 125318, 125324, 125336, 125360, 125374, 125390, 125404, 125410, 125412, 125416,
        125430, 125444, 125448, 125456, 125472, 125504, 125560, 125680, 125702, 125708, 125720,
        125744, 125758, 125792, 125820, 125838, 125852, 125880, 125890, 125892, 125896, 125904,
        125918, 125926, 125932, 125978, 125998, 126002, 126004, 126030, 126044, 126050, 126052,
        126056, 126094, 126108, 126136, 126146, 126148, 126152, 126160, 126182, 126202, 126222,
        126236, 126264, 126320, 126334, 126338, 126340, 126344, 126352, 126366, 126368, 126412,
        126450, 126452, 126486, 126502, 126508, 126522, 126534, 126540, 126552, 126574, 126578,
        126580, 126598, 126604, 126616, 126640, 126654, 126670, 126684, 126690, 126692, 126696,
        126738, 126754, 126756, 126760, 126774, 126786, 126788, 126792, 126800, 126814, 126822,
        126828, 126842, 126894, 126898, 126900, 126934, 127126, 127142, 127148, 127162, 127178,
        127186, 127188, 127254, 127270, 127276, 127290, 127302, 127308, 127320, 127342, 127346,
        127348, 127370, 127378, 127380, 127394, 127396, 127400, 127450, 127510, 127526, 127532,
        127546, 127558, 127576, 127598, 127602, 127604, 127622, 127628, 127640, 127664, 127678,
        127694, 127708, 127714, 127716, 127720, 127734, 127754, 127762, 127764, 127778, 127784,
        127810, 127812, 127816, 127824, 127838, 127846, 127866, 127898, 127918, 127922, 127924,
        128022, 128038, 128044, 128058, 128070, 128076, 128088, 128110, 128114, 128116, 128134,
        128140, 128152, 128176, 128190, 128206, 128220, 128226, 128228, 128232, 128246, 128262,
        128268, 128280, 128304, 128318, 128352, 128380, 128398, 128412, 128440, 128450, 128452,
        128456, 128464, 128478, 128486, 128492, 128506, 128522, 128530, 128532, 128546, 128548,
        128552, 128566, 128578, 128580, 128584, 128592, 128606, 128614, 128634, 128642, 128644,
        128648, 128656, 128670, 128672, 128700, 128716, 128754, 128756, 128794, 128814, 128818,
        128820, 128846, 128860, 128866, 128868, 128872, 128886, 128918, 128934, 128940, 128954,
        128978, 128980, 129178, 129198, 129202, 129204, 129238, 129258, 129306, 129326, 129330,
        129332, 129358, 129372, 129378, 129380, 129384, 129398, 129430, 129446, 129452, 129466,
        129482, 129490, 129492, 129562, 129582, 129586, 129588, 129614, 129628, 129634, 129636,
        129640, 129654, 129678, 129692, 129720, 129730, 129732, 129736, 129744, 129758, 129766,
        129772, 129814, 129830, 129836, 129850, 129862, 129868, 129880, 129902, 129906, 129908,
        129930, 129938, 129940, 129954, 129956, 129960, 129974, 130010,
      ])),
      (Ee.CODEWORD_TABLE = Int32Array.from([
        2627, 1819, 2622, 2621, 1813, 1812, 2729, 2724, 2723, 2779, 2774, 2773, 902, 896, 908, 868,
        865, 861, 859, 2511, 873, 871, 1780, 835, 2493, 825, 2491, 842, 837, 844, 1764, 1762, 811,
        810, 809, 2483, 807, 2482, 806, 2480, 815, 814, 813, 812, 2484, 817, 816, 1745, 1744, 1742,
        1746, 2655, 2637, 2635, 2626, 2625, 2623, 2628, 1820, 2752, 2739, 2737, 2728, 2727, 2725,
        2730, 2785, 2783, 2778, 2777, 2775, 2780, 787, 781, 747, 739, 736, 2413, 754, 752, 1719,
        692, 689, 681, 2371, 678, 2369, 700, 697, 694, 703, 1688, 1686, 642, 638, 2343, 631, 2341,
        627, 2338, 651, 646, 643, 2345, 654, 652, 1652, 1650, 1647, 1654, 601, 599, 2322, 596, 2321,
        594, 2319, 2317, 611, 610, 608, 606, 2324, 603, 2323, 615, 614, 612, 1617, 1616, 1614, 1612,
        616, 1619, 1618, 2575, 2538, 2536, 905, 901, 898, 909, 2509, 2507, 2504, 870, 867, 864, 860,
        2512, 875, 872, 1781, 2490, 2489, 2487, 2485, 1748, 836, 834, 832, 830, 2494, 827, 2492,
        843, 841, 839, 845, 1765, 1763, 2701, 2676, 2674, 2653, 2648, 2656, 2634, 2633, 2631, 2629,
        1821, 2638, 2636, 2770, 2763, 2761, 2750, 2745, 2753, 2736, 2735, 2733, 2731, 1848, 2740,
        2738, 2786, 2784, 591, 588, 576, 569, 566, 2296, 1590, 537, 534, 526, 2276, 522, 2274, 545,
        542, 539, 548, 1572, 1570, 481, 2245, 466, 2242, 462, 2239, 492, 485, 482, 2249, 496, 494,
        1534, 1531, 1528, 1538, 413, 2196, 406, 2191, 2188, 425, 419, 2202, 415, 2199, 432, 430,
        427, 1472, 1467, 1464, 433, 1476, 1474, 368, 367, 2160, 365, 2159, 362, 2157, 2155, 2152,
        378, 377, 375, 2166, 372, 2165, 369, 2162, 383, 381, 379, 2168, 1419, 1418, 1416, 1414, 385,
        1411, 384, 1423, 1422, 1420, 1424, 2461, 802, 2441, 2439, 790, 786, 783, 794, 2409, 2406,
        2403, 750, 742, 738, 2414, 756, 753, 1720, 2367, 2365, 2362, 2359, 1663, 693, 691, 684,
        2373, 680, 2370, 702, 699, 696, 704, 1690, 1687, 2337, 2336, 2334, 2332, 1624, 2329, 1622,
        640, 637, 2344, 634, 2342, 630, 2340, 650, 648, 645, 2346, 655, 653, 1653, 1651, 1649, 1655,
        2612, 2597, 2595, 2571, 2568, 2565, 2576, 2534, 2529, 2526, 1787, 2540, 2537, 907, 904, 900,
        910, 2503, 2502, 2500, 2498, 1768, 2495, 1767, 2510, 2508, 2506, 869, 866, 863, 2513, 876,
        874, 1782, 2720, 2713, 2711, 2697, 2694, 2691, 2702, 2672, 2670, 2664, 1828, 2678, 2675,
        2647, 2646, 2644, 2642, 1823, 2639, 1822, 2654, 2652, 2650, 2657, 2771, 1855, 2765, 2762,
        1850, 1849, 2751, 2749, 2747, 2754, 353, 2148, 344, 342, 336, 2142, 332, 2140, 345, 1375,
        1373, 306, 2130, 299, 2128, 295, 2125, 319, 314, 311, 2132, 1354, 1352, 1349, 1356, 262,
        257, 2101, 253, 2096, 2093, 274, 273, 267, 2107, 263, 2104, 280, 278, 275, 1316, 1311, 1308,
        1320, 1318, 2052, 202, 2050, 2044, 2040, 219, 2063, 212, 2060, 208, 2055, 224, 221, 2066,
        1260, 1258, 1252, 231, 1248, 229, 1266, 1264, 1261, 1268, 155, 1998, 153, 1996, 1994, 1991,
        1988, 165, 164, 2007, 162, 2006, 159, 2003, 2e3, 172, 171, 169, 2012, 166, 2010, 1186, 1184,
        1182, 1179, 175, 1176, 173, 1192, 1191, 1189, 1187, 176, 1194, 1193, 2313, 2307, 2305, 592,
        589, 2294, 2292, 2289, 578, 572, 568, 2297, 580, 1591, 2272, 2267, 2264, 1547, 538, 536,
        529, 2278, 525, 2275, 547, 544, 541, 1574, 1571, 2237, 2235, 2229, 1493, 2225, 1489, 478,
        2247, 470, 2244, 465, 2241, 493, 488, 484, 2250, 498, 495, 1536, 1533, 1530, 1539, 2187,
        2186, 2184, 2182, 1432, 2179, 1430, 2176, 1427, 414, 412, 2197, 409, 2195, 405, 2193, 2190,
        426, 424, 421, 2203, 418, 2201, 431, 429, 1473, 1471, 1469, 1466, 434, 1477, 1475, 2478,
        2472, 2470, 2459, 2457, 2454, 2462, 803, 2437, 2432, 2429, 1726, 2443, 2440, 792, 789, 785,
        2401, 2399, 2393, 1702, 2389, 1699, 2411, 2408, 2405, 745, 741, 2415, 758, 755, 1721, 2358,
        2357, 2355, 2353, 1661, 2350, 1660, 2347, 1657, 2368, 2366, 2364, 2361, 1666, 690, 687,
        2374, 683, 2372, 701, 698, 705, 1691, 1689, 2619, 2617, 2610, 2608, 2605, 2613, 2593, 2588,
        2585, 1803, 2599, 2596, 2563, 2561, 2555, 1797, 2551, 1795, 2573, 2570, 2567, 2577, 2525,
        2524, 2522, 2520, 1786, 2517, 1785, 2514, 1783, 2535, 2533, 2531, 2528, 1788, 2541, 2539,
        906, 903, 911, 2721, 1844, 2715, 2712, 1838, 1836, 2699, 2696, 2693, 2703, 1827, 1826, 1824,
        2673, 2671, 2669, 2666, 1829, 2679, 2677, 1858, 1857, 2772, 1854, 1853, 1851, 1856, 2766,
        2764, 143, 1987, 139, 1986, 135, 133, 131, 1984, 128, 1983, 125, 1981, 138, 137, 136, 1985,
        1133, 1132, 1130, 112, 110, 1974, 107, 1973, 104, 1971, 1969, 122, 121, 119, 117, 1977, 114,
        1976, 124, 1115, 1114, 1112, 1110, 1117, 1116, 84, 83, 1953, 81, 1952, 78, 1950, 1948, 1945,
        94, 93, 91, 1959, 88, 1958, 85, 1955, 99, 97, 95, 1961, 1086, 1085, 1083, 1081, 1078, 100,
        1090, 1089, 1087, 1091, 49, 47, 1917, 44, 1915, 1913, 1910, 1907, 59, 1926, 56, 1925, 53,
        1922, 1919, 66, 64, 1931, 61, 1929, 1042, 1040, 1038, 71, 1035, 70, 1032, 68, 1048, 1047,
        1045, 1043, 1050, 1049, 12, 10, 1869, 1867, 1864, 1861, 21, 1880, 19, 1877, 1874, 1871, 28,
        1888, 25, 1886, 22, 1883, 982, 980, 977, 974, 32, 30, 991, 989, 987, 984, 34, 995, 994, 992,
        2151, 2150, 2147, 2146, 2144, 356, 355, 354, 2149, 2139, 2138, 2136, 2134, 1359, 343, 341,
        338, 2143, 335, 2141, 348, 347, 346, 1376, 1374, 2124, 2123, 2121, 2119, 1326, 2116, 1324,
        310, 308, 305, 2131, 302, 2129, 298, 2127, 320, 318, 316, 313, 2133, 322, 321, 1355, 1353,
        1351, 1357, 2092, 2091, 2089, 2087, 1276, 2084, 1274, 2081, 1271, 259, 2102, 256, 2100, 252,
        2098, 2095, 272, 269, 2108, 266, 2106, 281, 279, 277, 1317, 1315, 1313, 1310, 282, 1321,
        1319, 2039, 2037, 2035, 2032, 1203, 2029, 1200, 1197, 207, 2053, 205, 2051, 201, 2049, 2046,
        2043, 220, 218, 2064, 215, 2062, 211, 2059, 228, 226, 223, 2069, 1259, 1257, 1254, 232,
        1251, 230, 1267, 1265, 1263, 2316, 2315, 2312, 2311, 2309, 2314, 2304, 2303, 2301, 2299,
        1593, 2308, 2306, 590, 2288, 2287, 2285, 2283, 1578, 2280, 1577, 2295, 2293, 2291, 579, 577,
        574, 571, 2298, 582, 581, 1592, 2263, 2262, 2260, 2258, 1545, 2255, 1544, 2252, 1541, 2273,
        2271, 2269, 2266, 1550, 535, 532, 2279, 528, 2277, 546, 543, 549, 1575, 1573, 2224, 2222,
        2220, 1486, 2217, 1485, 2214, 1482, 1479, 2238, 2236, 2234, 2231, 1496, 2228, 1492, 480,
        477, 2248, 473, 2246, 469, 2243, 490, 487, 2251, 497, 1537, 1535, 1532, 2477, 2476, 2474,
        2479, 2469, 2468, 2466, 2464, 1730, 2473, 2471, 2453, 2452, 2450, 2448, 1729, 2445, 1728,
        2460, 2458, 2456, 2463, 805, 804, 2428, 2427, 2425, 2423, 1725, 2420, 1724, 2417, 1722,
        2438, 2436, 2434, 2431, 1727, 2444, 2442, 793, 791, 788, 795, 2388, 2386, 2384, 1697, 2381,
        1696, 2378, 1694, 1692, 2402, 2400, 2398, 2395, 1703, 2392, 1701, 2412, 2410, 2407, 751,
        748, 744, 2416, 759, 757, 1807, 2620, 2618, 1806, 1805, 2611, 2609, 2607, 2614, 1802, 1801,
        1799, 2594, 2592, 2590, 2587, 1804, 2600, 2598, 1794, 1793, 1791, 1789, 2564, 2562, 2560,
        2557, 1798, 2554, 1796, 2574, 2572, 2569, 2578, 1847, 1846, 2722, 1843, 1842, 1840, 1845,
        2716, 2714, 1835, 1834, 1832, 1830, 1839, 1837, 2700, 2698, 2695, 2704, 1817, 1811, 1810,
        897, 862, 1777, 829, 826, 838, 1760, 1758, 808, 2481, 1741, 1740, 1738, 1743, 2624, 1818,
        2726, 2776, 782, 740, 737, 1715, 686, 679, 695, 1682, 1680, 639, 628, 2339, 647, 644, 1645,
        1643, 1640, 1648, 602, 600, 597, 595, 2320, 593, 2318, 609, 607, 604, 1611, 1610, 1608,
        1606, 613, 1615, 1613, 2328, 926, 924, 892, 886, 899, 857, 850, 2505, 1778, 824, 823, 821,
        819, 2488, 818, 2486, 833, 831, 828, 840, 1761, 1759, 2649, 2632, 2630, 2746, 2734, 2732,
        2782, 2781, 570, 567, 1587, 531, 527, 523, 540, 1566, 1564, 476, 467, 463, 2240, 486, 483,
        1524, 1521, 1518, 1529, 411, 403, 2192, 399, 2189, 423, 416, 1462, 1457, 1454, 428, 1468,
        1465, 2210, 366, 363, 2158, 360, 2156, 357, 2153, 376, 373, 370, 2163, 1410, 1409, 1407,
        1405, 382, 1402, 380, 1417, 1415, 1412, 1421, 2175, 2174, 777, 774, 771, 784, 732, 725, 722,
        2404, 743, 1716, 676, 674, 668, 2363, 665, 2360, 685, 1684, 1681, 626, 624, 622, 2335, 620,
        2333, 617, 2330, 641, 635, 649, 1646, 1644, 1642, 2566, 928, 925, 2530, 2527, 894, 891, 888,
        2501, 2499, 2496, 858, 856, 854, 851, 1779, 2692, 2668, 2665, 2645, 2643, 2640, 2651, 2768,
        2759, 2757, 2744, 2743, 2741, 2748, 352, 1382, 340, 337, 333, 1371, 1369, 307, 300, 296,
        2126, 315, 312, 1347, 1342, 1350, 261, 258, 250, 2097, 246, 2094, 271, 268, 264, 1306, 1301,
        1298, 276, 1312, 1309, 2115, 203, 2048, 195, 2045, 191, 2041, 213, 209, 2056, 1246, 1244,
        1238, 225, 1234, 222, 1256, 1253, 1249, 1262, 2080, 2079, 154, 1997, 150, 1995, 147, 1992,
        1989, 163, 160, 2004, 156, 2001, 1175, 1174, 1172, 1170, 1167, 170, 1164, 167, 1185, 1183,
        1180, 1177, 174, 1190, 1188, 2025, 2024, 2022, 587, 586, 564, 559, 556, 2290, 573, 1588,
        520, 518, 512, 2268, 508, 2265, 530, 1568, 1565, 461, 457, 2233, 450, 2230, 446, 2226, 479,
        471, 489, 1526, 1523, 1520, 397, 395, 2185, 392, 2183, 389, 2180, 2177, 410, 2194, 402, 422,
        1463, 1461, 1459, 1456, 1470, 2455, 799, 2433, 2430, 779, 776, 773, 2397, 2394, 2390, 734,
        728, 724, 746, 1717, 2356, 2354, 2351, 2348, 1658, 677, 675, 673, 670, 667, 688, 1685, 1683,
        2606, 2589, 2586, 2559, 2556, 2552, 927, 2523, 2521, 2518, 2515, 1784, 2532, 895, 893, 890,
        2718, 2709, 2707, 2689, 2687, 2684, 2663, 2662, 2660, 2658, 1825, 2667, 2769, 1852, 2760,
        2758, 142, 141, 1139, 1138, 134, 132, 129, 126, 1982, 1129, 1128, 1126, 1131, 113, 111, 108,
        105, 1972, 101, 1970, 120, 118, 115, 1109, 1108, 1106, 1104, 123, 1113, 1111, 82, 79, 1951,
        75, 1949, 72, 1946, 92, 89, 86, 1956, 1077, 1076, 1074, 1072, 98, 1069, 96, 1084, 1082,
        1079, 1088, 1968, 1967, 48, 45, 1916, 42, 1914, 39, 1911, 1908, 60, 57, 54, 1923, 50, 1920,
        1031, 1030, 1028, 1026, 67, 1023, 65, 1020, 62, 1041, 1039, 1036, 1033, 69, 1046, 1044,
        1944, 1943, 1941, 11, 9, 1868, 7, 1865, 1862, 1859, 20, 1878, 16, 1875, 13, 1872, 970, 968,
        966, 963, 29, 960, 26, 23, 983, 981, 978, 975, 33, 971, 31, 990, 988, 985, 1906, 1904, 1902,
        993, 351, 2145, 1383, 331, 330, 328, 326, 2137, 323, 2135, 339, 1372, 1370, 294, 293, 291,
        289, 2122, 286, 2120, 283, 2117, 309, 303, 317, 1348, 1346, 1344, 245, 244, 242, 2090, 239,
        2088, 236, 2085, 2082, 260, 2099, 249, 270, 1307, 1305, 1303, 1300, 1314, 189, 2038, 186,
        2036, 183, 2033, 2030, 2026, 206, 198, 2047, 194, 216, 1247, 1245, 1243, 1240, 227, 1237,
        1255, 2310, 2302, 2300, 2286, 2284, 2281, 565, 563, 561, 558, 575, 1589, 2261, 2259, 2256,
        2253, 1542, 521, 519, 517, 514, 2270, 511, 533, 1569, 1567, 2223, 2221, 2218, 2215, 1483,
        2211, 1480, 459, 456, 453, 2232, 449, 474, 491, 1527, 1525, 1522, 2475, 2467, 2465, 2451,
        2449, 2446, 801, 800, 2426, 2424, 2421, 2418, 1723, 2435, 780, 778, 775, 2387, 2385, 2382,
        2379, 1695, 2375, 1693, 2396, 735, 733, 730, 727, 749, 1718, 2616, 2615, 2604, 2603, 2601,
        2584, 2583, 2581, 2579, 1800, 2591, 2550, 2549, 2547, 2545, 1792, 2542, 1790, 2558, 929,
        2719, 1841, 2710, 2708, 1833, 1831, 2690, 2688, 2686, 1815, 1809, 1808, 1774, 1756, 1754,
        1737, 1736, 1734, 1739, 1816, 1711, 1676, 1674, 633, 629, 1638, 1636, 1633, 1641, 598, 1605,
        1604, 1602, 1600, 605, 1609, 1607, 2327, 887, 853, 1775, 822, 820, 1757, 1755, 1584, 524,
        1560, 1558, 468, 464, 1514, 1511, 1508, 1519, 408, 404, 400, 1452, 1447, 1444, 417, 1458,
        1455, 2208, 364, 361, 358, 2154, 1401, 1400, 1398, 1396, 374, 1393, 371, 1408, 1406, 1403,
        1413, 2173, 2172, 772, 726, 723, 1712, 672, 669, 666, 682, 1678, 1675, 625, 623, 621, 618,
        2331, 636, 632, 1639, 1637, 1635, 920, 918, 884, 880, 889, 849, 848, 847, 846, 2497, 855,
        852, 1776, 2641, 2742, 2787, 1380, 334, 1367, 1365, 301, 297, 1340, 1338, 1335, 1343, 255,
        251, 247, 1296, 1291, 1288, 265, 1302, 1299, 2113, 204, 196, 192, 2042, 1232, 1230, 1224,
        214, 1220, 210, 1242, 1239, 1235, 1250, 2077, 2075, 151, 148, 1993, 144, 1990, 1163, 1162,
        1160, 1158, 1155, 161, 1152, 157, 1173, 1171, 1168, 1165, 168, 1181, 1178, 2021, 2020, 2018,
        2023, 585, 560, 557, 1585, 516, 509, 1562, 1559, 458, 447, 2227, 472, 1516, 1513, 1510, 398,
        396, 393, 390, 2181, 386, 2178, 407, 1453, 1451, 1449, 1446, 420, 1460, 2209, 769, 764, 720,
        712, 2391, 729, 1713, 664, 663, 661, 659, 2352, 656, 2349, 671, 1679, 1677, 2553, 922, 919,
        2519, 2516, 885, 883, 881, 2685, 2661, 2659, 2767, 2756, 2755, 140, 1137, 1136, 130, 127,
        1125, 1124, 1122, 1127, 109, 106, 102, 1103, 1102, 1100, 1098, 116, 1107, 1105, 1980, 80,
        76, 73, 1947, 1068, 1067, 1065, 1063, 90, 1060, 87, 1075, 1073, 1070, 1080, 1966, 1965, 46,
        43, 40, 1912, 36, 1909, 1019, 1018, 1016, 1014, 58, 1011, 55, 1008, 51, 1029, 1027, 1024,
        1021, 63, 1037, 1034, 1940, 1939, 1937, 1942, 8, 1866, 4, 1863, 1, 1860, 956, 954, 952, 949,
        946, 17, 14, 969, 967, 964, 961, 27, 957, 24, 979, 976, 972, 1901, 1900, 1898, 1896, 986,
        1905, 1903, 350, 349, 1381, 329, 327, 324, 1368, 1366, 292, 290, 287, 284, 2118, 304, 1341,
        1339, 1337, 1345, 243, 240, 237, 2086, 233, 2083, 254, 1297, 1295, 1293, 1290, 1304, 2114,
        190, 187, 184, 2034, 180, 2031, 177, 2027, 199, 1233, 1231, 1229, 1226, 217, 1223, 1241,
        2078, 2076, 584, 555, 554, 552, 550, 2282, 562, 1586, 507, 506, 504, 502, 2257, 499, 2254,
        515, 1563, 1561, 445, 443, 441, 2219, 438, 2216, 435, 2212, 460, 454, 475, 1517, 1515, 1512,
        2447, 798, 797, 2422, 2419, 770, 768, 766, 2383, 2380, 2376, 721, 719, 717, 714, 731, 1714,
        2602, 2582, 2580, 2548, 2546, 2543, 923, 921, 2717, 2706, 2705, 2683, 2682, 2680, 1771,
        1752, 1750, 1733, 1732, 1731, 1735, 1814, 1707, 1670, 1668, 1631, 1629, 1626, 1634, 1599,
        1598, 1596, 1594, 1603, 1601, 2326, 1772, 1753, 1751, 1581, 1554, 1552, 1504, 1501, 1498,
        1509, 1442, 1437, 1434, 401, 1448, 1445, 2206, 1392, 1391, 1389, 1387, 1384, 359, 1399,
        1397, 1394, 1404, 2171, 2170, 1708, 1672, 1669, 619, 1632, 1630, 1628, 1773, 1378, 1363,
        1361, 1333, 1328, 1336, 1286, 1281, 1278, 248, 1292, 1289, 2111, 1218, 1216, 1210, 197,
        1206, 193, 1228, 1225, 1221, 1236, 2073, 2071, 1151, 1150, 1148, 1146, 152, 1143, 149, 1140,
        145, 1161, 1159, 1156, 1153, 158, 1169, 1166, 2017, 2016, 2014, 2019, 1582, 510, 1556, 1553,
        452, 448, 1506, 1500, 394, 391, 387, 1443, 1441, 1439, 1436, 1450, 2207, 765, 716, 713,
        1709, 662, 660, 657, 1673, 1671, 916, 914, 879, 878, 877, 882, 1135, 1134, 1121, 1120, 1118,
        1123, 1097, 1096, 1094, 1092, 103, 1101, 1099, 1979, 1059, 1058, 1056, 1054, 77, 1051, 74,
        1066, 1064, 1061, 1071, 1964, 1963, 1007, 1006, 1004, 1002, 999, 41, 996, 37, 1017, 1015,
        1012, 1009, 52, 1025, 1022, 1936, 1935, 1933, 1938, 942, 940, 938, 935, 932, 5, 2, 955, 953,
        950, 947, 18, 943, 15, 965, 962, 958, 1895, 1894, 1892, 1890, 973, 1899, 1897, 1379, 325,
        1364, 1362, 288, 285, 1334, 1332, 1330, 241, 238, 234, 1287, 1285, 1283, 1280, 1294, 2112,
        188, 185, 181, 178, 2028, 1219, 1217, 1215, 1212, 200, 1209, 1227, 2074, 2072, 583, 553,
        551, 1583, 505, 503, 500, 513, 1557, 1555, 444, 442, 439, 436, 2213, 455, 451, 1507, 1505,
        1502, 796, 763, 762, 760, 767, 711, 710, 708, 706, 2377, 718, 715, 1710, 2544, 917, 915,
        2681, 1627, 1597, 1595, 2325, 1769, 1749, 1747, 1499, 1438, 1435, 2204, 1390, 1388, 1385,
        1395, 2169, 2167, 1704, 1665, 1662, 1625, 1623, 1620, 1770, 1329, 1282, 1279, 2109, 1214,
        1207, 1222, 2068, 2065, 1149, 1147, 1144, 1141, 146, 1157, 1154, 2013, 2011, 2008, 2015,
        1579, 1549, 1546, 1495, 1487, 1433, 1431, 1428, 1425, 388, 1440, 2205, 1705, 658, 1667,
        1664, 1119, 1095, 1093, 1978, 1057, 1055, 1052, 1062, 1962, 1960, 1005, 1003, 1e3, 997, 38,
        1013, 1010, 1932, 1930, 1927, 1934, 941, 939, 936, 933, 6, 930, 3, 951, 948, 944, 1889,
        1887, 1884, 1881, 959, 1893, 1891, 35, 1377, 1360, 1358, 1327, 1325, 1322, 1331, 1277, 1275,
        1272, 1269, 235, 1284, 2110, 1205, 1204, 1201, 1198, 182, 1195, 179, 1213, 2070, 2067, 1580,
        501, 1551, 1548, 440, 437, 1497, 1494, 1490, 1503, 761, 709, 707, 1706, 913, 912, 2198,
        1386, 2164, 2161, 1621, 1766, 2103, 1208, 2058, 2054, 1145, 1142, 2005, 2002, 1999, 2009,
        1488, 1429, 1426, 2200, 1698, 1659, 1656, 1975, 1053, 1957, 1954, 1001, 998, 1924, 1921,
        1918, 1928, 937, 934, 931, 1879, 1876, 1873, 1870, 945, 1885, 1882, 1323, 1273, 1270, 2105,
        1202, 1199, 1196, 1211, 2061, 2057, 1576, 1543, 1540, 1484, 1481, 1478, 1491, 1700,
      ])))
    class bb {
      constructor(s, a) {
        ;((this.bits = s), (this.points = a))
      }
      getBits() {
        return this.bits
      }
      getPoints() {
        return this.points
      }
    }
    class Ae {
      static detectMultiple(s, a, l) {
        let u = s.getBlackMatrix(),
          d = Ae.detect(l, u)
        return (d.length || ((u = u.clone()), u.rotate180(), (d = Ae.detect(l, u))), new bb(u, d))
      }
      static detect(s, a) {
        const l = new Array()
        let u = 0,
          d = 0,
          g = !1
        for (; u < a.getHeight(); ) {
          const m = Ae.findVertices(a, u, d)
          if (m[0] == null && m[3] == null) {
            if (!g) break
            ;((g = !1), (d = 0))
            for (const b of l)
              (b[1] != null && (u = Math.trunc(Math.max(u, b[1].getY()))),
                b[3] != null && (u = Math.max(u, Math.trunc(b[3].getY()))))
            u += Ae.ROW_STEP
            continue
          }
          if (((g = !0), l.push(m), !s)) break
          m[2] != null
            ? ((d = Math.trunc(m[2].getX())), (u = Math.trunc(m[2].getY())))
            : ((d = Math.trunc(m[4].getX())), (u = Math.trunc(m[4].getY())))
        }
        return l
      }
      static findVertices(s, a, l) {
        const u = s.getHeight(),
          d = s.getWidth(),
          g = new Array(8)
        return (
          Ae.copyToResult(
            g,
            Ae.findRowsWithPattern(s, u, d, a, l, Ae.START_PATTERN),
            Ae.INDEXES_START_PATTERN
          ),
          g[4] != null && ((l = Math.trunc(g[4].getX())), (a = Math.trunc(g[4].getY()))),
          Ae.copyToResult(
            g,
            Ae.findRowsWithPattern(s, u, d, a, l, Ae.STOP_PATTERN),
            Ae.INDEXES_STOP_PATTERN
          ),
          g
        )
      }
      static copyToResult(s, a, l) {
        for (let u = 0; u < l.length; u++) s[l[u]] = a[u]
      }
      static findRowsWithPattern(s, a, l, u, d, g) {
        const m = new Array(4)
        let b = !1
        const v = new Int32Array(g.length)
        for (; u < a; u += Ae.ROW_STEP) {
          let T = Ae.findGuardPattern(s, d, u, l, !1, g, v)
          if (T != null) {
            for (; u > 0; ) {
              const D = Ae.findGuardPattern(s, d, --u, l, !1, g, v)
              if (D != null) T = D
              else {
                u++
                break
              }
            }
            ;((m[0] = new he(T[0], u)), (m[1] = new he(T[1], u)), (b = !0))
            break
          }
        }
        let C = u + 1
        if (b) {
          let T = 0,
            D = Int32Array.from([Math.trunc(m[0].getX()), Math.trunc(m[1].getX())])
          for (; C < a; C++) {
            const B = Ae.findGuardPattern(s, D[0], C, l, !1, g, v)
            if (
              B != null &&
              Math.abs(D[0] - B[0]) < Ae.MAX_PATTERN_DRIFT &&
              Math.abs(D[1] - B[1]) < Ae.MAX_PATTERN_DRIFT
            )
              ((D = B), (T = 0))
            else {
              if (T > Ae.SKIPPED_ROW_COUNT_MAX) break
              T++
            }
          }
          ;((C -= T + 1), (m[2] = new he(D[0], C)), (m[3] = new he(D[1], C)))
        }
        return (C - u < Ae.BARCODE_MIN_HEIGHT && R.fill(m, null), m)
      }
      static findGuardPattern(s, a, l, u, d, g, m) {
        R.fillWithin(m, 0, m.length, 0)
        let b = a,
          v = 0
        for (; s.get(b, l) && b > 0 && v++ < Ae.MAX_PIXEL_DRIFT; ) b--
        let C = b,
          T = 0,
          D = g.length
        for (let B = d; C < u; C++)
          if (s.get(C, l) !== B) m[T]++
          else {
            if (T === D - 1) {
              if (Ae.patternMatchVariance(m, g, Ae.MAX_INDIVIDUAL_VARIANCE) < Ae.MAX_AVG_VARIANCE)
                return new Int32Array([b, C])
              ;((b += m[0] + m[1]), k.arraycopy(m, 2, m, 0, T - 1), (m[T - 1] = 0), (m[T] = 0), T--)
            } else T++
            ;((m[T] = 1), (B = !B))
          }
        return T === D - 1 &&
          Ae.patternMatchVariance(m, g, Ae.MAX_INDIVIDUAL_VARIANCE) < Ae.MAX_AVG_VARIANCE
          ? new Int32Array([b, C - 1])
          : null
      }
      static patternMatchVariance(s, a, l) {
        let u = s.length,
          d = 0,
          g = 0
        for (let v = 0; v < u; v++) ((d += s[v]), (g += a[v]))
        if (d < g) return 1 / 0
        let m = d / g
        l *= m
        let b = 0
        for (let v = 0; v < u; v++) {
          let C = s[v],
            T = a[v] * m,
            D = C > T ? C - T : T - C
          if (D > l) return 1 / 0
          b += D
        }
        return b / d
      }
    }
    ;((Ae.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5])),
      (Ae.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3])),
      (Ae.MAX_AVG_VARIANCE = 0.42),
      (Ae.MAX_INDIVIDUAL_VARIANCE = 0.8),
      (Ae.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3])),
      (Ae.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1])),
      (Ae.MAX_PIXEL_DRIFT = 3),
      (Ae.MAX_PATTERN_DRIFT = 5),
      (Ae.SKIPPED_ROW_COUNT_MAX = 25),
      (Ae.ROW_STEP = 5),
      (Ae.BARCODE_MIN_HEIGHT = 10))
    class jt {
      constructor(s, a) {
        if (a.length === 0) throw new w()
        this.field = s
        let l = a.length
        if (l > 1 && a[0] === 0) {
          let u = 1
          for (; u < l && a[u] === 0; ) u++
          u === l
            ? (this.coefficients = new Int32Array([0]))
            : ((this.coefficients = new Int32Array(l - u)),
              k.arraycopy(a, u, this.coefficients, 0, this.coefficients.length))
        } else this.coefficients = a
      }
      getCoefficients() {
        return this.coefficients
      }
      getDegree() {
        return this.coefficients.length - 1
      }
      isZero() {
        return this.coefficients[0] === 0
      }
      getCoefficient(s) {
        return this.coefficients[this.coefficients.length - 1 - s]
      }
      evaluateAt(s) {
        if (s === 0) return this.getCoefficient(0)
        if (s === 1) {
          let u = 0
          for (let d of this.coefficients) u = this.field.add(u, d)
          return u
        }
        let a = this.coefficients[0],
          l = this.coefficients.length
        for (let u = 1; u < l; u++)
          a = this.field.add(this.field.multiply(s, a), this.coefficients[u])
        return a
      }
      add(s) {
        if (!this.field.equals(s.field))
          throw new w('ModulusPolys do not have same ModulusGF field')
        if (this.isZero()) return s
        if (s.isZero()) return this
        let a = this.coefficients,
          l = s.coefficients
        if (a.length > l.length) {
          let g = a
          ;((a = l), (l = g))
        }
        let u = new Int32Array(l.length),
          d = l.length - a.length
        k.arraycopy(l, 0, u, 0, d)
        for (let g = d; g < l.length; g++) u[g] = this.field.add(a[g - d], l[g])
        return new jt(this.field, u)
      }
      subtract(s) {
        if (!this.field.equals(s.field))
          throw new w('ModulusPolys do not have same ModulusGF field')
        return s.isZero() ? this : this.add(s.negative())
      }
      multiply(s) {
        return s instanceof jt ? this.multiplyOther(s) : this.multiplyScalar(s)
      }
      multiplyOther(s) {
        if (!this.field.equals(s.field))
          throw new w('ModulusPolys do not have same ModulusGF field')
        if (this.isZero() || s.isZero()) return new jt(this.field, new Int32Array([0]))
        let a = this.coefficients,
          l = a.length,
          u = s.coefficients,
          d = u.length,
          g = new Int32Array(l + d - 1)
        for (let m = 0; m < l; m++) {
          let b = a[m]
          for (let v = 0; v < d; v++)
            g[m + v] = this.field.add(g[m + v], this.field.multiply(b, u[v]))
        }
        return new jt(this.field, g)
      }
      negative() {
        let s = this.coefficients.length,
          a = new Int32Array(s)
        for (let l = 0; l < s; l++) a[l] = this.field.subtract(0, this.coefficients[l])
        return new jt(this.field, a)
      }
      multiplyScalar(s) {
        if (s === 0) return new jt(this.field, new Int32Array([0]))
        if (s === 1) return this
        let a = this.coefficients.length,
          l = new Int32Array(a)
        for (let u = 0; u < a; u++) l[u] = this.field.multiply(this.coefficients[u], s)
        return new jt(this.field, l)
      }
      multiplyByMonomial(s, a) {
        if (s < 0) throw new w()
        if (a === 0) return new jt(this.field, new Int32Array([0]))
        let l = this.coefficients.length,
          u = new Int32Array(l + s)
        for (let d = 0; d < l; d++) u[d] = this.field.multiply(this.coefficients[d], a)
        return new jt(this.field, u)
      }
      toString() {
        let s = new ve()
        for (let a = this.getDegree(); a >= 0; a--) {
          let l = this.getCoefficient(a)
          l !== 0 &&
            (l < 0 ? (s.append(' - '), (l = -l)) : s.length() > 0 && s.append(' + '),
            (a === 0 || l !== 1) && s.append(l),
            a !== 0 && (a === 1 ? s.append('x') : (s.append('x^'), s.append(a))))
        }
        return s.toString()
      }
    }
    class vb {
      add(s, a) {
        return (s + a) % this.modulus
      }
      subtract(s, a) {
        return (this.modulus + s - a) % this.modulus
      }
      exp(s) {
        return this.expTable[s]
      }
      log(s) {
        if (s === 0) throw new w()
        return this.logTable[s]
      }
      inverse(s) {
        if (s === 0) throw new zl()
        return this.expTable[this.modulus - this.logTable[s] - 1]
      }
      multiply(s, a) {
        return s === 0 || a === 0
          ? 0
          : this.expTable[(this.logTable[s] + this.logTable[a]) % (this.modulus - 1)]
      }
      getSize() {
        return this.modulus
      }
      equals(s) {
        return s === this
      }
    }
    class jh extends vb {
      constructor(s, a) {
        ;(super(),
          (this.modulus = s),
          (this.expTable = new Int32Array(s)),
          (this.logTable = new Int32Array(s)))
        let l = 1
        for (let u = 0; u < s; u++) ((this.expTable[u] = l), (l = (l * a) % s))
        for (let u = 0; u < s - 1; u++) this.logTable[this.expTable[u]] = u
        ;((this.zero = new jt(this, new Int32Array([0]))),
          (this.one = new jt(this, new Int32Array([1]))))
      }
      getZero() {
        return this.zero
      }
      getOne() {
        return this.one
      }
      buildMonomial(s, a) {
        if (s < 0) throw new w()
        if (a === 0) return this.zero
        let l = new Int32Array(s + 1)
        return ((l[0] = a), new jt(this, l))
      }
    }
    jh.PDF417_GF = new jh(Ee.NUMBER_OF_CODEWORDS, 3)
    class kp {
      constructor() {
        this.field = jh.PDF417_GF
      }
      decode(s, a, l) {
        let u = new jt(this.field, s),
          d = new Int32Array(a),
          g = !1
        for (let j = a; j > 0; j--) {
          let W = u.evaluateAt(this.field.exp(j))
          ;((d[a - j] = W), W !== 0 && (g = !0))
        }
        if (!g) return 0
        let m = this.field.getOne()
        if (l != null)
          for (const j of l) {
            let W = this.field.exp(s.length - 1 - j),
              Y = new jt(this.field, new Int32Array([this.field.subtract(0, W), 1]))
            m = m.multiply(Y)
          }
        let b = new jt(this.field, d),
          v = this.runEuclideanAlgorithm(this.field.buildMonomial(a, 1), b, a),
          C = v[0],
          T = v[1],
          D = this.findErrorLocations(C),
          B = this.findErrorMagnitudes(T, C, D)
        for (let j = 0; j < D.length; j++) {
          let W = s.length - 1 - this.field.log(D[j])
          if (W < 0) throw E.getChecksumInstance()
          s[W] = this.field.subtract(s[W], B[j])
        }
        return D.length
      }
      runEuclideanAlgorithm(s, a, l) {
        if (s.getDegree() < a.getDegree()) {
          let D = s
          ;((s = a), (a = D))
        }
        let u = s,
          d = a,
          g = this.field.getZero(),
          m = this.field.getOne()
        for (; d.getDegree() >= Math.round(l / 2); ) {
          let D = u,
            B = g
          if (((u = d), (g = m), u.isZero())) throw E.getChecksumInstance()
          d = D
          let j = this.field.getZero(),
            W = u.getCoefficient(u.getDegree()),
            Y = this.field.inverse(W)
          for (; d.getDegree() >= u.getDegree() && !d.isZero(); ) {
            let q = d.getDegree() - u.getDegree(),
              ne = this.field.multiply(d.getCoefficient(d.getDegree()), Y)
            ;((j = j.add(this.field.buildMonomial(q, ne))),
              (d = d.subtract(u.multiplyByMonomial(q, ne))))
          }
          m = j.multiply(g).subtract(B).negative()
        }
        let b = m.getCoefficient(0)
        if (b === 0) throw E.getChecksumInstance()
        let v = this.field.inverse(b),
          C = m.multiply(v),
          T = d.multiply(v)
        return [C, T]
      }
      findErrorLocations(s) {
        let a = s.getDegree(),
          l = new Int32Array(a),
          u = 0
        for (let d = 1; d < this.field.getSize() && u < a; d++)
          s.evaluateAt(d) === 0 && ((l[u] = this.field.inverse(d)), u++)
        if (u !== a) throw E.getChecksumInstance()
        return l
      }
      findErrorMagnitudes(s, a, l) {
        let u = a.getDegree(),
          d = new Int32Array(u)
        for (let v = 1; v <= u; v++) d[u - v] = this.field.multiply(v, a.getCoefficient(v))
        let g = new jt(this.field, d),
          m = l.length,
          b = new Int32Array(m)
        for (let v = 0; v < m; v++) {
          let C = this.field.inverse(l[v]),
            T = this.field.subtract(0, s.evaluateAt(C)),
            D = this.field.inverse(g.evaluateAt(C))
          b[v] = this.field.multiply(T, D)
        }
        return b
      }
    }
    class Gi {
      constructor(s, a, l, u, d) {
        s instanceof Gi ? this.constructor_2(s) : this.constructor_1(s, a, l, u, d)
      }
      constructor_1(s, a, l, u, d) {
        const g = a == null || l == null,
          m = u == null || d == null
        if (g && m) throw new H()
        ;(g
          ? ((a = new he(0, u.getY())), (l = new he(0, d.getY())))
          : m &&
            ((u = new he(s.getWidth() - 1, a.getY())), (d = new he(s.getWidth() - 1, l.getY()))),
          (this.image = s),
          (this.topLeft = a),
          (this.bottomLeft = l),
          (this.topRight = u),
          (this.bottomRight = d),
          (this.minX = Math.trunc(Math.min(a.getX(), l.getX()))),
          (this.maxX = Math.trunc(Math.max(u.getX(), d.getX()))),
          (this.minY = Math.trunc(Math.min(a.getY(), u.getY()))),
          (this.maxY = Math.trunc(Math.max(l.getY(), d.getY()))))
      }
      constructor_2(s) {
        ;((this.image = s.image),
          (this.topLeft = s.getTopLeft()),
          (this.bottomLeft = s.getBottomLeft()),
          (this.topRight = s.getTopRight()),
          (this.bottomRight = s.getBottomRight()),
          (this.minX = s.getMinX()),
          (this.maxX = s.getMaxX()),
          (this.minY = s.getMinY()),
          (this.maxY = s.getMaxY()))
      }
      static merge(s, a) {
        return s == null
          ? a
          : a == null
            ? s
            : new Gi(s.image, s.topLeft, s.bottomLeft, a.topRight, a.bottomRight)
      }
      addMissingRows(s, a, l) {
        let u = this.topLeft,
          d = this.bottomLeft,
          g = this.topRight,
          m = this.bottomRight
        if (s > 0) {
          let b = l ? this.topLeft : this.topRight,
            v = Math.trunc(b.getY() - s)
          v < 0 && (v = 0)
          let C = new he(b.getX(), v)
          l ? (u = C) : (g = C)
        }
        if (a > 0) {
          let b = l ? this.bottomLeft : this.bottomRight,
            v = Math.trunc(b.getY() + a)
          v >= this.image.getHeight() && (v = this.image.getHeight() - 1)
          let C = new he(b.getX(), v)
          l ? (d = C) : (m = C)
        }
        return new Gi(this.image, u, d, g, m)
      }
      getMinX() {
        return this.minX
      }
      getMaxX() {
        return this.maxX
      }
      getMinY() {
        return this.minY
      }
      getMaxY() {
        return this.maxY
      }
      getTopLeft() {
        return this.topLeft
      }
      getTopRight() {
        return this.topRight
      }
      getBottomLeft() {
        return this.bottomLeft
      }
      getBottomRight() {
        return this.bottomRight
      }
    }
    class xb {
      constructor(s, a, l, u) {
        ;((this.columnCount = s),
          (this.errorCorrectionLevel = u),
          (this.rowCountUpperPart = a),
          (this.rowCountLowerPart = l),
          (this.rowCount = a + l))
      }
      getColumnCount() {
        return this.columnCount
      }
      getErrorCorrectionLevel() {
        return this.errorCorrectionLevel
      }
      getRowCount() {
        return this.rowCount
      }
      getRowCountUpperPart() {
        return this.rowCountUpperPart
      }
      getRowCountLowerPart() {
        return this.rowCountLowerPart
      }
    }
    class ia {
      constructor() {
        this.buffer = ''
      }
      static form(s, a) {
        let l = -1
        function u(g, m, b, v, C, T) {
          if (g === '%%') return '%'
          if (a[++l] === void 0) return
          g = v ? parseInt(v.substr(1)) : void 0
          let D = C ? parseInt(C.substr(1)) : void 0,
            B
          switch (T) {
            case 's':
              B = a[l]
              break
            case 'c':
              B = a[l][0]
              break
            case 'f':
              B = parseFloat(a[l]).toFixed(g)
              break
            case 'p':
              B = parseFloat(a[l]).toPrecision(g)
              break
            case 'e':
              B = parseFloat(a[l]).toExponential(g)
              break
            case 'x':
              B = parseInt(a[l]).toString(D || 16)
              break
            case 'd':
              B = parseFloat(parseInt(a[l], D || 10).toPrecision(g)).toFixed(0)
              break
          }
          B = typeof B == 'object' ? JSON.stringify(B) : (+B).toString(D)
          let j = parseInt(b),
            W = b && b[0] + '' == '0' ? '0' : ' '
          for (; B.length < j; ) B = m !== void 0 ? B + W : W + B
          return B
        }
        let d = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g
        return s.replace(d, u)
      }
      format(s, ...a) {
        this.buffer += ia.form(s, a)
      }
      toString() {
        return this.buffer
      }
    }
    class sa {
      constructor(s) {
        ;((this.boundingBox = new Gi(s)),
          (this.codewords = new Array(s.getMaxY() - s.getMinY() + 1)))
      }
      getCodewordNearby(s) {
        let a = this.getCodeword(s)
        if (a != null) return a
        for (let l = 1; l < sa.MAX_NEARBY_DISTANCE; l++) {
          let u = this.imageRowToCodewordIndex(s) - l
          if (
            (u >= 0 && ((a = this.codewords[u]), a != null)) ||
            ((u = this.imageRowToCodewordIndex(s) + l),
            u < this.codewords.length && ((a = this.codewords[u]), a != null))
          )
            return a
        }
        return null
      }
      imageRowToCodewordIndex(s) {
        return s - this.boundingBox.getMinY()
      }
      setCodeword(s, a) {
        this.codewords[this.imageRowToCodewordIndex(s)] = a
      }
      getCodeword(s) {
        return this.codewords[this.imageRowToCodewordIndex(s)]
      }
      getBoundingBox() {
        return this.boundingBox
      }
      getCodewords() {
        return this.codewords
      }
      toString() {
        const s = new ia()
        let a = 0
        for (const l of this.codewords) {
          if (l == null) {
            s.format('%3d:    |   %n', a++)
            continue
          }
          s.format('%3d: %3d|%3d%n', a++, l.getRowNumber(), l.getValue())
        }
        return s.toString()
      }
    }
    sa.MAX_NEARBY_DISTANCE = 5
    class oa {
      constructor() {
        this.values = new Map()
      }
      setValue(s) {
        s = Math.trunc(s)
        let a = this.values.get(s)
        ;(a == null && (a = 0), a++, this.values.set(s, a))
      }
      getValue() {
        let s = -1,
          a = new Array()
        for (const [l, u] of this.values.entries()) {
          const d = { getKey: () => l, getValue: () => u }
          d.getValue() > s
            ? ((s = d.getValue()), (a = []), a.push(d.getKey()))
            : d.getValue() === s && a.push(d.getKey())
        }
        return Ee.toIntArray(a)
      }
      getConfidence(s) {
        return this.values.get(s)
      }
    }
    class _p extends sa {
      constructor(s, a) {
        ;(super(s), (this._isLeft = a))
      }
      setRowNumbers() {
        for (let s of this.getCodewords()) s != null && s.setRowNumberAsRowIndicatorColumn()
      }
      adjustCompleteIndicatorColumnRowNumbers(s) {
        let a = this.getCodewords()
        ;(this.setRowNumbers(), this.removeIncorrectCodewords(a, s))
        let l = this.getBoundingBox(),
          u = this._isLeft ? l.getTopLeft() : l.getTopRight(),
          d = this._isLeft ? l.getBottomLeft() : l.getBottomRight(),
          g = this.imageRowToCodewordIndex(Math.trunc(u.getY())),
          m = this.imageRowToCodewordIndex(Math.trunc(d.getY())),
          b = -1,
          v = 1,
          C = 0
        for (let T = g; T < m; T++) {
          if (a[T] == null) continue
          let D = a[T],
            B = D.getRowNumber() - b
          if (B === 0) C++
          else if (B === 1) ((v = Math.max(v, C)), (C = 1), (b = D.getRowNumber()))
          else if (B < 0 || D.getRowNumber() >= s.getRowCount() || B > T) a[T] = null
          else {
            let j
            v > 2 ? (j = (v - 2) * B) : (j = B)
            let W = j >= T
            for (let Y = 1; Y <= j && !W; Y++) W = a[T - Y] != null
            W ? (a[T] = null) : ((b = D.getRowNumber()), (C = 1))
          }
        }
      }
      getRowHeights() {
        let s = this.getBarcodeMetadata()
        if (s == null) return null
        this.adjustIncompleteIndicatorColumnRowNumbers(s)
        let a = new Int32Array(s.getRowCount())
        for (let l of this.getCodewords())
          if (l != null) {
            let u = l.getRowNumber()
            if (u >= a.length) continue
            a[u]++
          }
        return a
      }
      adjustIncompleteIndicatorColumnRowNumbers(s) {
        let a = this.getBoundingBox(),
          l = this._isLeft ? a.getTopLeft() : a.getTopRight(),
          u = this._isLeft ? a.getBottomLeft() : a.getBottomRight(),
          d = this.imageRowToCodewordIndex(Math.trunc(l.getY())),
          g = this.imageRowToCodewordIndex(Math.trunc(u.getY())),
          m = this.getCodewords(),
          b = -1
        for (let v = d; v < g; v++) {
          if (m[v] == null) continue
          let C = m[v]
          C.setRowNumberAsRowIndicatorColumn()
          let T = C.getRowNumber() - b
          T === 0 ||
            (T === 1
              ? (b = C.getRowNumber())
              : C.getRowNumber() >= s.getRowCount()
                ? (m[v] = null)
                : (b = C.getRowNumber()))
        }
      }
      getBarcodeMetadata() {
        let s = this.getCodewords(),
          a = new oa(),
          l = new oa(),
          u = new oa(),
          d = new oa()
        for (let m of s) {
          if (m == null) continue
          m.setRowNumberAsRowIndicatorColumn()
          let b = m.getValue() % 30,
            v = m.getRowNumber()
          switch ((this._isLeft || (v += 2), v % 3)) {
            case 0:
              l.setValue(b * 3 + 1)
              break
            case 1:
              ;(d.setValue(b / 3), u.setValue(b % 3))
              break
            case 2:
              a.setValue(b + 1)
              break
          }
        }
        if (
          a.getValue().length === 0 ||
          l.getValue().length === 0 ||
          u.getValue().length === 0 ||
          d.getValue().length === 0 ||
          a.getValue()[0] < 1 ||
          l.getValue()[0] + u.getValue()[0] < Ee.MIN_ROWS_IN_BARCODE ||
          l.getValue()[0] + u.getValue()[0] > Ee.MAX_ROWS_IN_BARCODE
        )
          return null
        let g = new xb(a.getValue()[0], l.getValue()[0], u.getValue()[0], d.getValue()[0])
        return (this.removeIncorrectCodewords(s, g), g)
      }
      removeIncorrectCodewords(s, a) {
        for (let l = 0; l < s.length; l++) {
          let u = s[l]
          if (s[l] == null) continue
          let d = u.getValue() % 30,
            g = u.getRowNumber()
          if (g > a.getRowCount()) {
            s[l] = null
            continue
          }
          switch ((this._isLeft || (g += 2), g % 3)) {
            case 0:
              d * 3 + 1 !== a.getRowCountUpperPart() && (s[l] = null)
              break
            case 1:
              ;(Math.trunc(d / 3) !== a.getErrorCorrectionLevel() ||
                d % 3 !== a.getRowCountLowerPart()) &&
                (s[l] = null)
              break
            case 2:
              d + 1 !== a.getColumnCount() && (s[l] = null)
              break
          }
        }
      }
      isLeft() {
        return this._isLeft
      }
      toString() {
        return (
          'IsLeft: ' +
          this._isLeft +
          `
` +
          super.toString()
        )
      }
    }
    class aa {
      constructor(s, a) {
        ;((this.ADJUST_ROW_NUMBER_SKIP = 2),
          (this.barcodeMetadata = s),
          (this.barcodeColumnCount = s.getColumnCount()),
          (this.boundingBox = a),
          (this.detectionResultColumns = new Array(this.barcodeColumnCount + 2)))
      }
      getDetectionResultColumns() {
        ;(this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]),
          this.adjustIndicatorColumnRowNumbers(
            this.detectionResultColumns[this.barcodeColumnCount + 1]
          ))
        let s = Ee.MAX_CODEWORDS_IN_BARCODE,
          a
        do ((a = s), (s = this.adjustRowNumbersAndGetCount()))
        while (s > 0 && s < a)
        return this.detectionResultColumns
      }
      adjustIndicatorColumnRowNumbers(s) {
        s != null && s.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata)
      }
      adjustRowNumbersAndGetCount() {
        let s = this.adjustRowNumbersByRow()
        if (s === 0) return 0
        for (let a = 1; a < this.barcodeColumnCount + 1; a++) {
          let l = this.detectionResultColumns[a].getCodewords()
          for (let u = 0; u < l.length; u++)
            l[u] != null && (l[u].hasValidRowNumber() || this.adjustRowNumbers(a, u, l))
        }
        return s
      }
      adjustRowNumbersByRow() {
        return (
          this.adjustRowNumbersFromBothRI(),
          this.adjustRowNumbersFromLRI() + this.adjustRowNumbersFromRRI()
        )
      }
      adjustRowNumbersFromBothRI() {
        if (
          this.detectionResultColumns[0] == null ||
          this.detectionResultColumns[this.barcodeColumnCount + 1] == null
        )
          return
        let s = this.detectionResultColumns[0].getCodewords(),
          a = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords()
        for (let l = 0; l < s.length; l++)
          if (s[l] != null && a[l] != null && s[l].getRowNumber() === a[l].getRowNumber())
            for (let u = 1; u <= this.barcodeColumnCount; u++) {
              let d = this.detectionResultColumns[u].getCodewords()[l]
              d != null &&
                (d.setRowNumber(s[l].getRowNumber()),
                d.hasValidRowNumber() || (this.detectionResultColumns[u].getCodewords()[l] = null))
            }
      }
      adjustRowNumbersFromRRI() {
        if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) return 0
        let s = 0,
          a = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords()
        for (let l = 0; l < a.length; l++) {
          if (a[l] == null) continue
          let u = a[l].getRowNumber(),
            d = 0
          for (let g = this.barcodeColumnCount + 1; g > 0 && d < this.ADJUST_ROW_NUMBER_SKIP; g--) {
            let m = this.detectionResultColumns[g].getCodewords()[l]
            m != null && ((d = aa.adjustRowNumberIfValid(u, d, m)), m.hasValidRowNumber() || s++)
          }
        }
        return s
      }
      adjustRowNumbersFromLRI() {
        if (this.detectionResultColumns[0] == null) return 0
        let s = 0,
          a = this.detectionResultColumns[0].getCodewords()
        for (let l = 0; l < a.length; l++) {
          if (a[l] == null) continue
          let u = a[l].getRowNumber(),
            d = 0
          for (let g = 1; g < this.barcodeColumnCount + 1 && d < this.ADJUST_ROW_NUMBER_SKIP; g++) {
            let m = this.detectionResultColumns[g].getCodewords()[l]
            m != null && ((d = aa.adjustRowNumberIfValid(u, d, m)), m.hasValidRowNumber() || s++)
          }
        }
        return s
      }
      static adjustRowNumberIfValid(s, a, l) {
        return (
          l == null ||
            l.hasValidRowNumber() ||
            (l.isValidRowNumber(s) ? (l.setRowNumber(s), (a = 0)) : ++a),
          a
        )
      }
      adjustRowNumbers(s, a, l) {
        if (!this.detectionResultColumns[s - 1]) return
        let u = l[a],
          d = this.detectionResultColumns[s - 1].getCodewords(),
          g = d
        this.detectionResultColumns[s + 1] != null &&
          (g = this.detectionResultColumns[s + 1].getCodewords())
        let m = new Array(14)
        ;((m[2] = d[a]),
          (m[3] = g[a]),
          a > 0 && ((m[0] = l[a - 1]), (m[4] = d[a - 1]), (m[5] = g[a - 1])),
          a > 1 && ((m[8] = l[a - 2]), (m[10] = d[a - 2]), (m[11] = g[a - 2])),
          a < l.length - 1 && ((m[1] = l[a + 1]), (m[6] = d[a + 1]), (m[7] = g[a + 1])),
          a < l.length - 2 && ((m[9] = l[a + 2]), (m[12] = d[a + 2]), (m[13] = g[a + 2])))
        for (let b of m) if (aa.adjustRowNumber(u, b)) return
      }
      static adjustRowNumber(s, a) {
        return a == null
          ? !1
          : a.hasValidRowNumber() && a.getBucket() === s.getBucket()
            ? (s.setRowNumber(a.getRowNumber()), !0)
            : !1
      }
      getBarcodeColumnCount() {
        return this.barcodeColumnCount
      }
      getBarcodeRowCount() {
        return this.barcodeMetadata.getRowCount()
      }
      getBarcodeECLevel() {
        return this.barcodeMetadata.getErrorCorrectionLevel()
      }
      setBoundingBox(s) {
        this.boundingBox = s
      }
      getBoundingBox() {
        return this.boundingBox
      }
      setDetectionResultColumn(s, a) {
        this.detectionResultColumns[s] = a
      }
      getDetectionResultColumn(s) {
        return this.detectionResultColumns[s]
      }
      toString() {
        let s = this.detectionResultColumns[0]
        s == null && (s = this.detectionResultColumns[this.barcodeColumnCount + 1])
        let a = new ia()
        for (let l = 0; l < s.getCodewords().length; l++) {
          a.format('CW %3d:', l)
          for (let u = 0; u < this.barcodeColumnCount + 2; u++) {
            if (this.detectionResultColumns[u] == null) {
              a.format('    |   ')
              continue
            }
            let d = this.detectionResultColumns[u].getCodewords()[l]
            if (d == null) {
              a.format('    |   ')
              continue
            }
            a.format(' %3d|%3d', d.getRowNumber(), d.getValue())
          }
          a.format('%n')
        }
        return a.toString()
      }
    }
    class la {
      constructor(s, a, l, u) {
        ;((this.rowNumber = la.BARCODE_ROW_UNKNOWN),
          (this.startX = Math.trunc(s)),
          (this.endX = Math.trunc(a)),
          (this.bucket = Math.trunc(l)),
          (this.value = Math.trunc(u)))
      }
      hasValidRowNumber() {
        return this.isValidRowNumber(this.rowNumber)
      }
      isValidRowNumber(s) {
        return s !== la.BARCODE_ROW_UNKNOWN && this.bucket === (s % 3) * 3
      }
      setRowNumberAsRowIndicatorColumn() {
        this.rowNumber = Math.trunc(Math.trunc(this.value / 30) * 3 + Math.trunc(this.bucket / 3))
      }
      getWidth() {
        return this.endX - this.startX
      }
      getStartX() {
        return this.startX
      }
      getEndX() {
        return this.endX
      }
      getBucket() {
        return this.bucket
      }
      getValue() {
        return this.value
      }
      getRowNumber() {
        return this.rowNumber
      }
      setRowNumber(s) {
        this.rowNumber = s
      }
      toString() {
        return this.rowNumber + '|' + this.value
      }
    }
    la.BARCODE_ROW_UNKNOWN = -1
    class fn {
      static initialize() {
        for (let s = 0; s < Ee.SYMBOL_TABLE.length; s++) {
          let a = Ee.SYMBOL_TABLE[s],
            l = a & 1
          for (let u = 0; u < Ee.BARS_IN_MODULE; u++) {
            let d = 0
            for (; (a & 1) === l; ) ((d += 1), (a >>= 1))
            ;((l = a & 1),
              fn.RATIOS_TABLE[s] || (fn.RATIOS_TABLE[s] = new Array(Ee.BARS_IN_MODULE)),
              (fn.RATIOS_TABLE[s][Ee.BARS_IN_MODULE - u - 1] = Math.fround(
                d / Ee.MODULES_IN_CODEWORD
              )))
          }
        }
        this.bSymbolTableReady = !0
      }
      static getDecodedValue(s) {
        let a = fn.getDecodedCodewordValue(fn.sampleBitCounts(s))
        return a !== -1 ? a : fn.getClosestDecodedValue(s)
      }
      static sampleBitCounts(s) {
        let a = Pe.sum(s),
          l = new Int32Array(Ee.BARS_IN_MODULE),
          u = 0,
          d = 0
        for (let g = 0; g < Ee.MODULES_IN_CODEWORD; g++) {
          let m = a / (2 * Ee.MODULES_IN_CODEWORD) + (g * a) / Ee.MODULES_IN_CODEWORD
          ;(d + s[u] <= m && ((d += s[u]), u++), l[u]++)
        }
        return l
      }
      static getDecodedCodewordValue(s) {
        let a = fn.getBitValue(s)
        return Ee.getCodeword(a) === -1 ? -1 : a
      }
      static getBitValue(s) {
        let a = 0
        for (let l = 0; l < s.length; l++)
          for (let u = 0; u < s[l]; u++) a = (a << 1) | (l % 2 === 0 ? 1 : 0)
        return Math.trunc(a)
      }
      static getClosestDecodedValue(s) {
        let a = Pe.sum(s),
          l = new Array(Ee.BARS_IN_MODULE)
        if (a > 1) for (let g = 0; g < l.length; g++) l[g] = Math.fround(s[g] / a)
        let u = Hl.MAX_VALUE,
          d = -1
        this.bSymbolTableReady || fn.initialize()
        for (let g = 0; g < fn.RATIOS_TABLE.length; g++) {
          let m = 0,
            b = fn.RATIOS_TABLE[g]
          for (let v = 0; v < Ee.BARS_IN_MODULE; v++) {
            let C = Math.fround(b[v] - l[v])
            if (((m += Math.fround(C * C)), m >= u)) break
          }
          m < u && ((u = m), (d = Ee.SYMBOL_TABLE[g]))
        }
        return d
      }
    }
    ;((fn.bSymbolTableReady = !1),
      (fn.RATIOS_TABLE = new Array(Ee.SYMBOL_TABLE.length).map(
        (_) => new Array(Ee.BARS_IN_MODULE)
      )))
    class Ip {
      constructor() {
        ;((this.segmentCount = -1),
          (this.fileSize = -1),
          (this.timestamp = -1),
          (this.checksum = -1))
      }
      getSegmentIndex() {
        return this.segmentIndex
      }
      setSegmentIndex(s) {
        this.segmentIndex = s
      }
      getFileId() {
        return this.fileId
      }
      setFileId(s) {
        this.fileId = s
      }
      getOptionalData() {
        return this.optionalData
      }
      setOptionalData(s) {
        this.optionalData = s
      }
      isLastSegment() {
        return this.lastSegment
      }
      setLastSegment(s) {
        this.lastSegment = s
      }
      getSegmentCount() {
        return this.segmentCount
      }
      setSegmentCount(s) {
        this.segmentCount = s
      }
      getSender() {
        return this.sender || null
      }
      setSender(s) {
        this.sender = s
      }
      getAddressee() {
        return this.addressee || null
      }
      setAddressee(s) {
        this.addressee = s
      }
      getFileName() {
        return this.fileName
      }
      setFileName(s) {
        this.fileName = s
      }
      getFileSize() {
        return this.fileSize
      }
      setFileSize(s) {
        this.fileSize = s
      }
      getChecksum() {
        return this.checksum
      }
      setChecksum(s) {
        this.checksum = s
      }
      getTimestamp() {
        return this.timestamp
      }
      setTimestamp(s) {
        this.timestamp = s
      }
    }
    class Np {
      static parseLong(s, a = void 0) {
        return parseInt(s, a)
      }
    }
    class Tp extends p {}
    Tp.kind = 'NullPointerException'
    class Eb {
      writeBytes(s) {
        this.writeBytesOffset(s, 0, s.length)
      }
      writeBytesOffset(s, a, l) {
        if (s == null) throw new Tp()
        if (a < 0 || a > s.length || l < 0 || a + l > s.length || a + l < 0) throw new P()
        if (l !== 0) for (let u = 0; u < l; u++) this.write(s[a + u])
      }
      flush() {}
      close() {}
    }
    class Cb extends p {}
    class Sb extends Eb {
      constructor(s = 32) {
        if ((super(), (this.count = 0), s < 0)) throw new w('Negative initial size: ' + s)
        this.buf = new Uint8Array(s)
      }
      ensureCapacity(s) {
        s - this.buf.length > 0 && this.grow(s)
      }
      grow(s) {
        let a = this.buf.length << 1
        if ((a - s < 0 && (a = s), a < 0)) {
          if (s < 0) throw new Cb()
          a = M.MAX_VALUE
        }
        this.buf = R.copyOfUint8Array(this.buf, a)
      }
      write(s) {
        ;(this.ensureCapacity(this.count + 1), (this.buf[this.count] = s), (this.count += 1))
      }
      writeBytesOffset(s, a, l) {
        if (a < 0 || a > s.length || l < 0 || a + l - s.length > 0) throw new P()
        ;(this.ensureCapacity(this.count + l),
          k.arraycopy(s, a, this.buf, this.count, l),
          (this.count += l))
      }
      writeTo(s) {
        s.writeBytesOffset(this.buf, 0, this.count)
      }
      reset() {
        this.count = 0
      }
      toByteArray() {
        return R.copyOfUint8Array(this.buf, this.count)
      }
      size() {
        return this.count
      }
      toString(s) {
        return s
          ? typeof s == 'string'
            ? this.toString_string(s)
            : this.toString_number(s)
          : this.toString_void()
      }
      toString_void() {
        return new String(this.buf).toString()
      }
      toString_string(s) {
        return new String(this.buf).toString()
      }
      toString_number(s) {
        return new String(this.buf).toString()
      }
      close() {}
    }
    var Xe
    ;(function (_) {
      ;((_[(_.ALPHA = 0)] = 'ALPHA'),
        (_[(_.LOWER = 1)] = 'LOWER'),
        (_[(_.MIXED = 2)] = 'MIXED'),
        (_[(_.PUNCT = 3)] = 'PUNCT'),
        (_[(_.ALPHA_SHIFT = 4)] = 'ALPHA_SHIFT'),
        (_[(_.PUNCT_SHIFT = 5)] = 'PUNCT_SHIFT'))
    })(Xe || (Xe = {}))
    function Rp() {
      if (typeof window < 'u') return window.BigInt || null
      if (typeof ha < 'u') return ha.BigInt || null
      if (typeof self < 'u') return self.BigInt || null
      throw new Error("Can't search globals for BigInt!")
    }
    let Ql
    function ii(_) {
      if ((typeof Ql > 'u' && (Ql = Rp()), Ql === null)) throw new Error('BigInt is not supported!')
      return Ql(_)
    }
    function Ab() {
      let _ = []
      _[0] = ii(1)
      let s = ii(900)
      _[1] = s
      for (let a = 2; a < 16; a++) _[a] = _[a - 1] * s
      return _
    }
    class K {
      static decode(s, a) {
        let l = new ve(''),
          u = Z.ISO8859_1
        l.enableDecoding(u)
        let d = 1,
          g = s[d++],
          m = new Ip()
        for (; d < s[0]; ) {
          switch (g) {
            case K.TEXT_COMPACTION_MODE_LATCH:
              d = K.textCompaction(s, d, l)
              break
            case K.BYTE_COMPACTION_MODE_LATCH:
            case K.BYTE_COMPACTION_MODE_LATCH_6:
              d = K.byteCompaction(g, s, u, d, l)
              break
            case K.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
              l.append(s[d++])
              break
            case K.NUMERIC_COMPACTION_MODE_LATCH:
              d = K.numericCompaction(s, d, l)
              break
            case K.ECI_CHARSET:
              Z.getCharacterSetECIByValue(s[d++])
              break
            case K.ECI_GENERAL_PURPOSE:
              d += 2
              break
            case K.ECI_USER_DEFINED:
              d++
              break
            case K.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              d = K.decodeMacroBlock(s, d, m)
              break
            case K.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
            case K.MACRO_PDF417_TERMINATOR:
              throw new V()
            default:
              ;(d--, (d = K.textCompaction(s, d, l)))
              break
          }
          if (d < s.length) g = s[d++]
          else throw V.getFormatInstance()
        }
        if (l.length() === 0) throw V.getFormatInstance()
        let b = new Jo(null, l.toString(), null, a)
        return (b.setOther(m), b)
      }
      static decodeMacroBlock(s, a, l) {
        if (a + K.NUMBER_OF_SEQUENCE_CODEWORDS > s[0]) throw V.getFormatInstance()
        let u = new Int32Array(K.NUMBER_OF_SEQUENCE_CODEWORDS)
        for (let m = 0; m < K.NUMBER_OF_SEQUENCE_CODEWORDS; m++, a++) u[m] = s[a]
        l.setSegmentIndex(M.parseInt(K.decodeBase900toBase10(u, K.NUMBER_OF_SEQUENCE_CODEWORDS)))
        let d = new ve()
        ;((a = K.textCompaction(s, a, d)), l.setFileId(d.toString()))
        let g = -1
        for (s[a] === K.BEGIN_MACRO_PDF417_OPTIONAL_FIELD && (g = a + 1); a < s[0]; )
          switch (s[a]) {
            case K.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              switch ((a++, s[a])) {
                case K.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                  let m = new ve()
                  ;((a = K.textCompaction(s, a + 1, m)), l.setFileName(m.toString()))
                  break
                case K.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                  let b = new ve()
                  ;((a = K.textCompaction(s, a + 1, b)), l.setSender(b.toString()))
                  break
                case K.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                  let v = new ve()
                  ;((a = K.textCompaction(s, a + 1, v)), l.setAddressee(v.toString()))
                  break
                case K.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                  let C = new ve()
                  ;((a = K.numericCompaction(s, a + 1, C)),
                    l.setSegmentCount(M.parseInt(C.toString())))
                  break
                case K.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                  let T = new ve()
                  ;((a = K.numericCompaction(s, a + 1, T)),
                    l.setTimestamp(Np.parseLong(T.toString())))
                  break
                case K.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                  let D = new ve()
                  ;((a = K.numericCompaction(s, a + 1, D)), l.setChecksum(M.parseInt(D.toString())))
                  break
                case K.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                  let B = new ve()
                  ;((a = K.numericCompaction(s, a + 1, B)),
                    l.setFileSize(Np.parseLong(B.toString())))
                  break
                default:
                  throw V.getFormatInstance()
              }
              break
            case K.MACRO_PDF417_TERMINATOR:
              ;(a++, l.setLastSegment(!0))
              break
            default:
              throw V.getFormatInstance()
          }
        if (g !== -1) {
          let m = a - g
          ;(l.isLastSegment() && m--, l.setOptionalData(R.copyOfRange(s, g, g + m)))
        }
        return a
      }
      static textCompaction(s, a, l) {
        let u = new Int32Array((s[0] - a) * 2),
          d = new Int32Array((s[0] - a) * 2),
          g = 0,
          m = !1
        for (; a < s[0] && !m; ) {
          let b = s[a++]
          if (b < K.TEXT_COMPACTION_MODE_LATCH) ((u[g] = b / 30), (u[g + 1] = b % 30), (g += 2))
          else
            switch (b) {
              case K.TEXT_COMPACTION_MODE_LATCH:
                u[g++] = K.TEXT_COMPACTION_MODE_LATCH
                break
              case K.BYTE_COMPACTION_MODE_LATCH:
              case K.BYTE_COMPACTION_MODE_LATCH_6:
              case K.NUMERIC_COMPACTION_MODE_LATCH:
              case K.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case K.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case K.MACRO_PDF417_TERMINATOR:
                ;(a--, (m = !0))
                break
              case K.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                ;((u[g] = K.MODE_SHIFT_TO_BYTE_COMPACTION_MODE), (b = s[a++]), (d[g] = b), g++)
                break
            }
        }
        return (K.decodeTextCompaction(u, d, g, l), a)
      }
      static decodeTextCompaction(s, a, l, u) {
        let d = Xe.ALPHA,
          g = Xe.ALPHA,
          m = 0
        for (; m < l; ) {
          let b = s[m],
            v = ''
          switch (d) {
            case Xe.ALPHA:
              if (b < 26) v = String.fromCharCode(65 + b)
              else
                switch (b) {
                  case 26:
                    v = ' '
                    break
                  case K.LL:
                    d = Xe.LOWER
                    break
                  case K.ML:
                    d = Xe.MIXED
                    break
                  case K.PS:
                    ;((g = d), (d = Xe.PUNCT_SHIFT))
                    break
                  case K.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    u.append(a[m])
                    break
                  case K.TEXT_COMPACTION_MODE_LATCH:
                    d = Xe.ALPHA
                    break
                }
              break
            case Xe.LOWER:
              if (b < 26) v = String.fromCharCode(97 + b)
              else
                switch (b) {
                  case 26:
                    v = ' '
                    break
                  case K.AS:
                    ;((g = d), (d = Xe.ALPHA_SHIFT))
                    break
                  case K.ML:
                    d = Xe.MIXED
                    break
                  case K.PS:
                    ;((g = d), (d = Xe.PUNCT_SHIFT))
                    break
                  case K.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    u.append(a[m])
                    break
                  case K.TEXT_COMPACTION_MODE_LATCH:
                    d = Xe.ALPHA
                    break
                }
              break
            case Xe.MIXED:
              if (b < K.PL) v = K.MIXED_CHARS[b]
              else
                switch (b) {
                  case K.PL:
                    d = Xe.PUNCT
                    break
                  case 26:
                    v = ' '
                    break
                  case K.LL:
                    d = Xe.LOWER
                    break
                  case K.AL:
                    d = Xe.ALPHA
                    break
                  case K.PS:
                    ;((g = d), (d = Xe.PUNCT_SHIFT))
                    break
                  case K.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    u.append(a[m])
                    break
                  case K.TEXT_COMPACTION_MODE_LATCH:
                    d = Xe.ALPHA
                    break
                }
              break
            case Xe.PUNCT:
              if (b < K.PAL) v = K.PUNCT_CHARS[b]
              else
                switch (b) {
                  case K.PAL:
                    d = Xe.ALPHA
                    break
                  case K.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    u.append(a[m])
                    break
                  case K.TEXT_COMPACTION_MODE_LATCH:
                    d = Xe.ALPHA
                    break
                }
              break
            case Xe.ALPHA_SHIFT:
              if (((d = g), b < 26)) v = String.fromCharCode(65 + b)
              else
                switch (b) {
                  case 26:
                    v = ' '
                    break
                  case K.TEXT_COMPACTION_MODE_LATCH:
                    d = Xe.ALPHA
                    break
                }
              break
            case Xe.PUNCT_SHIFT:
              if (((d = g), b < K.PAL)) v = K.PUNCT_CHARS[b]
              else
                switch (b) {
                  case K.PAL:
                    d = Xe.ALPHA
                    break
                  case K.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    u.append(a[m])
                    break
                  case K.TEXT_COMPACTION_MODE_LATCH:
                    d = Xe.ALPHA
                    break
                }
              break
          }
          ;(v !== '' && u.append(v), m++)
        }
      }
      static byteCompaction(s, a, l, u, d) {
        let g = new Sb(),
          m = 0,
          b = 0,
          v = !1
        switch (s) {
          case K.BYTE_COMPACTION_MODE_LATCH:
            let C = new Int32Array(6),
              T = a[u++]
            for (; u < a[0] && !v; )
              switch (((C[m++] = T), (b = 900 * b + T), (T = a[u++]), T)) {
                case K.TEXT_COMPACTION_MODE_LATCH:
                case K.BYTE_COMPACTION_MODE_LATCH:
                case K.NUMERIC_COMPACTION_MODE_LATCH:
                case K.BYTE_COMPACTION_MODE_LATCH_6:
                case K.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                case K.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case K.MACRO_PDF417_TERMINATOR:
                  ;(u--, (v = !0))
                  break
                default:
                  if (m % 5 === 0 && m > 0) {
                    for (let D = 0; D < 6; ++D) g.write(Number(ii(b) >> ii(8 * (5 - D))))
                    ;((b = 0), (m = 0))
                  }
                  break
              }
            u === a[0] && T < K.TEXT_COMPACTION_MODE_LATCH && (C[m++] = T)
            for (let D = 0; D < m; D++) g.write(C[D])
            break
          case K.BYTE_COMPACTION_MODE_LATCH_6:
            for (; u < a[0] && !v; ) {
              let D = a[u++]
              if (D < K.TEXT_COMPACTION_MODE_LATCH) (m++, (b = 900 * b + D))
              else
                switch (D) {
                  case K.TEXT_COMPACTION_MODE_LATCH:
                  case K.BYTE_COMPACTION_MODE_LATCH:
                  case K.NUMERIC_COMPACTION_MODE_LATCH:
                  case K.BYTE_COMPACTION_MODE_LATCH_6:
                  case K.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  case K.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case K.MACRO_PDF417_TERMINATOR:
                    ;(u--, (v = !0))
                    break
                }
              if (m % 5 === 0 && m > 0) {
                for (let B = 0; B < 6; ++B) g.write(Number(ii(b) >> ii(8 * (5 - B))))
                ;((b = 0), (m = 0))
              }
            }
            break
        }
        return (d.append(oe.decode(g.toByteArray(), l)), u)
      }
      static numericCompaction(s, a, l) {
        let u = 0,
          d = !1,
          g = new Int32Array(K.MAX_NUMERIC_CODEWORDS)
        for (; a < s[0] && !d; ) {
          let m = s[a++]
          if ((a === s[0] && (d = !0), m < K.TEXT_COMPACTION_MODE_LATCH)) ((g[u] = m), u++)
          else
            switch (m) {
              case K.TEXT_COMPACTION_MODE_LATCH:
              case K.BYTE_COMPACTION_MODE_LATCH:
              case K.BYTE_COMPACTION_MODE_LATCH_6:
              case K.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case K.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case K.MACRO_PDF417_TERMINATOR:
                ;(a--, (d = !0))
                break
            }
          ;(u % K.MAX_NUMERIC_CODEWORDS === 0 || m === K.NUMERIC_COMPACTION_MODE_LATCH || d) &&
            u > 0 &&
            (l.append(K.decodeBase900toBase10(g, u)), (u = 0))
        }
        return a
      }
      static decodeBase900toBase10(s, a) {
        let l = ii(0)
        for (let d = 0; d < a; d++) l += K.EXP900[a - d - 1] * ii(s[d])
        let u = l.toString()
        if (u.charAt(0) !== '1') throw new V()
        return u.substring(1)
      }
    }
    ;((K.TEXT_COMPACTION_MODE_LATCH = 900),
      (K.BYTE_COMPACTION_MODE_LATCH = 901),
      (K.NUMERIC_COMPACTION_MODE_LATCH = 902),
      (K.BYTE_COMPACTION_MODE_LATCH_6 = 924),
      (K.ECI_USER_DEFINED = 925),
      (K.ECI_GENERAL_PURPOSE = 926),
      (K.ECI_CHARSET = 927),
      (K.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928),
      (K.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923),
      (K.MACRO_PDF417_TERMINATOR = 922),
      (K.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913),
      (K.MAX_NUMERIC_CODEWORDS = 15),
      (K.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0),
      (K.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1),
      (K.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2),
      (K.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3),
      (K.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4),
      (K.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5),
      (K.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6),
      (K.PL = 25),
      (K.LL = 27),
      (K.AS = 27),
      (K.ML = 28),
      (K.AL = 28),
      (K.PS = 29),
      (K.PAL = 29),
      (K.PUNCT_CHARS = `;<>@[\\]_\`~!\r	,:
-.$/"|*()?{}'`),
      (K.MIXED_CHARS = '0123456789&\r	,:#-.$/+%*=^'),
      (K.EXP900 = Rp() ? Ab() : []),
      (K.NUMBER_OF_SEQUENCE_CODEWORDS = 2))
    class ke {
      constructor() {}
      static decode(s, a, l, u, d, g, m) {
        let b = new Gi(s, a, l, u, d),
          v = null,
          C = null,
          T
        for (let j = !0; ; j = !1) {
          if (
            (a != null && (v = ke.getRowIndicatorColumn(s, b, a, !0, g, m)),
            u != null && (C = ke.getRowIndicatorColumn(s, b, u, !1, g, m)),
            (T = ke.merge(v, C)),
            T == null)
          )
            throw H.getNotFoundInstance()
          let W = T.getBoundingBox()
          if (j && W != null && (W.getMinY() < b.getMinY() || W.getMaxY() > b.getMaxY())) b = W
          else break
        }
        T.setBoundingBox(b)
        let D = T.getBarcodeColumnCount() + 1
        ;(T.setDetectionResultColumn(0, v), T.setDetectionResultColumn(D, C))
        let B = v != null
        for (let j = 1; j <= D; j++) {
          let W = B ? j : D - j
          if (T.getDetectionResultColumn(W) !== void 0) continue
          let Y
          ;(W === 0 || W === D ? (Y = new _p(b, W === 0)) : (Y = new sa(b)),
            T.setDetectionResultColumn(W, Y))
          let q = -1,
            ne = q
          for (let te = b.getMinY(); te <= b.getMaxY(); te++) {
            if (((q = ke.getStartColumn(T, W, te, B)), q < 0 || q > b.getMaxX())) {
              if (ne === -1) continue
              q = ne
            }
            let $ = ke.detectCodeword(s, b.getMinX(), b.getMaxX(), B, q, te, g, m)
            $ != null &&
              (Y.setCodeword(te, $),
              (ne = q),
              (g = Math.min(g, $.getWidth())),
              (m = Math.max(m, $.getWidth())))
          }
        }
        return ke.createDecoderResult(T)
      }
      static merge(s, a) {
        if (s == null && a == null) return null
        let l = ke.getBarcodeMetadata(s, a)
        if (l == null) return null
        let u = Gi.merge(ke.adjustBoundingBox(s), ke.adjustBoundingBox(a))
        return new aa(l, u)
      }
      static adjustBoundingBox(s) {
        if (s == null) return null
        let a = s.getRowHeights()
        if (a == null) return null
        let l = ke.getMax(a),
          u = 0
        for (let m of a) if (((u += l - m), m > 0)) break
        let d = s.getCodewords()
        for (let m = 0; u > 0 && d[m] == null; m++) u--
        let g = 0
        for (let m = a.length - 1; m >= 0 && ((g += l - a[m]), !(a[m] > 0)); m--);
        for (let m = d.length - 1; g > 0 && d[m] == null; m--) g--
        return s.getBoundingBox().addMissingRows(u, g, s.isLeft())
      }
      static getMax(s) {
        let a = -1
        for (let l of s) a = Math.max(a, l)
        return a
      }
      static getBarcodeMetadata(s, a) {
        let l
        if (s == null || (l = s.getBarcodeMetadata()) == null)
          return a == null ? null : a.getBarcodeMetadata()
        let u
        return a == null || (u = a.getBarcodeMetadata()) == null
          ? l
          : l.getColumnCount() !== u.getColumnCount() &&
              l.getErrorCorrectionLevel() !== u.getErrorCorrectionLevel() &&
              l.getRowCount() !== u.getRowCount()
            ? null
            : l
      }
      static getRowIndicatorColumn(s, a, l, u, d, g) {
        let m = new _p(a, u)
        for (let b = 0; b < 2; b++) {
          let v = b === 0 ? 1 : -1,
            C = Math.trunc(Math.trunc(l.getX()))
          for (
            let T = Math.trunc(Math.trunc(l.getY()));
            T <= a.getMaxY() && T >= a.getMinY();
            T += v
          ) {
            let D = ke.detectCodeword(s, 0, s.getWidth(), u, C, T, d, g)
            D != null && (m.setCodeword(T, D), u ? (C = D.getStartX()) : (C = D.getEndX()))
          }
        }
        return m
      }
      static adjustCodewordCount(s, a) {
        let l = a[0][1],
          u = l.getValue(),
          d =
            s.getBarcodeColumnCount() * s.getBarcodeRowCount() -
            ke.getNumberOfECCodeWords(s.getBarcodeECLevel())
        if (u.length === 0) {
          if (d < 1 || d > Ee.MAX_CODEWORDS_IN_BARCODE) throw H.getNotFoundInstance()
          l.setValue(d)
        } else u[0] !== d && l.setValue(d)
      }
      static createDecoderResult(s) {
        let a = ke.createBarcodeMatrix(s)
        ke.adjustCodewordCount(s, a)
        let l = new Array(),
          u = new Int32Array(s.getBarcodeRowCount() * s.getBarcodeColumnCount()),
          d = [],
          g = new Array()
        for (let b = 0; b < s.getBarcodeRowCount(); b++)
          for (let v = 0; v < s.getBarcodeColumnCount(); v++) {
            let C = a[b][v + 1].getValue(),
              T = b * s.getBarcodeColumnCount() + v
            C.length === 0 ? l.push(T) : C.length === 1 ? (u[T] = C[0]) : (g.push(T), d.push(C))
          }
        let m = new Array(d.length)
        for (let b = 0; b < m.length; b++) m[b] = d[b]
        return ke.createDecoderResultFromAmbiguousValues(
          s.getBarcodeECLevel(),
          u,
          Ee.toIntArray(l),
          Ee.toIntArray(g),
          m
        )
      }
      static createDecoderResultFromAmbiguousValues(s, a, l, u, d) {
        let g = new Int32Array(u.length),
          m = 100
        for (; m-- > 0; ) {
          for (let b = 0; b < g.length; b++) a[u[b]] = d[b][g[b]]
          try {
            return ke.decodeCodewords(a, s, l)
          } catch (b) {
            if (!(b instanceof E)) throw b
          }
          if (g.length === 0) throw E.getChecksumInstance()
          for (let b = 0; b < g.length; b++)
            if (g[b] < d[b].length - 1) {
              g[b]++
              break
            } else if (((g[b] = 0), b === g.length - 1)) throw E.getChecksumInstance()
        }
        throw E.getChecksumInstance()
      }
      static createBarcodeMatrix(s) {
        let a = Array.from(
          { length: s.getBarcodeRowCount() },
          () => new Array(s.getBarcodeColumnCount() + 2)
        )
        for (let u = 0; u < a.length; u++) for (let d = 0; d < a[u].length; d++) a[u][d] = new oa()
        let l = 0
        for (let u of s.getDetectionResultColumns()) {
          if (u != null) {
            for (let d of u.getCodewords())
              if (d != null) {
                let g = d.getRowNumber()
                if (g >= 0) {
                  if (g >= a.length) continue
                  a[g][l].setValue(d.getValue())
                }
              }
          }
          l++
        }
        return a
      }
      static isValidBarcodeColumn(s, a) {
        return a >= 0 && a <= s.getBarcodeColumnCount() + 1
      }
      static getStartColumn(s, a, l, u) {
        let d = u ? 1 : -1,
          g = null
        if (
          (ke.isValidBarcodeColumn(s, a - d) &&
            (g = s.getDetectionResultColumn(a - d).getCodeword(l)),
          g != null)
        )
          return u ? g.getEndX() : g.getStartX()
        if (((g = s.getDetectionResultColumn(a).getCodewordNearby(l)), g != null))
          return u ? g.getStartX() : g.getEndX()
        if (
          (ke.isValidBarcodeColumn(s, a - d) &&
            (g = s.getDetectionResultColumn(a - d).getCodewordNearby(l)),
          g != null)
        )
          return u ? g.getEndX() : g.getStartX()
        let m = 0
        for (; ke.isValidBarcodeColumn(s, a - d); ) {
          a -= d
          for (let b of s.getDetectionResultColumn(a).getCodewords())
            if (b != null)
              return (u ? b.getEndX() : b.getStartX()) + d * m * (b.getEndX() - b.getStartX())
          m++
        }
        return u ? s.getBoundingBox().getMinX() : s.getBoundingBox().getMaxX()
      }
      static detectCodeword(s, a, l, u, d, g, m, b) {
        d = ke.adjustCodewordStartColumn(s, a, l, u, d, g)
        let v = ke.getModuleBitCount(s, a, l, u, d, g)
        if (v == null) return null
        let C,
          T = Pe.sum(v)
        if (u) C = d + T
        else {
          for (let j = 0; j < v.length / 2; j++) {
            let W = v[j]
            ;((v[j] = v[v.length - 1 - j]), (v[v.length - 1 - j] = W))
          }
          ;((C = d), (d = C - T))
        }
        if (!ke.checkCodewordSkew(T, m, b)) return null
        let D = fn.getDecodedValue(v),
          B = Ee.getCodeword(D)
        return B === -1 ? null : new la(d, C, ke.getCodewordBucketNumber(D), B)
      }
      static getModuleBitCount(s, a, l, u, d, g) {
        let m = d,
          b = new Int32Array(8),
          v = 0,
          C = u ? 1 : -1,
          T = u
        for (; (u ? m < l : m >= a) && v < b.length; )
          s.get(m, g) === T ? (b[v]++, (m += C)) : (v++, (T = !T))
        return v === b.length || (m === (u ? l : a) && v === b.length - 1) ? b : null
      }
      static getNumberOfECCodeWords(s) {
        return 2 << s
      }
      static adjustCodewordStartColumn(s, a, l, u, d, g) {
        let m = d,
          b = u ? -1 : 1
        for (let v = 0; v < 2; v++) {
          for (; (u ? m >= a : m < l) && u === s.get(m, g); ) {
            if (Math.abs(d - m) > ke.CODEWORD_SKEW_SIZE) return d
            m += b
          }
          ;((b = -b), (u = !u))
        }
        return m
      }
      static checkCodewordSkew(s, a, l) {
        return a - ke.CODEWORD_SKEW_SIZE <= s && s <= l + ke.CODEWORD_SKEW_SIZE
      }
      static decodeCodewords(s, a, l) {
        if (s.length === 0) throw V.getFormatInstance()
        let u = 1 << (a + 1),
          d = ke.correctErrors(s, l, u)
        ke.verifyCodewordCount(s, u)
        let g = K.decode(s, '' + a)
        return (g.setErrorsCorrected(d), g.setErasures(l.length), g)
      }
      static correctErrors(s, a, l) {
        if ((a != null && a.length > l / 2 + ke.MAX_ERRORS) || l < 0 || l > ke.MAX_EC_CODEWORDS)
          throw E.getChecksumInstance()
        return ke.errorCorrection.decode(s, l, a)
      }
      static verifyCodewordCount(s, a) {
        if (s.length < 4) throw V.getFormatInstance()
        let l = s[0]
        if (l > s.length) throw V.getFormatInstance()
        if (l === 0)
          if (a < s.length) s[0] = s.length - a
          else throw V.getFormatInstance()
      }
      static getBitCountForCodeword(s) {
        let a = new Int32Array(8),
          l = 0,
          u = a.length - 1
        for (; !((s & 1) !== l && ((l = s & 1), u--, u < 0)); ) (a[u]++, (s >>= 1))
        return a
      }
      static getCodewordBucketNumber(s) {
        return s instanceof Int32Array
          ? this.getCodewordBucketNumber_Int32Array(s)
          : this.getCodewordBucketNumber_number(s)
      }
      static getCodewordBucketNumber_number(s) {
        return ke.getCodewordBucketNumber(ke.getBitCountForCodeword(s))
      }
      static getCodewordBucketNumber_Int32Array(s) {
        return (s[0] - s[2] + s[4] - s[6] + 9) % 9
      }
      static toString(s) {
        let a = new ia()
        for (let l = 0; l < s.length; l++) {
          a.format('Row %2d: ', l)
          for (let u = 0; u < s[l].length; u++) {
            let d = s[l][u]
            d.getValue().length === 0
              ? a.format('        ', null)
              : a.format('%4d(%2d)', d.getValue()[0], d.getConfidence(d.getValue()[0]))
          }
          a.format('%n')
        }
        return a.toString()
      }
    }
    ;((ke.CODEWORD_SKEW_SIZE = 2),
      (ke.MAX_ERRORS = 3),
      (ke.MAX_EC_CODEWORDS = 512),
      (ke.errorCorrection = new kp()))
    class Vt {
      decode(s, a = null) {
        let l = Vt.decode(s, a, !1)
        if (l == null || l.length === 0 || l[0] == null) throw H.getNotFoundInstance()
        return l[0]
      }
      decodeMultiple(s, a = null) {
        try {
          return Vt.decode(s, a, !0)
        } catch (l) {
          throw l instanceof V || l instanceof E ? H.getNotFoundInstance() : l
        }
      }
      static decode(s, a, l) {
        const u = new Array(),
          d = Ae.detectMultiple(s, a, l)
        for (const g of d.getPoints()) {
          const m = ke.decode(
              d.getBits(),
              g[4],
              g[5],
              g[6],
              g[7],
              Vt.getMinCodewordWidth(g),
              Vt.getMaxCodewordWidth(g)
            ),
            b = new Be(m.getText(), m.getRawBytes(), void 0, g, ue.PDF_417)
          b.putMetadata(Rt.ERROR_CORRECTION_LEVEL, m.getECLevel())
          const v = m.getOther()
          ;(v != null && b.putMetadata(Rt.PDF417_EXTRA_METADATA, v), u.push(b))
        }
        return u.map((g) => g)
      }
      static getMaxWidth(s, a) {
        return s == null || a == null ? 0 : Math.trunc(Math.abs(s.getX() - a.getX()))
      }
      static getMinWidth(s, a) {
        return s == null || a == null ? M.MAX_VALUE : Math.trunc(Math.abs(s.getX() - a.getX()))
      }
      static getMaxCodewordWidth(s) {
        return Math.floor(
          Math.max(
            Math.max(
              Vt.getMaxWidth(s[0], s[4]),
              (Vt.getMaxWidth(s[6], s[2]) * Ee.MODULES_IN_CODEWORD) / Ee.MODULES_IN_STOP_PATTERN
            ),
            Math.max(
              Vt.getMaxWidth(s[1], s[5]),
              (Vt.getMaxWidth(s[7], s[3]) * Ee.MODULES_IN_CODEWORD) / Ee.MODULES_IN_STOP_PATTERN
            )
          )
        )
      }
      static getMinCodewordWidth(s) {
        return Math.floor(
          Math.min(
            Math.min(
              Vt.getMinWidth(s[0], s[4]),
              (Vt.getMinWidth(s[6], s[2]) * Ee.MODULES_IN_CODEWORD) / Ee.MODULES_IN_STOP_PATTERN
            ),
            Math.min(
              Vt.getMinWidth(s[1], s[5]),
              (Vt.getMinWidth(s[7], s[3]) * Ee.MODULES_IN_CODEWORD) / Ee.MODULES_IN_STOP_PATTERN
            )
          )
        )
      }
      reset() {}
    }
    class $l extends p {}
    $l.kind = 'ReaderException'
    class Mp {
      constructor(s, a) {
        ;((this.verbose = s === !0), a && this.setHints(a))
      }
      decode(s, a) {
        return (a && this.setHints(a), this.decodeInternal(s))
      }
      decodeWithState(s) {
        return (
          (this.readers === null || this.readers === void 0) && this.setHints(null),
          this.decodeInternal(s)
        )
      }
      setHints(s) {
        this.hints = s
        const a = !r(s) && s.get(z.TRY_HARDER) === !0,
          l = r(s) ? null : s.get(z.POSSIBLE_FORMATS),
          u = new Array()
        if (!r(l)) {
          const d = l.some(
            (g) =>
              g === ue.UPC_A ||
              g === ue.UPC_E ||
              g === ue.EAN_13 ||
              g === ue.EAN_8 ||
              g === ue.CODABAR ||
              g === ue.CODE_39 ||
              g === ue.CODE_93 ||
              g === ue.CODE_128 ||
              g === ue.ITF ||
              g === ue.RSS_14 ||
              g === ue.RSS_EXPANDED
          )
          ;(d && !a && u.push(new Zs(s, this.verbose)),
            l.includes(ue.QR_CODE) && u.push(new ri()),
            l.includes(ue.DATA_MATRIX) && u.push(new ni()),
            l.includes(ue.AZTEC) && u.push(new Gl()),
            l.includes(ue.PDF_417) && u.push(new Vt()),
            d && a && u.push(new Zs(s, this.verbose)))
        }
        ;(u.length === 0 &&
          (a || u.push(new Zs(s, this.verbose)),
          u.push(new ri()),
          u.push(new ni()),
          u.push(new Gl()),
          u.push(new Vt()),
          a && u.push(new Zs(s, this.verbose))),
          (this.readers = u))
      }
      reset() {
        if (this.readers !== null) for (const s of this.readers) s.reset()
      }
      decodeInternal(s) {
        if (this.readers === null) throw new $l('No readers where selected, nothing can be read.')
        for (const a of this.readers)
          try {
            return a.decode(s, this.hints)
          } catch (l) {
            if (l instanceof $l) continue
          }
        throw new H('No MultiFormat Readers were able to detect the code.')
      }
    }
    class kb extends Tt {
      constructor(s = null, a = 500) {
        const l = new Mp()
        ;(l.setHints(s), super(l, a))
      }
      decodeBitmap(s) {
        return this.reader.decodeWithState(s)
      }
    }
    class _b extends Tt {
      constructor(s = 500) {
        super(new Vt(), s)
      }
    }
    class Ib extends Tt {
      constructor(s = 500) {
        super(new ri(), s)
      }
    }
    var Vh
    ;(function (_) {
      ;((_[(_.ERROR_CORRECTION = 0)] = 'ERROR_CORRECTION'),
        (_[(_.CHARACTER_SET = 1)] = 'CHARACTER_SET'),
        (_[(_.DATA_MATRIX_SHAPE = 2)] = 'DATA_MATRIX_SHAPE'),
        (_[(_.MIN_SIZE = 3)] = 'MIN_SIZE'),
        (_[(_.MAX_SIZE = 4)] = 'MAX_SIZE'),
        (_[(_.MARGIN = 5)] = 'MARGIN'),
        (_[(_.PDF417_COMPACT = 6)] = 'PDF417_COMPACT'),
        (_[(_.PDF417_COMPACTION = 7)] = 'PDF417_COMPACTION'),
        (_[(_.PDF417_DIMENSIONS = 8)] = 'PDF417_DIMENSIONS'),
        (_[(_.AZTEC_LAYERS = 9)] = 'AZTEC_LAYERS'),
        (_[(_.QR_VERSION = 10)] = 'QR_VERSION'))
    })(Vh || (Vh = {}))
    var _t = Vh
    class Uh {
      constructor(s) {
        ;((this.field = s),
          (this.cachedGenerators = []),
          this.cachedGenerators.push(new un(s, Int32Array.from([1]))))
      }
      buildGenerator(s) {
        const a = this.cachedGenerators
        if (s >= a.length) {
          let l = a[a.length - 1]
          const u = this.field
          for (let d = a.length; d <= s; d++) {
            const g = l.multiply(
              new un(u, Int32Array.from([1, u.exp(d - 1 + u.getGeneratorBase())]))
            )
            ;(a.push(g), (l = g))
          }
        }
        return a[s]
      }
      encode(s, a) {
        if (a === 0) throw new w('No error correction bytes')
        const l = s.length - a
        if (l <= 0) throw new w('No data bytes provided')
        const u = this.buildGenerator(a),
          d = new Int32Array(l)
        k.arraycopy(s, 0, d, 0, l)
        let g = new un(this.field, d)
        g = g.multiplyByMonomial(a, 1)
        const m = g.divide(u)[1].getCoefficients(),
          b = a - m.length
        for (let v = 0; v < b; v++) s[l + v] = 0
        k.arraycopy(m, 0, s, l + b, m.length)
      }
    }
    class gt {
      constructor() {}
      static applyMaskPenaltyRule1(s) {
        return gt.applyMaskPenaltyRule1Internal(s, !0) + gt.applyMaskPenaltyRule1Internal(s, !1)
      }
      static applyMaskPenaltyRule2(s) {
        let a = 0
        const l = s.getArray(),
          u = s.getWidth(),
          d = s.getHeight()
        for (let g = 0; g < d - 1; g++) {
          const m = l[g]
          for (let b = 0; b < u - 1; b++) {
            const v = m[b]
            v === m[b + 1] && v === l[g + 1][b] && v === l[g + 1][b + 1] && a++
          }
        }
        return gt.N2 * a
      }
      static applyMaskPenaltyRule3(s) {
        let a = 0
        const l = s.getArray(),
          u = s.getWidth(),
          d = s.getHeight()
        for (let g = 0; g < d; g++)
          for (let m = 0; m < u; m++) {
            const b = l[g]
            ;(m + 6 < u &&
              b[m] === 1 &&
              b[m + 1] === 0 &&
              b[m + 2] === 1 &&
              b[m + 3] === 1 &&
              b[m + 4] === 1 &&
              b[m + 5] === 0 &&
              b[m + 6] === 1 &&
              (gt.isWhiteHorizontal(b, m - 4, m) || gt.isWhiteHorizontal(b, m + 7, m + 11)) &&
              a++,
              g + 6 < d &&
                l[g][m] === 1 &&
                l[g + 1][m] === 0 &&
                l[g + 2][m] === 1 &&
                l[g + 3][m] === 1 &&
                l[g + 4][m] === 1 &&
                l[g + 5][m] === 0 &&
                l[g + 6][m] === 1 &&
                (gt.isWhiteVertical(l, m, g - 4, g) || gt.isWhiteVertical(l, m, g + 7, g + 11)) &&
                a++)
          }
        return a * gt.N3
      }
      static isWhiteHorizontal(s, a, l) {
        ;((a = Math.max(a, 0)), (l = Math.min(l, s.length)))
        for (let u = a; u < l; u++) if (s[u] === 1) return !1
        return !0
      }
      static isWhiteVertical(s, a, l, u) {
        ;((l = Math.max(l, 0)), (u = Math.min(u, s.length)))
        for (let d = l; d < u; d++) if (s[d][a] === 1) return !1
        return !0
      }
      static applyMaskPenaltyRule4(s) {
        let a = 0
        const l = s.getArray(),
          u = s.getWidth(),
          d = s.getHeight()
        for (let m = 0; m < d; m++) {
          const b = l[m]
          for (let v = 0; v < u; v++) b[v] === 1 && a++
        }
        const g = s.getHeight() * s.getWidth()
        return Math.floor((Math.abs(a * 2 - g) * 10) / g) * gt.N4
      }
      static getDataMaskBit(s, a, l) {
        let u, d
        switch (s) {
          case 0:
            u = (l + a) & 1
            break
          case 1:
            u = l & 1
            break
          case 2:
            u = a % 3
            break
          case 3:
            u = (l + a) % 3
            break
          case 4:
            u = (Math.floor(l / 2) + Math.floor(a / 3)) & 1
            break
          case 5:
            ;((d = l * a), (u = (d & 1) + (d % 3)))
            break
          case 6:
            ;((d = l * a), (u = ((d & 1) + (d % 3)) & 1))
            break
          case 7:
            ;((d = l * a), (u = ((d % 3) + ((l + a) & 1)) & 1))
            break
          default:
            throw new w('Invalid mask pattern: ' + s)
        }
        return u === 0
      }
      static applyMaskPenaltyRule1Internal(s, a) {
        let l = 0
        const u = a ? s.getHeight() : s.getWidth(),
          d = a ? s.getWidth() : s.getHeight(),
          g = s.getArray()
        for (let m = 0; m < u; m++) {
          let b = 0,
            v = -1
          for (let C = 0; C < d; C++) {
            const T = a ? g[m][C] : g[C][m]
            T === v ? b++ : (b >= 5 && (l += gt.N1 + (b - 5)), (b = 1), (v = T))
          }
          b >= 5 && (l += gt.N1 + (b - 5))
        }
        return l
      }
    }
    ;((gt.N1 = 3), (gt.N2 = 3), (gt.N3 = 40), (gt.N4 = 10))
    class Jl {
      constructor(s, a) {
        ;((this.width = s), (this.height = a))
        const l = new Array(a)
        for (let u = 0; u !== a; u++) l[u] = new Uint8Array(s)
        this.bytes = l
      }
      getHeight() {
        return this.height
      }
      getWidth() {
        return this.width
      }
      get(s, a) {
        return this.bytes[a][s]
      }
      getArray() {
        return this.bytes
      }
      setNumber(s, a, l) {
        this.bytes[a][s] = l
      }
      setBoolean(s, a, l) {
        this.bytes[a][s] = l ? 1 : 0
      }
      clear(s) {
        for (const a of this.bytes) R.fill(a, s)
      }
      equals(s) {
        if (!(s instanceof Jl)) return !1
        const a = s
        if (this.width !== a.width || this.height !== a.height) return !1
        for (let l = 0, u = this.height; l < u; ++l) {
          const d = this.bytes[l],
            g = a.bytes[l]
          for (let m = 0, b = this.width; m < b; ++m) if (d[m] !== g[m]) return !1
        }
        return !0
      }
      toString() {
        const s = new ve()
        for (let a = 0, l = this.height; a < l; ++a) {
          const u = this.bytes[a]
          for (let d = 0, g = this.width; d < g; ++d)
            switch (u[d]) {
              case 0:
                s.append(' 0')
                break
              case 1:
                s.append(' 1')
                break
              default:
                s.append('  ')
                break
            }
          s.append(`
`)
        }
        return s.toString()
      }
    }
    class Yi {
      constructor() {
        this.maskPattern = -1
      }
      getMode() {
        return this.mode
      }
      getECLevel() {
        return this.ecLevel
      }
      getVersion() {
        return this.version
      }
      getMaskPattern() {
        return this.maskPattern
      }
      getMatrix() {
        return this.matrix
      }
      toString() {
        const s = new ve()
        return (
          s.append(`<<
`),
          s.append(' mode: '),
          s.append(this.mode ? this.mode.toString() : 'null'),
          s.append(`
 ecLevel: `),
          s.append(this.ecLevel ? this.ecLevel.toString() : 'null'),
          s.append(`
 version: `),
          s.append(this.version ? this.version.toString() : 'null'),
          s.append(`
 maskPattern: `),
          s.append(this.maskPattern.toString()),
          this.matrix
            ? (s.append(`
 matrix:
`),
              s.append(this.matrix.toString()))
            : s.append(`
 matrix: null
`),
          s.append(`>>
`),
          s.toString()
        )
      }
      setMode(s) {
        this.mode = s
      }
      setECLevel(s) {
        this.ecLevel = s
      }
      setVersion(s) {
        this.version = s
      }
      setMaskPattern(s) {
        this.maskPattern = s
      }
      setMatrix(s) {
        this.matrix = s
      }
      static isValidMaskPattern(s) {
        return s >= 0 && s < Yi.NUM_MASK_PATTERNS
      }
    }
    Yi.NUM_MASK_PATTERNS = 8
    class Ye extends p {}
    Ye.kind = 'WriterException'
    class we {
      constructor() {}
      static clearMatrix(s) {
        s.clear(255)
      }
      static buildMatrix(s, a, l, u, d) {
        ;(we.clearMatrix(d),
          we.embedBasicPatterns(l, d),
          we.embedTypeInfo(a, u, d),
          we.maybeEmbedVersionInfo(l, d),
          we.embedDataBits(s, u, d))
      }
      static embedBasicPatterns(s, a) {
        ;(we.embedPositionDetectionPatternsAndSeparators(a),
          we.embedDarkDotAtLeftBottomCorner(a),
          we.maybeEmbedPositionAdjustmentPatterns(s, a),
          we.embedTimingPatterns(a))
      }
      static embedTypeInfo(s, a, l) {
        const u = new O()
        we.makeTypeInfoBits(s, a, u)
        for (let d = 0, g = u.getSize(); d < g; ++d) {
          const m = u.get(u.getSize() - 1 - d),
            b = we.TYPE_INFO_COORDINATES[d],
            v = b[0],
            C = b[1]
          if ((l.setBoolean(v, C, m), d < 8)) {
            const T = l.getWidth() - d - 1
            l.setBoolean(T, 8, m)
          } else {
            const T = l.getHeight() - 7 + (d - 8)
            l.setBoolean(8, T, m)
          }
        }
      }
      static maybeEmbedVersionInfo(s, a) {
        if (s.getVersionNumber() < 7) return
        const l = new O()
        we.makeVersionInfoBits(s, l)
        let u = 6 * 3 - 1
        for (let d = 0; d < 6; ++d)
          for (let g = 0; g < 3; ++g) {
            const m = l.get(u)
            ;(u--,
              a.setBoolean(d, a.getHeight() - 11 + g, m),
              a.setBoolean(a.getHeight() - 11 + g, d, m))
          }
      }
      static embedDataBits(s, a, l) {
        let u = 0,
          d = -1,
          g = l.getWidth() - 1,
          m = l.getHeight() - 1
        for (; g > 0; ) {
          for (g === 6 && (g -= 1); m >= 0 && m < l.getHeight(); ) {
            for (let b = 0; b < 2; ++b) {
              const v = g - b
              if (!we.isEmpty(l.get(v, m))) continue
              let C
              ;(u < s.getSize() ? ((C = s.get(u)), ++u) : (C = !1),
                a !== 255 && gt.getDataMaskBit(a, v, m) && (C = !C),
                l.setBoolean(v, m, C))
            }
            m += d
          }
          ;((d = -d), (m += d), (g -= 2))
        }
        if (u !== s.getSize()) throw new Ye('Not all bits consumed: ' + u + '/' + s.getSize())
      }
      static findMSBSet(s) {
        return 32 - M.numberOfLeadingZeros(s)
      }
      static calculateBCHCode(s, a) {
        if (a === 0) throw new w('0 polynomial')
        const l = we.findMSBSet(a)
        for (s <<= l - 1; we.findMSBSet(s) >= l; ) s ^= a << (we.findMSBSet(s) - l)
        return s
      }
      static makeTypeInfoBits(s, a, l) {
        if (!Yi.isValidMaskPattern(a)) throw new Ye('Invalid mask pattern')
        const u = (s.getBits() << 3) | a
        l.appendBits(u, 5)
        const d = we.calculateBCHCode(u, we.TYPE_INFO_POLY)
        l.appendBits(d, 10)
        const g = new O()
        if ((g.appendBits(we.TYPE_INFO_MASK_PATTERN, 15), l.xor(g), l.getSize() !== 15))
          throw new Ye('should not happen but we got: ' + l.getSize())
      }
      static makeVersionInfoBits(s, a) {
        a.appendBits(s.getVersionNumber(), 6)
        const l = we.calculateBCHCode(s.getVersionNumber(), we.VERSION_INFO_POLY)
        if ((a.appendBits(l, 12), a.getSize() !== 18))
          throw new Ye('should not happen but we got: ' + a.getSize())
      }
      static isEmpty(s) {
        return s === 255
      }
      static embedTimingPatterns(s) {
        for (let a = 8; a < s.getWidth() - 8; ++a) {
          const l = (a + 1) % 2
          ;(we.isEmpty(s.get(a, 6)) && s.setNumber(a, 6, l),
            we.isEmpty(s.get(6, a)) && s.setNumber(6, a, l))
        }
      }
      static embedDarkDotAtLeftBottomCorner(s) {
        if (s.get(8, s.getHeight() - 8) === 0) throw new Ye()
        s.setNumber(8, s.getHeight() - 8, 1)
      }
      static embedHorizontalSeparationPattern(s, a, l) {
        for (let u = 0; u < 8; ++u) {
          if (!we.isEmpty(l.get(s + u, a))) throw new Ye()
          l.setNumber(s + u, a, 0)
        }
      }
      static embedVerticalSeparationPattern(s, a, l) {
        for (let u = 0; u < 7; ++u) {
          if (!we.isEmpty(l.get(s, a + u))) throw new Ye()
          l.setNumber(s, a + u, 0)
        }
      }
      static embedPositionAdjustmentPattern(s, a, l) {
        for (let u = 0; u < 5; ++u) {
          const d = we.POSITION_ADJUSTMENT_PATTERN[u]
          for (let g = 0; g < 5; ++g) l.setNumber(s + g, a + u, d[g])
        }
      }
      static embedPositionDetectionPattern(s, a, l) {
        for (let u = 0; u < 7; ++u) {
          const d = we.POSITION_DETECTION_PATTERN[u]
          for (let g = 0; g < 7; ++g) l.setNumber(s + g, a + u, d[g])
        }
      }
      static embedPositionDetectionPatternsAndSeparators(s) {
        const a = we.POSITION_DETECTION_PATTERN[0].length
        ;(we.embedPositionDetectionPattern(0, 0, s),
          we.embedPositionDetectionPattern(s.getWidth() - a, 0, s),
          we.embedPositionDetectionPattern(0, s.getWidth() - a, s))
        const l = 8
        ;(we.embedHorizontalSeparationPattern(0, l - 1, s),
          we.embedHorizontalSeparationPattern(s.getWidth() - l, l - 1, s),
          we.embedHorizontalSeparationPattern(0, s.getWidth() - l, s))
        const u = 7
        ;(we.embedVerticalSeparationPattern(u, 0, s),
          we.embedVerticalSeparationPattern(s.getHeight() - u - 1, 0, s),
          we.embedVerticalSeparationPattern(u, s.getHeight() - u, s))
      }
      static maybeEmbedPositionAdjustmentPatterns(s, a) {
        if (s.getVersionNumber() < 2) return
        const l = s.getVersionNumber() - 1,
          u = we.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[l]
        for (let d = 0, g = u.length; d !== g; d++) {
          const m = u[d]
          if (m >= 0)
            for (let b = 0; b !== g; b++) {
              const v = u[b]
              v >= 0 &&
                we.isEmpty(a.get(v, m)) &&
                we.embedPositionAdjustmentPattern(v - 2, m - 2, a)
            }
        }
      }
    }
    ;((we.POSITION_DETECTION_PATTERN = Array.from([
      Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
    ])),
      (we.POSITION_ADJUSTMENT_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1]),
      ])),
      (we.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
        Int32Array.from([6, 30, 58, 86, 114, 142, 170]),
      ])),
      (we.TYPE_INFO_COORDINATES = Array.from([
        Int32Array.from([8, 0]),
        Int32Array.from([8, 1]),
        Int32Array.from([8, 2]),
        Int32Array.from([8, 3]),
        Int32Array.from([8, 4]),
        Int32Array.from([8, 5]),
        Int32Array.from([8, 7]),
        Int32Array.from([8, 8]),
        Int32Array.from([7, 8]),
        Int32Array.from([5, 8]),
        Int32Array.from([4, 8]),
        Int32Array.from([3, 8]),
        Int32Array.from([2, 8]),
        Int32Array.from([1, 8]),
        Int32Array.from([0, 8]),
      ])),
      (we.VERSION_INFO_POLY = 7973),
      (we.TYPE_INFO_POLY = 1335),
      (we.TYPE_INFO_MASK_PATTERN = 21522))
    class Nb {
      constructor(s, a) {
        ;((this.dataBytes = s), (this.errorCorrectionBytes = a))
      }
      getDataBytes() {
        return this.dataBytes
      }
      getErrorCorrectionBytes() {
        return this.errorCorrectionBytes
      }
    }
    class Je {
      constructor() {}
      static calculateMaskPenalty(s) {
        return (
          gt.applyMaskPenaltyRule1(s) +
          gt.applyMaskPenaltyRule2(s) +
          gt.applyMaskPenaltyRule3(s) +
          gt.applyMaskPenaltyRule4(s)
        )
      }
      static encode(s, a, l = null) {
        let u = Je.DEFAULT_BYTE_MODE_ENCODING
        const d = l !== null && l.get(_t.CHARACTER_SET) !== void 0
        d && (u = l.get(_t.CHARACTER_SET).toString())
        const g = this.chooseMode(s, u),
          m = new O()
        if (g === me.BYTE && (d || Je.DEFAULT_BYTE_MODE_ENCODING !== u)) {
          const te = Z.getCharacterSetECIByName(u)
          te !== void 0 && this.appendECI(te, m)
        }
        this.appendModeInfo(g, m)
        const b = new O()
        this.appendBytes(s, g, b, u)
        let v
        if (l !== null && l.get(_t.QR_VERSION) !== void 0) {
          const te = Number.parseInt(l.get(_t.QR_VERSION).toString(), 10)
          v = de.getVersionForNumber(te)
          const $ = this.calculateBitsNeeded(g, m, b, v)
          if (!this.willFit($, v, a)) throw new Ye('Data too big for requested version')
        } else v = this.recommendVersion(a, g, m, b)
        const C = new O()
        C.appendBitArray(m)
        const T = g === me.BYTE ? b.getSizeInBytes() : s.length
        ;(this.appendLengthInfo(T, v, g, C), C.appendBitArray(b))
        const D = v.getECBlocksForLevel(a),
          B = v.getTotalCodewords() - D.getTotalECCodewords()
        this.terminateBits(B, C)
        const j = this.interleaveWithECBytes(C, v.getTotalCodewords(), B, D.getNumBlocks()),
          W = new Yi()
        ;(W.setECLevel(a), W.setMode(g), W.setVersion(v))
        const Y = v.getDimensionForVersion(),
          q = new Jl(Y, Y),
          ne = this.chooseMaskPattern(j, a, v, q)
        return (W.setMaskPattern(ne), we.buildMatrix(j, a, v, ne, q), W.setMatrix(q), W)
      }
      static recommendVersion(s, a, l, u) {
        const d = this.calculateBitsNeeded(a, l, u, de.getVersionForNumber(1)),
          g = this.chooseVersion(d, s),
          m = this.calculateBitsNeeded(a, l, u, g)
        return this.chooseVersion(m, s)
      }
      static calculateBitsNeeded(s, a, l, u) {
        return a.getSize() + s.getCharacterCountBits(u) + l.getSize()
      }
      static getAlphanumericCode(s) {
        return s < Je.ALPHANUMERIC_TABLE.length ? Je.ALPHANUMERIC_TABLE[s] : -1
      }
      static chooseMode(s, a = null) {
        if (Z.SJIS.getName() === a && this.isOnlyDoubleByteKanji(s)) return me.KANJI
        let l = !1,
          u = !1
        for (let d = 0, g = s.length; d < g; ++d) {
          const m = s.charAt(d)
          if (Je.isDigit(m)) l = !0
          else if (this.getAlphanumericCode(m.charCodeAt(0)) !== -1) u = !0
          else return me.BYTE
        }
        return u ? me.ALPHANUMERIC : l ? me.NUMERIC : me.BYTE
      }
      static isOnlyDoubleByteKanji(s) {
        let a
        try {
          a = oe.encode(s, Z.SJIS)
        } catch {
          return !1
        }
        const l = a.length
        if (l % 2 !== 0) return !1
        for (let u = 0; u < l; u += 2) {
          const d = a[u] & 255
          if ((d < 129 || d > 159) && (d < 224 || d > 235)) return !1
        }
        return !0
      }
      static chooseMaskPattern(s, a, l, u) {
        let d = Number.MAX_SAFE_INTEGER,
          g = -1
        for (let m = 0; m < Yi.NUM_MASK_PATTERNS; m++) {
          we.buildMatrix(s, a, l, m, u)
          let b = this.calculateMaskPenalty(u)
          b < d && ((d = b), (g = m))
        }
        return g
      }
      static chooseVersion(s, a) {
        for (let l = 1; l <= 40; l++) {
          const u = de.getVersionForNumber(l)
          if (Je.willFit(s, u, a)) return u
        }
        throw new Ye('Data too big')
      }
      static willFit(s, a, l) {
        const u = a.getTotalCodewords(),
          d = a.getECBlocksForLevel(l).getTotalECCodewords(),
          g = u - d,
          m = (s + 7) / 8
        return g >= m
      }
      static terminateBits(s, a) {
        const l = s * 8
        if (a.getSize() > l)
          throw new Ye('data bits cannot fit in the QR Code' + a.getSize() + ' > ' + l)
        for (let g = 0; g < 4 && a.getSize() < l; ++g) a.appendBit(!1)
        const u = a.getSize() & 7
        if (u > 0) for (let g = u; g < 8; g++) a.appendBit(!1)
        const d = s - a.getSizeInBytes()
        for (let g = 0; g < d; ++g) a.appendBits(g & 1 ? 17 : 236, 8)
        if (a.getSize() !== l) throw new Ye('Bits size does not equal capacity')
      }
      static getNumDataBytesAndNumECBytesForBlockID(s, a, l, u, d, g) {
        if (u >= l) throw new Ye('Block ID too large')
        const m = s % l,
          b = l - m,
          v = Math.floor(s / l),
          C = v + 1,
          T = Math.floor(a / l),
          D = T + 1,
          B = v - T,
          j = C - D
        if (B !== j) throw new Ye('EC bytes mismatch')
        if (l !== b + m) throw new Ye('RS blocks mismatch')
        if (s !== (T + B) * b + (D + j) * m) throw new Ye('Total bytes mismatch')
        u < b ? ((d[0] = T), (g[0] = B)) : ((d[0] = D), (g[0] = j))
      }
      static interleaveWithECBytes(s, a, l, u) {
        if (s.getSizeInBytes() !== l) throw new Ye('Number of bits and data bytes does not match')
        let d = 0,
          g = 0,
          m = 0
        const b = new Array()
        for (let C = 0; C < u; ++C) {
          const T = new Int32Array(1),
            D = new Int32Array(1)
          Je.getNumDataBytesAndNumECBytesForBlockID(a, l, u, C, T, D)
          const B = T[0],
            j = new Uint8Array(B)
          s.toBytes(8 * d, j, 0, B)
          const W = Je.generateECBytes(j, D[0])
          ;(b.push(new Nb(j, W)), (g = Math.max(g, B)), (m = Math.max(m, W.length)), (d += T[0]))
        }
        if (l !== d) throw new Ye('Data bytes does not match offset')
        const v = new O()
        for (let C = 0; C < g; ++C)
          for (const T of b) {
            const D = T.getDataBytes()
            C < D.length && v.appendBits(D[C], 8)
          }
        for (let C = 0; C < m; ++C)
          for (const T of b) {
            const D = T.getErrorCorrectionBytes()
            C < D.length && v.appendBits(D[C], 8)
          }
        if (a !== v.getSizeInBytes())
          throw new Ye('Interleaving error: ' + a + ' and ' + v.getSizeInBytes() + ' differ.')
        return v
      }
      static generateECBytes(s, a) {
        const l = s.length,
          u = new Int32Array(l + a)
        for (let g = 0; g < l; g++) u[g] = s[g] & 255
        new Uh(Fe.QR_CODE_FIELD_256).encode(u, a)
        const d = new Uint8Array(a)
        for (let g = 0; g < a; g++) d[g] = u[l + g]
        return d
      }
      static appendModeInfo(s, a) {
        a.appendBits(s.getBits(), 4)
      }
      static appendLengthInfo(s, a, l, u) {
        const d = l.getCharacterCountBits(a)
        if (s >= 1 << d) throw new Ye(s + ' is bigger than ' + ((1 << d) - 1))
        u.appendBits(s, d)
      }
      static appendBytes(s, a, l, u) {
        switch (a) {
          case me.NUMERIC:
            Je.appendNumericBytes(s, l)
            break
          case me.ALPHANUMERIC:
            Je.appendAlphanumericBytes(s, l)
            break
          case me.BYTE:
            Je.append8BitBytes(s, l, u)
            break
          case me.KANJI:
            Je.appendKanjiBytes(s, l)
            break
          default:
            throw new Ye('Invalid mode: ' + a)
        }
      }
      static getDigit(s) {
        return s.charCodeAt(0) - 48
      }
      static isDigit(s) {
        const a = Je.getDigit(s)
        return a >= 0 && a <= 9
      }
      static appendNumericBytes(s, a) {
        const l = s.length
        let u = 0
        for (; u < l; ) {
          const d = Je.getDigit(s.charAt(u))
          if (u + 2 < l) {
            const g = Je.getDigit(s.charAt(u + 1)),
              m = Je.getDigit(s.charAt(u + 2))
            ;(a.appendBits(d * 100 + g * 10 + m, 10), (u += 3))
          } else if (u + 1 < l) {
            const g = Je.getDigit(s.charAt(u + 1))
            ;(a.appendBits(d * 10 + g, 7), (u += 2))
          } else (a.appendBits(d, 4), u++)
        }
      }
      static appendAlphanumericBytes(s, a) {
        const l = s.length
        let u = 0
        for (; u < l; ) {
          const d = Je.getAlphanumericCode(s.charCodeAt(u))
          if (d === -1) throw new Ye()
          if (u + 1 < l) {
            const g = Je.getAlphanumericCode(s.charCodeAt(u + 1))
            if (g === -1) throw new Ye()
            ;(a.appendBits(d * 45 + g, 11), (u += 2))
          } else (a.appendBits(d, 6), u++)
        }
      }
      static append8BitBytes(s, a, l) {
        let u
        try {
          u = oe.encode(s, l)
        } catch (d) {
          throw new Ye(d)
        }
        for (let d = 0, g = u.length; d !== g; d++) {
          const m = u[d]
          a.appendBits(m, 8)
        }
      }
      static appendKanjiBytes(s, a) {
        let l
        try {
          l = oe.encode(s, Z.SJIS)
        } catch (d) {
          throw new Ye(d)
        }
        const u = l.length
        for (let d = 0; d < u; d += 2) {
          const g = l[d] & 255,
            m = l[d + 1] & 255,
            b = ((g << 8) & 4294967295) | m
          let v = -1
          if (
            (b >= 33088 && b <= 40956
              ? (v = b - 33088)
              : b >= 57408 && b <= 60351 && (v = b - 49472),
            v === -1)
          )
            throw new Ye('Invalid byte sequence')
          const C = (v >> 8) * 192 + (v & 255)
          a.appendBits(C, 13)
        }
      }
      static appendECI(s, a) {
        ;(a.appendBits(me.ECI.getBits(), 4), a.appendBits(s.getValue(), 8))
      }
    }
    ;((Je.ALPHANUMERIC_TABLE = Int32Array.from([
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41,
      42, 43, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16,
      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1,
      -1,
    ])),
      (Je.DEFAULT_BYTE_MODE_ENCODING = Z.UTF8.getName()))
    class Zi {
      write(s, a, l, u = null) {
        if (s.length === 0) throw new w('Found empty contents')
        if (a < 0 || l < 0) throw new w('Requested dimensions are too small: ' + a + 'x' + l)
        let d = qe.L,
          g = Zi.QUIET_ZONE_SIZE
        u !== null &&
          (u.get(_t.ERROR_CORRECTION) !== void 0 &&
            (d = qe.fromString(u.get(_t.ERROR_CORRECTION).toString())),
          u.get(_t.MARGIN) !== void 0 && (g = Number.parseInt(u.get(_t.MARGIN).toString(), 10)))
        const m = Je.encode(s, d, u)
        return this.renderResult(m, a, l, g)
      }
      writeToDom(s, a, l, u, d = null) {
        typeof s == 'string' && (s = document.querySelector(s))
        const g = this.write(a, l, u, d)
        s && s.appendChild(g)
      }
      renderResult(s, a, l, u) {
        const d = s.getMatrix()
        if (d === null) throw new dr()
        const g = d.getWidth(),
          m = d.getHeight(),
          b = g + u * 2,
          v = m + u * 2,
          C = Math.max(a, b),
          T = Math.max(l, v),
          D = Math.min(Math.floor(C / b), Math.floor(T / v)),
          B = Math.floor((C - g * D) / 2),
          j = Math.floor((T - m * D) / 2),
          W = this.createSVGElement(C, T)
        for (let Y = 0, q = j; Y < m; Y++, q += D)
          for (let ne = 0, te = B; ne < g; ne++, te += D)
            if (d.get(ne, Y) === 1) {
              const $ = this.createSvgRectElement(te, q, D, D)
              W.appendChild($)
            }
        return W
      }
      createSVGElement(s, a) {
        const l = document.createElementNS(Zi.SVG_NS, 'svg')
        return (
          l.setAttributeNS(null, 'height', s.toString()),
          l.setAttributeNS(null, 'width', a.toString()),
          l
        )
      }
      createSvgRectElement(s, a, l, u) {
        const d = document.createElementNS(Zi.SVG_NS, 'rect')
        return (
          d.setAttributeNS(null, 'x', s.toString()),
          d.setAttributeNS(null, 'y', a.toString()),
          d.setAttributeNS(null, 'height', l.toString()),
          d.setAttributeNS(null, 'width', u.toString()),
          d.setAttributeNS(null, 'fill', '#000000'),
          d
        )
      }
    }
    ;((Zi.QUIET_ZONE_SIZE = 4), (Zi.SVG_NS = 'http://www.w3.org/2000/svg'))
    class qs {
      encode(s, a, l, u, d) {
        if (s.length === 0) throw new w('Found empty contents')
        if (a !== ue.QR_CODE) throw new w('Can only encode QR_CODE, but got ' + a)
        if (l < 0 || u < 0) throw new w(`Requested dimensions are too small: ${l}x${u}`)
        let g = qe.L,
          m = qs.QUIET_ZONE_SIZE
        d !== null &&
          (d.get(_t.ERROR_CORRECTION) !== void 0 &&
            (g = qe.fromString(d.get(_t.ERROR_CORRECTION).toString())),
          d.get(_t.MARGIN) !== void 0 && (m = Number.parseInt(d.get(_t.MARGIN).toString(), 10)))
        const b = Je.encode(s, g, d)
        return qs.renderResult(b, l, u, m)
      }
      static renderResult(s, a, l, u) {
        const d = s.getMatrix()
        if (d === null) throw new dr()
        const g = d.getWidth(),
          m = d.getHeight(),
          b = g + u * 2,
          v = m + u * 2,
          C = Math.max(a, b),
          T = Math.max(l, v),
          D = Math.min(Math.floor(C / b), Math.floor(T / v)),
          B = Math.floor((C - g * D) / 2),
          j = Math.floor((T - m * D) / 2),
          W = new Ie(C, T)
        for (let Y = 0, q = j; Y < m; Y++, q += D)
          for (let ne = 0, te = B; ne < g; ne++, te += D)
            d.get(ne, Y) === 1 && W.setRegion(te, q, D, D)
        return W
      }
    }
    qs.QUIET_ZONE_SIZE = 4
    class Tb {
      encode(s, a, l, u, d) {
        let g
        switch (a) {
          case ue.QR_CODE:
            g = new qs()
            break
          default:
            throw new w('No encoder available for format ' + a)
        }
        return g.encode(s, a, l, u, d)
      }
    }
    class mr extends se {
      constructor(s, a, l, u, d, g, m, b) {
        if (
          (super(g, m),
          (this.yuvData = s),
          (this.dataWidth = a),
          (this.dataHeight = l),
          (this.left = u),
          (this.top = d),
          u + g > a || d + m > l)
        )
          throw new w('Crop rectangle does not fit within image data.')
        b && this.reverseHorizontal(g, m)
      }
      getRow(s, a) {
        if (s < 0 || s >= this.getHeight()) throw new w('Requested row is outside the image: ' + s)
        const l = this.getWidth()
        ;(a == null || a.length < l) && (a = new Uint8ClampedArray(l))
        const u = (s + this.top) * this.dataWidth + this.left
        return (k.arraycopy(this.yuvData, u, a, 0, l), a)
      }
      getMatrix() {
        const s = this.getWidth(),
          a = this.getHeight()
        if (s === this.dataWidth && a === this.dataHeight) return this.yuvData
        const l = s * a,
          u = new Uint8ClampedArray(l)
        let d = this.top * this.dataWidth + this.left
        if (s === this.dataWidth) return (k.arraycopy(this.yuvData, d, u, 0, l), u)
        for (let g = 0; g < a; g++) {
          const m = g * s
          ;(k.arraycopy(this.yuvData, d, u, m, s), (d += this.dataWidth))
        }
        return u
      }
      isCropSupported() {
        return !0
      }
      crop(s, a, l, u) {
        return new mr(
          this.yuvData,
          this.dataWidth,
          this.dataHeight,
          this.left + s,
          this.top + a,
          l,
          u,
          !1
        )
      }
      renderThumbnail() {
        const s = this.getWidth() / mr.THUMBNAIL_SCALE_FACTOR,
          a = this.getHeight() / mr.THUMBNAIL_SCALE_FACTOR,
          l = new Int32Array(s * a),
          u = this.yuvData
        let d = this.top * this.dataWidth + this.left
        for (let g = 0; g < a; g++) {
          const m = g * s
          for (let b = 0; b < s; b++) {
            const v = u[d + b * mr.THUMBNAIL_SCALE_FACTOR] & 255
            l[m + b] = 4278190080 | (v * 65793)
          }
          d += this.dataWidth * mr.THUMBNAIL_SCALE_FACTOR
        }
        return l
      }
      getThumbnailWidth() {
        return this.getWidth() / mr.THUMBNAIL_SCALE_FACTOR
      }
      getThumbnailHeight() {
        return this.getHeight() / mr.THUMBNAIL_SCALE_FACTOR
      }
      reverseHorizontal(s, a) {
        const l = this.yuvData
        for (
          let u = 0, d = this.top * this.dataWidth + this.left;
          u < a;
          u++, d += this.dataWidth
        ) {
          const g = d + s / 2
          for (let m = d, b = d + s - 1; m < g; m++, b--) {
            const v = l[m]
            ;((l[m] = l[b]), (l[b] = v))
          }
        }
      }
      invert() {
        return new fe(this)
      }
    }
    mr.THUMBNAIL_SCALE_FACTOR = 2
    class Wh extends se {
      constructor(s, a, l, u, d, g, m) {
        if (
          (super(a, l),
          (this.dataWidth = u),
          (this.dataHeight = d),
          (this.left = g),
          (this.top = m),
          s.BYTES_PER_ELEMENT === 4)
        ) {
          const b = a * l,
            v = new Uint8ClampedArray(b)
          for (let C = 0; C < b; C++) {
            const T = s[C],
              D = (T >> 16) & 255,
              B = (T >> 7) & 510,
              j = T & 255
            v[C] = ((D + B + j) / 4) & 255
          }
          this.luminances = v
        } else this.luminances = s
        if (
          (u === void 0 && (this.dataWidth = a),
          d === void 0 && (this.dataHeight = l),
          g === void 0 && (this.left = 0),
          m === void 0 && (this.top = 0),
          this.left + a > this.dataWidth || this.top + l > this.dataHeight)
        )
          throw new w('Crop rectangle does not fit within image data.')
      }
      getRow(s, a) {
        if (s < 0 || s >= this.getHeight()) throw new w('Requested row is outside the image: ' + s)
        const l = this.getWidth()
        ;(a == null || a.length < l) && (a = new Uint8ClampedArray(l))
        const u = (s + this.top) * this.dataWidth + this.left
        return (k.arraycopy(this.luminances, u, a, 0, l), a)
      }
      getMatrix() {
        const s = this.getWidth(),
          a = this.getHeight()
        if (s === this.dataWidth && a === this.dataHeight) return this.luminances
        const l = s * a,
          u = new Uint8ClampedArray(l)
        let d = this.top * this.dataWidth + this.left
        if (s === this.dataWidth) return (k.arraycopy(this.luminances, d, u, 0, l), u)
        for (let g = 0; g < a; g++) {
          const m = g * s
          ;(k.arraycopy(this.luminances, d, u, m, s), (d += this.dataWidth))
        }
        return u
      }
      isCropSupported() {
        return !0
      }
      crop(s, a, l, u) {
        return new Wh(
          this.luminances,
          l,
          u,
          this.dataWidth,
          this.dataHeight,
          this.left + s,
          this.top + a
        )
      }
      invert() {
        return new fe(this)
      }
    }
    class Pp extends Z {
      static forName(s) {
        return this.getCharacterSetECIByName(s)
      }
    }
    class zh {}
    zh.ISO_8859_1 = Z.ISO8859_1
    class Dp {
      isCompact() {
        return this.compact
      }
      setCompact(s) {
        this.compact = s
      }
      getSize() {
        return this.size
      }
      setSize(s) {
        this.size = s
      }
      getLayers() {
        return this.layers
      }
      setLayers(s) {
        this.layers = s
      }
      getCodeWords() {
        return this.codeWords
      }
      setCodeWords(s) {
        this.codeWords = s
      }
      getMatrix() {
        return this.matrix
      }
      setMatrix(s) {
        this.matrix = s
      }
    }
    class Lp {
      static singletonList(s) {
        return [s]
      }
      static min(s, a) {
        return s.sort(a)[0]
      }
    }
    class Rb {
      constructor(s) {
        this.previous = s
      }
      getPrevious() {
        return this.previous
      }
    }
    class Qs extends Rb {
      constructor(s, a, l) {
        ;(super(s), (this.value = a), (this.bitCount = l))
      }
      appendTo(s, a) {
        s.appendBits(this.value, this.bitCount)
      }
      add(s, a) {
        return new Qs(this, s, a)
      }
      addBinaryShift(s, a) {
        return (
          console.warn('addBinaryShift on SimpleToken, this simply returns a copy of this token'),
          new Qs(this, s, a)
        )
      }
      toString() {
        let s = this.value & ((1 << this.bitCount) - 1)
        return (
          (s |= 1 << this.bitCount),
          '<' + M.toBinaryString(s | (1 << this.bitCount)).substring(1) + '>'
        )
      }
    }
    class Hh extends Qs {
      constructor(s, a, l) {
        ;(super(s, 0, 0), (this.binaryShiftStart = a), (this.binaryShiftByteCount = l))
      }
      appendTo(s, a) {
        for (let l = 0; l < this.binaryShiftByteCount; l++)
          ((l === 0 || (l === 31 && this.binaryShiftByteCount <= 62)) &&
            (s.appendBits(31, 5),
            this.binaryShiftByteCount > 62
              ? s.appendBits(this.binaryShiftByteCount - 31, 16)
              : l === 0
                ? s.appendBits(Math.min(this.binaryShiftByteCount, 31), 5)
                : s.appendBits(this.binaryShiftByteCount - 31, 5)),
            s.appendBits(a[this.binaryShiftStart + l], 8))
      }
      addBinaryShift(s, a) {
        return new Hh(this, s, a)
      }
      toString() {
        return (
          '<' +
          this.binaryShiftStart +
          '::' +
          (this.binaryShiftStart + this.binaryShiftByteCount - 1) +
          '>'
        )
      }
    }
    function Mb(_, s, a) {
      return new Hh(_, s, a)
    }
    function ca(_, s, a) {
      return new Qs(_, s, a)
    }
    const Pb = ['UPPER', 'LOWER', 'DIGIT', 'MIXED', 'PUNCT'],
      si = 0,
      ec = 1,
      zn = 2,
      Op = 3,
      yr = 4,
      Db = new Qs(null, 0, 0),
      Xh = [
        Int32Array.from([0, (5 << 16) + 28, (5 << 16) + 30, (5 << 16) + 29, 656318]),
        Int32Array.from([(9 << 16) + 480 + 14, 0, (5 << 16) + 30, (5 << 16) + 29, 656318]),
        Int32Array.from([(4 << 16) + 14, (9 << 16) + 448 + 28, 0, (9 << 16) + 448 + 29, 932798]),
        Int32Array.from([(5 << 16) + 29, (5 << 16) + 28, 656318, 0, (5 << 16) + 30]),
        Int32Array.from([(5 << 16) + 31, 656380, 656382, 656381, 0]),
      ]
    function Lb(_) {
      for (let s of _) R.fill(s, -1)
      return (
        (_[si][yr] = 0),
        (_[ec][yr] = 0),
        (_[ec][si] = 28),
        (_[Op][yr] = 0),
        (_[zn][yr] = 0),
        (_[zn][si] = 15),
        _
      )
    }
    const Bp = Lb(R.createInt32Array(6, 6))
    class wr {
      constructor(s, a, l, u) {
        ;((this.token = s), (this.mode = a), (this.binaryShiftByteCount = l), (this.bitCount = u))
      }
      getMode() {
        return this.mode
      }
      getToken() {
        return this.token
      }
      getBinaryShiftByteCount() {
        return this.binaryShiftByteCount
      }
      getBitCount() {
        return this.bitCount
      }
      latchAndAppend(s, a) {
        let l = this.bitCount,
          u = this.token
        if (s !== this.mode) {
          let g = Xh[this.mode][s]
          ;((u = ca(u, g & 65535, g >> 16)), (l += g >> 16))
        }
        let d = s === zn ? 4 : 5
        return ((u = ca(u, a, d)), new wr(u, s, 0, l + d))
      }
      shiftAndAppend(s, a) {
        let l = this.token,
          u = this.mode === zn ? 4 : 5
        return (
          (l = ca(l, Bp[this.mode][s], u)),
          (l = ca(l, a, 5)),
          new wr(l, this.mode, 0, this.bitCount + u + 5)
        )
      }
      addBinaryShiftChar(s) {
        let a = this.token,
          l = this.mode,
          u = this.bitCount
        if (this.mode === yr || this.mode === zn) {
          let m = Xh[l][si]
          ;((a = ca(a, m & 65535, m >> 16)), (u += m >> 16), (l = si))
        }
        let d =
            this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31
              ? 18
              : this.binaryShiftByteCount === 62
                ? 9
                : 8,
          g = new wr(a, l, this.binaryShiftByteCount + 1, u + d)
        return (g.binaryShiftByteCount === 2078 && (g = g.endBinaryShift(s + 1)), g)
      }
      endBinaryShift(s) {
        if (this.binaryShiftByteCount === 0) return this
        let a = this.token
        return (
          (a = Mb(a, s - this.binaryShiftByteCount, this.binaryShiftByteCount)),
          new wr(a, this.mode, 0, this.bitCount)
        )
      }
      isBetterThanOrEqualTo(s) {
        let a = this.bitCount + (Xh[this.mode][s.mode] >> 16)
        return (
          this.binaryShiftByteCount < s.binaryShiftByteCount
            ? (a += wr.calculateBinaryShiftCost(s) - wr.calculateBinaryShiftCost(this))
            : this.binaryShiftByteCount > s.binaryShiftByteCount &&
              s.binaryShiftByteCount > 0 &&
              (a += 10),
          a <= s.bitCount
        )
      }
      toBitArray(s) {
        let a = []
        for (let u = this.endBinaryShift(s.length).token; u !== null; u = u.getPrevious())
          a.unshift(u)
        let l = new O()
        for (const u of a) u.appendTo(l, s)
        return l
      }
      toString() {
        return re.format(
          '%s bits=%d bytes=%d',
          Pb[this.mode],
          this.bitCount,
          this.binaryShiftByteCount
        )
      }
      static calculateBinaryShiftCost(s) {
        return s.binaryShiftByteCount > 62
          ? 21
          : s.binaryShiftByteCount > 31
            ? 20
            : s.binaryShiftByteCount > 0
              ? 10
              : 0
      }
    }
    wr.INITIAL_STATE = new wr(Db, si, 0, 0)
    function Ob(_) {
      const s = re.getCharCode(' '),
        a = re.getCharCode('.'),
        l = re.getCharCode(',')
      _[si][s] = 1
      const u = re.getCharCode('Z'),
        d = re.getCharCode('A')
      for (let D = d; D <= u; D++) _[si][D] = D - d + 2
      _[ec][s] = 1
      const g = re.getCharCode('z'),
        m = re.getCharCode('a')
      for (let D = m; D <= g; D++) _[ec][D] = D - m + 2
      _[zn][s] = 1
      const b = re.getCharCode('9'),
        v = re.getCharCode('0')
      for (let D = v; D <= b; D++) _[zn][D] = D - v + 2
      ;((_[zn][l] = 12), (_[zn][a] = 13))
      const C = [
        '\0',
        ' ',
        '',
        '',
        '',
        '',
        '',
        '',
        '\x07',
        '\b',
        '	',
        `
`,
        '\v',
        '\f',
        '\r',
        '\x1B',
        '',
        '',
        '',
        '',
        '@',
        '\\',
        '^',
        '_',
        '`',
        '|',
        '~',
        '',
      ]
      for (let D = 0; D < C.length; D++) _[Op][re.getCharCode(C[D])] = D
      const T = [
        '\0',
        '\r',
        '\0',
        '\0',
        '\0',
        '\0',
        '!',
        "'",
        '#',
        '$',
        '%',
        '&',
        "'",
        '(',
        ')',
        '*',
        '+',
        ',',
        '-',
        '.',
        '/',
        ':',
        ';',
        '<',
        '=',
        '>',
        '?',
        '[',
        ']',
        '{',
        '}',
      ]
      for (let D = 0; D < T.length; D++)
        re.getCharCode(T[D]) > 0 && (_[yr][re.getCharCode(T[D])] = D)
      return _
    }
    const Gh = Ob(R.createInt32Array(5, 256))
    class ua {
      constructor(s) {
        this.text = s
      }
      encode() {
        const s = re.getCharCode(' '),
          a = re.getCharCode(`
`)
        let l = Lp.singletonList(wr.INITIAL_STATE)
        for (let u = 0; u < this.text.length; u++) {
          let d,
            g = u + 1 < this.text.length ? this.text[u + 1] : 0
          switch (this.text[u]) {
            case re.getCharCode('\r'):
              d = g === a ? 2 : 0
              break
            case re.getCharCode('.'):
              d = g === s ? 3 : 0
              break
            case re.getCharCode(','):
              d = g === s ? 4 : 0
              break
            case re.getCharCode(':'):
              d = g === s ? 5 : 0
              break
            default:
              d = 0
          }
          d > 0
            ? ((l = ua.updateStateListForPair(l, u, d)), u++)
            : (l = this.updateStateListForChar(l, u))
        }
        return Lp.min(l, (u, d) => u.getBitCount() - d.getBitCount()).toBitArray(this.text)
      }
      updateStateListForChar(s, a) {
        const l = []
        for (let u of s) this.updateStateForChar(u, a, l)
        return ua.simplifyStates(l)
      }
      updateStateForChar(s, a, l) {
        let u = this.text[a] & 255,
          d = Gh[s.getMode()][u] > 0,
          g = null
        for (let m = 0; m <= yr; m++) {
          let b = Gh[m][u]
          if (b > 0) {
            if ((g == null && (g = s.endBinaryShift(a)), !d || m === s.getMode() || m === zn)) {
              const v = g.latchAndAppend(m, b)
              l.push(v)
            }
            if (!d && Bp[s.getMode()][m] >= 0) {
              const v = g.shiftAndAppend(m, b)
              l.push(v)
            }
          }
        }
        if (s.getBinaryShiftByteCount() > 0 || Gh[s.getMode()][u] === 0) {
          let m = s.addBinaryShiftChar(a)
          l.push(m)
        }
      }
      static updateStateListForPair(s, a, l) {
        const u = []
        for (let d of s) this.updateStateForPair(d, a, l, u)
        return this.simplifyStates(u)
      }
      static updateStateForPair(s, a, l, u) {
        let d = s.endBinaryShift(a)
        if (
          (u.push(d.latchAndAppend(yr, l)),
          s.getMode() !== yr && u.push(d.shiftAndAppend(yr, l)),
          l === 3 || l === 4)
        ) {
          let g = d.latchAndAppend(zn, 16 - l).latchAndAppend(zn, 1)
          u.push(g)
        }
        if (s.getBinaryShiftByteCount() > 0) {
          let g = s.addBinaryShiftChar(a).addBinaryShiftChar(a + 1)
          u.push(g)
        }
      }
      static simplifyStates(s) {
        let a = []
        for (const l of s) {
          let u = !0
          for (const d of a) {
            if (d.isBetterThanOrEqualTo(l)) {
              u = !1
              break
            }
            l.isBetterThanOrEqualTo(d) && (a = a.filter((g) => g !== d))
          }
          u && a.push(l)
        }
        return a
      }
    }
    class De {
      constructor() {}
      static encodeBytes(s) {
        return De.encode(s, De.DEFAULT_EC_PERCENT, De.DEFAULT_AZTEC_LAYERS)
      }
      static encode(s, a, l) {
        let u = new ua(s).encode(),
          d = M.truncDivision(u.getSize() * a, 100) + 11,
          g = u.getSize() + d,
          m,
          b,
          v,
          C,
          T
        if (l !== De.DEFAULT_AZTEC_LAYERS) {
          if (((m = l < 0), (b = Math.abs(l)), b > (m ? De.MAX_NB_BITS_COMPACT : De.MAX_NB_BITS)))
            throw new w(re.format('Illegal value %s for layers', l))
          ;((v = De.totalBitsInLayer(b, m)), (C = De.WORD_SIZE[b]))
          let $ = v - (v % C)
          if (((T = De.stuffBits(u, C)), T.getSize() + d > $))
            throw new w('Data to large for user specified layer')
          if (m && T.getSize() > C * 64) throw new w('Data to large for user specified layer')
        } else {
          ;((C = 0), (T = null))
          for (let $ = 0; ; $++) {
            if ($ > De.MAX_NB_BITS) throw new w('Data too large for an Aztec code')
            if (((m = $ <= 3), (b = m ? $ + 1 : $), (v = De.totalBitsInLayer(b, m)), g > v))
              continue
            ;(T == null || C !== De.WORD_SIZE[b]) &&
              ((C = De.WORD_SIZE[b]), (T = De.stuffBits(u, C)))
            let Te = v - (v % C)
            if (!(m && T.getSize() > C * 64) && T.getSize() + d <= Te) break
          }
        }
        let D = De.generateCheckWords(T, v, C),
          B = T.getSize() / C,
          j = De.generateModeMessage(m, b, B),
          W = (m ? 11 : 14) + b * 4,
          Y = new Int32Array(W),
          q
        if (m) {
          q = W
          for (let $ = 0; $ < Y.length; $++) Y[$] = $
        } else {
          q = W + 1 + 2 * M.truncDivision(M.truncDivision(W, 2) - 1, 15)
          let $ = M.truncDivision(W, 2),
            Te = M.truncDivision(q, 2)
          for (let Ce = 0; Ce < $; Ce++) {
            let pn = Ce + M.truncDivision(Ce, 15)
            ;((Y[$ - Ce - 1] = Te - pn - 1), (Y[$ + Ce] = Te + pn + 1))
          }
        }
        let ne = new Ie(q)
        for (let $ = 0, Te = 0; $ < b; $++) {
          let Ce = (b - $) * 4 + (m ? 9 : 12)
          for (let pn = 0; pn < Ce; pn++) {
            let rr = pn * 2
            for (let gn = 0; gn < 2; gn++)
              (D.get(Te + rr + gn) && ne.set(Y[$ * 2 + gn], Y[$ * 2 + pn]),
                D.get(Te + Ce * 2 + rr + gn) && ne.set(Y[$ * 2 + pn], Y[W - 1 - $ * 2 - gn]),
                D.get(Te + Ce * 4 + rr + gn) &&
                  ne.set(Y[W - 1 - $ * 2 - gn], Y[W - 1 - $ * 2 - pn]),
                D.get(Te + Ce * 6 + rr + gn) && ne.set(Y[W - 1 - $ * 2 - pn], Y[$ * 2 + gn]))
          }
          Te += Ce * 8
        }
        if ((De.drawModeMessage(ne, m, q, j), m)) De.drawBullsEye(ne, M.truncDivision(q, 2), 5)
        else {
          De.drawBullsEye(ne, M.truncDivision(q, 2), 7)
          for (let $ = 0, Te = 0; $ < M.truncDivision(W, 2) - 1; $ += 15, Te += 16)
            for (let Ce = M.truncDivision(q, 2) & 1; Ce < q; Ce += 2)
              (ne.set(M.truncDivision(q, 2) - Te, Ce),
                ne.set(M.truncDivision(q, 2) + Te, Ce),
                ne.set(Ce, M.truncDivision(q, 2) - Te),
                ne.set(Ce, M.truncDivision(q, 2) + Te))
        }
        let te = new Dp()
        return (
          te.setCompact(m),
          te.setSize(q),
          te.setLayers(b),
          te.setCodeWords(B),
          te.setMatrix(ne),
          te
        )
      }
      static drawBullsEye(s, a, l) {
        for (let u = 0; u < l; u += 2)
          for (let d = a - u; d <= a + u; d++)
            (s.set(d, a - u), s.set(d, a + u), s.set(a - u, d), s.set(a + u, d))
        ;(s.set(a - l, a - l),
          s.set(a - l + 1, a - l),
          s.set(a - l, a - l + 1),
          s.set(a + l, a - l),
          s.set(a + l, a - l + 1),
          s.set(a + l, a + l - 1))
      }
      static generateModeMessage(s, a, l) {
        let u = new O()
        return (
          s
            ? (u.appendBits(a - 1, 2),
              u.appendBits(l - 1, 6),
              (u = De.generateCheckWords(u, 28, 4)))
            : (u.appendBits(a - 1, 5),
              u.appendBits(l - 1, 11),
              (u = De.generateCheckWords(u, 40, 4))),
          u
        )
      }
      static drawModeMessage(s, a, l, u) {
        let d = M.truncDivision(l, 2)
        if (a)
          for (let g = 0; g < 7; g++) {
            let m = d - 3 + g
            ;(u.get(g) && s.set(m, d - 5),
              u.get(g + 7) && s.set(d + 5, m),
              u.get(20 - g) && s.set(m, d + 5),
              u.get(27 - g) && s.set(d - 5, m))
          }
        else
          for (let g = 0; g < 10; g++) {
            let m = d - 5 + g + M.truncDivision(g, 5)
            ;(u.get(g) && s.set(m, d - 7),
              u.get(g + 10) && s.set(d + 7, m),
              u.get(29 - g) && s.set(m, d + 7),
              u.get(39 - g) && s.set(d - 7, m))
          }
      }
      static generateCheckWords(s, a, l) {
        let u = s.getSize() / l,
          d = new Uh(De.getGF(l)),
          g = M.truncDivision(a, l),
          m = De.bitsToWords(s, l, g)
        d.encode(m, g - u)
        let b = a % l,
          v = new O()
        v.appendBits(0, b)
        for (const C of Array.from(m)) v.appendBits(C, l)
        return v
      }
      static bitsToWords(s, a, l) {
        let u = new Int32Array(l),
          d,
          g
        for (d = 0, g = s.getSize() / a; d < g; d++) {
          let m = 0
          for (let b = 0; b < a; b++) m |= s.get(d * a + b) ? 1 << (a - b - 1) : 0
          u[d] = m
        }
        return u
      }
      static getGF(s) {
        switch (s) {
          case 4:
            return Fe.AZTEC_PARAM
          case 6:
            return Fe.AZTEC_DATA_6
          case 8:
            return Fe.AZTEC_DATA_8
          case 10:
            return Fe.AZTEC_DATA_10
          case 12:
            return Fe.AZTEC_DATA_12
          default:
            throw new w('Unsupported word size ' + s)
        }
      }
      static stuffBits(s, a) {
        let l = new O(),
          u = s.getSize(),
          d = (1 << a) - 2
        for (let g = 0; g < u; g += a) {
          let m = 0
          for (let b = 0; b < a; b++) (g + b >= u || s.get(g + b)) && (m |= 1 << (a - 1 - b))
          ;(m & d) === d
            ? (l.appendBits(m & d, a), g--)
            : m & d
              ? l.appendBits(m, a)
              : (l.appendBits(m | 1, a), g--)
        }
        return l
      }
      static totalBitsInLayer(s, a) {
        return ((a ? 88 : 112) + 16 * s) * s
      }
    }
    ;((De.DEFAULT_EC_PERCENT = 33),
      (De.DEFAULT_AZTEC_LAYERS = 0),
      (De.MAX_NB_BITS = 32),
      (De.MAX_NB_BITS_COMPACT = 4),
      (De.WORD_SIZE = Int32Array.from([
        4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 12,
        12, 12, 12, 12, 12, 12, 12, 12,
      ])))
    class tc {
      encode(s, a, l, u) {
        return this.encodeWithHints(s, a, l, u, null)
      }
      encodeWithHints(s, a, l, u, d) {
        let g = zh.ISO_8859_1,
          m = De.DEFAULT_EC_PERCENT,
          b = De.DEFAULT_AZTEC_LAYERS
        return (
          d != null &&
            (d.has(_t.CHARACTER_SET) && (g = Pp.forName(d.get(_t.CHARACTER_SET).toString())),
            d.has(_t.ERROR_CORRECTION) && (m = M.parseInt(d.get(_t.ERROR_CORRECTION).toString())),
            d.has(_t.AZTEC_LAYERS) && (b = M.parseInt(d.get(_t.AZTEC_LAYERS).toString()))),
          tc.encodeLayers(s, a, l, u, g, m, b)
        )
      }
      static encodeLayers(s, a, l, u, d, g, m) {
        if (a !== ue.AZTEC) throw new w('Can only encode AZTEC, but got ' + a)
        let b = De.encode(re.getBytes(s, d), g, m)
        return tc.renderResult(b, l, u)
      }
      static renderResult(s, a, l) {
        let u = s.getMatrix()
        if (u == null) throw new dr()
        let d = u.getWidth(),
          g = u.getHeight(),
          m = Math.max(a, d),
          b = Math.max(l, g),
          v = Math.min(m / d, b / g),
          C = (m - d * v) / 2,
          T = (b - g * v) / 2,
          D = new Ie(m, b)
        for (let B = 0, j = T; B < g; B++, j += v)
          for (let W = 0, Y = C; W < d; W++, Y += v) u.get(W, B) && D.setRegion(Y, j, v, v)
        return D
      }
    }
    ;((n.AbstractExpandedDecoder = Rh),
      (n.ArgumentException = y),
      (n.ArithmeticException = zl),
      (n.AztecCode = Dp),
      (n.AztecCodeReader = Gl),
      (n.AztecCodeWriter = tc),
      (n.AztecDecoder = Ke),
      (n.AztecDetector = vp),
      (n.AztecDetectorResult = wp),
      (n.AztecEncoder = De),
      (n.AztecHighLevelEncoder = ua),
      (n.AztecPoint = tn),
      (n.BarcodeFormat = ue),
      (n.Binarizer = S),
      (n.BinaryBitmap = x),
      (n.BitArray = O),
      (n.BitMatrix = Ie),
      (n.BitSource = Lh),
      (n.BrowserAztecCodeReader = lb),
      (n.BrowserBarcodeReader = fb),
      (n.BrowserCodeReader = Tt),
      (n.BrowserDatamatrixCodeReader = gb),
      (n.BrowserMultiFormatReader = kb),
      (n.BrowserPDF417Reader = _b),
      (n.BrowserQRCodeReader = Ib),
      (n.BrowserQRCodeSvgWriter = Zi),
      (n.CharacterSetECI = Z),
      (n.ChecksumException = E),
      (n.Code128Reader = ie),
      (n.Code39Reader = At),
      (n.DataMatrixDecodedBitStreamParser = ti),
      (n.DataMatrixReader = ni),
      (n.DecodeHintType = z),
      (n.DecoderResult = Jo),
      (n.DefaultGridSampler = bp),
      (n.DetectorResult = Xl),
      (n.EAN13Reader = zi),
      (n.EncodeHintType = _t),
      (n.Exception = p),
      (n.FormatException = V),
      (n.GenericGF = Fe),
      (n.GenericGFPoly = un),
      (n.GlobalHistogramBinarizer = xe),
      (n.GridSampler = _h),
      (n.GridSamplerInstance = Jr),
      (n.HTMLCanvasElementLuminanceSource = pe),
      (n.HybridBinarizer = ge),
      (n.ITFReader = Ge),
      (n.IllegalArgumentException = w),
      (n.IllegalStateException = dr),
      (n.InvertedLuminanceSource = fe),
      (n.LuminanceSource = se),
      (n.MathUtils = Pe),
      (n.MultiFormatOneDReader = Zs),
      (n.MultiFormatReader = Mp),
      (n.MultiFormatWriter = Tb),
      (n.NotFoundException = H),
      (n.OneDReader = Ct),
      (n.PDF417DecodedBitStreamParser = K),
      (n.PDF417DecoderErrorCorrection = kp),
      (n.PDF417Reader = Vt),
      (n.PDF417ResultMetadata = Ip),
      (n.PerspectiveTransform = tr),
      (n.PlanarYUVLuminanceSource = mr),
      (n.QRCodeByteMatrix = Jl),
      (n.QRCodeDataMask = Un),
      (n.QRCodeDecodedBitStreamParser = ot),
      (n.QRCodeDecoderErrorCorrectionLevel = qe),
      (n.QRCodeDecoderFormatInformation = Zt),
      (n.QRCodeEncoder = Je),
      (n.QRCodeEncoderQRCode = Yi),
      (n.QRCodeMaskUtil = gt),
      (n.QRCodeMatrixUtil = we),
      (n.QRCodeMode = me),
      (n.QRCodeReader = ri),
      (n.QRCodeVersion = de),
      (n.QRCodeWriter = qs),
      (n.RGBLuminanceSource = Wh),
      (n.RSS14Reader = pt),
      (n.RSSExpandedReader = Q),
      (n.ReaderException = $l),
      (n.ReedSolomonDecoder = ta),
      (n.ReedSolomonEncoder = Uh),
      (n.ReedSolomonException = Hs),
      (n.Result = Be),
      (n.ResultMetadataType = Rt),
      (n.ResultPoint = he),
      (n.StringUtils = re),
      (n.UnsupportedOperationException = J),
      (n.VideoInputDevice = We),
      (n.WhiteRectangleDetector = Tr),
      (n.WriterException = Ye),
      (n.ZXingArrays = R),
      (n.ZXingCharset = Pp),
      (n.ZXingInteger = M),
      (n.ZXingStandardCharsets = zh),
      (n.ZXingStringBuilder = ve),
      (n.ZXingStringEncoding = oe),
      (n.ZXingSystem = k),
      (n.createAbstractExpandedDecoder = Sp),
      Object.defineProperty(n, '__esModule', { value: !0 }))
  })
})(Ef, Ef.exports)
var tt = Ef.exports
const MT = Ky(tt),
  PT = Zy({ __proto__: null, default: MT }, [tt])
var Vy = (function () {
    function e(t, n, r) {
      if (
        ((this.formatMap = new Map([
          [le.QR_CODE, tt.BarcodeFormat.QR_CODE],
          [le.AZTEC, tt.BarcodeFormat.AZTEC],
          [le.CODABAR, tt.BarcodeFormat.CODABAR],
          [le.CODE_39, tt.BarcodeFormat.CODE_39],
          [le.CODE_93, tt.BarcodeFormat.CODE_93],
          [le.CODE_128, tt.BarcodeFormat.CODE_128],
          [le.DATA_MATRIX, tt.BarcodeFormat.DATA_MATRIX],
          [le.MAXICODE, tt.BarcodeFormat.MAXICODE],
          [le.ITF, tt.BarcodeFormat.ITF],
          [le.EAN_13, tt.BarcodeFormat.EAN_13],
          [le.EAN_8, tt.BarcodeFormat.EAN_8],
          [le.PDF_417, tt.BarcodeFormat.PDF_417],
          [le.RSS_14, tt.BarcodeFormat.RSS_14],
          [le.RSS_EXPANDED, tt.BarcodeFormat.RSS_EXPANDED],
          [le.UPC_A, tt.BarcodeFormat.UPC_A],
          [le.UPC_E, tt.BarcodeFormat.UPC_E],
          [le.UPC_EAN_EXTENSION, tt.BarcodeFormat.UPC_EAN_EXTENSION],
        ])),
        (this.reverseFormatMap = this.createReverseFormatMap()),
        !PT)
      )
        throw 'Use html5qrcode.min.js without edit, ZXing not found.'
      ;((this.verbose = n), (this.logger = r))
      var i = this.createZXingFormats(t),
        o = new Map()
      ;(o.set(tt.DecodeHintType.POSSIBLE_FORMATS, i),
        o.set(tt.DecodeHintType.TRY_HARDER, !1),
        (this.hints = o))
    }
    return (
      (e.prototype.decodeAsync = function (t) {
        var n = this
        return new Promise(function (r, i) {
          try {
            r(n.decode(t))
          } catch (o) {
            i(o)
          }
        })
      }),
      (e.prototype.decode = function (t) {
        var n = new tt.MultiFormatReader(this.verbose, this.hints),
          r = new tt.HTMLCanvasElementLuminanceSource(t),
          i = new tt.BinaryBitmap(new tt.HybridBinarizer(r)),
          o = n.decode(i)
        return {
          text: o.text,
          format: ib.create(this.toHtml5QrcodeSupportedFormats(o.format)),
          debugData: this.createDebugData(),
        }
      }),
      (e.prototype.createReverseFormatMap = function () {
        var t = new Map()
        return (
          this.formatMap.forEach(function (n, r, i) {
            t.set(n, r)
          }),
          t
        )
      }),
      (e.prototype.toHtml5QrcodeSupportedFormats = function (t) {
        if (!this.reverseFormatMap.has(t)) throw "reverseFormatMap doesn't have ".concat(t)
        return this.reverseFormatMap.get(t)
      }),
      (e.prototype.createZXingFormats = function (t) {
        for (var n = [], r = 0, i = t; r < i.length; r++) {
          var o = i[r]
          this.formatMap.has(o)
            ? n.push(this.formatMap.get(o))
            : this.logger.logError(''.concat(o, ' is not supported by') + 'ZXingHtml5QrcodeShim')
        }
        return n
      }),
      (e.prototype.createDebugData = function () {
        return { decoderName: 'zxing-js' }
      }),
      e
    )
  })(),
  DT = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  LT = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  Uy = (function () {
    function e(t, n, r) {
      if (
        ((this.formatMap = new Map([
          [le.QR_CODE, 'qr_code'],
          [le.AZTEC, 'aztec'],
          [le.CODABAR, 'codabar'],
          [le.CODE_39, 'code_39'],
          [le.CODE_93, 'code_93'],
          [le.CODE_128, 'code_128'],
          [le.DATA_MATRIX, 'data_matrix'],
          [le.ITF, 'itf'],
          [le.EAN_13, 'ean_13'],
          [le.EAN_8, 'ean_8'],
          [le.PDF_417, 'pdf417'],
          [le.UPC_A, 'upc_a'],
          [le.UPC_E, 'upc_e'],
        ])),
        (this.reverseFormatMap = this.createReverseFormatMap()),
        !e.isSupported())
      )
        throw 'Use html5qrcode.min.js without edit, Use BarcodeDetectorDelegate only if it isSupported();'
      ;((this.verbose = n), (this.logger = r))
      var i = this.createBarcodeDetectorFormats(t)
      if (((this.detector = new BarcodeDetector(i)), !this.detector))
        throw 'BarcodeDetector detector not supported'
    }
    return (
      (e.isSupported = function () {
        if (!('BarcodeDetector' in window)) return !1
        var t = new BarcodeDetector({ formats: ['qr_code'] })
        return typeof t < 'u'
      }),
      (e.prototype.decodeAsync = function (t) {
        return DT(this, void 0, void 0, function () {
          var n, r
          return LT(this, function (i) {
            switch (i.label) {
              case 0:
                return [4, this.detector.detect(t)]
              case 1:
                if (((n = i.sent()), !n || n.length === 0)) throw 'No barcode or QR code detected.'
                return (
                  (r = this.selectLargestBarcode(n)),
                  [
                    2,
                    {
                      text: r.rawValue,
                      format: ib.create(this.toHtml5QrcodeSupportedFormats(r.format)),
                      debugData: this.createDebugData(),
                    },
                  ]
                )
            }
          })
        })
      }),
      (e.prototype.selectLargestBarcode = function (t) {
        for (var n = null, r = 0, i = 0, o = t; i < o.length; i++) {
          var c = o[i],
            h = c.boundingBox.width * c.boundingBox.height
          h > r && ((r = h), (n = c))
        }
        if (!n) throw 'No largest barcode found'
        return n
      }),
      (e.prototype.createBarcodeDetectorFormats = function (t) {
        for (var n = [], r = 0, i = t; r < i.length; r++) {
          var o = i[r]
          this.formatMap.has(o)
            ? n.push(this.formatMap.get(o))
            : this.logger.warn(''.concat(o, ' is not supported by') + 'BarcodeDetectorDelegate')
        }
        return { formats: n }
      }),
      (e.prototype.toHtml5QrcodeSupportedFormats = function (t) {
        if (!this.reverseFormatMap.has(t)) throw "reverseFormatMap doesn't have ".concat(t)
        return this.reverseFormatMap.get(t)
      }),
      (e.prototype.createReverseFormatMap = function () {
        var t = new Map()
        return (
          this.formatMap.forEach(function (n, r, i) {
            t.set(n, r)
          }),
          t
        )
      }),
      (e.prototype.createDebugData = function () {
        return { decoderName: 'BarcodeDetector' }
      }),
      e
    )
  })(),
  Wy = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  zy = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  OT = (function () {
    function e(t, n, r, i) {
      ;((this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100),
        (this.executions = 0),
        (this.executionResults = []),
        (this.wasPrimaryDecoderUsedInLastDecode = !1),
        (this.verbose = r),
        n && Uy.isSupported()
          ? ((this.primaryDecoder = new Uy(t, r, i)), (this.secondaryDecoder = new Vy(t, r, i)))
          : (this.primaryDecoder = new Vy(t, r, i)))
    }
    return (
      (e.prototype.decodeAsync = function (t) {
        return Wy(this, void 0, void 0, function () {
          var n
          return zy(this, function (r) {
            switch (r.label) {
              case 0:
                ;((n = performance.now()), (r.label = 1))
              case 1:
                return (r.trys.push([1, , 3, 4]), [4, this.getDecoder().decodeAsync(t)])
              case 2:
                return [2, r.sent()]
              case 3:
                return (this.possiblyLogPerformance(n), [7])
              case 4:
                return [2]
            }
          })
        })
      }),
      (e.prototype.decodeRobustlyAsync = function (t) {
        return Wy(this, void 0, void 0, function () {
          var n, r
          return zy(this, function (i) {
            switch (i.label) {
              case 0:
                ;((n = performance.now()), (i.label = 1))
              case 1:
                return (i.trys.push([1, 3, 4, 5]), [4, this.primaryDecoder.decodeAsync(t)])
              case 2:
                return [2, i.sent()]
              case 3:
                if (((r = i.sent()), this.secondaryDecoder))
                  return [2, this.secondaryDecoder.decodeAsync(t)]
                throw r
              case 4:
                return (this.possiblyLogPerformance(n), [7])
              case 5:
                return [2]
            }
          })
        })
      }),
      (e.prototype.getDecoder = function () {
        return this.secondaryDecoder
          ? this.wasPrimaryDecoderUsedInLastDecode === !1
            ? ((this.wasPrimaryDecoderUsedInLastDecode = !0), this.primaryDecoder)
            : ((this.wasPrimaryDecoderUsedInLastDecode = !1), this.secondaryDecoder)
          : this.primaryDecoder
      }),
      (e.prototype.possiblyLogPerformance = function (t) {
        if (this.verbose) {
          var n = performance.now() - t
          ;(this.executionResults.push(n), this.executions++, this.possiblyFlushPerformanceReport())
        }
      }),
      (e.prototype.possiblyFlushPerformanceReport = function () {
        if (!(this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE)) {
          for (var t = 0, n = 0, r = this.executionResults; n < r.length; n++) {
            var i = r[n]
            t += i
          }
          var o = t / this.executionResults.length
          ;(console.log(
            ''.concat(o, ' ms for ').concat(this.executionResults.length, ' last runs.')
          ),
            (this.executions = 0),
            (this.executionResults = []))
        }
      }),
      e
    )
  })(),
  yp = (function () {
    var e = function (t, n) {
      return (
        (e =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i
            }) ||
          function (r, i) {
            for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o])
          }),
        e(t, n)
      )
    }
    return function (t, n) {
      if (typeof n != 'function' && n !== null)
        throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null')
      e(t, n)
      function r() {
        this.constructor = t
      }
      t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r())
    }
  })(),
  Gu = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  Yu = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  ob = (function () {
    function e(t, n) {
      ;((this.name = t), (this.track = n))
    }
    return (
      (e.prototype.isSupported = function () {
        return this.track.getCapabilities ? this.name in this.track.getCapabilities() : !1
      }),
      (e.prototype.apply = function (t) {
        var n = {}
        n[this.name] = t
        var r = { advanced: [n] }
        return this.track.applyConstraints(r)
      }),
      (e.prototype.value = function () {
        var t = this.track.getSettings()
        if (this.name in t) {
          var n = t[this.name]
          return n
        }
        return null
      }),
      e
    )
  })(),
  BT = (function (e) {
    yp(t, e)
    function t(n, r) {
      return e.call(this, n, r) || this
    }
    return (
      (t.prototype.min = function () {
        return this.getCapabilities().min
      }),
      (t.prototype.max = function () {
        return this.getCapabilities().max
      }),
      (t.prototype.step = function () {
        return this.getCapabilities().step
      }),
      (t.prototype.apply = function (n) {
        var r = {}
        r[this.name] = n
        var i = { advanced: [r] }
        return this.track.applyConstraints(i)
      }),
      (t.prototype.getCapabilities = function () {
        this.failIfNotSupported()
        var n = this.track.getCapabilities(),
          r = n[this.name]
        return { min: r.min, max: r.max, step: r.step }
      }),
      (t.prototype.failIfNotSupported = function () {
        if (!this.isSupported()) throw new Error(''.concat(this.name, ' capability not supported'))
      }),
      t
    )
  })(ob),
  FT = (function (e) {
    yp(t, e)
    function t(n) {
      return e.call(this, 'zoom', n) || this
    }
    return t
  })(BT),
  jT = (function (e) {
    yp(t, e)
    function t(n) {
      return e.call(this, 'torch', n) || this
    }
    return t
  })(ob),
  VT = (function () {
    function e(t) {
      this.track = t
    }
    return (
      (e.prototype.zoomFeature = function () {
        return new FT(this.track)
      }),
      (e.prototype.torchFeature = function () {
        return new jT(this.track)
      }),
      e
    )
  })(),
  UT = (function () {
    function e(t, n, r) {
      ;((this.isClosed = !1),
        (this.parentElement = t),
        (this.mediaStream = n),
        (this.callbacks = r),
        (this.surface = this.createVideoElement(this.parentElement.clientWidth)),
        t.append(this.surface))
    }
    return (
      (e.prototype.createVideoElement = function (t) {
        var n = document.createElement('video')
        return (
          (n.style.width = ''.concat(t, 'px')),
          (n.style.display = 'block'),
          (n.muted = !0),
          n.setAttribute('muted', 'true'),
          (n.playsInline = !0),
          n
        )
      }),
      (e.prototype.setupSurface = function () {
        var t = this
        ;((this.surface.onabort = function () {
          throw 'RenderedCameraImpl video surface onabort() called'
        }),
          (this.surface.onerror = function () {
            throw 'RenderedCameraImpl video surface onerror() called'
          }))
        var n = function () {
          var r = t.surface.clientWidth,
            i = t.surface.clientHeight
          ;(t.callbacks.onRenderSurfaceReady(r, i), t.surface.removeEventListener('playing', n))
        }
        ;(this.surface.addEventListener('playing', n),
          (this.surface.srcObject = this.mediaStream),
          this.surface.play())
      }),
      (e.create = function (t, n, r, i) {
        return Gu(this, void 0, void 0, function () {
          var o, c
          return Yu(this, function (h) {
            switch (h.label) {
              case 0:
                return (
                  (o = new e(t, n, i)),
                  r.aspectRatio
                    ? ((c = { aspectRatio: r.aspectRatio }),
                      [4, o.getFirstTrackOrFail().applyConstraints(c)])
                    : [3, 2]
                )
              case 1:
                ;(h.sent(), (h.label = 2))
              case 2:
                return (o.setupSurface(), [2, o])
            }
          })
        })
      }),
      (e.prototype.failIfClosed = function () {
        if (this.isClosed) throw 'The RenderedCamera has already been closed.'
      }),
      (e.prototype.getFirstTrackOrFail = function () {
        if ((this.failIfClosed(), this.mediaStream.getVideoTracks().length === 0))
          throw 'No video tracks found'
        return this.mediaStream.getVideoTracks()[0]
      }),
      (e.prototype.pause = function () {
        ;(this.failIfClosed(), this.surface.pause())
      }),
      (e.prototype.resume = function (t) {
        this.failIfClosed()
        var n = this,
          r = function () {
            ;(setTimeout(t, 200), n.surface.removeEventListener('playing', r))
          }
        ;(this.surface.addEventListener('playing', r), this.surface.play())
      }),
      (e.prototype.isPaused = function () {
        return (this.failIfClosed(), this.surface.paused)
      }),
      (e.prototype.getSurface = function () {
        return (this.failIfClosed(), this.surface)
      }),
      (e.prototype.getRunningTrackCapabilities = function () {
        return this.getFirstTrackOrFail().getCapabilities()
      }),
      (e.prototype.getRunningTrackSettings = function () {
        return this.getFirstTrackOrFail().getSettings()
      }),
      (e.prototype.applyVideoConstraints = function (t) {
        return Gu(this, void 0, void 0, function () {
          return Yu(this, function (n) {
            if ('aspectRatio' in t) throw "Changing 'aspectRatio' in run-time is not yet supported."
            return [2, this.getFirstTrackOrFail().applyConstraints(t)]
          })
        })
      }),
      (e.prototype.close = function () {
        if (this.isClosed) return Promise.resolve()
        var t = this
        return new Promise(function (n, r) {
          var i = t.mediaStream.getVideoTracks(),
            o = i.length,
            c = 0
          t.mediaStream.getVideoTracks().forEach(function (h) {
            ;(t.mediaStream.removeTrack(h),
              h.stop(),
              ++c,
              c >= o && ((t.isClosed = !0), t.parentElement.removeChild(t.surface), n()))
          })
        })
      }),
      (e.prototype.getCapabilities = function () {
        return new VT(this.getFirstTrackOrFail())
      }),
      e
    )
  })(),
  WT = (function () {
    function e(t) {
      this.mediaStream = t
    }
    return (
      (e.prototype.render = function (t, n, r) {
        return Gu(this, void 0, void 0, function () {
          return Yu(this, function (i) {
            return [2, UT.create(t, this.mediaStream, n, r)]
          })
        })
      }),
      (e.create = function (t) {
        return Gu(this, void 0, void 0, function () {
          var n, r
          return Yu(this, function (i) {
            switch (i.label) {
              case 0:
                if (!navigator.mediaDevices) throw 'navigator.mediaDevices not supported'
                return ((n = { audio: !1, video: t }), [4, navigator.mediaDevices.getUserMedia(n)])
              case 1:
                return ((r = i.sent()), [2, new e(r)])
            }
          })
        })
      }),
      e
    )
  })(),
  Hy = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  Xy = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  zT = (function () {
    function e() {}
    return (
      (e.failIfNotSupported = function () {
        return Hy(this, void 0, void 0, function () {
          return Xy(this, function (t) {
            if (!navigator.mediaDevices) throw 'navigator.mediaDevices not supported'
            return [2, new e()]
          })
        })
      }),
      (e.prototype.create = function (t) {
        return Hy(this, void 0, void 0, function () {
          return Xy(this, function (n) {
            return [2, WT.create(t)]
          })
        })
      }),
      e
    )
  })(),
  HT = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  XT = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  GT = (function () {
    function e() {}
    return (
      (e.retrieve = function () {
        if (navigator.mediaDevices) return e.getCamerasFromMediaDevices()
        var t = MediaStreamTrack
        return MediaStreamTrack && t.getSources
          ? e.getCamerasFromMediaStreamTrack()
          : e.rejectWithError()
      }),
      (e.rejectWithError = function () {
        var t = Eo.unableToQuerySupportedDevices()
        return (
          e.isHttpsOrLocalhost() || (t = Eo.insecureContextCameraQueryError()),
          Promise.reject(t)
        )
      }),
      (e.isHttpsOrLocalhost = function () {
        if (location.protocol === 'https:') return !0
        var t = location.host.split(':')[0]
        return t === '127.0.0.1' || t === 'localhost'
      }),
      (e.getCamerasFromMediaDevices = function () {
        return HT(this, void 0, void 0, function () {
          var t, n, r, i, o, c, h
          return XT(this, function (f) {
            switch (f.label) {
              case 0:
                return (
                  (t = function (p) {
                    for (var y = p.getVideoTracks(), w = 0, x = y; w < x.length; w++) {
                      var E = x[w]
                      ;((E.enabled = !1), E.stop(), p.removeTrack(E))
                    }
                  }),
                  [4, navigator.mediaDevices.getUserMedia({ audio: !1, video: !0 })]
                )
              case 1:
                return ((n = f.sent()), [4, navigator.mediaDevices.enumerateDevices()])
              case 2:
                for (r = f.sent(), i = [], o = 0, c = r; o < c.length; o++)
                  ((h = c[o]),
                    h.kind === 'videoinput' && i.push({ id: h.deviceId, label: h.label }))
                return (t(n), [2, i])
            }
          })
        })
      }),
      (e.getCamerasFromMediaStreamTrack = function () {
        return new Promise(function (t, n) {
          var r = function (o) {
              for (var c = [], h = 0, f = o; h < f.length; h++) {
                var p = f[h]
                p.kind === 'video' && c.push({ id: p.id, label: p.label })
              }
              t(c)
            },
            i = MediaStreamTrack
          i.getSources(r)
        })
      }),
      e
    )
  })(),
  mt
;(function (e) {
  ;((e[(e.UNKNOWN = 0)] = 'UNKNOWN'),
    (e[(e.NOT_STARTED = 1)] = 'NOT_STARTED'),
    (e[(e.SCANNING = 2)] = 'SCANNING'),
    (e[(e.PAUSED = 3)] = 'PAUSED'))
})(mt || (mt = {}))
var YT = (function () {
    function e() {
      ;((this.state = mt.NOT_STARTED), (this.onGoingTransactionNewState = mt.UNKNOWN))
    }
    return (
      (e.prototype.directTransition = function (t) {
        ;(this.failIfTransitionOngoing(), this.validateTransition(t), (this.state = t))
      }),
      (e.prototype.startTransition = function (t) {
        return (
          this.failIfTransitionOngoing(),
          this.validateTransition(t),
          (this.onGoingTransactionNewState = t),
          this
        )
      }),
      (e.prototype.execute = function () {
        if (this.onGoingTransactionNewState === mt.UNKNOWN)
          throw 'Transaction is already cancelled, cannot execute().'
        var t = this.onGoingTransactionNewState
        ;((this.onGoingTransactionNewState = mt.UNKNOWN), this.directTransition(t))
      }),
      (e.prototype.cancel = function () {
        if (this.onGoingTransactionNewState === mt.UNKNOWN)
          throw 'Transaction is already cancelled, cannot cancel().'
        this.onGoingTransactionNewState = mt.UNKNOWN
      }),
      (e.prototype.getState = function () {
        return this.state
      }),
      (e.prototype.failIfTransitionOngoing = function () {
        if (this.onGoingTransactionNewState !== mt.UNKNOWN)
          throw 'Cannot transition to a new state, already under transition'
      }),
      (e.prototype.validateTransition = function (t) {
        switch (this.state) {
          case mt.UNKNOWN:
            throw 'Transition from unknown is not allowed'
          case mt.NOT_STARTED:
            this.failIfNewStateIs(t, [mt.PAUSED])
            break
          case mt.SCANNING:
            break
          case mt.PAUSED:
            break
        }
      }),
      (e.prototype.failIfNewStateIs = function (t, n) {
        for (var r = 0, i = n; r < i.length; r++) {
          var o = i[r]
          if (t === o) throw 'Cannot transition from '.concat(this.state, ' to ').concat(t)
        }
      }),
      e
    )
  })(),
  ZT = (function () {
    function e(t) {
      this.stateManager = t
    }
    return (
      (e.prototype.startTransition = function (t) {
        return this.stateManager.startTransition(t)
      }),
      (e.prototype.directTransition = function (t) {
        this.stateManager.directTransition(t)
      }),
      (e.prototype.getState = function () {
        return this.stateManager.getState()
      }),
      (e.prototype.canScanFile = function () {
        return this.stateManager.getState() === mt.NOT_STARTED
      }),
      (e.prototype.isScanning = function () {
        return this.stateManager.getState() !== mt.NOT_STARTED
      }),
      (e.prototype.isStrictlyScanning = function () {
        return this.stateManager.getState() === mt.SCANNING
      }),
      (e.prototype.isPaused = function () {
        return this.stateManager.getState() === mt.PAUSED
      }),
      e
    )
  })(),
  KT = (function () {
    function e() {}
    return (
      (e.create = function () {
        return new ZT(new YT())
      }),
      e
    )
  })(),
  qT = (function () {
    var e = function (t, n) {
      return (
        (e =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i
            }) ||
          function (r, i) {
            for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o])
          }),
        e(t, n)
      )
    }
    return function (t, n) {
      if (typeof n != 'function' && n !== null)
        throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null')
      e(t, n)
      function r() {
        this.constructor = t
      }
      t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r())
    }
  })(),
  _n = (function (e) {
    qT(t, e)
    function t() {
      return (e !== null && e.apply(this, arguments)) || this
    }
    return (
      (t.DEFAULT_WIDTH = 300),
      (t.DEFAULT_WIDTH_OFFSET = 2),
      (t.FILE_SCAN_MIN_HEIGHT = 300),
      (t.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100),
      (t.MIN_QR_BOX_SIZE = 50),
      (t.SHADED_LEFT = 1),
      (t.SHADED_RIGHT = 2),
      (t.SHADED_TOP = 3),
      (t.SHADED_BOTTOM = 4),
      (t.SHADED_REGION_ELEMENT_ID = 'qr-shaded-region'),
      (t.VERBOSE = !1),
      (t.BORDER_SHADER_DEFAULT_COLOR = '#ffffff'),
      (t.BORDER_SHADER_MATCH_COLOR = 'rgb(90, 193, 56)'),
      t
    )
  })(NT),
  QT = (function () {
    function e(t, n) {
      ;((this.logger = n),
        (this.fps = _n.SCAN_DEFAULT_FPS),
        t
          ? (t.fps && (this.fps = t.fps),
            (this.disableFlip = t.disableFlip === !0),
            (this.qrbox = t.qrbox),
            (this.aspectRatio = t.aspectRatio),
            (this.videoConstraints = t.videoConstraints))
          : (this.disableFlip = _n.DEFAULT_DISABLE_FLIP))
    }
    return (
      (e.prototype.isMediaStreamConstraintsValid = function () {
        return this.videoConstraints
          ? sb.isMediaStreamConstraintsValid(this.videoConstraints, this.logger)
          : (this.logger.logError('Empty videoConstraints', !0), !1)
      }),
      (e.prototype.isShadedBoxEnabled = function () {
        return !Dr(this.qrbox)
      }),
      (e.create = function (t, n) {
        return new e(t, n)
      }),
      e
    )
  })(),
  $T = (function () {
    function e(t, n) {
      if (
        ((this.element = null),
        (this.canvasElement = null),
        (this.scannerPausedUiElement = null),
        (this.hasBorderShaders = null),
        (this.borderShaders = null),
        (this.qrMatch = null),
        (this.renderedCamera = null),
        (this.qrRegion = null),
        (this.context = null),
        (this.lastScanImageFile = null),
        (this.isScanning = !1),
        !document.getElementById(t))
      )
        throw 'HTML Element with id='.concat(t, ' not found')
      ;((this.elementId = t), (this.verbose = !1))
      var r
      ;(typeof n == 'boolean'
        ? (this.verbose = n === !0)
        : n && ((r = n), (this.verbose = r.verbose === !0), r.experimentalFeatures),
        (this.logger = new RT(this.verbose)),
        (this.qrcode = new OT(
          this.getSupportedFormats(n),
          this.getUseBarCodeDetectorIfSupported(r),
          this.verbose,
          this.logger
        )),
        this.foreverScanTimeout,
        (this.shouldScan = !0),
        (this.stateManagerProxy = KT.create()))
    }
    return (
      (e.prototype.start = function (t, n, r, i) {
        var o = this
        if (!t) throw 'cameraIdOrConfig is required'
        if (!r || typeof r != 'function')
          throw 'qrCodeSuccessCallback is required and should be a function.'
        var c
        i ? (c = i) : (c = this.verbose ? this.logger.log : function () {})
        var h = QT.create(n, this.logger)
        this.clearElement()
        var f = !1
        h.videoConstraints &&
          (h.isMediaStreamConstraintsValid()
            ? (f = !0)
            : this.logger.logError(
                "'videoConstraints' is not valid 'MediaStreamConstraints, it will be ignored.'",
                !0
              ))
        var p = f,
          y = document.getElementById(this.elementId)
        ;(y.clientWidth ? y.clientWidth : _n.DEFAULT_WIDTH,
          (y.style.position = 'relative'),
          (this.shouldScan = !0),
          (this.element = y))
        var w = this,
          x = this.stateManagerProxy.startTransition(mt.SCANNING)
        return new Promise(function (E, S) {
          var k = p ? h.videoConstraints : w.createVideoConstraints(t)
          if (!k) {
            ;(x.cancel(), S('videoConstraints should be defined'))
            return
          }
          var P = {}
          ;(!p || h.aspectRatio) && (P.aspectRatio = h.aspectRatio)
          var I = {
            onRenderSurfaceReady: function (R, M) {
              ;(w.setupUi(R, M, h), (w.isScanning = !0), w.foreverScan(h, r, c))
            },
          }
          zT.failIfNotSupported()
            .then(function (R) {
              R.create(k)
                .then(function (M) {
                  return M.render(o.element, P, I)
                    .then(function (O) {
                      ;((w.renderedCamera = O), x.execute(), E(null))
                    })
                    .catch(function (O) {
                      ;(x.cancel(), S(O))
                    })
                })
                .catch(function (M) {
                  ;(x.cancel(), S(Eo.errorGettingUserMedia(M)))
                })
            })
            .catch(function (R) {
              ;(x.cancel(), S(Eo.cameraStreamingNotSupported()))
            })
        })
      }),
      (e.prototype.pause = function (t) {
        if (!this.stateManagerProxy.isStrictlyScanning())
          throw 'Cannot pause, scanner is not scanning.'
        ;(this.stateManagerProxy.directTransition(mt.PAUSED),
          this.showPausedState(),
          (Dr(t) || t !== !0) && (t = !1),
          t && this.renderedCamera && this.renderedCamera.pause())
      }),
      (e.prototype.resume = function () {
        if (!this.stateManagerProxy.isPaused()) throw 'Cannot result, scanner is not paused.'
        if (!this.renderedCamera) throw "renderedCamera doesn't exist while trying resume()"
        var t = this,
          n = function () {
            ;(t.stateManagerProxy.directTransition(mt.SCANNING), t.hidePausedState())
          }
        if (!this.renderedCamera.isPaused()) {
          n()
          return
        }
        this.renderedCamera.resume(function () {
          n()
        })
      }),
      (e.prototype.getState = function () {
        return this.stateManagerProxy.getState()
      }),
      (e.prototype.stop = function () {
        var t = this
        if (!this.stateManagerProxy.isScanning())
          throw 'Cannot stop, scanner is not running or paused.'
        var n = this.stateManagerProxy.startTransition(mt.NOT_STARTED)
        ;((this.shouldScan = !1), this.foreverScanTimeout && clearTimeout(this.foreverScanTimeout))
        var r = function () {
            if (t.element) {
              var o = document.getElementById(_n.SHADED_REGION_ELEMENT_ID)
              o && t.element.removeChild(o)
            }
          },
          i = this
        return this.renderedCamera.close().then(function () {
          return (
            (i.renderedCamera = null),
            i.element && (i.element.removeChild(i.canvasElement), (i.canvasElement = null)),
            r(),
            i.qrRegion && (i.qrRegion = null),
            i.context && (i.context = null),
            n.execute(),
            i.hidePausedState(),
            (i.isScanning = !1),
            Promise.resolve()
          )
        })
      }),
      (e.prototype.scanFile = function (t, n) {
        return this.scanFileV2(t, n).then(function (r) {
          return r.decodedText
        })
      }),
      (e.prototype.scanFileV2 = function (t, n) {
        var r = this
        if (!t || !(t instanceof File))
          throw "imageFile argument is mandatory and should be instance of File. Use 'event.target.files[0]'."
        if ((Dr(n) && (n = !0), !this.stateManagerProxy.canScanFile()))
          throw 'Cannot start file scan - ongoing camera scan'
        return new Promise(function (i, o) {
          ;(r.possiblyCloseLastScanImageFile(),
            r.clearElement(),
            (r.lastScanImageFile = URL.createObjectURL(t)))
          var c = new Image()
          ;((c.onload = function () {
            var h = c.width,
              f = c.height,
              p = document.getElementById(r.elementId),
              y = p.clientWidth ? p.clientWidth : _n.DEFAULT_WIDTH,
              w = Math.max(p.clientHeight ? p.clientHeight : f, _n.FILE_SCAN_MIN_HEIGHT),
              x = r.computeCanvasDrawConfig(h, f, y, w)
            if (n) {
              var E = r.createCanvasElement(y, w, 'qr-canvas-visible')
              ;((E.style.display = 'inline-block'), p.appendChild(E))
              var S = E.getContext('2d')
              if (!S) throw 'Unable to get 2d context from canvas'
              ;((S.canvas.width = y),
                (S.canvas.height = w),
                S.drawImage(c, 0, 0, h, f, x.x, x.y, x.width, x.height))
            }
            var k = _n.FILE_SCAN_HIDDEN_CANVAS_PADDING,
              P = Math.max(c.width, x.width),
              I = Math.max(c.height, x.height),
              R = P + 2 * k,
              M = I + 2 * k,
              O = r.createCanvasElement(R, M)
            p.appendChild(O)
            var F = O.getContext('2d')
            if (!F) throw 'Unable to get 2d context from canvas'
            ;((F.canvas.width = R), (F.canvas.height = M), F.drawImage(c, 0, 0, h, f, k, k, P, I))
            try {
              r.qrcode
                .decodeRobustlyAsync(O)
                .then(function (z) {
                  i(jy.createFromQrcodeResult(z))
                })
                .catch(o)
            } catch (z) {
              o('QR code parse error, error = '.concat(z))
            }
          }),
            (c.onerror = o),
            (c.onabort = o),
            (c.onstalled = o),
            (c.onsuspend = o),
            (c.src = URL.createObjectURL(t)))
        })
      }),
      (e.prototype.clear = function () {
        this.clearElement()
      }),
      (e.getCameras = function () {
        return GT.retrieve()
      }),
      (e.prototype.getRunningTrackCapabilities = function () {
        return this.getRenderedCameraOrFail().getRunningTrackCapabilities()
      }),
      (e.prototype.getRunningTrackSettings = function () {
        return this.getRenderedCameraOrFail().getRunningTrackSettings()
      }),
      (e.prototype.getRunningTrackCameraCapabilities = function () {
        return this.getRenderedCameraOrFail().getCapabilities()
      }),
      (e.prototype.applyVideoConstraints = function (t) {
        if (t) {
          if (!sb.isMediaStreamConstraintsValid(t, this.logger))
            throw 'invalid videoConstaints passed, check logs for more details'
        } else throw 'videoConstaints is required argument.'
        return this.getRenderedCameraOrFail().applyVideoConstraints(t)
      }),
      (e.prototype.getRenderedCameraOrFail = function () {
        if (this.renderedCamera == null)
          throw 'Scanning is not in running state, call this API only when QR code scanning using camera is in running state.'
        return this.renderedCamera
      }),
      (e.prototype.getSupportedFormats = function (t) {
        var n = [
          le.QR_CODE,
          le.AZTEC,
          le.CODABAR,
          le.CODE_39,
          le.CODE_93,
          le.CODE_128,
          le.DATA_MATRIX,
          le.MAXICODE,
          le.ITF,
          le.EAN_13,
          le.EAN_8,
          le.PDF_417,
          le.RSS_14,
          le.RSS_EXPANDED,
          le.UPC_A,
          le.UPC_E,
          le.UPC_EAN_EXTENSION,
        ]
        if (!t || typeof t == 'boolean' || !t.formatsToSupport) return n
        if (!Array.isArray(t.formatsToSupport))
          throw 'configOrVerbosityFlag.formatsToSupport should be undefined or an array.'
        if (t.formatsToSupport.length === 0) throw 'Atleast 1 formatsToSupport is needed.'
        for (var r = [], i = 0, o = t.formatsToSupport; i < o.length; i++) {
          var c = o[i]
          IT(c)
            ? r.push(c)
            : this.logger.warn('Invalid format: '.concat(c, ' passed in config, ignoring.'))
        }
        if (r.length === 0) throw 'None of formatsToSupport match supported values.'
        return r
      }),
      (e.prototype.getUseBarCodeDetectorIfSupported = function (t) {
        if (Dr(t)) return !0
        if (!Dr(t.useBarCodeDetectorIfSupported)) return t.useBarCodeDetectorIfSupported !== !1
        if (Dr(t.experimentalFeatures)) return !0
        var n = t.experimentalFeatures
        return Dr(n.useBarCodeDetectorIfSupported) ? !0 : n.useBarCodeDetectorIfSupported !== !1
      }),
      (e.prototype.validateQrboxSize = function (t, n, r) {
        var i = this,
          o = r.qrbox
        this.validateQrboxConfig(o)
        var c = this.toQrdimensions(t, n, o),
          h = function (p) {
            if (p < _n.MIN_QR_BOX_SIZE)
              throw (
                "minimum size of 'config.qrbox' dimension value is" +
                ' '.concat(_n.MIN_QR_BOX_SIZE, 'px.')
              )
          },
          f = function (p) {
            return (
              p > t &&
                (i.logger.warn(
                  '`qrbox.width` or `qrbox` is larger than the width of the root element. The width will be truncated to the width of root element.'
                ),
                (p = t)),
              p
            )
          }
        ;(h(c.width), h(c.height), (c.width = f(c.width)))
      }),
      (e.prototype.validateQrboxConfig = function (t) {
        if (
          typeof t != 'number' &&
          typeof t != 'function' &&
          (t.width === void 0 || t.height === void 0)
        )
          throw "Invalid instance of QrDimensions passed for 'config.qrbox'. Both 'width' and 'height' should be set."
      }),
      (e.prototype.toQrdimensions = function (t, n, r) {
        if (typeof r == 'number') return { width: r, height: r }
        if (typeof r == 'function')
          try {
            return r(t, n)
          } catch (i) {
            throw new Error(
              'qrbox config was passed as a function but it failed with unknown error' + i
            )
          }
        return r
      }),
      (e.prototype.setupUi = function (t, n, r) {
        r.isShadedBoxEnabled() && this.validateQrboxSize(t, n, r)
        var i = Dr(r.qrbox) ? { width: t, height: n } : r.qrbox
        this.validateQrboxConfig(i)
        var o = this.toQrdimensions(t, n, i)
        o.height > n &&
          this.logger.warn(
            '[Html5Qrcode] config.qrbox has height that isgreater than the height of the video stream. Shading will be ignored'
          )
        var c = r.isShadedBoxEnabled() && o.height <= n,
          h = { x: 0, y: 0, width: t, height: n },
          f = c ? this.getShadedRegionBounds(t, n, o) : h,
          p = this.createCanvasElement(f.width, f.height),
          y = { willReadFrequently: !0 },
          w = p.getContext('2d', y)
        ;((w.canvas.width = f.width),
          (w.canvas.height = f.height),
          this.element.append(p),
          c && this.possiblyInsertShadingElement(this.element, t, n, o),
          this.createScannerPausedUiElement(this.element),
          (this.qrRegion = f),
          (this.context = w),
          (this.canvasElement = p))
      }),
      (e.prototype.createScannerPausedUiElement = function (t) {
        var n = document.createElement('div')
        ;((n.innerText = Eo.scannerPaused()),
          (n.style.display = 'none'),
          (n.style.position = 'absolute'),
          (n.style.top = '0px'),
          (n.style.zIndex = '1'),
          (n.style.background = 'rgba(9, 9, 9, 0.46)'),
          (n.style.color = '#FFECEC'),
          (n.style.textAlign = 'center'),
          (n.style.width = '100%'),
          t.appendChild(n),
          (this.scannerPausedUiElement = n))
      }),
      (e.prototype.scanContext = function (t, n) {
        var r = this
        return this.stateManagerProxy.isPaused()
          ? Promise.resolve(!1)
          : this.qrcode
              .decodeAsync(this.canvasElement)
              .then(function (i) {
                return (t(i.text, jy.createFromQrcodeResult(i)), r.possiblyUpdateShaders(!0), !0)
              })
              .catch(function (i) {
                r.possiblyUpdateShaders(!1)
                var o = Eo.codeParseError(i)
                return (n(o, TT.createFrom(o)), !1)
              })
      }),
      (e.prototype.foreverScan = function (t, n, r) {
        var i = this
        if (this.shouldScan && this.renderedCamera) {
          var o = this.renderedCamera.getSurface(),
            c = o.videoWidth / o.clientWidth,
            h = o.videoHeight / o.clientHeight
          if (!this.qrRegion) throw 'qrRegion undefined when localMediaStream is ready.'
          var f = this.qrRegion.width * c,
            p = this.qrRegion.height * h,
            y = this.qrRegion.x * c,
            w = this.qrRegion.y * h
          this.context.drawImage(o, y, w, f, p, 0, 0, this.qrRegion.width, this.qrRegion.height)
          var x = function () {
            i.foreverScanTimeout = setTimeout(function () {
              i.foreverScan(t, n, r)
            }, i.getTimeoutFps(t.fps))
          }
          this.scanContext(n, r)
            .then(function (E) {
              !E && t.disableFlip !== !0
                ? (i.context.translate(i.context.canvas.width, 0),
                  i.context.scale(-1, 1),
                  i.scanContext(n, r).finally(function () {
                    x()
                  }))
                : x()
            })
            .catch(function (E) {
              ;(i.logger.logError('Error happend while scanning context', E), x())
            })
        }
      }),
      (e.prototype.createVideoConstraints = function (t) {
        if (typeof t == 'string') return { deviceId: { exact: t } }
        if (typeof t == 'object') {
          var n = 'facingMode',
            r = 'deviceId',
            i = { user: !0, environment: !0 },
            o = 'exact',
            c = function (S) {
              if (S in i) return !0
              throw "config has invalid 'facingMode' value = " + "'".concat(S, "'")
            },
            h = Object.keys(t)
          if (h.length !== 1)
            throw (
              "'cameraIdOrConfig' object should have exactly 1 key," +
              ' if passed as an object, found '.concat(h.length, ' keys')
            )
          var f = Object.keys(t)[0]
          if (f !== n && f !== r)
            throw (
              "Only '".concat(n, "' and '").concat(r, "' ") +
              " are supported for 'cameraIdOrConfig'"
            )
          if (f === n) {
            var p = t.facingMode
            if (typeof p == 'string') {
              if (c(p)) return { facingMode: p }
            } else if (typeof p == 'object')
              if (o in p) {
                if (c(p[''.concat(o)])) return { facingMode: { exact: p[''.concat(o)] } }
              } else
                throw "'facingMode' should be string or object with" + ' '.concat(o, ' as key.')
            else {
              var y = typeof p
              throw "Invalid type of 'facingMode' = ".concat(y)
            }
          } else {
            var w = t.deviceId
            if (typeof w == 'string') return { deviceId: w }
            if (typeof w == 'object') {
              if (o in w) return { deviceId: { exact: w[''.concat(o)] } }
              throw "'deviceId' should be string or object with" + ' '.concat(o, ' as key.')
            } else {
              var x = typeof w
              throw "Invalid type of 'deviceId' = ".concat(x)
            }
          }
        }
        var E = typeof t
        throw "Invalid type of 'cameraIdOrConfig' = ".concat(E)
      }),
      (e.prototype.computeCanvasDrawConfig = function (t, n, r, i) {
        if (t <= r && n <= i) {
          var o = (r - t) / 2,
            c = (i - n) / 2
          return { x: o, y: c, width: t, height: n }
        } else {
          var h = t,
            f = n
          return (
            t > r && ((n = (r / t) * n), (t = r)),
            n > i && ((t = (i / n) * t), (n = i)),
            this.logger.log(
              'Image downsampled from ' +
                ''.concat(h, 'X').concat(f) +
                ' to '.concat(t, 'X').concat(n, '.')
            ),
            this.computeCanvasDrawConfig(t, n, r, i)
          )
        }
      }),
      (e.prototype.clearElement = function () {
        if (this.stateManagerProxy.isScanning())
          throw 'Cannot clear while scan is ongoing, close it first.'
        var t = document.getElementById(this.elementId)
        t && (t.innerHTML = '')
      }),
      (e.prototype.possiblyUpdateShaders = function (t) {
        this.qrMatch !== t &&
          (this.hasBorderShaders &&
            this.borderShaders &&
            this.borderShaders.length &&
            this.borderShaders.forEach(function (n) {
              n.style.backgroundColor = t
                ? _n.BORDER_SHADER_MATCH_COLOR
                : _n.BORDER_SHADER_DEFAULT_COLOR
            }),
          (this.qrMatch = t))
      }),
      (e.prototype.possiblyCloseLastScanImageFile = function () {
        this.lastScanImageFile &&
          (URL.revokeObjectURL(this.lastScanImageFile), (this.lastScanImageFile = null))
      }),
      (e.prototype.createCanvasElement = function (t, n, r) {
        var i = t,
          o = n,
          c = document.createElement('canvas')
        return (
          (c.style.width = ''.concat(i, 'px')),
          (c.style.height = ''.concat(o, 'px')),
          (c.style.display = 'none'),
          (c.id = Dr(r) ? 'qr-canvas' : r),
          c
        )
      }),
      (e.prototype.getShadedRegionBounds = function (t, n, r) {
        if (r.width > t || r.height > n)
          throw "'config.qrbox' dimensions should not be greater than the dimensions of the root HTML element."
        return { x: (t - r.width) / 2, y: (n - r.height) / 2, width: r.width, height: r.height }
      }),
      (e.prototype.possiblyInsertShadingElement = function (t, n, r, i) {
        if (!(n - i.width < 1 || r - i.height < 1)) {
          var o = document.createElement('div')
          o.style.position = 'absolute'
          var c = (n - i.width) / 2,
            h = (r - i.height) / 2
          if (
            ((o.style.borderLeft = ''.concat(c, 'px solid rgba(0, 0, 0, 0.48)')),
            (o.style.borderRight = ''.concat(c, 'px solid rgba(0, 0, 0, 0.48)')),
            (o.style.borderTop = ''.concat(h, 'px solid rgba(0, 0, 0, 0.48)')),
            (o.style.borderBottom = ''.concat(h, 'px solid rgba(0, 0, 0, 0.48)')),
            (o.style.boxSizing = 'border-box'),
            (o.style.top = '0px'),
            (o.style.bottom = '0px'),
            (o.style.left = '0px'),
            (o.style.right = '0px'),
            (o.id = ''.concat(_n.SHADED_REGION_ELEMENT_ID)),
            n - i.width < 11 || r - i.height < 11)
          )
            this.hasBorderShaders = !1
          else {
            var f = 5,
              p = 40
            ;(this.insertShaderBorders(o, p, f, -f, null, 0, !0),
              this.insertShaderBorders(o, p, f, -f, null, 0, !1),
              this.insertShaderBorders(o, p, f, null, -f, 0, !0),
              this.insertShaderBorders(o, p, f, null, -f, 0, !1),
              this.insertShaderBorders(o, f, p + f, -f, null, -f, !0),
              this.insertShaderBorders(o, f, p + f, null, -f, -f, !0),
              this.insertShaderBorders(o, f, p + f, -f, null, -f, !1),
              this.insertShaderBorders(o, f, p + f, null, -f, -f, !1),
              (this.hasBorderShaders = !0))
          }
          t.append(o)
        }
      }),
      (e.prototype.insertShaderBorders = function (t, n, r, i, o, c, h) {
        var f = document.createElement('div')
        ;((f.style.position = 'absolute'),
          (f.style.backgroundColor = _n.BORDER_SHADER_DEFAULT_COLOR),
          (f.style.width = ''.concat(n, 'px')),
          (f.style.height = ''.concat(r, 'px')),
          i !== null && (f.style.top = ''.concat(i, 'px')),
          o !== null && (f.style.bottom = ''.concat(o, 'px')),
          h ? (f.style.left = ''.concat(c, 'px')) : (f.style.right = ''.concat(c, 'px')),
          this.borderShaders || (this.borderShaders = []),
          this.borderShaders.push(f),
          t.appendChild(f))
      }),
      (e.prototype.showPausedState = function () {
        if (!this.scannerPausedUiElement)
          throw '[internal error] scanner paused UI element not found'
        this.scannerPausedUiElement.style.display = 'block'
      }),
      (e.prototype.hidePausedState = function () {
        if (!this.scannerPausedUiElement)
          throw '[internal error] scanner paused UI element not found'
        this.scannerPausedUiElement.style.display = 'none'
      }),
      (e.prototype.getTimeoutFps = function (t) {
        return 1e3 / t
      }),
      e
    )
  })(),
  Gy
;(function (e) {
  ;((e[(e.STATUS_DEFAULT = 0)] = 'STATUS_DEFAULT'),
    (e[(e.STATUS_SUCCESS = 1)] = 'STATUS_SUCCESS'),
    (e[(e.STATUS_WARNING = 2)] = 'STATUS_WARNING'),
    (e[(e.STATUS_REQUESTING_PERMISSION = 3)] = 'STATUS_REQUESTING_PERMISSION'))
})(Gy || (Gy = {}))
const JT = ({ onScan: e }) => {
  const t = X.useRef(null),
    [n, r] = X.useState(!1),
    [i, o] = X.useState(null),
    c = 'vibe-prism-scanner'
  return (
    X.useEffect(() => {
      if (!n) return
      const h = new $T(c)
      return (
        (t.current = h),
        h
          .start(
            { facingMode: 'environment' },
            { fps: 10, qrbox: { width: 220, height: 220 } },
            (f) => {
              ;(e(f), h.stop().catch(() => {}), r(!1))
            },
            (f) => {
              ;(typeof f == 'string' && f.includes('NotFound')) ||
                o('Camera scan is active. Align the QR token.')
            }
          )
          .catch((f) => {
            ;(o(String(f)), r(!1))
          }),
        () => {
          h.stop()
            .then(() => h.clear())
            .catch(() => {})
        }
      )
    }, [n, e]),
    N.jsxs('div', {
      className: 'glass-panel p-6',
      children: [
        N.jsxs('div', {
          className: 'flex items-center gap-3',
          children: [
            N.jsx(Vl, { size: 24, className: 'text-emerald-300' }),
            N.jsxs('div', {
              children: [
                N.jsx('h3', { className: 'text-lg font-semibold', children: 'Scan Token' }),
                N.jsx('p', {
                  className: 'text-sm text-slate-400',
                  children: 'Use your camera to restore a Nexus Who payload.',
                }),
              ],
            }),
          ],
        }),
        N.jsx('div', {
          className: 'mt-4',
          children: N.jsx('button', {
            type: 'button',
            onClick: () => r((h) => !h),
            className: 'button-secondary',
            children: n ? 'Stop Scanner' : 'Start Scanner',
          }),
        }),
        n && N.jsx('div', { id: c, className: 'mt-4 overflow-hidden rounded-xl' }),
        i && N.jsx('p', { className: 'mt-3 text-xs text-rose-300', children: i }),
      ],
    })
  )
}
Wl.register(xo, Ja, Ur, X3, Z3, ru, yf, bf, IN)
const Yy = {
    GREEN: 'bg-emerald-500/10 text-emerald-200 border-emerald-400/30',
    YELLOW: 'bg-amber-500/10 text-amber-200 border-amber-400/30',
    RED: 'bg-rose-500/10 text-rose-200 border-rose-400/30',
  },
  eR = {
    masking: 'Rapid defensive responses detected under 450ms.',
    contradictions: 'Lie-trap items returned high agreement.',
    halo: 'Response pattern suggests overly idealized self-presentation.',
  },
  tR = () => {
    const [e, t] = X.useState(sessionStorage.getItem('VP_DECODE_UNLOCK') === '1'),
      [n, r] = X.useState(t3() ?? ''),
      [i, o] = X.useState(null),
      [c, h] = X.useState(null),
      f = X.useCallback(async (E) => {
        try {
          const S = e3(E.trim()).split('|'),
            k = S.pop(),
            P = S.join('|')
          if (!k) throw new Error('Checksum missing')
          if ((await tp(P)).slice(0, 8) !== k) throw new Error('Checksum mismatch')
          if (S[0] !== 'VP1') throw new Error('Unsupported payload')
          const I = S[14],
            R = JSON.parse(I),
            M = S[12]
              .split(';')
              .map((F) => F.split(':'))
              .filter((F) => F[1] === 'true')
              .map((F) => F[0]),
            O = S[13] === 'none' ? [] : S[13].split('~')
          ;(o({
            band: S[3],
            dtiBase: Number(S[4]),
            dtiFinal: Number(S[5]),
            scores: { N: Number(S[6]), M: Number(S[7]), P: Number(S[8]), MD: Number(S[9]) },
            integrity: Number(S[10]),
            archetype: S[11],
            maskFlags: M,
            overrideFlags: O,
            answers: R,
          }),
            h(null))
        } catch (S) {
          ;(h(String(S)), o(null))
        }
      }, []),
      p = () => {
        if (!n.trim()) {
          h('Paste a token or scan a QR code.')
          return
        }
        f(n.trim())
      },
      y = X.useMemo(() => (i ? new Map(i.answers.map((E) => [E.questionId, E])) : new Map()), [i]),
      w = X.useMemo(() => {
        if (!i) return null
        const E = {
            labels: ['N', 'M', 'P', 'MD'],
            datasets: [
              {
                label: 'Trait Strength',
                data: [i.scores.N, i.scores.M, i.scores.P, i.scores.MD],
                backgroundColor: 'rgba(56, 189, 248, 0.15)',
                borderColor: 'rgba(56, 189, 248, 0.6)',
                borderWidth: 2,
                pointBackgroundColor: 'rgba(56, 189, 248, 0.9)',
              },
            ],
          },
          S = {
            labels: ['N', 'M', 'P', 'MD'],
            datasets: [
              {
                label: 'Intensity',
                data: [i.scores.N, i.scores.M, i.scores.P, i.scores.MD],
                backgroundColor: [
                  'rgba(16, 185, 129, 0.4)',
                  'rgba(59, 130, 246, 0.4)',
                  'rgba(239, 68, 68, 0.4)',
                  'rgba(251, 191, 36, 0.4)',
                ],
                borderRadius: 8,
              },
            ],
          },
          k = i.answers.map((I) => I.rtMs),
          P = {
            labels: i.answers.map((I) => `Q${I.questionId}`),
            datasets: [
              {
                label: 'Response Time (ms)',
                data: k,
                borderColor: 'rgba(148, 163, 184, 0.8)',
                backgroundColor: 'rgba(148, 163, 184, 0.2)',
                pointBackgroundColor: k.map((I) =>
                  I < 450 ? 'rgba(248, 113, 113, 0.9)' : 'rgba(148, 163, 184, 0.9)'
                ),
                tension: 0.3,
              },
            ],
          }
        return { radarData: E, barData: S, lineData: P }
      }, [i]),
      x = () => {
        if (!i) return
        const E = window.open('', '_blank')
        E &&
          (E.document.write(`
      <html>
        <head>
          <title>Nexus Who Report</title>
          <style>
            body { font-family: Inter, sans-serif; padding: 32px; background: #0f172a; color: #e2e8f0; }
            h1, h2 { color: #f8fafc; }
            .badge { display: inline-block; padding: 6px 12px; border-radius: 999px; background: #1e293b; margin-right: 8px; }
            .section { margin-bottom: 24px; }
          </style>
        </head>
        <body>
          <h1>Nexus Who Forensic Report</h1>
          <div class="section">
            <h2>Summary</h2>
            <p><span class="badge">Band: ${i.band}</span><span class="badge">Archetype: ${i.archetype}</span></p>
            <p>DTI Base: ${i.dtiBase} | DTI Final: ${i.dtiFinal}</p>
            <p>Integrity: ${i.integrity}</p>
          </div>
          <div class="section">
            <h2>Overrides</h2>
            <p>${i.overrideFlags.join('; ') || 'None'}</p>
          </div>
          <div class="section">
            <h2>Masking & Integrity Flags</h2>
            <p>${i.maskFlags.join(', ') || 'None'}</p>
          </div>
        </body>
      </html>
    `),
          E.document.close(),
          E.focus(),
          E.print())
      }
    return e
      ? N.jsxs('div', {
          className: 'mx-auto flex w-full max-w-6xl flex-col gap-8 px-6 py-16',
          children: [
            N.jsxs('div', {
              className: 'flex flex-wrap items-center justify-between gap-4',
              children: [
                N.jsxs('div', {
                  children: [
                    N.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.4em] text-slate-400',
                      children: 'Nexus Who  forensic decoder',
                    }),
                    N.jsx('h1', {
                      className: 'mt-3 text-3xl font-semibold',
                      children: 'Restore & Decode',
                    }),
                    N.jsx('p', {
                      className: 'mt-2 text-sm text-slate-400',
                      children:
                        'Paste a token or scan your QR to rebuild the full report in seconds.',
                    }),
                  ],
                }),
                N.jsxs('button', {
                  type: 'button',
                  onClick: x,
                  className: 'button-secondary',
                  children: [N.jsx(K6, { size: 18 }), 'Download Report'],
                }),
              ],
            }),
            N.jsxs('section', {
              className: 'grid gap-6 lg:grid-cols-[1.1fr_0.9fr]',
              children: [
                N.jsxs('div', {
                  className: 'glass-panel p-6',
                  children: [
                    N.jsxs('div', {
                      className: 'flex items-center gap-3',
                      children: [
                        N.jsx(xs, { size: 22, className: 'text-emerald-300' }),
                        N.jsxs('div', {
                          children: [
                            N.jsx('h3', {
                              className: 'text-lg font-semibold',
                              children: 'Decoder Status',
                            }),
                            N.jsx('p', {
                              className: 'text-sm text-slate-400',
                              children:
                                'Your session is authenticated for secure profile restoration.',
                            }),
                          ],
                        }),
                      ],
                    }),
                    N.jsxs('div', {
                      className: 'mt-4 grid gap-3 text-sm text-slate-300',
                      children: [
                        N.jsxs('div', {
                          className:
                            'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                          children: [
                            N.jsx('span', { children: 'Session' }),
                            N.jsx('span', { className: 'text-emerald-200', children: 'Unlocked' }),
                          ],
                        }),
                        N.jsxs('div', {
                          className:
                            'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                          children: [
                            N.jsx('span', { children: 'Storage' }),
                            N.jsx('span', { className: 'text-slate-300', children: 'Local only' }),
                          ],
                        }),
                        N.jsxs('div', {
                          className:
                            'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                          children: [
                            N.jsx('span', { children: 'Report' }),
                            N.jsx('span', {
                              className: 'text-slate-300',
                              children: 'Full forensic',
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
                N.jsxs('div', {
                  className: 'glass-panel p-6',
                  children: [
                    N.jsx('h3', {
                      className: 'text-lg font-semibold',
                      children: 'Decode checklist',
                    }),
                    N.jsx('ul', {
                      className: 'mt-4 space-y-2 text-sm text-slate-300',
                      children: [
                        'Use the most recent token for accurate scores.',
                        'Scan in a well-lit space for best QR results.',
                        'Export a PDF if you need to share the report.',
                      ].map((E) => N.jsx('li', { className: 'list-item', children: E }, E)),
                    }),
                  ],
                }),
              ],
            }),
            N.jsxs('div', {
              className: 'grid gap-6 lg:grid-cols-[1.1fr_0.9fr]',
              children: [
                N.jsxs('div', {
                  className: 'glass-panel p-6',
                  children: [
                    N.jsxs('div', {
                      className: 'flex items-center gap-3',
                      children: [
                        N.jsx(xs, { size: 22, className: 'text-emerald-300' }),
                        N.jsxs('div', {
                          children: [
                            N.jsx('h3', {
                              className: 'text-lg font-semibold',
                              children: 'Paste Token',
                            }),
                            N.jsx('p', {
                              className: 'text-sm text-slate-400',
                              children:
                                'Paste the Base64 URL-safe token to decode the full report.',
                            }),
                          ],
                        }),
                      ],
                    }),
                    N.jsx('textarea', {
                      value: n,
                      onChange: (E) => r(E.target.value),
                      className:
                        'mt-4 h-28 w-full rounded-xl border border-white/10 bg-slate-900/60 p-3 text-xs text-slate-200',
                    }),
                    c && N.jsx('p', { className: 'mt-2 text-xs text-rose-300', children: c }),
                    N.jsx('button', {
                      type: 'button',
                      onClick: p,
                      className: 'button-primary mt-4',
                      children: 'Decode Token',
                    }),
                  ],
                }),
                N.jsx(JT, {
                  onScan: (E) => {
                    ;(r(E), f(E))
                  },
                }),
              ],
            }),
            i &&
              w &&
              N.jsxs(qn.div, {
                initial: { opacity: 0 },
                animate: { opacity: 1 },
                transition: { duration: 0.4 },
                className: 'flex flex-col gap-8',
                children: [
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex flex-wrap items-center justify-between gap-4',
                        children: [
                          N.jsxs('div', {
                            children: [
                              N.jsx('p', {
                                className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                                children: 'Summary',
                              }),
                              N.jsx('h2', {
                                className: 'text-2xl font-semibold',
                                children: 'Forensic Snapshot',
                              }),
                            ],
                          }),
                          N.jsx('span', {
                            className: `badge border ${Yy[i.band] ?? Yy.GREEN}`,
                            children: i.band,
                          }),
                        ],
                      }),
                      N.jsxs('div', {
                        className: 'mt-4 grid gap-4 md:grid-cols-2',
                        children: [
                          N.jsxs('div', {
                            className: 'rounded-xl border border-white/10 bg-slate-900/60 p-4',
                            children: [
                              N.jsx('p', {
                                className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                                children: 'DTI',
                              }),
                              N.jsxs('p', {
                                className: 'mt-2 text-lg font-semibold',
                                children: ['Base ', i.dtiBase, '  Final ', i.dtiFinal],
                              }),
                            ],
                          }),
                          N.jsxs('div', {
                            className: 'rounded-xl border border-white/10 bg-slate-900/60 p-4',
                            children: [
                              N.jsx('p', {
                                className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                                children: 'Archetype',
                              }),
                              N.jsx('p', {
                                className: 'mt-2 text-lg font-semibold',
                                children: i.archetype,
                              }),
                            ],
                          }),
                          N.jsxs('div', {
                            className: 'rounded-xl border border-white/10 bg-slate-900/60 p-4',
                            children: [
                              N.jsxs('div', {
                                className: 'flex items-center gap-2 text-sm text-slate-400',
                                children: [N.jsx($0, { size: 18 }), 'Integrity Score'],
                              }),
                              N.jsx('p', {
                                className: 'mt-2 text-lg font-semibold',
                                children: i.integrity,
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex items-center gap-3',
                        children: [
                          N.jsx(Qc, { size: 22, className: 'text-rose-300' }),
                          N.jsxs('div', {
                            children: [
                              N.jsx('h2', {
                                className: 'text-xl font-semibold',
                                children: 'Overrides & Safety Triggers',
                              }),
                              N.jsx('p', {
                                className: 'text-sm text-slate-400',
                                children: 'Immediate escalations based on safety thresholds.',
                              }),
                            ],
                          }),
                        ],
                      }),
                      N.jsxs('div', {
                        className: 'mt-4 space-y-2',
                        children: [
                          i.overrideFlags.length === 0 &&
                            N.jsx('p', {
                              className: 'text-sm text-slate-400',
                              children: 'No overrides triggered.',
                            }),
                          i.overrideFlags.map((E) =>
                            N.jsxs(
                              qn.div,
                              {
                                initial: { opacity: 0 },
                                animate: { opacity: [0.7, 1, 0.7] },
                                transition: { duration: 2.4, repeat: 1 / 0, ease: 'easeInOut' },
                                className:
                                  'flex items-center gap-3 rounded-xl border border-rose-500/30 bg-rose-500/10 p-3',
                                children: [
                                  N.jsx(Qc, { size: 18, className: 'text-rose-300' }),
                                  N.jsx('span', {
                                    className: 'text-sm text-rose-100',
                                    children: E,
                                  }),
                                ],
                              },
                              E
                            )
                          ),
                        ],
                      }),
                      N.jsx('p', {
                        className: 'mt-3 text-xs text-slate-400',
                        children:
                          'Overrides trigger when Q11, Q15, or Q18 score  2, or when trait levels cross the P > 75 and MD > 60 threshold.',
                      }),
                      i.overrideFlags.length > 0 &&
                        N.jsx('p', {
                          className: 'mt-3 text-xs text-rose-200',
                          children: 'Band escalated to RED due to active overrides.',
                        }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex items-center gap-3',
                        children: [
                          N.jsx(bh, { size: 22, className: 'text-emerald-300' }),
                          N.jsxs('div', {
                            children: [
                              N.jsx('h2', {
                                className: 'text-xl font-semibold',
                                children: 'Trait Analysis',
                              }),
                              N.jsx('p', {
                                className: 'text-sm text-slate-400',
                                children: 'Weighted trait intensities.',
                              }),
                            ],
                          }),
                        ],
                      }),
                      N.jsxs('div', {
                        className: 'mt-6 grid gap-6 lg:grid-cols-2',
                        children: [
                          N.jsx('div', {
                            className: 'h-64',
                            children: N.jsx(eb, {
                              data: w.radarData,
                              options: {
                                scales: {
                                  r: {
                                    ticks: { display: !1 },
                                    grid: { color: 'rgba(148, 163, 184, 0.2)' },
                                    pointLabels: { color: 'rgba(226, 232, 240, 0.8)' },
                                    suggestedMin: 0,
                                    suggestedMax: 100,
                                  },
                                },
                                plugins: { legend: { display: !1 } },
                                animation: { duration: 900 },
                              },
                            }),
                          }),
                          N.jsx('div', {
                            className: 'h-64',
                            children: N.jsx(aT, {
                              data: w.barData,
                              options: {
                                scales: {
                                  y: {
                                    grid: { color: 'rgba(148, 163, 184, 0.2)' },
                                    ticks: { color: 'rgba(226, 232, 240, 0.7)' },
                                    suggestedMin: 0,
                                    suggestedMax: 100,
                                  },
                                  x: { ticks: { color: 'rgba(226, 232, 240, 0.7)' } },
                                },
                                plugins: { legend: { display: !1 } },
                                animation: { duration: 900 },
                              },
                            }),
                          }),
                        ],
                      }),
                      N.jsx('div', {
                        className: 'mt-6 grid gap-4 md:grid-cols-2',
                        children: [
                          {
                            key: 'N',
                            label: 'Narcissism (N)',
                            copy: 'Elevated focus on visibility, status control, and perceived centrality in group dynamics.',
                          },
                          {
                            key: 'M',
                            label: 'Machiavellianism (M)',
                            copy: 'Strategic, long-horizon planning with emphasis on leverage, timing, and advantage.',
                          },
                          {
                            key: 'P',
                            label: 'Psychopathy (P)',
                            copy: 'Emotional detachment, intensity, and willingness to prioritize outcomes over social cost.',
                          },
                          {
                            key: 'MD',
                            label: 'Manipulation Doctrine (MD)',
                            copy: 'Preferred influence tactics, persuasion confidence, and group-shaping behaviors.',
                          },
                        ].map((E) =>
                          N.jsxs(
                            'div',
                            {
                              className: 'rounded-xl border border-white/10 bg-slate-900/60 p-4',
                              children: [
                                N.jsx('p', {
                                  className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                                  children: E.label,
                                }),
                                N.jsx('p', {
                                  className: 'mt-2 text-sm text-slate-300',
                                  children: E.copy,
                                }),
                              ],
                            },
                            E.key
                          )
                        ),
                      }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex items-center gap-3',
                        children: [
                          i.maskFlags.length > 0
                            ? N.jsx(of, { size: 22, className: 'text-amber-300' })
                            : N.jsx(q6, { size: 22, className: 'text-emerald-300' }),
                          N.jsxs('div', {
                            children: [
                              N.jsx('h2', {
                                className: 'text-xl font-semibold',
                                children: 'Integrity & Masking',
                              }),
                              N.jsx('p', {
                                className: 'text-sm text-slate-400',
                                children:
                                  'Flags highlight defensive responding, contradictions, and halo effects.',
                              }),
                            ],
                          }),
                        ],
                      }),
                      N.jsxs('div', {
                        className: 'mt-4 space-y-2',
                        children: [
                          i.maskFlags.length === 0 &&
                            N.jsx('p', {
                              className: 'text-sm text-slate-400',
                              children: 'No integrity flags detected.',
                            }),
                          i.maskFlags.map((E) =>
                            N.jsxs(
                              'div',
                              {
                                className:
                                  'rounded-xl border border-amber-400/30 bg-amber-500/10 p-3 text-sm text-amber-100',
                                children: [
                                  N.jsx('p', {
                                    className: 'text-sm font-semibold uppercase tracking-[0.2em]',
                                    children: E,
                                  }),
                                  N.jsx('p', {
                                    className: 'mt-1 text-xs text-amber-200',
                                    children: eR[E] ?? 'Integrity signal observed.',
                                  }),
                                ],
                              },
                              E
                            )
                          ),
                        ],
                      }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex items-center gap-3',
                        children: [
                          N.jsx(Vl, { size: 20, className: 'text-slate-300' }),
                          N.jsxs('div', {
                            children: [
                              N.jsx('h2', {
                                className: 'text-xl font-semibold',
                                children: 'Response Time Analysis',
                              }),
                              N.jsx('p', {
                                className: 'text-sm text-slate-400',
                                children: 'Highlights rapid responses under 450ms.',
                              }),
                            ],
                          }),
                        ],
                      }),
                      N.jsx('div', {
                        className: 'mt-6 h-64',
                        children: N.jsx(oT, {
                          data: w.lineData,
                          options: {
                            scales: {
                              y: {
                                ticks: { color: 'rgba(226, 232, 240, 0.7)' },
                                grid: { color: 'rgba(148, 163, 184, 0.2)' },
                              },
                              x: { ticks: { color: 'rgba(226, 232, 240, 0.7)' } },
                            },
                            plugins: { legend: { display: !1 } },
                            animation: { duration: 900 },
                          },
                        }),
                      }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsx('h2', {
                        className: 'text-xl font-semibold',
                        children: 'Full Answer Breakdown',
                      }),
                      N.jsx('p', {
                        className: 'text-sm text-slate-400',
                        children: 'Detailed view of each response, timing, and trait impact.',
                      }),
                      N.jsx('div', {
                        className: 'mt-6 space-y-4',
                        children: af.map((E) => {
                          const S = y.get(E.id)
                          if (!S) return null
                          const k = E.reverse ? 3 - S.answer : S.answer,
                            P = `${E.trait} +${k}`,
                            I = S.rtMs < 450
                          return N.jsxs(
                            'div',
                            {
                              className: 'rounded-2xl border border-white/10 bg-slate-900/60 p-4',
                              children: [
                                N.jsxs('div', {
                                  className: 'flex flex-wrap items-start justify-between gap-3',
                                  children: [
                                    N.jsxs('div', {
                                      children: [
                                        N.jsxs('p', {
                                          className:
                                            'text-xs uppercase tracking-[0.3em] text-slate-400',
                                          children: ['Q', E.id],
                                        }),
                                        N.jsx('h3', {
                                          className: 'mt-1 text-lg font-semibold text-slate-50',
                                          children: E.text,
                                        }),
                                      ],
                                    }),
                                    N.jsxs('div', {
                                      className: 'flex gap-2',
                                      children: [
                                        E.lieTrap &&
                                          N.jsxs('span', {
                                            className:
                                              'badge gap-2 border border-amber-400/40 bg-amber-500/10 text-amber-200',
                                            children: [N.jsx(of, { size: 12 }), 'Lie Trap'],
                                          }),
                                        E.safetyTrigger &&
                                          N.jsxs('span', {
                                            className:
                                              'badge gap-2 border border-rose-400/40 bg-rose-500/10 text-rose-200',
                                            children: [N.jsx(Qc, { size: 12 }), 'Safety Trigger'],
                                          }),
                                      ],
                                    }),
                                  ],
                                }),
                                N.jsxs('div', {
                                  className: 'mt-3 flex flex-wrap gap-3 text-xs text-slate-400',
                                  children: [
                                    N.jsxs('span', { children: ['Answer: ', S.answer] }),
                                    N.jsxs('span', { children: ['RT: ', S.rtMs, 'ms'] }),
                                    N.jsxs('span', { children: ['Impact: ', P] }),
                                    I &&
                                      N.jsx('span', {
                                        className: 'text-rose-300',
                                        children: 'Fast response',
                                      }),
                                  ],
                                }),
                                N.jsxs('p', {
                                  className: 'mt-3 text-sm text-slate-300',
                                  children: [
                                    'This response suggests a ',
                                    E.trait,
                                    '-aligned behavior with a measured intensity of ',
                                    k,
                                    ' on the internal scale. The pacing indicates',
                                    ' ',
                                    I ? 'defensive' : 'deliberate',
                                    ' engagement.',
                                  ],
                                }),
                              ],
                            },
                            E.id
                          )
                        }),
                      }),
                    ],
                  }),
                ],
              }),
          ],
        })
      : N.jsxs('div', {
          className: 'mx-auto w-full max-w-3xl px-6 py-16',
          children: [
            N.jsx(_T, { onUnlock: () => t(!0) }),
            N.jsx('p', {
              className: 'mt-4 text-xs text-slate-500',
              children:
                'Decoder access is restricted. Unlocking stores a session flag in the browser only.',
            }),
          ],
        })
  },
  nR = () =>
    N.jsx('footer', {
      className: 'mt-16 border-t border-white/5 bg-slate-950/70',
      children: N.jsxs('div', {
        className: 'mx-auto flex w-full max-w-6xl flex-col gap-10 px-6 py-12',
        children: [
          N.jsxs('div', {
            className: 'grid gap-8 lg:grid-cols-[1.2fr_0.9fr_0.9fr]',
            children: [
              N.jsxs('div', {
                className: 'space-y-4',
                children: [
                  N.jsxs('div', {
                    className: 'flex items-center gap-3',
                    children: [
                      N.jsx('span', {
                        className:
                          'flex h-10 w-10 items-center justify-center rounded-2xl border border-emerald-400/30 bg-emerald-500/10 text-emerald-200',
                        children: N.jsx(Qo, { size: 18 }),
                      }),
                      N.jsxs('div', {
                        children: [
                          N.jsx('p', {
                            className: 'text-xs uppercase tracking-[0.3em] text-emerald-200',
                            children: 'Vibe Prism',
                          }),
                          N.jsx('p', {
                            className: 'text-sm font-semibold text-slate-50',
                            children: 'Nexus Who Intelligence Lab',
                          }),
                        ],
                      }),
                    ],
                  }),
                  N.jsx('p', {
                    className: 'text-sm text-slate-400',
                    children:
                      'Built for insight-forward teams and creators who want to understand the energy they bring into every room. Private by design, calm by default.',
                  }),
                ],
              }),
              N.jsxs('div', {
                className: 'space-y-3',
                children: [
                  N.jsx('p', {
                    className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                    children: 'Core Pillars',
                  }),
                  N.jsxs('ul', {
                    className: 'space-y-2 text-sm text-slate-300',
                    children: [
                      N.jsxs('li', {
                        className: 'flex items-center gap-2',
                        children: [
                          N.jsx(ep, { size: 16, className: 'text-emerald-300' }),
                          'Momentum-aware personality mapping',
                        ],
                      }),
                      N.jsxs('li', {
                        className: 'flex items-center gap-2',
                        children: [
                          N.jsx(J0, { size: 16, className: 'text-emerald-300' }),
                          'Precision archetypes with clear next steps',
                        ],
                      }),
                      N.jsxs('li', {
                        className: 'flex items-center gap-2',
                        children: [
                          N.jsx(Q6, { size: 16, className: 'text-emerald-300' }),
                          'Integrity signals baked into every score',
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              N.jsxs('div', {
                className: 'glass-panel p-5',
                children: [
                  N.jsx('p', {
                    className: 'text-sm font-semibold text-slate-100',
                    children: 'Ready to capture your profile?',
                  }),
                  N.jsx('p', {
                    className: 'mt-2 text-xs text-slate-400',
                    children: 'Launch the quiz, lock in your token, and decode whenever you want.',
                  }),
                  N.jsxs('div', {
                    className: 'mt-4 flex flex-wrap gap-3',
                    children: [
                      N.jsx(er, {
                        to: '/quiz',
                        className: 'button-primary',
                        children: 'Start the quiz',
                      }),
                      N.jsx(er, {
                        to: '/restore',
                        className: 'button-secondary',
                        children: 'Decode token',
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
          N.jsxs('div', {
            className: 'flex flex-wrap items-center justify-between gap-3 text-xs text-slate-500',
            children: [
              N.jsx('span', {
                children: ' 2026 Vibe Prism  Nexus Who Minisite. All rights reserved.',
              }),
              N.jsx('span', {
                children: 'Encrypted locally. Nothing leaves your device without permission.',
              }),
            ],
          }),
        ],
      }),
    }),
  rR = [
    { label: 'Overview', to: '/' },
    { label: 'Quiz', to: '/quiz' },
    { label: 'Results', to: '/result' },
    { label: 'Restore', to: '/restore' },
  ],
  iR = () =>
    N.jsx('header', {
      className: 'sticky top-0 z-40 border-b border-white/5 bg-slate-950/70 backdrop-blur',
      children: N.jsxs('div', {
        className: 'mx-auto flex w-full max-w-6xl items-center justify-between px-6 py-4',
        children: [
          N.jsxs(er, {
            to: '/',
            className: 'flex items-center gap-3',
            children: [
              N.jsx('span', {
                className:
                  'flex h-10 w-10 items-center justify-center rounded-2xl border border-emerald-400/30 bg-emerald-500/10 text-emerald-200',
                children: N.jsx(Qo, { size: 18 }),
              }),
              N.jsxs('div', {
                children: [
                  N.jsx('p', {
                    className: 'text-xs uppercase tracking-[0.3em] text-emerald-200',
                    children: 'Vibe Prism',
                  }),
                  N.jsx('p', {
                    className: 'text-sm font-semibold text-slate-50',
                    children: 'Nexus Who Minisite',
                  }),
                ],
              }),
            ],
          }),
          N.jsx('nav', {
            className: 'hidden items-center gap-6 text-sm text-slate-300 md:flex',
            children: rR.map((e) =>
              N.jsx(
                gC,
                {
                  to: e.to,
                  className: ({ isActive: t }) => `nav-link ${t ? 'nav-link-active' : ''}`,
                  children: e.label,
                },
                e.to
              )
            ),
          }),
          N.jsx('div', {
            className: 'flex items-center gap-3',
            children: N.jsx(er, {
              to: '/quiz',
              className: 'button-primary hidden sm:inline-flex',
              children: 'Start the quiz',
            }),
          }),
        ],
      }),
    }),
  sR = {
    initial: { opacity: 0, y: 16 },
    animate: { opacity: 1, y: 0, transition: { duration: 0.4 } },
    exit: { opacity: 0, y: -12, transition: { duration: 0.2 } },
  },
  oR = () =>
    N.jsxs('div', {
      className:
        'flex min-h-screen flex-col bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 text-slate-100',
      children: [
        N.jsx(iR, {}),
        N.jsx(qn.main, {
          variants: sR,
          initial: 'initial',
          animate: 'animate',
          exit: 'exit',
          className: 'flex-1',
          children: N.jsxs(iC, {
            children: [
              N.jsx(no, { path: '/', element: N.jsx(sk, {}) }),
              N.jsx(no, { path: '/quiz', element: N.jsx(yk, {}) }),
              N.jsx(no, { path: '/result', element: N.jsx(CT, {}) }),
              N.jsx(no, { path: '/restore', element: N.jsx(tR, {}) }),
              N.jsx(no, { path: '*', element: N.jsx(nC, { to: '/', replace: !0 }) }),
            ],
          }),
        }),
        N.jsx(nR, {}),
      ],
    }),
  ab = document.getElementById('root')
if (!ab) throw new Error('Root container missing')
cw(ab).render(N.jsx(A.StrictMode, { children: N.jsx(dC, { children: N.jsx(oR, {}) }) }))
