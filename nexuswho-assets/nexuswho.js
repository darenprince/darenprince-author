;(function () {
  const e = document.createElement('link').relList
  if (e && e.supports && e.supports('modulepreload')) return
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i)
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === 'childList')
        for (const c of s.addedNodes) c.tagName === 'LINK' && c.rel === 'modulepreload' && r(c)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(i) {
    const s = {}
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : i.crossOrigin === 'anonymous'
          ? (s.credentials = 'omit')
          : (s.credentials = 'same-origin'),
      s
    )
  }
  function r(i) {
    if (i.ep) return
    i.ep = !0
    const s = n(i)
    fetch(i.href, s)
  }
})()
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r)
  new MutationObserver((r) => {
    for (const i of r)
      if (i.type === 'childList')
        for (const s of i.addedNodes) s.tagName === 'LINK' && s.rel === 'modulepreload' && n(s)
  }).observe(document, { childList: !0, subtree: !0 })
  function e(r) {
    const i = {}
    return (
      r.integrity && (i.integrity = r.integrity),
      r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : r.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    )
  }
  function n(r) {
    if (r.ep) return
    r.ep = !0
    const i = e(r)
    fetch(r.href, i)
  }
})()
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r)
  new MutationObserver((r) => {
    for (const i of r)
      if (i.type === 'childList')
        for (const s of i.addedNodes) s.tagName === 'LINK' && s.rel === 'modulepreload' && n(s)
  }).observe(document, { childList: !0, subtree: !0 })
  function e(r) {
    const i = {}
    return (
      r.integrity && (i.integrity = r.integrity),
      r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : r.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    )
  }
  function n(r) {
    if (r.ep) return
    r.ep = !0
    const i = e(r)
    fetch(r.href, i)
  }
})()
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r)
  new MutationObserver((r) => {
    for (const i of r)
      if (i.type === 'childList')
        for (const s of i.addedNodes) s.tagName === 'LINK' && s.rel === 'modulepreload' && n(s)
  }).observe(document, { childList: !0, subtree: !0 })
  function e(r) {
    const i = {}
    return (
      r.integrity && (i.integrity = r.integrity),
      r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : r.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    )
  }
  function n(r) {
    if (r.ep) return
    r.ep = !0
    const i = e(r)
    fetch(r.href, i)
  }
})()
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r)
  new MutationObserver((r) => {
    for (const i of r)
      if (i.type === 'childList')
        for (const s of i.addedNodes) s.tagName === 'LINK' && s.rel === 'modulepreload' && n(s)
  }).observe(document, { childList: !0, subtree: !0 })
  function e(r) {
    const i = {}
    return (
      r.integrity && (i.integrity = r.integrity),
      r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : r.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    )
  }
  function n(r) {
    if (r.ep) return
    r.ep = !0
    const i = e(r)
    fetch(r.href, i)
  }
})()
var jb = Object.defineProperty,
  Vb = (t, e, n) =>
    e in t ? jb(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  yt = (t, e, n) => Vb(t, typeof e != 'symbol' ? e + '' : e, n)
function Zy(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n]
    if (typeof r != 'string' && !Array.isArray(r)) {
      for (const i in r)
        if (i !== 'default' && !(i in t)) {
          const s = Object.getOwnPropertyDescriptor(r, i)
          s && Object.defineProperty(t, i, s.get ? s : { enumerable: !0, get: () => r[i] })
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }))
}
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r)
  new MutationObserver((r) => {
    for (const i of r)
      if (i.type === 'childList')
        for (const s of i.addedNodes) s.tagName === 'LINK' && s.rel === 'modulepreload' && n(s)
  }).observe(document, { childList: !0, subtree: !0 })
  function e(r) {
    const i = {}
    return (
      r.integrity && (i.integrity = r.integrity),
      r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : r.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    )
  }
  function n(r) {
    if (r.ep) return
    r.ep = !0
    const i = e(r)
    fetch(r.href, i)
  }
})()
var ha =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
      ? window
      : typeof global < 'u'
        ? global
        : typeof self < 'u'
          ? self
          : {}
function qy(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t
}
var Ky = { exports: {} },
  Zu = {},
  Qy = { exports: {} },
  Rt = {}
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Nl = Symbol.for('react.element'),
  Wb = Symbol.for('react.portal'),
  Ub = Symbol.for('react.fragment'),
  zb = Symbol.for('react.strict_mode'),
  Hb = Symbol.for('react.profiler'),
  Xb = Symbol.for('react.provider'),
  Gb = Symbol.for('react.context'),
  Yb = Symbol.for('react.forward_ref'),
  Zb = Symbol.for('react.suspense'),
  qb = Symbol.for('react.memo'),
  Kb = Symbol.for('react.lazy'),
  Fp = Symbol.iterator
function Qb(t) {
  return t === null || typeof t != 'object'
    ? null
    : ((t = (Fp && t[Fp]) || t['@@iterator']), typeof t == 'function' ? t : null)
}
var $y = {
    isMounted: function () {
      return !1
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  Jy = Object.assign,
  t8 = {}
function Hs(t, e, n) {
  ;((this.props = t), (this.context = e), (this.refs = t8), (this.updater = n || $y))
}
Hs.prototype.isReactComponent = {}
Hs.prototype.setState = function (t, e) {
  if (typeof t != 'object' && typeof t != 'function' && t != null)
    throw Error(
      'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
    )
  this.updater.enqueueSetState(this, t, e, 'setState')
}
Hs.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, 'forceUpdate')
}
function e8() {}
e8.prototype = Hs.prototype
function Cf(t, e, n) {
  ;((this.props = t), (this.context = e), (this.refs = t8), (this.updater = n || $y))
}
var Sf = (Cf.prototype = new e8())
Sf.constructor = Cf
Jy(Sf, Hs.prototype)
Sf.isPureReactComponent = !0
var jp = Array.isArray,
  n8 = Object.prototype.hasOwnProperty,
  Af = { current: null },
  r8 = { key: !0, ref: !0, __self: !0, __source: !0 }
function i8(t, e, n) {
  var r,
    i = {},
    s = null,
    c = null
  if (e != null)
    for (r in (e.ref !== void 0 && (c = e.ref), e.key !== void 0 && (s = '' + e.key), e))
      n8.call(e, r) && !r8.hasOwnProperty(r) && (i[r] = e[r])
  var h = arguments.length - 2
  if (h === 1) i.children = n
  else if (1 < h) {
    for (var f = Array(h), p = 0; p < h; p++) f[p] = arguments[p + 2]
    i.children = f
  }
  if (t && t.defaultProps) for (r in ((h = t.defaultProps), h)) i[r] === void 0 && (i[r] = h[r])
  return { $$typeof: Nl, type: t, key: s, ref: c, props: i, _owner: Af.current }
}
function $b(t, e) {
  return { $$typeof: Nl, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner }
}
function kf(t) {
  return typeof t == 'object' && t !== null && t.$$typeof === Nl
}
function Jb(t) {
  var e = { '=': '=0', ':': '=2' }
  return (
    '$' +
    t.replace(/[=:]/g, function (n) {
      return e[n]
    })
  )
}
var Vp = /\/+/g
function Yh(t, e) {
  return typeof t == 'object' && t !== null && t.key != null ? Jb('' + t.key) : e.toString(36)
}
function Oc(t, e, n, r, i) {
  var s = typeof t
  ;(s === 'undefined' || s === 'boolean') && (t = null)
  var c = !1
  if (t === null) c = !0
  else
    switch (s) {
      case 'string':
      case 'number':
        c = !0
        break
      case 'object':
        switch (t.$$typeof) {
          case Nl:
          case Wb:
            c = !0
        }
    }
  if (c)
    return (
      (c = t),
      (i = i(c)),
      (t = r === '' ? '.' + Yh(c, 0) : r),
      jp(i)
        ? ((n = ''),
          t != null && (n = t.replace(Vp, '$&/') + '/'),
          Oc(i, e, n, '', function (p) {
            return p
          }))
        : i != null &&
          (kf(i) &&
            (i = $b(
              i,
              n +
                (!i.key || (c && c.key === i.key) ? '' : ('' + i.key).replace(Vp, '$&/') + '/') +
                t
            )),
          e.push(i)),
      1
    )
  if (((c = 0), (r = r === '' ? '.' : r + ':'), jp(t)))
    for (var h = 0; h < t.length; h++) {
      s = t[h]
      var f = r + Yh(s, h)
      c += Oc(s, e, n, f, i)
    }
  else if (((f = Qb(t)), typeof f == 'function'))
    for (t = f.call(t), h = 0; !(s = t.next()).done; )
      ((s = s.value), (f = r + Yh(s, h++)), (c += Oc(s, e, n, f, i)))
  else if (s === 'object')
    throw (
      (e = String(t)),
      Error(
        'Objects are not valid as a React child (found: ' +
          (e === '[object Object]' ? 'object with keys {' + Object.keys(t).join(', ') + '}' : e) +
          '). If you meant to render a collection of children, use an array instead.'
      )
    )
  return c
}
function nc(t, e, n) {
  if (t == null) return t
  var r = [],
    i = 0
  return (
    Oc(t, r, '', '', function (s) {
      return e.call(n, s, i++)
    }),
    r
  )
}
function tv(t) {
  if (t._status === -1) {
    var e = t._result
    ;((e = e()),
      e.then(
        function (n) {
          ;(t._status === 0 || t._status === -1) && ((t._status = 1), (t._result = n))
        },
        function (n) {
          ;(t._status === 0 || t._status === -1) && ((t._status = 2), (t._result = n))
        }
      ),
      t._status === -1 && ((t._status = 0), (t._result = e)))
  }
  if (t._status === 1) return t._result.default
  throw t._result
}
var an = { current: null },
  Bc = { transition: null },
  ev = { ReactCurrentDispatcher: an, ReactCurrentBatchConfig: Bc, ReactCurrentOwner: Af }
function o8() {
  throw Error('act(...) is not supported in production builds of React.')
}
Rt.Children = {
  map: nc,
  forEach: function (t, e, n) {
    nc(
      t,
      function () {
        e.apply(this, arguments)
      },
      n
    )
  },
  count: function (t) {
    var e = 0
    return (
      nc(t, function () {
        e++
      }),
      e
    )
  },
  toArray: function (t) {
    return (
      nc(t, function (e) {
        return e
      }) || []
    )
  },
  only: function (t) {
    if (!kf(t)) throw Error('React.Children.only expected to receive a single React element child.')
    return t
  },
}
Rt.Component = Hs
Rt.Fragment = Ub
Rt.Profiler = Hb
Rt.PureComponent = Cf
Rt.StrictMode = zb
Rt.Suspense = Zb
Rt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ev
Rt.act = o8
Rt.cloneElement = function (t, e, n) {
  if (t == null)
    throw Error(
      'React.cloneElement(...): The argument must be a React element, but you passed ' + t + '.'
    )
  var r = Jy({}, t.props),
    i = t.key,
    s = t.ref,
    c = t._owner
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (c = Af.current)),
      e.key !== void 0 && (i = '' + e.key),
      t.type && t.type.defaultProps)
    )
      var h = t.type.defaultProps
    for (f in e)
      n8.call(e, f) &&
        !r8.hasOwnProperty(f) &&
        (r[f] = e[f] === void 0 && h !== void 0 ? h[f] : e[f])
  }
  var f = arguments.length - 2
  if (f === 1) r.children = n
  else if (1 < f) {
    h = Array(f)
    for (var p = 0; p < f; p++) h[p] = arguments[p + 2]
    r.children = h
  }
  return { $$typeof: Nl, type: t.type, key: i, ref: s, props: r, _owner: c }
}
Rt.createContext = function (t) {
  return (
    (t = {
      $$typeof: Gb,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (t.Provider = { $$typeof: Xb, _context: t }),
    (t.Consumer = t)
  )
}
Rt.createElement = i8
Rt.createFactory = function (t) {
  var e = i8.bind(null, t)
  return ((e.type = t), e)
}
Rt.createRef = function () {
  return { current: null }
}
Rt.forwardRef = function (t) {
  return { $$typeof: Yb, render: t }
}
Rt.isValidElement = kf
Rt.lazy = function (t) {
  return { $$typeof: Kb, _payload: { _status: -1, _result: t }, _init: tv }
}
Rt.memo = function (t, e) {
  return { $$typeof: qb, type: t, compare: e === void 0 ? null : e }
}
Rt.startTransition = function (t) {
  var e = Bc.transition
  Bc.transition = {}
  try {
    t()
  } finally {
    Bc.transition = e
  }
}
Rt.unstable_act = o8
Rt.useCallback = function (t, e) {
  return an.current.useCallback(t, e)
}
Rt.useContext = function (t) {
  return an.current.useContext(t)
}
Rt.useDebugValue = function () {}
Rt.useDeferredValue = function (t) {
  return an.current.useDeferredValue(t)
}
Rt.useEffect = function (t, e) {
  return an.current.useEffect(t, e)
}
Rt.useId = function () {
  return an.current.useId()
}
Rt.useImperativeHandle = function (t, e, n) {
  return an.current.useImperativeHandle(t, e, n)
}
Rt.useInsertionEffect = function (t, e) {
  return an.current.useInsertionEffect(t, e)
}
Rt.useLayoutEffect = function (t, e) {
  return an.current.useLayoutEffect(t, e)
}
Rt.useMemo = function (t, e) {
  return an.current.useMemo(t, e)
}
Rt.useReducer = function (t, e, n) {
  return an.current.useReducer(t, e, n)
}
Rt.useRef = function (t) {
  return an.current.useRef(t)
}
Rt.useState = function (t) {
  return an.current.useState(t)
}
Rt.useSyncExternalStore = function (t, e, n) {
  return an.current.useSyncExternalStore(t, e, n)
}
Rt.useTransition = function () {
  return an.current.useTransition()
}
Rt.version = '18.3.1'
Qy.exports = Rt
var X = Qy.exports
const A = qy(X),
  nv = Zy({ __proto__: null, default: A }, [X])
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var rv = X,
  iv = Symbol.for('react.element'),
  ov = Symbol.for('react.fragment'),
  sv = Object.prototype.hasOwnProperty,
  av = rv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  lv = { key: !0, ref: !0, __self: !0, __source: !0 }
function s8(t, e, n) {
  var r,
    i = {},
    s = null,
    c = null
  ;(n !== void 0 && (s = '' + n),
    e.key !== void 0 && (s = '' + e.key),
    e.ref !== void 0 && (c = e.ref))
  for (r in e) sv.call(e, r) && !lv.hasOwnProperty(r) && (i[r] = e[r])
  if (t && t.defaultProps) for (r in ((e = t.defaultProps), e)) i[r] === void 0 && (i[r] = e[r])
  return { $$typeof: iv, type: t, key: s, ref: c, props: i, _owner: av.current }
}
Zu.Fragment = ov
Zu.jsx = s8
Zu.jsxs = s8
Ky.exports = Zu
var R = Ky.exports,
  a8 = { exports: {} },
  Fn = {},
  l8 = { exports: {} },
  c8 = {}
;(function (t) {
  function e(ot, ft) {
    var pt = ot.length
    ot.push(ft)
    t: for (; 0 < pt; ) {
      var Ut = (pt - 1) >>> 1,
        St = ot[Ut]
      if (0 < i(St, ft)) ((ot[Ut] = ft), (ot[pt] = St), (pt = Ut))
      else break t
    }
  }
  function n(ot) {
    return ot.length === 0 ? null : ot[0]
  }
  function r(ot) {
    if (ot.length === 0) return null
    var ft = ot[0],
      pt = ot.pop()
    if (pt !== ft) {
      ot[0] = pt
      t: for (var Ut = 0, St = ot.length, Te = St >>> 1; Ut < Te; ) {
        var Bt = 2 * (Ut + 1) - 1,
          Sn = ot[Bt],
          ut = Bt + 1,
          $r = ot[ut]
        if (0 > i(Sn, pt))
          ut < St && 0 > i($r, Sn)
            ? ((ot[Ut] = $r), (ot[ut] = pt), (Ut = ut))
            : ((ot[Ut] = Sn), (ot[Bt] = pt), (Ut = Bt))
        else if (ut < St && 0 > i($r, pt)) ((ot[Ut] = $r), (ot[ut] = pt), (Ut = ut))
        else break t
      }
    }
    return ft
  }
  function i(ot, ft) {
    var pt = ot.sortIndex - ft.sortIndex
    return pt !== 0 ? pt : ot.id - ft.id
  }
  if (typeof performance == 'object' && typeof performance.now == 'function') {
    var s = performance
    t.unstable_now = function () {
      return s.now()
    }
  } else {
    var c = Date,
      h = c.now()
    t.unstable_now = function () {
      return c.now() - h
    }
  }
  var f = [],
    p = [],
    y = 1,
    w = null,
    x = 3,
    E = !1,
    S = !1,
    k = !1,
    D = typeof setTimeout == 'function' ? setTimeout : null,
    _ = typeof clearTimeout == 'function' ? clearTimeout : null,
    N = typeof setImmediate < 'u' ? setImmediate : null
  typeof navigator < 'u' &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling)
  function M(ot) {
    for (var ft = n(p); ft !== null; ) {
      if (ft.callback === null) r(p)
      else if (ft.startTime <= ot) (r(p), (ft.sortIndex = ft.expirationTime), e(f, ft))
      else break
      ft = n(p)
    }
  }
  function O(ot) {
    if (((k = !1), M(ot), !S))
      if (n(f) !== null) ((S = !0), xt(F))
      else {
        var ft = n(p)
        ft !== null && gt(O, ft.startTime - ot)
      }
  }
  function F(ot, ft) {
    ;((S = !1), k && ((k = !1), _(W), (W = -1)), (E = !0))
    var pt = x
    try {
      for (M(ft), w = n(f); w !== null && (!(w.expirationTime > ft) || (ot && !st())); ) {
        var Ut = w.callback
        if (typeof Ut == 'function') {
          ;((w.callback = null), (x = w.priorityLevel))
          var St = Ut(w.expirationTime <= ft)
          ;((ft = t.unstable_now()),
            typeof St == 'function' ? (w.callback = St) : w === n(f) && r(f),
            M(ft))
        } else r(f)
        w = n(f)
      }
      if (w !== null) var Te = !0
      else {
        var Bt = n(p)
        ;(Bt !== null && gt(O, Bt.startTime - ft), (Te = !1))
      }
      return Te
    } finally {
      ;((w = null), (x = pt), (E = !1))
    }
  }
  var z = !1,
    V = null,
    W = -1,
    Z = 5,
    J = -1
  function st() {
    return !(t.unstable_now() - J < Z)
  }
  function rt() {
    if (V !== null) {
      var ot = t.unstable_now()
      J = ot
      var ft = !0
      try {
        ft = V(!0, ot)
      } finally {
        ft ? vt() : ((z = !1), (V = null))
      }
    } else z = !1
  }
  var vt
  if (typeof N == 'function')
    vt = function () {
      N(rt)
    }
  else if (typeof MessageChannel < 'u') {
    var _t = new MessageChannel(),
      H = _t.port2
    ;((_t.port1.onmessage = rt),
      (vt = function () {
        H.postMessage(null)
      }))
  } else
    vt = function () {
      D(rt, 0)
    }
  function xt(ot) {
    ;((V = ot), z || ((z = !0), vt()))
  }
  function gt(ot, ft) {
    W = D(function () {
      ot(t.unstable_now())
    }, ft)
  }
  ;((t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (ot) {
      ot.callback = null
    }),
    (t.unstable_continueExecution = function () {
      S || E || ((S = !0), xt(F))
    }),
    (t.unstable_forceFrameRate = function (ot) {
      0 > ot || 125 < ot
        ? console.error(
            'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
          )
        : (Z = 0 < ot ? Math.floor(1e3 / ot) : 5)
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return x
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(f)
    }),
    (t.unstable_next = function (ot) {
      switch (x) {
        case 1:
        case 2:
        case 3:
          var ft = 3
          break
        default:
          ft = x
      }
      var pt = x
      x = ft
      try {
        return ot()
      } finally {
        x = pt
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (ot, ft) {
      switch (ot) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          ot = 3
      }
      var pt = x
      x = ot
      try {
        return ft()
      } finally {
        x = pt
      }
    }),
    (t.unstable_scheduleCallback = function (ot, ft, pt) {
      var Ut = t.unstable_now()
      switch (
        (typeof pt == 'object' && pt !== null
          ? ((pt = pt.delay), (pt = typeof pt == 'number' && 0 < pt ? Ut + pt : Ut))
          : (pt = Ut),
        ot)
      ) {
        case 1:
          var St = -1
          break
        case 2:
          St = 250
          break
        case 5:
          St = 1073741823
          break
        case 4:
          St = 1e4
          break
        default:
          St = 5e3
      }
      return (
        (St = pt + St),
        (ot = {
          id: y++,
          callback: ft,
          priorityLevel: ot,
          startTime: pt,
          expirationTime: St,
          sortIndex: -1,
        }),
        pt > Ut
          ? ((ot.sortIndex = pt),
            e(p, ot),
            n(f) === null && ot === n(p) && (k ? (_(W), (W = -1)) : (k = !0), gt(O, pt - Ut)))
          : ((ot.sortIndex = St), e(f, ot), S || E || ((S = !0), xt(F))),
        ot
      )
    }),
    (t.unstable_shouldYield = st),
    (t.unstable_wrapCallback = function (ot) {
      var ft = x
      return function () {
        var pt = x
        x = ft
        try {
          return ot.apply(this, arguments)
        } finally {
          x = pt
        }
      }
    }))
})(c8)
l8.exports = c8
var cv = l8.exports
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var uv = X,
  On = cv
function tt(t) {
  for (
    var e = 'https://reactjs.org/docs/error-decoder.html?invariant=' + t, n = 1;
    n < arguments.length;
    n++
  )
    e += '&args[]=' + encodeURIComponent(arguments[n])
  return (
    'Minified React error #' +
    t +
    '; visit ' +
    e +
    ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
  )
}
var u8 = new Set(),
  el = {}
function ko(t, e) {
  ;(Ts(t, e), Ts(t + 'Capture', e))
}
function Ts(t, e) {
  for (el[t] = e, t = 0; t < e.length; t++) u8.add(e[t])
}
var Xr = !(
    typeof window > 'u' ||
    typeof window.document > 'u' ||
    typeof window.document.createElement > 'u'
  ),
  Zd = Object.prototype.hasOwnProperty,
  hv =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Wp = {},
  Up = {}
function dv(t) {
  return Zd.call(Up, t) ? !0 : Zd.call(Wp, t) ? !1 : hv.test(t) ? (Up[t] = !0) : ((Wp[t] = !0), !1)
}
function fv(t, e, n, r) {
  if (n !== null && n.type === 0) return !1
  switch (typeof e) {
    case 'function':
    case 'symbol':
      return !0
    case 'boolean':
      return r
        ? !1
        : n !== null
          ? !n.acceptsBooleans
          : ((t = t.toLowerCase().slice(0, 5)), t !== 'data-' && t !== 'aria-')
    default:
      return !1
  }
}
function pv(t, e, n, r) {
  if (e === null || typeof e > 'u' || fv(t, e, n, r)) return !0
  if (r) return !1
  if (n !== null)
    switch (n.type) {
      case 3:
        return !e
      case 4:
        return e === !1
      case 5:
        return isNaN(e)
      case 6:
        return isNaN(e) || 1 > e
    }
  return !1
}
function ln(t, e, n, r, i, s, c) {
  ;((this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = t),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = c))
}
var Ge = {}
'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
  .split(' ')
  .forEach(function (t) {
    Ge[t] = new ln(t, 0, !1, t, null, !1, !1)
  })
;[
  ['acceptCharset', 'accept-charset'],
  ['className', 'class'],
  ['htmlFor', 'for'],
  ['httpEquiv', 'http-equiv'],
].forEach(function (t) {
  var e = t[0]
  Ge[e] = new ln(e, 1, !1, t[1], null, !1, !1)
})
;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (t) {
  Ge[t] = new ln(t, 2, !1, t.toLowerCase(), null, !1, !1)
})
;['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (t) {
  Ge[t] = new ln(t, 2, !1, t, null, !1, !1)
})
'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
  .split(' ')
  .forEach(function (t) {
    Ge[t] = new ln(t, 3, !1, t.toLowerCase(), null, !1, !1)
  })
;['checked', 'multiple', 'muted', 'selected'].forEach(function (t) {
  Ge[t] = new ln(t, 3, !0, t, null, !1, !1)
})
;['capture', 'download'].forEach(function (t) {
  Ge[t] = new ln(t, 4, !1, t, null, !1, !1)
})
;['cols', 'rows', 'size', 'span'].forEach(function (t) {
  Ge[t] = new ln(t, 6, !1, t, null, !1, !1)
})
;['rowSpan', 'start'].forEach(function (t) {
  Ge[t] = new ln(t, 5, !1, t.toLowerCase(), null, !1, !1)
})
var If = /[\-:]([a-z])/g
function _f(t) {
  return t[1].toUpperCase()
}
'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
  .split(' ')
  .forEach(function (t) {
    var e = t.replace(If, _f)
    Ge[e] = new ln(e, 1, !1, t, null, !1, !1)
  })
'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
  .split(' ')
  .forEach(function (t) {
    var e = t.replace(If, _f)
    Ge[e] = new ln(e, 1, !1, t, 'http://www.w3.org/1999/xlink', !1, !1)
  })
;['xml:base', 'xml:lang', 'xml:space'].forEach(function (t) {
  var e = t.replace(If, _f)
  Ge[e] = new ln(e, 1, !1, t, 'http://www.w3.org/XML/1998/namespace', !1, !1)
})
;['tabIndex', 'crossOrigin'].forEach(function (t) {
  Ge[t] = new ln(t, 1, !1, t.toLowerCase(), null, !1, !1)
})
Ge.xlinkHref = new ln('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)
;['src', 'href', 'action', 'formAction'].forEach(function (t) {
  Ge[t] = new ln(t, 1, !1, t.toLowerCase(), null, !0, !0)
})
function Rf(t, e, n, r) {
  var i = Ge.hasOwnProperty(e) ? Ge[e] : null
  ;(i !== null
    ? i.type !== 0
    : r || !(2 < e.length) || (e[0] !== 'o' && e[0] !== 'O') || (e[1] !== 'n' && e[1] !== 'N')) &&
    (pv(e, n, i, r) && (n = null),
    r || i === null
      ? dv(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, '' + n))
      : i.mustUseProperty
        ? (t[i.propertyName] = n === null ? (i.type === 3 ? !1 : '') : n)
        : ((e = i.attributeName),
          (r = i.attributeNamespace),
          n === null
            ? t.removeAttribute(e)
            : ((i = i.type),
              (n = i === 3 || (i === 4 && n === !0) ? '' : '' + n),
              r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))))
}
var Kr = uv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  rc = Symbol.for('react.element'),
  is = Symbol.for('react.portal'),
  os = Symbol.for('react.fragment'),
  Tf = Symbol.for('react.strict_mode'),
  qd = Symbol.for('react.profiler'),
  h8 = Symbol.for('react.provider'),
  d8 = Symbol.for('react.context'),
  Nf = Symbol.for('react.forward_ref'),
  Kd = Symbol.for('react.suspense'),
  Qd = Symbol.for('react.suspense_list'),
  Mf = Symbol.for('react.memo'),
  ci = Symbol.for('react.lazy'),
  f8 = Symbol.for('react.offscreen'),
  zp = Symbol.iterator
function da(t) {
  return t === null || typeof t != 'object'
    ? null
    : ((t = (zp && t[zp]) || t['@@iterator']), typeof t == 'function' ? t : null)
}
var de = Object.assign,
  Zh
function ka(t) {
  if (Zh === void 0)
    try {
      throw Error()
    } catch (n) {
      var e = n.stack.trim().match(/\n( *(at )?)/)
      Zh = (e && e[1]) || ''
    }
  return (
    `
` +
    Zh +
    t
  )
}
var qh = !1
function Kh(t, e) {
  if (!t || qh) return ''
  qh = !0
  var n = Error.prepareStackTrace
  Error.prepareStackTrace = void 0
  try {
    if (e)
      if (
        ((e = function () {
          throw Error()
        }),
        Object.defineProperty(e.prototype, 'props', {
          set: function () {
            throw Error()
          },
        }),
        typeof Reflect == 'object' && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, [])
        } catch (p) {
          var r = p
        }
        Reflect.construct(t, [], e)
      } else {
        try {
          e.call()
        } catch (p) {
          r = p
        }
        t.call(e.prototype)
      }
    else {
      try {
        throw Error()
      } catch (p) {
        r = p
      }
      t()
    }
  } catch (p) {
    if (p && r && typeof p.stack == 'string') {
      for (
        var i = p.stack.split(`
`),
          s = r.stack.split(`
`),
          c = i.length - 1,
          h = s.length - 1;
        1 <= c && 0 <= h && i[c] !== s[h];

      )
        h--
      for (; 1 <= c && 0 <= h; c--, h--)
        if (i[c] !== s[h]) {
          if (c !== 1 || h !== 1)
            do
              if ((c--, h--, 0 > h || i[c] !== s[h])) {
                var f =
                  `
` + i[c].replace(' at new ', ' at ')
                return (
                  t.displayName &&
                    f.includes('<anonymous>') &&
                    (f = f.replace('<anonymous>', t.displayName)),
                  f
                )
              }
            while (1 <= c && 0 <= h)
          break
        }
    }
  } finally {
    ;((qh = !1), (Error.prepareStackTrace = n))
  }
  return (t = t ? t.displayName || t.name : '') ? ka(t) : ''
}
function gv(t) {
  switch (t.tag) {
    case 5:
      return ka(t.type)
    case 16:
      return ka('Lazy')
    case 13:
      return ka('Suspense')
    case 19:
      return ka('SuspenseList')
    case 0:
    case 2:
    case 15:
      return ((t = Kh(t.type, !1)), t)
    case 11:
      return ((t = Kh(t.type.render, !1)), t)
    case 1:
      return ((t = Kh(t.type, !0)), t)
    default:
      return ''
  }
}
function $d(t) {
  if (t == null) return null
  if (typeof t == 'function') return t.displayName || t.name || null
  if (typeof t == 'string') return t
  switch (t) {
    case os:
      return 'Fragment'
    case is:
      return 'Portal'
    case qd:
      return 'Profiler'
    case Tf:
      return 'StrictMode'
    case Kd:
      return 'Suspense'
    case Qd:
      return 'SuspenseList'
  }
  if (typeof t == 'object')
    switch (t.$$typeof) {
      case d8:
        return (t.displayName || 'Context') + '.Consumer'
      case h8:
        return (t._context.displayName || 'Context') + '.Provider'
      case Nf:
        var e = t.render
        return (
          (t = t.displayName),
          t ||
            ((t = e.displayName || e.name || ''),
            (t = t !== '' ? 'ForwardRef(' + t + ')' : 'ForwardRef')),
          t
        )
      case Mf:
        return ((e = t.displayName || null), e !== null ? e : $d(t.type) || 'Memo')
      case ci:
        ;((e = t._payload), (t = t._init))
        try {
          return $d(t(e))
        } catch {}
    }
  return null
}
function mv(t) {
  var e = t.type
  switch (t.tag) {
    case 24:
      return 'Cache'
    case 9:
      return (e.displayName || 'Context') + '.Consumer'
    case 10:
      return (e._context.displayName || 'Context') + '.Provider'
    case 18:
      return 'DehydratedFragment'
    case 11:
      return (
        (t = e.render),
        (t = t.displayName || t.name || ''),
        e.displayName || (t !== '' ? 'ForwardRef(' + t + ')' : 'ForwardRef')
      )
    case 7:
      return 'Fragment'
    case 5:
      return e
    case 4:
      return 'Portal'
    case 3:
      return 'Root'
    case 6:
      return 'Text'
    case 16:
      return $d(e)
    case 8:
      return e === Tf ? 'StrictMode' : 'Mode'
    case 22:
      return 'Offscreen'
    case 12:
      return 'Profiler'
    case 21:
      return 'Scope'
    case 13:
      return 'Suspense'
    case 19:
      return 'SuspenseList'
    case 25:
      return 'TracingMarker'
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == 'function') return e.displayName || e.name || null
      if (typeof e == 'string') return e
  }
  return null
}
function Mi(t) {
  switch (typeof t) {
    case 'boolean':
    case 'number':
    case 'string':
    case 'undefined':
      return t
    case 'object':
      return t
    default:
      return ''
  }
}
function p8(t) {
  var e = t.type
  return (t = t.nodeName) && t.toLowerCase() === 'input' && (e === 'checkbox' || e === 'radio')
}
function yv(t) {
  var e = p8(t) ? 'checked' : 'value',
    n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    r = '' + t[e]
  if (
    !t.hasOwnProperty(e) &&
    typeof n < 'u' &&
    typeof n.get == 'function' &&
    typeof n.set == 'function'
  ) {
    var i = n.get,
      s = n.set
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        get: function () {
          return i.call(this)
        },
        set: function (c) {
          ;((r = '' + c), s.call(this, c))
        },
      }),
      Object.defineProperty(t, e, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r
        },
        setValue: function (c) {
          r = '' + c
        },
        stopTracking: function () {
          ;((t._valueTracker = null), delete t[e])
        },
      }
    )
  }
}
function ic(t) {
  t._valueTracker || (t._valueTracker = yv(t))
}
function g8(t) {
  if (!t) return !1
  var e = t._valueTracker
  if (!e) return !0
  var n = e.getValue(),
    r = ''
  return (
    t && (r = p8(t) ? (t.checked ? 'true' : 'false') : t.value),
    (t = r),
    t !== n ? (e.setValue(t), !0) : !1
  )
}
function iu(t) {
  if (((t = t || (typeof document < 'u' ? document : void 0)), typeof t > 'u')) return null
  try {
    return t.activeElement || t.body
  } catch {
    return t.body
  }
}
function Jd(t, e) {
  var n = e.checked
  return de({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? t._wrapperState.initialChecked,
  })
}
function Hp(t, e) {
  var n = e.defaultValue == null ? '' : e.defaultValue,
    r = e.checked != null ? e.checked : e.defaultChecked
  ;((n = Mi(e.value != null ? e.value : n)),
    (t._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled: e.type === 'checkbox' || e.type === 'radio' ? e.checked != null : e.value != null,
    }))
}
function m8(t, e) {
  ;((e = e.checked), e != null && Rf(t, 'checked', e, !1))
}
function t1(t, e) {
  m8(t, e)
  var n = Mi(e.value),
    r = e.type
  if (n != null)
    r === 'number'
      ? ((n === 0 && t.value === '') || t.value != n) && (t.value = '' + n)
      : t.value !== '' + n && (t.value = '' + n)
  else if (r === 'submit' || r === 'reset') {
    t.removeAttribute('value')
    return
  }
  ;(e.hasOwnProperty('value')
    ? e1(t, e.type, n)
    : e.hasOwnProperty('defaultValue') && e1(t, e.type, Mi(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked))
}
function Xp(t, e, n) {
  if (e.hasOwnProperty('value') || e.hasOwnProperty('defaultValue')) {
    var r = e.type
    if (!((r !== 'submit' && r !== 'reset') || (e.value !== void 0 && e.value !== null))) return
    ;((e = '' + t._wrapperState.initialValue),
      n || e === t.value || (t.value = e),
      (t.defaultValue = e))
  }
  ;((n = t.name),
    n !== '' && (t.name = ''),
    (t.defaultChecked = !!t._wrapperState.initialChecked),
    n !== '' && (t.name = n))
}
function e1(t, e, n) {
  ;(e !== 'number' || iu(t.ownerDocument) !== t) &&
    (n == null
      ? (t.defaultValue = '' + t._wrapperState.initialValue)
      : t.defaultValue !== '' + n && (t.defaultValue = '' + n))
}
var Ia = Array.isArray
function Cs(t, e, n, r) {
  if (((t = t.options), e)) {
    e = {}
    for (var i = 0; i < n.length; i++) e['$' + n[i]] = !0
    for (n = 0; n < t.length; n++)
      ((i = e.hasOwnProperty('$' + t[n].value)),
        t[n].selected !== i && (t[n].selected = i),
        i && r && (t[n].defaultSelected = !0))
  } else {
    for (n = '' + Mi(n), e = null, i = 0; i < t.length; i++) {
      if (t[i].value === n) {
        ;((t[i].selected = !0), r && (t[i].defaultSelected = !0))
        return
      }
      e !== null || t[i].disabled || (e = t[i])
    }
    e !== null && (e.selected = !0)
  }
}
function n1(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(tt(91))
  return de({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: '' + t._wrapperState.initialValue,
  })
}
function Gp(t, e) {
  var n = e.value
  if (n == null) {
    if (((n = e.children), (e = e.defaultValue), n != null)) {
      if (e != null) throw Error(tt(92))
      if (Ia(n)) {
        if (1 < n.length) throw Error(tt(93))
        n = n[0]
      }
      e = n
    }
    ;(e == null && (e = ''), (n = e))
  }
  t._wrapperState = { initialValue: Mi(n) }
}
function y8(t, e) {
  var n = Mi(e.value),
    r = Mi(e.defaultValue)
  ;(n != null &&
    ((n = '' + n),
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    r != null && (t.defaultValue = '' + r))
}
function Yp(t) {
  var e = t.textContent
  e === t._wrapperState.initialValue && e !== '' && e !== null && (t.value = e)
}
function w8(t) {
  switch (t) {
    case 'svg':
      return 'http://www.w3.org/2000/svg'
    case 'math':
      return 'http://www.w3.org/1998/Math/MathML'
    default:
      return 'http://www.w3.org/1999/xhtml'
  }
}
function r1(t, e) {
  return t == null || t === 'http://www.w3.org/1999/xhtml'
    ? w8(e)
    : t === 'http://www.w3.org/2000/svg' && e === 'foreignObject'
      ? 'http://www.w3.org/1999/xhtml'
      : t
}
var oc,
  b8 = (function (t) {
    return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
      ? function (e, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return t(e, n, r, i)
          })
        }
      : t
  })(function (t, e) {
    if (t.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in t) t.innerHTML = e
    else {
      for (
        oc = oc || document.createElement('div'),
          oc.innerHTML = '<svg>' + e.valueOf().toString() + '</svg>',
          e = oc.firstChild;
        t.firstChild;

      )
        t.removeChild(t.firstChild)
      for (; e.firstChild; ) t.appendChild(e.firstChild)
    }
  })
function nl(t, e) {
  if (e) {
    var n = t.firstChild
    if (n && n === t.lastChild && n.nodeType === 3) {
      n.nodeValue = e
      return
    }
  }
  t.textContent = e
}
var Oa = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  wv = ['Webkit', 'ms', 'Moz', 'O']
Object.keys(Oa).forEach(function (t) {
  wv.forEach(function (e) {
    ;((e = e + t.charAt(0).toUpperCase() + t.substring(1)), (Oa[e] = Oa[t]))
  })
})
function v8(t, e, n) {
  return e == null || typeof e == 'boolean' || e === ''
    ? ''
    : n || typeof e != 'number' || e === 0 || (Oa.hasOwnProperty(t) && Oa[t])
      ? ('' + e).trim()
      : e + 'px'
}
function x8(t, e) {
  t = t.style
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var r = n.indexOf('--') === 0,
        i = v8(n, e[n], r)
      ;(n === 'float' && (n = 'cssFloat'), r ? t.setProperty(n, i) : (t[n] = i))
    }
}
var bv = de(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
)
function i1(t, e) {
  if (e) {
    if (bv[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(tt(137, t))
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(tt(60))
      if (typeof e.dangerouslySetInnerHTML != 'object' || !('__html' in e.dangerouslySetInnerHTML))
        throw Error(tt(61))
    }
    if (e.style != null && typeof e.style != 'object') throw Error(tt(62))
  }
}
function o1(t, e) {
  if (t.indexOf('-') === -1) return typeof e.is == 'string'
  switch (t) {
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return !1
    default:
      return !0
  }
}
var s1 = null
function Df(t) {
  return (
    (t = t.target || t.srcElement || window),
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
  )
}
var a1 = null,
  Ss = null,
  As = null
function Zp(t) {
  if ((t = Pl(t))) {
    if (typeof a1 != 'function') throw Error(tt(280))
    var e = t.stateNode
    e && ((e = Ju(e)), a1(t.stateNode, t.type, e))
  }
}
function E8(t) {
  Ss ? (As ? As.push(t) : (As = [t])) : (Ss = t)
}
function C8() {
  if (Ss) {
    var t = Ss,
      e = As
    if (((As = Ss = null), Zp(t), e)) for (t = 0; t < e.length; t++) Zp(e[t])
  }
}
function S8(t, e) {
  return t(e)
}
function A8() {}
var Qh = !1
function k8(t, e, n) {
  if (Qh) return t(e, n)
  Qh = !0
  try {
    return S8(t, e, n)
  } finally {
    ;((Qh = !1), (Ss !== null || As !== null) && (A8(), C8()))
  }
}
function rl(t, e) {
  var n = t.stateNode
  if (n === null) return null
  var r = Ju(n)
  if (r === null) return null
  n = r[e]
  t: switch (e) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      ;((r = !r.disabled) ||
        ((t = t.type),
        (r = !(t === 'button' || t === 'input' || t === 'select' || t === 'textarea'))),
        (t = !r))
      break t
    default:
      t = !1
  }
  if (t) return null
  if (n && typeof n != 'function') throw Error(tt(231, e, typeof n))
  return n
}
var l1 = !1
if (Xr)
  try {
    var fa = {}
    ;(Object.defineProperty(fa, 'passive', {
      get: function () {
        l1 = !0
      },
    }),
      window.addEventListener('test', fa, fa),
      window.removeEventListener('test', fa, fa))
  } catch {
    l1 = !1
  }
function vv(t, e, n, r, i, s, c, h, f) {
  var p = Array.prototype.slice.call(arguments, 3)
  try {
    e.apply(n, p)
  } catch (y) {
    this.onError(y)
  }
}
var Ba = !1,
  ou = null,
  su = !1,
  c1 = null,
  xv = {
    onError: function (t) {
      ;((Ba = !0), (ou = t))
    },
  }
function Ev(t, e, n, r, i, s, c, h, f) {
  ;((Ba = !1), (ou = null), vv.apply(xv, arguments))
}
function Cv(t, e, n, r, i, s, c, h, f) {
  if ((Ev.apply(this, arguments), Ba)) {
    if (Ba) {
      var p = ou
      ;((Ba = !1), (ou = null))
    } else throw Error(tt(198))
    su || ((su = !0), (c1 = p))
  }
}
function Io(t) {
  var e = t,
    n = t
  if (t.alternate) for (; e.return; ) e = e.return
  else {
    t = e
    do ((e = t), e.flags & 4098 && (n = e.return), (t = e.return))
    while (t)
  }
  return e.tag === 3 ? n : null
}
function I8(t) {
  if (t.tag === 13) {
    var e = t.memoizedState
    if ((e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)), e !== null))
      return e.dehydrated
  }
  return null
}
function qp(t) {
  if (Io(t) !== t) throw Error(tt(188))
}
function Sv(t) {
  var e = t.alternate
  if (!e) {
    if (((e = Io(t)), e === null)) throw Error(tt(188))
    return e !== t ? null : t
  }
  for (var n = t, r = e; ; ) {
    var i = n.return
    if (i === null) break
    var s = i.alternate
    if (s === null) {
      if (((r = i.return), r !== null)) {
        n = r
        continue
      }
      break
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === n) return (qp(i), t)
        if (s === r) return (qp(i), e)
        s = s.sibling
      }
      throw Error(tt(188))
    }
    if (n.return !== r.return) ((n = i), (r = s))
    else {
      for (var c = !1, h = i.child; h; ) {
        if (h === n) {
          ;((c = !0), (n = i), (r = s))
          break
        }
        if (h === r) {
          ;((c = !0), (r = i), (n = s))
          break
        }
        h = h.sibling
      }
      if (!c) {
        for (h = s.child; h; ) {
          if (h === n) {
            ;((c = !0), (n = s), (r = i))
            break
          }
          if (h === r) {
            ;((c = !0), (r = s), (n = i))
            break
          }
          h = h.sibling
        }
        if (!c) throw Error(tt(189))
      }
    }
    if (n.alternate !== r) throw Error(tt(190))
  }
  if (n.tag !== 3) throw Error(tt(188))
  return n.stateNode.current === n ? t : e
}
function _8(t) {
  return ((t = Sv(t)), t !== null ? R8(t) : null)
}
function R8(t) {
  if (t.tag === 5 || t.tag === 6) return t
  for (t = t.child; t !== null; ) {
    var e = R8(t)
    if (e !== null) return e
    t = t.sibling
  }
  return null
}
var T8 = On.unstable_scheduleCallback,
  Kp = On.unstable_cancelCallback,
  Av = On.unstable_shouldYield,
  kv = On.unstable_requestPaint,
  Ee = On.unstable_now,
  Iv = On.unstable_getCurrentPriorityLevel,
  Pf = On.unstable_ImmediatePriority,
  N8 = On.unstable_UserBlockingPriority,
  au = On.unstable_NormalPriority,
  _v = On.unstable_LowPriority,
  M8 = On.unstable_IdlePriority,
  qu = null,
  Ar = null
function Rv(t) {
  if (Ar && typeof Ar.onCommitFiberRoot == 'function')
    try {
      Ar.onCommitFiberRoot(qu, t, void 0, (t.current.flags & 128) === 128)
    } catch {}
}
var cr = Math.clz32 ? Math.clz32 : Mv,
  Tv = Math.log,
  Nv = Math.LN2
function Mv(t) {
  return ((t >>>= 0), t === 0 ? 32 : (31 - ((Tv(t) / Nv) | 0)) | 0)
}
var sc = 64,
  ac = 4194304
function _a(t) {
  switch (t & -t) {
    case 1:
      return 1
    case 2:
      return 2
    case 4:
      return 4
    case 8:
      return 8
    case 16:
      return 16
    case 32:
      return 32
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424
    case 134217728:
      return 134217728
    case 268435456:
      return 268435456
    case 536870912:
      return 536870912
    case 1073741824:
      return 1073741824
    default:
      return t
  }
}
function lu(t, e) {
  var n = t.pendingLanes
  if (n === 0) return 0
  var r = 0,
    i = t.suspendedLanes,
    s = t.pingedLanes,
    c = n & 268435455
  if (c !== 0) {
    var h = c & ~i
    h !== 0 ? (r = _a(h)) : ((s &= c), s !== 0 && (r = _a(s)))
  } else ((c = n & ~i), c !== 0 ? (r = _a(c)) : s !== 0 && (r = _a(s)))
  if (r === 0) return 0
  if (
    e !== 0 &&
    e !== r &&
    !(e & i) &&
    ((i = r & -r), (s = e & -e), i >= s || (i === 16 && (s & 4194240) !== 0))
  )
    return e
  if ((r & 4 && (r |= n & 16), (e = t.entangledLanes), e !== 0))
    for (t = t.entanglements, e &= r; 0 < e; )
      ((n = 31 - cr(e)), (i = 1 << n), (r |= t[n]), (e &= ~i))
  return r
}
function Dv(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1
    default:
      return -1
  }
}
function Pv(t, e) {
  for (
    var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes;
    0 < s;

  ) {
    var c = 31 - cr(s),
      h = 1 << c,
      f = i[c]
    ;(f === -1 ? (!(h & n) || h & r) && (i[c] = Dv(h, e)) : f <= e && (t.expiredLanes |= h),
      (s &= ~h))
  }
}
function u1(t) {
  return ((t = t.pendingLanes & -1073741825), t !== 0 ? t : t & 1073741824 ? 1073741824 : 0)
}
function D8() {
  var t = sc
  return ((sc <<= 1), !(sc & 4194240) && (sc = 64), t)
}
function $h(t) {
  for (var e = [], n = 0; 31 > n; n++) e.push(t)
  return e
}
function Ml(t, e, n) {
  ;((t.pendingLanes |= e),
    e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
    (t = t.eventTimes),
    (e = 31 - cr(e)),
    (t[e] = n))
}
function Lv(t, e) {
  var n = t.pendingLanes & ~e
  ;((t.pendingLanes = e),
    (t.suspendedLanes = 0),
    (t.pingedLanes = 0),
    (t.expiredLanes &= e),
    (t.mutableReadLanes &= e),
    (t.entangledLanes &= e),
    (e = t.entanglements))
  var r = t.eventTimes
  for (t = t.expirationTimes; 0 < n; ) {
    var i = 31 - cr(n),
      s = 1 << i
    ;((e[i] = 0), (r[i] = -1), (t[i] = -1), (n &= ~s))
  }
}
function Lf(t, e) {
  var n = (t.entangledLanes |= e)
  for (t = t.entanglements; n; ) {
    var r = 31 - cr(n),
      i = 1 << r
    ;((i & e) | (t[r] & e) && (t[r] |= e), (n &= ~i))
  }
}
var Ht = 0
function P8(t) {
  return ((t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1)
}
var L8,
  Of,
  O8,
  B8,
  F8,
  h1 = !1,
  lc = [],
  Ei = null,
  Ci = null,
  Si = null,
  il = new Map(),
  ol = new Map(),
  hi = [],
  Ov =
    'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
      ' '
    )
function Qp(t, e) {
  switch (t) {
    case 'focusin':
    case 'focusout':
      Ei = null
      break
    case 'dragenter':
    case 'dragleave':
      Ci = null
      break
    case 'mouseover':
    case 'mouseout':
      Si = null
      break
    case 'pointerover':
    case 'pointerout':
      il.delete(e.pointerId)
      break
    case 'gotpointercapture':
    case 'lostpointercapture':
      ol.delete(e.pointerId)
  }
}
function pa(t, e, n, r, i, s) {
  return t === null || t.nativeEvent !== s
    ? ((t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      }),
      e !== null && ((e = Pl(e)), e !== null && Of(e)),
      t)
    : ((t.eventSystemFlags |= r),
      (e = t.targetContainers),
      i !== null && e.indexOf(i) === -1 && e.push(i),
      t)
}
function Bv(t, e, n, r, i) {
  switch (e) {
    case 'focusin':
      return ((Ei = pa(Ei, t, e, n, r, i)), !0)
    case 'dragenter':
      return ((Ci = pa(Ci, t, e, n, r, i)), !0)
    case 'mouseover':
      return ((Si = pa(Si, t, e, n, r, i)), !0)
    case 'pointerover':
      var s = i.pointerId
      return (il.set(s, pa(il.get(s) || null, t, e, n, r, i)), !0)
    case 'gotpointercapture':
      return ((s = i.pointerId), ol.set(s, pa(ol.get(s) || null, t, e, n, r, i)), !0)
  }
  return !1
}
function j8(t) {
  var e = oo(t.target)
  if (e !== null) {
    var n = Io(e)
    if (n !== null) {
      if (((e = n.tag), e === 13)) {
        if (((e = I8(n)), e !== null)) {
          ;((t.blockedOn = e),
            F8(t.priority, function () {
              O8(n)
            }))
          return
        }
      } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null
        return
      }
    }
  }
  t.blockedOn = null
}
function Fc(t) {
  if (t.blockedOn !== null) return !1
  for (var e = t.targetContainers; 0 < e.length; ) {
    var n = d1(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent)
    if (n === null) {
      n = t.nativeEvent
      var r = new n.constructor(n.type, n)
      ;((s1 = r), n.target.dispatchEvent(r), (s1 = null))
    } else return ((e = Pl(n)), e !== null && Of(e), (t.blockedOn = n), !1)
    e.shift()
  }
  return !0
}
function $p(t, e, n) {
  Fc(t) && n.delete(e)
}
function Fv() {
  ;((h1 = !1),
    Ei !== null && Fc(Ei) && (Ei = null),
    Ci !== null && Fc(Ci) && (Ci = null),
    Si !== null && Fc(Si) && (Si = null),
    il.forEach($p),
    ol.forEach($p))
}
function ga(t, e) {
  t.blockedOn === e &&
    ((t.blockedOn = null),
    h1 || ((h1 = !0), On.unstable_scheduleCallback(On.unstable_NormalPriority, Fv)))
}
function sl(t) {
  function e(i) {
    return ga(i, t)
  }
  if (0 < lc.length) {
    ga(lc[0], t)
    for (var n = 1; n < lc.length; n++) {
      var r = lc[n]
      r.blockedOn === t && (r.blockedOn = null)
    }
  }
  for (
    Ei !== null && ga(Ei, t),
      Ci !== null && ga(Ci, t),
      Si !== null && ga(Si, t),
      il.forEach(e),
      ol.forEach(e),
      n = 0;
    n < hi.length;
    n++
  )
    ((r = hi[n]), r.blockedOn === t && (r.blockedOn = null))
  for (; 0 < hi.length && ((n = hi[0]), n.blockedOn === null); )
    (j8(n), n.blockedOn === null && hi.shift())
}
var ks = Kr.ReactCurrentBatchConfig,
  cu = !0
function jv(t, e, n, r) {
  var i = Ht,
    s = ks.transition
  ks.transition = null
  try {
    ;((Ht = 1), Bf(t, e, n, r))
  } finally {
    ;((Ht = i), (ks.transition = s))
  }
}
function Vv(t, e, n, r) {
  var i = Ht,
    s = ks.transition
  ks.transition = null
  try {
    ;((Ht = 4), Bf(t, e, n, r))
  } finally {
    ;((Ht = i), (ks.transition = s))
  }
}
function Bf(t, e, n, r) {
  if (cu) {
    var i = d1(t, e, n, r)
    if (i === null) (ld(t, e, r, uu, n), Qp(t, r))
    else if (Bv(i, t, e, n, r)) r.stopPropagation()
    else if ((Qp(t, r), e & 4 && -1 < Ov.indexOf(t))) {
      for (; i !== null; ) {
        var s = Pl(i)
        if ((s !== null && L8(s), (s = d1(t, e, n, r)), s === null && ld(t, e, r, uu, n), s === i))
          break
        i = s
      }
      i !== null && r.stopPropagation()
    } else ld(t, e, r, null, n)
  }
}
var uu = null
function d1(t, e, n, r) {
  if (((uu = null), (t = Df(r)), (t = oo(t)), t !== null))
    if (((e = Io(t)), e === null)) t = null
    else if (((n = e.tag), n === 13)) {
      if (((t = I8(e)), t !== null)) return t
      t = null
    } else if (n === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null
      t = null
    } else e !== t && (t = null)
  return ((uu = t), null)
}
function V8(t) {
  switch (t) {
    case 'cancel':
    case 'click':
    case 'close':
    case 'contextmenu':
    case 'copy':
    case 'cut':
    case 'auxclick':
    case 'dblclick':
    case 'dragend':
    case 'dragstart':
    case 'drop':
    case 'focusin':
    case 'focusout':
    case 'input':
    case 'invalid':
    case 'keydown':
    case 'keypress':
    case 'keyup':
    case 'mousedown':
    case 'mouseup':
    case 'paste':
    case 'pause':
    case 'play':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointerup':
    case 'ratechange':
    case 'reset':
    case 'resize':
    case 'seeked':
    case 'submit':
    case 'touchcancel':
    case 'touchend':
    case 'touchstart':
    case 'volumechange':
    case 'change':
    case 'selectionchange':
    case 'textInput':
    case 'compositionstart':
    case 'compositionend':
    case 'compositionupdate':
    case 'beforeblur':
    case 'afterblur':
    case 'beforeinput':
    case 'blur':
    case 'fullscreenchange':
    case 'focus':
    case 'hashchange':
    case 'popstate':
    case 'select':
    case 'selectstart':
      return 1
    case 'drag':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'mousemove':
    case 'mouseout':
    case 'mouseover':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'scroll':
    case 'toggle':
    case 'touchmove':
    case 'wheel':
    case 'mouseenter':
    case 'mouseleave':
    case 'pointerenter':
    case 'pointerleave':
      return 4
    case 'message':
      switch (Iv()) {
        case Pf:
          return 1
        case N8:
          return 4
        case au:
        case _v:
          return 16
        case M8:
          return 536870912
        default:
          return 16
      }
    default:
      return 16
  }
}
var fi = null,
  Ff = null,
  jc = null
function W8() {
  if (jc) return jc
  var t,
    e = Ff,
    n = e.length,
    r,
    i = 'value' in fi ? fi.value : fi.textContent,
    s = i.length
  for (t = 0; t < n && e[t] === i[t]; t++);
  var c = n - t
  for (r = 1; r <= c && e[n - r] === i[s - r]; r++);
  return (jc = i.slice(t, 1 < r ? 1 - r : void 0))
}
function Vc(t) {
  var e = t.keyCode
  return (
    'charCode' in t ? ((t = t.charCode), t === 0 && e === 13 && (t = 13)) : (t = e),
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
  )
}
function cc() {
  return !0
}
function Jp() {
  return !1
}
function jn(t) {
  function e(n, r, i, s, c) {
    ;((this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = s),
      (this.target = c),
      (this.currentTarget = null))
    for (var h in t) t.hasOwnProperty(h) && ((n = t[h]), (this[h] = n ? n(s) : s[h]))
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? cc
        : Jp),
      (this.isPropagationStopped = Jp),
      this
    )
  }
  return (
    de(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0
        var n = this.nativeEvent
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != 'unknown' && (n.returnValue = !1),
          (this.isDefaultPrevented = cc))
      },
      stopPropagation: function () {
        var n = this.nativeEvent
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != 'unknown' && (n.cancelBubble = !0),
          (this.isPropagationStopped = cc))
      },
      persist: function () {},
      isPersistent: cc,
    }),
    e
  )
}
var Xs = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  jf = jn(Xs),
  Dl = de({}, Xs, { view: 0, detail: 0 }),
  Wv = jn(Dl),
  Jh,
  td,
  ma,
  Ku = de({}, Dl, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Vf,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0
        ? t.fromElement === t.srcElement
          ? t.toElement
          : t.fromElement
        : t.relatedTarget
    },
    movementX: function (t) {
      return 'movementX' in t
        ? t.movementX
        : (t !== ma &&
            (ma && t.type === 'mousemove'
              ? ((Jh = t.screenX - ma.screenX), (td = t.screenY - ma.screenY))
              : (td = Jh = 0),
            (ma = t)),
          Jh)
    },
    movementY: function (t) {
      return 'movementY' in t ? t.movementY : td
    },
  }),
  tg = jn(Ku),
  Uv = de({}, Ku, { dataTransfer: 0 }),
  zv = jn(Uv),
  Hv = de({}, Dl, { relatedTarget: 0 }),
  ed = jn(Hv),
  Xv = de({}, Xs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Gv = jn(Xv),
  Yv = de({}, Xs, {
    clipboardData: function (t) {
      return 'clipboardData' in t ? t.clipboardData : window.clipboardData
    },
  }),
  Zv = jn(Yv),
  qv = de({}, Xs, { data: 0 }),
  eg = jn(qv),
  Kv = {
    Esc: 'Escape',
    Spacebar: ' ',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown',
    Del: 'Delete',
    Win: 'OS',
    Menu: 'ContextMenu',
    Apps: 'ContextMenu',
    Scroll: 'ScrollLock',
    MozPrintableKey: 'Unidentified',
  },
  Qv = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta',
  },
  $v = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
function Jv(t) {
  var e = this.nativeEvent
  return e.getModifierState ? e.getModifierState(t) : (t = $v[t]) ? !!e[t] : !1
}
function Vf() {
  return Jv
}
var tx = de({}, Dl, {
    key: function (t) {
      if (t.key) {
        var e = Kv[t.key] || t.key
        if (e !== 'Unidentified') return e
      }
      return t.type === 'keypress'
        ? ((t = Vc(t)), t === 13 ? 'Enter' : String.fromCharCode(t))
        : t.type === 'keydown' || t.type === 'keyup'
          ? Qv[t.keyCode] || 'Unidentified'
          : ''
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Vf,
    charCode: function (t) {
      return t.type === 'keypress' ? Vc(t) : 0
    },
    keyCode: function (t) {
      return t.type === 'keydown' || t.type === 'keyup' ? t.keyCode : 0
    },
    which: function (t) {
      return t.type === 'keypress'
        ? Vc(t)
        : t.type === 'keydown' || t.type === 'keyup'
          ? t.keyCode
          : 0
    },
  }),
  ex = jn(tx),
  nx = de({}, Ku, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  ng = jn(nx),
  rx = de({}, Dl, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Vf,
  }),
  ix = jn(rx),
  ox = de({}, Xs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  sx = jn(ox),
  ax = de({}, Ku, {
    deltaX: function (t) {
      return 'deltaX' in t ? t.deltaX : 'wheelDeltaX' in t ? -t.wheelDeltaX : 0
    },
    deltaY: function (t) {
      return 'deltaY' in t
        ? t.deltaY
        : 'wheelDeltaY' in t
          ? -t.wheelDeltaY
          : 'wheelDelta' in t
            ? -t.wheelDelta
            : 0
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  lx = jn(ax),
  cx = [9, 13, 27, 32],
  Wf = Xr && 'CompositionEvent' in window,
  Fa = null
Xr && 'documentMode' in document && (Fa = document.documentMode)
var ux = Xr && 'TextEvent' in window && !Fa,
  U8 = Xr && (!Wf || (Fa && 8 < Fa && 11 >= Fa)),
  rg = ' ',
  ig = !1
function z8(t, e) {
  switch (t) {
    case 'keyup':
      return cx.indexOf(e.keyCode) !== -1
    case 'keydown':
      return e.keyCode !== 229
    case 'keypress':
    case 'mousedown':
    case 'focusout':
      return !0
    default:
      return !1
  }
}
function H8(t) {
  return ((t = t.detail), typeof t == 'object' && 'data' in t ? t.data : null)
}
var ss = !1
function hx(t, e) {
  switch (t) {
    case 'compositionend':
      return H8(e)
    case 'keypress':
      return e.which !== 32 ? null : ((ig = !0), rg)
    case 'textInput':
      return ((t = e.data), t === rg && ig ? null : t)
    default:
      return null
  }
}
function dx(t, e) {
  if (ss)
    return t === 'compositionend' || (!Wf && z8(t, e))
      ? ((t = W8()), (jc = Ff = fi = null), (ss = !1), t)
      : null
  switch (t) {
    case 'paste':
      return null
    case 'keypress':
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char
        if (e.which) return String.fromCharCode(e.which)
      }
      return null
    case 'compositionend':
      return U8 && e.locale !== 'ko' ? null : e.data
    default:
      return null
  }
}
var fx = {
  color: !0,
  date: !0,
  datetime: !0,
  'datetime-local': !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
}
function og(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase()
  return e === 'input' ? !!fx[t.type] : e === 'textarea'
}
function X8(t, e, n, r) {
  ;(E8(r),
    (e = hu(e, 'onChange')),
    0 < e.length &&
      ((n = new jf('onChange', 'change', null, n, r)), t.push({ event: n, listeners: e })))
}
var ja = null,
  al = null
function px(t) {
  n4(t, 0)
}
function Qu(t) {
  var e = cs(t)
  if (g8(e)) return t
}
function gx(t, e) {
  if (t === 'change') return e
}
var G8 = !1
if (Xr) {
  var nd
  if (Xr) {
    var rd = 'oninput' in document
    if (!rd) {
      var sg = document.createElement('div')
      ;(sg.setAttribute('oninput', 'return;'), (rd = typeof sg.oninput == 'function'))
    }
    nd = rd
  } else nd = !1
  G8 = nd && (!document.documentMode || 9 < document.documentMode)
}
function ag() {
  ja && (ja.detachEvent('onpropertychange', Y8), (al = ja = null))
}
function Y8(t) {
  if (t.propertyName === 'value' && Qu(al)) {
    var e = []
    ;(X8(e, al, t, Df(t)), k8(px, e))
  }
}
function mx(t, e, n) {
  t === 'focusin'
    ? (ag(), (ja = e), (al = n), ja.attachEvent('onpropertychange', Y8))
    : t === 'focusout' && ag()
}
function yx(t) {
  if (t === 'selectionchange' || t === 'keyup' || t === 'keydown') return Qu(al)
}
function wx(t, e) {
  if (t === 'click') return Qu(e)
}
function bx(t, e) {
  if (t === 'input' || t === 'change') return Qu(e)
}
function vx(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e)
}
var hr = typeof Object.is == 'function' ? Object.is : vx
function ll(t, e) {
  if (hr(t, e)) return !0
  if (typeof t != 'object' || t === null || typeof e != 'object' || e === null) return !1
  var n = Object.keys(t),
    r = Object.keys(e)
  if (n.length !== r.length) return !1
  for (r = 0; r < n.length; r++) {
    var i = n[r]
    if (!Zd.call(e, i) || !hr(t[i], e[i])) return !1
  }
  return !0
}
function lg(t) {
  for (; t && t.firstChild; ) t = t.firstChild
  return t
}
function cg(t, e) {
  var n = lg(t)
  t = 0
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = t + n.textContent.length), t <= e && r >= e)) return { node: n, offset: e - t }
      t = r
    }
    t: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling
          break t
        }
        n = n.parentNode
      }
      n = void 0
    }
    n = lg(n)
  }
}
function Z8(t, e) {
  return t && e
    ? t === e
      ? !0
      : t && t.nodeType === 3
        ? !1
        : e && e.nodeType === 3
          ? Z8(t, e.parentNode)
          : 'contains' in t
            ? t.contains(e)
            : t.compareDocumentPosition
              ? !!(t.compareDocumentPosition(e) & 16)
              : !1
    : !1
}
function q8() {
  for (var t = window, e = iu(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var n = typeof e.contentWindow.location.href == 'string'
    } catch {
      n = !1
    }
    if (n) t = e.contentWindow
    else break
    e = iu(t.document)
  }
  return e
}
function Uf(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase()
  return (
    e &&
    ((e === 'input' &&
      (t.type === 'text' ||
        t.type === 'search' ||
        t.type === 'tel' ||
        t.type === 'url' ||
        t.type === 'password')) ||
      e === 'textarea' ||
      t.contentEditable === 'true')
  )
}
function xx(t) {
  var e = q8(),
    n = t.focusedElem,
    r = t.selectionRange
  if (e !== n && n && n.ownerDocument && Z8(n.ownerDocument.documentElement, n)) {
    if (r !== null && Uf(n)) {
      if (((e = r.start), (t = r.end), t === void 0 && (t = e), 'selectionStart' in n))
        ((n.selectionStart = e), (n.selectionEnd = Math.min(t, n.value.length)))
      else if (
        ((t = ((e = n.ownerDocument || document) && e.defaultView) || window), t.getSelection)
      ) {
        t = t.getSelection()
        var i = n.textContent.length,
          s = Math.min(r.start, i)
        ;((r = r.end === void 0 ? s : Math.min(r.end, i)),
          !t.extend && s > r && ((i = r), (r = s), (s = i)),
          (i = cg(n, s)))
        var c = cg(n, r)
        i &&
          c &&
          (t.rangeCount !== 1 ||
            t.anchorNode !== i.node ||
            t.anchorOffset !== i.offset ||
            t.focusNode !== c.node ||
            t.focusOffset !== c.offset) &&
          ((e = e.createRange()),
          e.setStart(i.node, i.offset),
          t.removeAllRanges(),
          s > r
            ? (t.addRange(e), t.extend(c.node, c.offset))
            : (e.setEnd(c.node, c.offset), t.addRange(e)))
      }
    }
    for (e = [], t = n; (t = t.parentNode); )
      t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop })
    for (typeof n.focus == 'function' && n.focus(), n = 0; n < e.length; n++)
      ((t = e[n]), (t.element.scrollLeft = t.left), (t.element.scrollTop = t.top))
  }
}
var Ex = Xr && 'documentMode' in document && 11 >= document.documentMode,
  as = null,
  f1 = null,
  Va = null,
  p1 = !1
function ug(t, e, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument
  p1 ||
    as == null ||
    as !== iu(r) ||
    ((r = as),
    'selectionStart' in r && Uf(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = ((r.ownerDocument && r.ownerDocument.defaultView) || window).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (Va && ll(Va, r)) ||
      ((Va = r),
      (r = hu(f1, 'onSelect')),
      0 < r.length &&
        ((e = new jf('onSelect', 'select', null, e, n)),
        t.push({ event: e, listeners: r }),
        (e.target = as))))
}
function uc(t, e) {
  var n = {}
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n['Webkit' + t] = 'webkit' + e),
    (n['Moz' + t] = 'moz' + e),
    n
  )
}
var ls = {
    animationend: uc('Animation', 'AnimationEnd'),
    animationiteration: uc('Animation', 'AnimationIteration'),
    animationstart: uc('Animation', 'AnimationStart'),
    transitionend: uc('Transition', 'TransitionEnd'),
  },
  id = {},
  K8 = {}
Xr &&
  ((K8 = document.createElement('div').style),
  'AnimationEvent' in window ||
    (delete ls.animationend.animation,
    delete ls.animationiteration.animation,
    delete ls.animationstart.animation),
  'TransitionEvent' in window || delete ls.transitionend.transition)
function $u(t) {
  if (id[t]) return id[t]
  if (!ls[t]) return t
  var e = ls[t],
    n
  for (n in e) if (e.hasOwnProperty(n) && n in K8) return (id[t] = e[n])
  return t
}
var Q8 = $u('animationend'),
  $8 = $u('animationiteration'),
  J8 = $u('animationstart'),
  t4 = $u('transitionend'),
  e4 = new Map(),
  hg =
    'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
      ' '
    )
function Bi(t, e) {
  ;(e4.set(t, e), ko(e, [t]))
}
for (var od = 0; od < hg.length; od++) {
  var sd = hg[od],
    Cx = sd.toLowerCase(),
    Sx = sd[0].toUpperCase() + sd.slice(1)
  Bi(Cx, 'on' + Sx)
}
Bi(Q8, 'onAnimationEnd')
Bi($8, 'onAnimationIteration')
Bi(J8, 'onAnimationStart')
Bi('dblclick', 'onDoubleClick')
Bi('focusin', 'onFocus')
Bi('focusout', 'onBlur')
Bi(t4, 'onTransitionEnd')
Ts('onMouseEnter', ['mouseout', 'mouseover'])
Ts('onMouseLeave', ['mouseout', 'mouseover'])
Ts('onPointerEnter', ['pointerout', 'pointerover'])
Ts('onPointerLeave', ['pointerout', 'pointerover'])
ko('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' '))
ko(
  'onSelect',
  'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(' ')
)
ko('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste'])
ko('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' '))
ko('onCompositionStart', 'compositionstart focusout keydown keypress keyup mousedown'.split(' '))
ko('onCompositionUpdate', 'compositionupdate focusout keydown keypress keyup mousedown'.split(' '))
var Ra =
    'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
      ' '
    ),
  Ax = new Set('cancel close invalid load scroll toggle'.split(' ').concat(Ra))
function dg(t, e, n) {
  var r = t.type || 'unknown-event'
  ;((t.currentTarget = n), Cv(r, e, void 0, t), (t.currentTarget = null))
}
function n4(t, e) {
  e = (e & 4) !== 0
  for (var n = 0; n < t.length; n++) {
    var r = t[n],
      i = r.event
    r = r.listeners
    t: {
      var s = void 0
      if (e)
        for (var c = r.length - 1; 0 <= c; c--) {
          var h = r[c],
            f = h.instance,
            p = h.currentTarget
          if (((h = h.listener), f !== s && i.isPropagationStopped())) break t
          ;(dg(i, h, p), (s = f))
        }
      else
        for (c = 0; c < r.length; c++) {
          if (
            ((h = r[c]),
            (f = h.instance),
            (p = h.currentTarget),
            (h = h.listener),
            f !== s && i.isPropagationStopped())
          )
            break t
          ;(dg(i, h, p), (s = f))
        }
    }
  }
  if (su) throw ((t = c1), (su = !1), (c1 = null), t)
}
function te(t, e) {
  var n = e[b1]
  n === void 0 && (n = e[b1] = new Set())
  var r = t + '__bubble'
  n.has(r) || (r4(e, t, 2, !1), n.add(r))
}
function ad(t, e, n) {
  var r = 0
  ;(e && (r |= 4), r4(n, t, r, e))
}
var hc = '_reactListening' + Math.random().toString(36).slice(2)
function cl(t) {
  if (!t[hc]) {
    ;((t[hc] = !0),
      u8.forEach(function (n) {
        n !== 'selectionchange' && (Ax.has(n) || ad(n, !1, t), ad(n, !0, t))
      }))
    var e = t.nodeType === 9 ? t : t.ownerDocument
    e === null || e[hc] || ((e[hc] = !0), ad('selectionchange', !1, e))
  }
}
function r4(t, e, n, r) {
  switch (V8(e)) {
    case 1:
      var i = jv
      break
    case 4:
      i = Vv
      break
    default:
      i = Bf
  }
  ;((n = i.bind(null, e, n, t)),
    (i = void 0),
    !l1 || (e !== 'touchstart' && e !== 'touchmove' && e !== 'wheel') || (i = !0),
    r
      ? i !== void 0
        ? t.addEventListener(e, n, { capture: !0, passive: i })
        : t.addEventListener(e, n, !0)
      : i !== void 0
        ? t.addEventListener(e, n, { passive: i })
        : t.addEventListener(e, n, !1))
}
function ld(t, e, n, r, i) {
  var s = r
  if (!(e & 1) && !(e & 2) && r !== null)
    t: for (;;) {
      if (r === null) return
      var c = r.tag
      if (c === 3 || c === 4) {
        var h = r.stateNode.containerInfo
        if (h === i || (h.nodeType === 8 && h.parentNode === i)) break
        if (c === 4)
          for (c = r.return; c !== null; ) {
            var f = c.tag
            if (
              (f === 3 || f === 4) &&
              ((f = c.stateNode.containerInfo), f === i || (f.nodeType === 8 && f.parentNode === i))
            )
              return
            c = c.return
          }
        for (; h !== null; ) {
          if (((c = oo(h)), c === null)) return
          if (((f = c.tag), f === 5 || f === 6)) {
            r = s = c
            continue t
          }
          h = h.parentNode
        }
      }
      r = r.return
    }
  k8(function () {
    var p = s,
      y = Df(n),
      w = []
    t: {
      var x = e4.get(t)
      if (x !== void 0) {
        var E = jf,
          S = t
        switch (t) {
          case 'keypress':
            if (Vc(n) === 0) break t
          case 'keydown':
          case 'keyup':
            E = ex
            break
          case 'focusin':
            ;((S = 'focus'), (E = ed))
            break
          case 'focusout':
            ;((S = 'blur'), (E = ed))
            break
          case 'beforeblur':
          case 'afterblur':
            E = ed
            break
          case 'click':
            if (n.button === 2) break t
          case 'auxclick':
          case 'dblclick':
          case 'mousedown':
          case 'mousemove':
          case 'mouseup':
          case 'mouseout':
          case 'mouseover':
          case 'contextmenu':
            E = tg
            break
          case 'drag':
          case 'dragend':
          case 'dragenter':
          case 'dragexit':
          case 'dragleave':
          case 'dragover':
          case 'dragstart':
          case 'drop':
            E = zv
            break
          case 'touchcancel':
          case 'touchend':
          case 'touchmove':
          case 'touchstart':
            E = ix
            break
          case Q8:
          case $8:
          case J8:
            E = Gv
            break
          case t4:
            E = sx
            break
          case 'scroll':
            E = Wv
            break
          case 'wheel':
            E = lx
            break
          case 'copy':
          case 'cut':
          case 'paste':
            E = Zv
            break
          case 'gotpointercapture':
          case 'lostpointercapture':
          case 'pointercancel':
          case 'pointerdown':
          case 'pointermove':
          case 'pointerout':
          case 'pointerover':
          case 'pointerup':
            E = ng
        }
        var k = (e & 4) !== 0,
          D = !k && t === 'scroll',
          _ = k ? (x !== null ? x + 'Capture' : null) : x
        k = []
        for (var N = p, M; N !== null; ) {
          M = N
          var O = M.stateNode
          if (
            (M.tag === 5 &&
              O !== null &&
              ((M = O), _ !== null && ((O = rl(N, _)), O != null && k.push(ul(N, O, M)))),
            D)
          )
            break
          N = N.return
        }
        0 < k.length && ((x = new E(x, S, null, n, y)), w.push({ event: x, listeners: k }))
      }
    }
    if (!(e & 7)) {
      t: {
        if (
          ((x = t === 'mouseover' || t === 'pointerover'),
          (E = t === 'mouseout' || t === 'pointerout'),
          x && n !== s1 && (S = n.relatedTarget || n.fromElement) && (oo(S) || S[Gr]))
        )
          break t
        if (
          (E || x) &&
          ((x =
            y.window === y ? y : (x = y.ownerDocument) ? x.defaultView || x.parentWindow : window),
          E
            ? ((S = n.relatedTarget || n.toElement),
              (E = p),
              (S = S ? oo(S) : null),
              S !== null && ((D = Io(S)), S !== D || (S.tag !== 5 && S.tag !== 6)) && (S = null))
            : ((E = null), (S = p)),
          E !== S)
        ) {
          if (
            ((k = tg),
            (O = 'onMouseLeave'),
            (_ = 'onMouseEnter'),
            (N = 'mouse'),
            (t === 'pointerout' || t === 'pointerover') &&
              ((k = ng), (O = 'onPointerLeave'), (_ = 'onPointerEnter'), (N = 'pointer')),
            (D = E == null ? x : cs(E)),
            (M = S == null ? x : cs(S)),
            (x = new k(O, N + 'leave', E, n, y)),
            (x.target = D),
            (x.relatedTarget = M),
            (O = null),
            oo(y) === p &&
              ((k = new k(_, N + 'enter', S, n, y)),
              (k.target = M),
              (k.relatedTarget = D),
              (O = k)),
            (D = O),
            E && S)
          )
            e: {
              for (k = E, _ = S, N = 0, M = k; M; M = es(M)) N++
              for (M = 0, O = _; O; O = es(O)) M++
              for (; 0 < N - M; ) ((k = es(k)), N--)
              for (; 0 < M - N; ) ((_ = es(_)), M--)
              for (; N--; ) {
                if (k === _ || (_ !== null && k === _.alternate)) break e
                ;((k = es(k)), (_ = es(_)))
              }
              k = null
            }
          else k = null
          ;(E !== null && fg(w, x, E, k, !1), S !== null && D !== null && fg(w, D, S, k, !0))
        }
      }
      t: {
        if (
          ((x = p ? cs(p) : window),
          (E = x.nodeName && x.nodeName.toLowerCase()),
          E === 'select' || (E === 'input' && x.type === 'file'))
        )
          var F = gx
        else if (og(x))
          if (G8) F = bx
          else {
            F = yx
            var z = mx
          }
        else
          (E = x.nodeName) &&
            E.toLowerCase() === 'input' &&
            (x.type === 'checkbox' || x.type === 'radio') &&
            (F = wx)
        if (F && (F = F(t, p))) {
          X8(w, F, n, y)
          break t
        }
        ;(z && z(t, x, p),
          t === 'focusout' &&
            (z = x._wrapperState) &&
            z.controlled &&
            x.type === 'number' &&
            e1(x, 'number', x.value))
      }
      switch (((z = p ? cs(p) : window), t)) {
        case 'focusin':
          ;(og(z) || z.contentEditable === 'true') && ((as = z), (f1 = p), (Va = null))
          break
        case 'focusout':
          Va = f1 = as = null
          break
        case 'mousedown':
          p1 = !0
          break
        case 'contextmenu':
        case 'mouseup':
        case 'dragend':
          ;((p1 = !1), ug(w, n, y))
          break
        case 'selectionchange':
          if (Ex) break
        case 'keydown':
        case 'keyup':
          ug(w, n, y)
      }
      var V
      if (Wf)
        t: {
          switch (t) {
            case 'compositionstart':
              var W = 'onCompositionStart'
              break t
            case 'compositionend':
              W = 'onCompositionEnd'
              break t
            case 'compositionupdate':
              W = 'onCompositionUpdate'
              break t
          }
          W = void 0
        }
      else
        ss
          ? z8(t, n) && (W = 'onCompositionEnd')
          : t === 'keydown' && n.keyCode === 229 && (W = 'onCompositionStart')
      ;(W &&
        (U8 &&
          n.locale !== 'ko' &&
          (ss || W !== 'onCompositionStart'
            ? W === 'onCompositionEnd' && ss && (V = W8())
            : ((fi = y), (Ff = 'value' in fi ? fi.value : fi.textContent), (ss = !0))),
        (z = hu(p, W)),
        0 < z.length &&
          ((W = new eg(W, t, null, n, y)),
          w.push({ event: W, listeners: z }),
          V ? (W.data = V) : ((V = H8(n)), V !== null && (W.data = V)))),
        (V = ux ? hx(t, n) : dx(t, n)) &&
          ((p = hu(p, 'onBeforeInput')),
          0 < p.length &&
            ((y = new eg('onBeforeInput', 'beforeinput', null, n, y)),
            w.push({ event: y, listeners: p }),
            (y.data = V))))
    }
    n4(w, e)
  })
}
function ul(t, e, n) {
  return { instance: t, listener: e, currentTarget: n }
}
function hu(t, e) {
  for (var n = e + 'Capture', r = []; t !== null; ) {
    var i = t,
      s = i.stateNode
    ;(i.tag === 5 &&
      s !== null &&
      ((i = s),
      (s = rl(t, n)),
      s != null && r.unshift(ul(t, s, i)),
      (s = rl(t, e)),
      s != null && r.push(ul(t, s, i))),
      (t = t.return))
  }
  return r
}
function es(t) {
  if (t === null) return null
  do t = t.return
  while (t && t.tag !== 5)
  return t || null
}
function fg(t, e, n, r, i) {
  for (var s = e._reactName, c = []; n !== null && n !== r; ) {
    var h = n,
      f = h.alternate,
      p = h.stateNode
    if (f !== null && f === r) break
    ;(h.tag === 5 &&
      p !== null &&
      ((h = p),
      i
        ? ((f = rl(n, s)), f != null && c.unshift(ul(n, f, h)))
        : i || ((f = rl(n, s)), f != null && c.push(ul(n, f, h)))),
      (n = n.return))
  }
  c.length !== 0 && t.push({ event: e, listeners: c })
}
var kx = /\r\n?/g,
  Ix = /\u0000|\uFFFD/g
function pg(t) {
  return (typeof t == 'string' ? t : '' + t)
    .replace(
      kx,
      `
`
    )
    .replace(Ix, '')
}
function dc(t, e, n) {
  if (((e = pg(e)), pg(t) !== e && n)) throw Error(tt(425))
}
function du() {}
var g1 = null,
  m1 = null
function y1(t, e) {
  return (
    t === 'textarea' ||
    t === 'noscript' ||
    typeof e.children == 'string' ||
    typeof e.children == 'number' ||
    (typeof e.dangerouslySetInnerHTML == 'object' &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  )
}
var w1 = typeof setTimeout == 'function' ? setTimeout : void 0,
  _x = typeof clearTimeout == 'function' ? clearTimeout : void 0,
  gg = typeof Promise == 'function' ? Promise : void 0,
  Rx =
    typeof queueMicrotask == 'function'
      ? queueMicrotask
      : typeof gg < 'u'
        ? function (t) {
            return gg.resolve(null).then(t).catch(Tx)
          }
        : w1
function Tx(t) {
  setTimeout(function () {
    throw t
  })
}
function cd(t, e) {
  var n = e,
    r = 0
  do {
    var i = n.nextSibling
    if ((t.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === '/$')) {
        if (r === 0) {
          ;(t.removeChild(i), sl(e))
          return
        }
        r--
      } else (n !== '$' && n !== '$?' && n !== '$!') || r++
    n = i
  } while (n)
  sl(e)
}
function Ai(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType
    if (e === 1 || e === 3) break
    if (e === 8) {
      if (((e = t.data), e === '$' || e === '$!' || e === '$?')) break
      if (e === '/$') return null
    }
  }
  return t
}
function mg(t) {
  t = t.previousSibling
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var n = t.data
      if (n === '$' || n === '$!' || n === '$?') {
        if (e === 0) return t
        e--
      } else n === '/$' && e++
    }
    t = t.previousSibling
  }
  return null
}
var Gs = Math.random().toString(36).slice(2),
  Sr = '__reactFiber$' + Gs,
  hl = '__reactProps$' + Gs,
  Gr = '__reactContainer$' + Gs,
  b1 = '__reactEvents$' + Gs,
  Nx = '__reactListeners$' + Gs,
  Mx = '__reactHandles$' + Gs
function oo(t) {
  var e = t[Sr]
  if (e) return e
  for (var n = t.parentNode; n; ) {
    if ((e = n[Gr] || n[Sr])) {
      if (((n = e.alternate), e.child !== null || (n !== null && n.child !== null)))
        for (t = mg(t); t !== null; ) {
          if ((n = t[Sr])) return n
          t = mg(t)
        }
      return e
    }
    ;((t = n), (n = t.parentNode))
  }
  return null
}
function Pl(t) {
  return (
    (t = t[Sr] || t[Gr]),
    !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t
  )
}
function cs(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode
  throw Error(tt(33))
}
function Ju(t) {
  return t[hl] || null
}
var v1 = [],
  us = -1
function Fi(t) {
  return { current: t }
}
function ne(t) {
  0 > us || ((t.current = v1[us]), (v1[us] = null), us--)
}
function $t(t, e) {
  ;(us++, (v1[us] = t.current), (t.current = e))
}
var Di = {},
  tn = Fi(Di),
  vn = Fi(!1),
  yo = Di
function Ns(t, e) {
  var n = t.type.contextTypes
  if (!n) return Di
  var r = t.stateNode
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
    return r.__reactInternalMemoizedMaskedChildContext
  var i = {},
    s
  for (s in n) i[s] = e[s]
  return (
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = e),
      (t.__reactInternalMemoizedMaskedChildContext = i)),
    i
  )
}
function xn(t) {
  return ((t = t.childContextTypes), t != null)
}
function fu() {
  ;(ne(vn), ne(tn))
}
function yg(t, e, n) {
  if (tn.current !== Di) throw Error(tt(168))
  ;($t(tn, e), $t(vn, n))
}
function i4(t, e, n) {
  var r = t.stateNode
  if (((e = e.childContextTypes), typeof r.getChildContext != 'function')) return n
  r = r.getChildContext()
  for (var i in r) if (!(i in e)) throw Error(tt(108, mv(t) || 'Unknown', i))
  return de({}, n, r)
}
function pu(t) {
  return (
    (t = ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || Di),
    (yo = tn.current),
    $t(tn, t),
    $t(vn, vn.current),
    !0
  )
}
function wg(t, e, n) {
  var r = t.stateNode
  if (!r) throw Error(tt(169))
  ;(n
    ? ((t = i4(t, e, yo)),
      (r.__reactInternalMemoizedMergedChildContext = t),
      ne(vn),
      ne(tn),
      $t(tn, t))
    : ne(vn),
    $t(vn, n))
}
var Or = null,
  th = !1,
  ud = !1
function o4(t) {
  Or === null ? (Or = [t]) : Or.push(t)
}
function Dx(t) {
  ;((th = !0), o4(t))
}
function ji() {
  if (!ud && Or !== null) {
    ud = !0
    var t = 0,
      e = Ht
    try {
      var n = Or
      for (Ht = 1; t < n.length; t++) {
        var r = n[t]
        do r = r(!0)
        while (r !== null)
      }
      ;((Or = null), (th = !1))
    } catch (i) {
      throw (Or !== null && (Or = Or.slice(t + 1)), T8(Pf, ji), i)
    } finally {
      ;((Ht = e), (ud = !1))
    }
  }
  return null
}
var hs = [],
  ds = 0,
  gu = null,
  mu = 0,
  Yn = [],
  Zn = 0,
  wo = null,
  Fr = 1,
  jr = ''
function Ji(t, e) {
  ;((hs[ds++] = mu), (hs[ds++] = gu), (gu = t), (mu = e))
}
function s4(t, e, n) {
  ;((Yn[Zn++] = Fr), (Yn[Zn++] = jr), (Yn[Zn++] = wo), (wo = t))
  var r = Fr
  t = jr
  var i = 32 - cr(r) - 1
  ;((r &= ~(1 << i)), (n += 1))
  var s = 32 - cr(e) + i
  if (30 < s) {
    var c = i - (i % 5)
    ;((s = (r & ((1 << c) - 1)).toString(32)),
      (r >>= c),
      (i -= c),
      (Fr = (1 << (32 - cr(e) + i)) | (n << i) | r),
      (jr = s + t))
  } else ((Fr = (1 << s) | (n << i) | r), (jr = t))
}
function zf(t) {
  t.return !== null && (Ji(t, 1), s4(t, 1, 0))
}
function Hf(t) {
  for (; t === gu; ) ((gu = hs[--ds]), (hs[ds] = null), (mu = hs[--ds]), (hs[ds] = null))
  for (; t === wo; )
    ((wo = Yn[--Zn]),
      (Yn[Zn] = null),
      (jr = Yn[--Zn]),
      (Yn[Zn] = null),
      (Fr = Yn[--Zn]),
      (Yn[Zn] = null))
}
var Dn = null,
  Tn = null,
  oe = !1,
  lr = null
function a4(t, e) {
  var n = qn(5, null, null, 0)
  ;((n.elementType = 'DELETED'),
    (n.stateNode = e),
    (n.return = t),
    (e = t.deletions),
    e === null ? ((t.deletions = [n]), (t.flags |= 16)) : e.push(n))
}
function bg(t, e) {
  switch (t.tag) {
    case 5:
      var n = t.type
      return (
        (e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e),
        e !== null ? ((t.stateNode = e), (Dn = t), (Tn = Ai(e.firstChild)), !0) : !1
      )
    case 6:
      return (
        (e = t.pendingProps === '' || e.nodeType !== 3 ? null : e),
        e !== null ? ((t.stateNode = e), (Dn = t), (Tn = null), !0) : !1
      )
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((n = wo !== null ? { id: Fr, overflow: jr } : null),
            (t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }),
            (n = qn(18, null, null, 0)),
            (n.stateNode = e),
            (n.return = t),
            (t.child = n),
            (Dn = t),
            (Tn = null),
            !0)
          : !1
      )
    default:
      return !1
  }
}
function x1(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}
function E1(t) {
  if (oe) {
    var e = Tn
    if (e) {
      var n = e
      if (!bg(t, e)) {
        if (x1(t)) throw Error(tt(418))
        e = Ai(n.nextSibling)
        var r = Dn
        e && bg(t, e) ? a4(r, n) : ((t.flags = (t.flags & -4097) | 2), (oe = !1), (Dn = t))
      }
    } else {
      if (x1(t)) throw Error(tt(418))
      ;((t.flags = (t.flags & -4097) | 2), (oe = !1), (Dn = t))
    }
  }
}
function vg(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; ) t = t.return
  Dn = t
}
function fc(t) {
  if (t !== Dn) return !1
  if (!oe) return (vg(t), (oe = !0), !1)
  var e
  if (
    ((e = t.tag !== 3) &&
      !(e = t.tag !== 5) &&
      ((e = t.type), (e = e !== 'head' && e !== 'body' && !y1(t.type, t.memoizedProps))),
    e && (e = Tn))
  ) {
    if (x1(t)) throw (l4(), Error(tt(418)))
    for (; e; ) (a4(t, e), (e = Ai(e.nextSibling)))
  }
  if ((vg(t), t.tag === 13)) {
    if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t)) throw Error(tt(317))
    t: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var n = t.data
          if (n === '/$') {
            if (e === 0) {
              Tn = Ai(t.nextSibling)
              break t
            }
            e--
          } else (n !== '$' && n !== '$!' && n !== '$?') || e++
        }
        t = t.nextSibling
      }
      Tn = null
    }
  } else Tn = Dn ? Ai(t.stateNode.nextSibling) : null
  return !0
}
function l4() {
  for (var t = Tn; t; ) t = Ai(t.nextSibling)
}
function Ms() {
  ;((Tn = Dn = null), (oe = !1))
}
function Xf(t) {
  lr === null ? (lr = [t]) : lr.push(t)
}
var Px = Kr.ReactCurrentBatchConfig
function ya(t, e, n) {
  if (((t = n.ref), t !== null && typeof t != 'function' && typeof t != 'object')) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(tt(309))
        var r = n.stateNode
      }
      if (!r) throw Error(tt(147, t))
      var i = r,
        s = '' + t
      return e !== null && e.ref !== null && typeof e.ref == 'function' && e.ref._stringRef === s
        ? e.ref
        : ((e = function (c) {
            var h = i.refs
            c === null ? delete h[s] : (h[s] = c)
          }),
          (e._stringRef = s),
          e)
    }
    if (typeof t != 'string') throw Error(tt(284))
    if (!n._owner) throw Error(tt(290, t))
  }
  return t
}
function pc(t, e) {
  throw (
    (t = Object.prototype.toString.call(e)),
    Error(
      tt(31, t === '[object Object]' ? 'object with keys {' + Object.keys(e).join(', ') + '}' : t)
    )
  )
}
function xg(t) {
  var e = t._init
  return e(t._payload)
}
function c4(t) {
  function e(_, N) {
    if (t) {
      var M = _.deletions
      M === null ? ((_.deletions = [N]), (_.flags |= 16)) : M.push(N)
    }
  }
  function n(_, N) {
    if (!t) return null
    for (; N !== null; ) (e(_, N), (N = N.sibling))
    return null
  }
  function r(_, N) {
    for (_ = new Map(); N !== null; )
      (N.key !== null ? _.set(N.key, N) : _.set(N.index, N), (N = N.sibling))
    return _
  }
  function i(_, N) {
    return ((_ = Ri(_, N)), (_.index = 0), (_.sibling = null), _)
  }
  function s(_, N, M) {
    return (
      (_.index = M),
      t
        ? ((M = _.alternate),
          M !== null ? ((M = M.index), M < N ? ((_.flags |= 2), N) : M) : ((_.flags |= 2), N))
        : ((_.flags |= 1048576), N)
    )
  }
  function c(_) {
    return (t && _.alternate === null && (_.flags |= 2), _)
  }
  function h(_, N, M, O) {
    return N === null || N.tag !== 6
      ? ((N = yd(M, _.mode, O)), (N.return = _), N)
      : ((N = i(N, M)), (N.return = _), N)
  }
  function f(_, N, M, O) {
    var F = M.type
    return F === os
      ? y(_, N, M.props.children, O, M.key)
      : N !== null &&
          (N.elementType === F ||
            (typeof F == 'object' && F !== null && F.$$typeof === ci && xg(F) === N.type))
        ? ((O = i(N, M.props)), (O.ref = ya(_, N, M)), (O.return = _), O)
        : ((O = Yc(M.type, M.key, M.props, null, _.mode, O)),
          (O.ref = ya(_, N, M)),
          (O.return = _),
          O)
  }
  function p(_, N, M, O) {
    return N === null ||
      N.tag !== 4 ||
      N.stateNode.containerInfo !== M.containerInfo ||
      N.stateNode.implementation !== M.implementation
      ? ((N = wd(M, _.mode, O)), (N.return = _), N)
      : ((N = i(N, M.children || [])), (N.return = _), N)
  }
  function y(_, N, M, O, F) {
    return N === null || N.tag !== 7
      ? ((N = ho(M, _.mode, O, F)), (N.return = _), N)
      : ((N = i(N, M)), (N.return = _), N)
  }
  function w(_, N, M) {
    if ((typeof N == 'string' && N !== '') || typeof N == 'number')
      return ((N = yd('' + N, _.mode, M)), (N.return = _), N)
    if (typeof N == 'object' && N !== null) {
      switch (N.$$typeof) {
        case rc:
          return (
            (M = Yc(N.type, N.key, N.props, null, _.mode, M)),
            (M.ref = ya(_, null, N)),
            (M.return = _),
            M
          )
        case is:
          return ((N = wd(N, _.mode, M)), (N.return = _), N)
        case ci:
          var O = N._init
          return w(_, O(N._payload), M)
      }
      if (Ia(N) || da(N)) return ((N = ho(N, _.mode, M, null)), (N.return = _), N)
      pc(_, N)
    }
    return null
  }
  function x(_, N, M, O) {
    var F = N !== null ? N.key : null
    if ((typeof M == 'string' && M !== '') || typeof M == 'number')
      return F !== null ? null : h(_, N, '' + M, O)
    if (typeof M == 'object' && M !== null) {
      switch (M.$$typeof) {
        case rc:
          return M.key === F ? f(_, N, M, O) : null
        case is:
          return M.key === F ? p(_, N, M, O) : null
        case ci:
          return ((F = M._init), x(_, N, F(M._payload), O))
      }
      if (Ia(M) || da(M)) return F !== null ? null : y(_, N, M, O, null)
      pc(_, M)
    }
    return null
  }
  function E(_, N, M, O, F) {
    if ((typeof O == 'string' && O !== '') || typeof O == 'number')
      return ((_ = _.get(M) || null), h(N, _, '' + O, F))
    if (typeof O == 'object' && O !== null) {
      switch (O.$$typeof) {
        case rc:
          return ((_ = _.get(O.key === null ? M : O.key) || null), f(N, _, O, F))
        case is:
          return ((_ = _.get(O.key === null ? M : O.key) || null), p(N, _, O, F))
        case ci:
          var z = O._init
          return E(_, N, M, z(O._payload), F)
      }
      if (Ia(O) || da(O)) return ((_ = _.get(M) || null), y(N, _, O, F, null))
      pc(N, O)
    }
    return null
  }
  function S(_, N, M, O) {
    for (var F = null, z = null, V = N, W = (N = 0), Z = null; V !== null && W < M.length; W++) {
      V.index > W ? ((Z = V), (V = null)) : (Z = V.sibling)
      var J = x(_, V, M[W], O)
      if (J === null) {
        V === null && (V = Z)
        break
      }
      ;(t && V && J.alternate === null && e(_, V),
        (N = s(J, N, W)),
        z === null ? (F = J) : (z.sibling = J),
        (z = J),
        (V = Z))
    }
    if (W === M.length) return (n(_, V), oe && Ji(_, W), F)
    if (V === null) {
      for (; W < M.length; W++)
        ((V = w(_, M[W], O)),
          V !== null && ((N = s(V, N, W)), z === null ? (F = V) : (z.sibling = V), (z = V)))
      return (oe && Ji(_, W), F)
    }
    for (V = r(_, V); W < M.length; W++)
      ((Z = E(V, _, W, M[W], O)),
        Z !== null &&
          (t && Z.alternate !== null && V.delete(Z.key === null ? W : Z.key),
          (N = s(Z, N, W)),
          z === null ? (F = Z) : (z.sibling = Z),
          (z = Z)))
    return (
      t &&
        V.forEach(function (st) {
          return e(_, st)
        }),
      oe && Ji(_, W),
      F
    )
  }
  function k(_, N, M, O) {
    var F = da(M)
    if (typeof F != 'function') throw Error(tt(150))
    if (((M = F.call(M)), M == null)) throw Error(tt(151))
    for (
      var z = (F = null), V = N, W = (N = 0), Z = null, J = M.next();
      V !== null && !J.done;
      W++, J = M.next()
    ) {
      V.index > W ? ((Z = V), (V = null)) : (Z = V.sibling)
      var st = x(_, V, J.value, O)
      if (st === null) {
        V === null && (V = Z)
        break
      }
      ;(t && V && st.alternate === null && e(_, V),
        (N = s(st, N, W)),
        z === null ? (F = st) : (z.sibling = st),
        (z = st),
        (V = Z))
    }
    if (J.done) return (n(_, V), oe && Ji(_, W), F)
    if (V === null) {
      for (; !J.done; W++, J = M.next())
        ((J = w(_, J.value, O)),
          J !== null && ((N = s(J, N, W)), z === null ? (F = J) : (z.sibling = J), (z = J)))
      return (oe && Ji(_, W), F)
    }
    for (V = r(_, V); !J.done; W++, J = M.next())
      ((J = E(V, _, W, J.value, O)),
        J !== null &&
          (t && J.alternate !== null && V.delete(J.key === null ? W : J.key),
          (N = s(J, N, W)),
          z === null ? (F = J) : (z.sibling = J),
          (z = J)))
    return (
      t &&
        V.forEach(function (rt) {
          return e(_, rt)
        }),
      oe && Ji(_, W),
      F
    )
  }
  function D(_, N, M, O) {
    if (
      (typeof M == 'object' &&
        M !== null &&
        M.type === os &&
        M.key === null &&
        (M = M.props.children),
      typeof M == 'object' && M !== null)
    ) {
      switch (M.$$typeof) {
        case rc:
          t: {
            for (var F = M.key, z = N; z !== null; ) {
              if (z.key === F) {
                if (((F = M.type), F === os)) {
                  if (z.tag === 7) {
                    ;(n(_, z.sibling), (N = i(z, M.props.children)), (N.return = _), (_ = N))
                    break t
                  }
                } else if (
                  z.elementType === F ||
                  (typeof F == 'object' && F !== null && F.$$typeof === ci && xg(F) === z.type)
                ) {
                  ;(n(_, z.sibling),
                    (N = i(z, M.props)),
                    (N.ref = ya(_, z, M)),
                    (N.return = _),
                    (_ = N))
                  break t
                }
                n(_, z)
                break
              } else e(_, z)
              z = z.sibling
            }
            M.type === os
              ? ((N = ho(M.props.children, _.mode, O, M.key)), (N.return = _), (_ = N))
              : ((O = Yc(M.type, M.key, M.props, null, _.mode, O)),
                (O.ref = ya(_, N, M)),
                (O.return = _),
                (_ = O))
          }
          return c(_)
        case is:
          t: {
            for (z = M.key; N !== null; ) {
              if (N.key === z)
                if (
                  N.tag === 4 &&
                  N.stateNode.containerInfo === M.containerInfo &&
                  N.stateNode.implementation === M.implementation
                ) {
                  ;(n(_, N.sibling), (N = i(N, M.children || [])), (N.return = _), (_ = N))
                  break t
                } else {
                  n(_, N)
                  break
                }
              else e(_, N)
              N = N.sibling
            }
            ;((N = wd(M, _.mode, O)), (N.return = _), (_ = N))
          }
          return c(_)
        case ci:
          return ((z = M._init), D(_, N, z(M._payload), O))
      }
      if (Ia(M)) return S(_, N, M, O)
      if (da(M)) return k(_, N, M, O)
      pc(_, M)
    }
    return (typeof M == 'string' && M !== '') || typeof M == 'number'
      ? ((M = '' + M),
        N !== null && N.tag === 6
          ? (n(_, N.sibling), (N = i(N, M)), (N.return = _), (_ = N))
          : (n(_, N), (N = yd(M, _.mode, O)), (N.return = _), (_ = N)),
        c(_))
      : n(_, N)
  }
  return D
}
var Ds = c4(!0),
  u4 = c4(!1),
  yu = Fi(null),
  wu = null,
  fs = null,
  Gf = null
function Yf() {
  Gf = fs = wu = null
}
function Zf(t) {
  var e = yu.current
  ;(ne(yu), (t._currentValue = e))
}
function C1(t, e, n) {
  for (; t !== null; ) {
    var r = t.alternate
    if (
      ((t.childLanes & e) !== e
        ? ((t.childLanes |= e), r !== null && (r.childLanes |= e))
        : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
      t === n)
    )
      break
    t = t.return
  }
}
function Is(t, e) {
  ;((wu = t),
    (Gf = fs = null),
    (t = t.dependencies),
    t !== null && t.firstContext !== null && (t.lanes & e && (bn = !0), (t.firstContext = null)))
}
function $n(t) {
  var e = t._currentValue
  if (Gf !== t)
    if (((t = { context: t, memoizedValue: e, next: null }), fs === null)) {
      if (wu === null) throw Error(tt(308))
      ;((fs = t), (wu.dependencies = { lanes: 0, firstContext: t }))
    } else fs = fs.next = t
  return e
}
var so = null
function qf(t) {
  so === null ? (so = [t]) : so.push(t)
}
function h4(t, e, n, r) {
  var i = e.interleaved
  return (
    i === null ? ((n.next = n), qf(e)) : ((n.next = i.next), (i.next = n)),
    (e.interleaved = n),
    Yr(t, r)
  )
}
function Yr(t, e) {
  t.lanes |= e
  var n = t.alternate
  for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
    ((t.childLanes |= e),
      (n = t.alternate),
      n !== null && (n.childLanes |= e),
      (n = t),
      (t = t.return))
  return n.tag === 3 ? n.stateNode : null
}
var ui = !1
function Kf(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  }
}
function d4(t, e) {
  ;((t = t.updateQueue),
    e.updateQueue === t &&
      (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects,
      }))
}
function Ur(t, e) {
  return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null }
}
function ki(t, e, n) {
  var r = t.updateQueue
  if (r === null) return null
  if (((r = r.shared), Lt & 2)) {
    var i = r.pending
    return (
      i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)),
      (r.pending = e),
      Yr(t, n)
    )
  }
  return (
    (i = r.interleaved),
    i === null ? ((e.next = e), qf(r)) : ((e.next = i.next), (i.next = e)),
    (r.interleaved = e),
    Yr(t, n)
  )
}
function Wc(t, e, n) {
  if (((e = e.updateQueue), e !== null && ((e = e.shared), (n & 4194240) !== 0))) {
    var r = e.lanes
    ;((r &= t.pendingLanes), (n |= r), (e.lanes = n), Lf(t, n))
  }
}
function Eg(t, e) {
  var n = t.updateQueue,
    r = t.alternate
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      s = null
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var c = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        }
        ;(s === null ? (i = s = c) : (s = s.next = c), (n = n.next))
      } while (n !== null)
      s === null ? (i = s = e) : (s = s.next = e)
    } else i = s = e
    ;((n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects,
    }),
      (t.updateQueue = n))
    return
  }
  ;((t = n.lastBaseUpdate),
    t === null ? (n.firstBaseUpdate = e) : (t.next = e),
    (n.lastBaseUpdate = e))
}
function bu(t, e, n, r) {
  var i = t.updateQueue
  ui = !1
  var s = i.firstBaseUpdate,
    c = i.lastBaseUpdate,
    h = i.shared.pending
  if (h !== null) {
    i.shared.pending = null
    var f = h,
      p = f.next
    ;((f.next = null), c === null ? (s = p) : (c.next = p), (c = f))
    var y = t.alternate
    y !== null &&
      ((y = y.updateQueue),
      (h = y.lastBaseUpdate),
      h !== c && (h === null ? (y.firstBaseUpdate = p) : (h.next = p), (y.lastBaseUpdate = f)))
  }
  if (s !== null) {
    var w = i.baseState
    ;((c = 0), (y = p = f = null), (h = s))
    do {
      var x = h.lane,
        E = h.eventTime
      if ((r & x) === x) {
        y !== null &&
          (y = y.next =
            {
              eventTime: E,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null,
            })
        t: {
          var S = t,
            k = h
          switch (((x = e), (E = n), k.tag)) {
            case 1:
              if (((S = k.payload), typeof S == 'function')) {
                w = S.call(E, w, x)
                break t
              }
              w = S
              break t
            case 3:
              S.flags = (S.flags & -65537) | 128
            case 0:
              if (((S = k.payload), (x = typeof S == 'function' ? S.call(E, w, x) : S), x == null))
                break t
              w = de({}, w, x)
              break t
            case 2:
              ui = !0
          }
        }
        h.callback !== null &&
          h.lane !== 0 &&
          ((t.flags |= 64), (x = i.effects), x === null ? (i.effects = [h]) : x.push(h))
      } else
        ((E = {
          eventTime: E,
          lane: x,
          tag: h.tag,
          payload: h.payload,
          callback: h.callback,
          next: null,
        }),
          y === null ? ((p = y = E), (f = w)) : (y = y.next = E),
          (c |= x))
      if (((h = h.next), h === null)) {
        if (((h = i.shared.pending), h === null)) break
        ;((x = h), (h = x.next), (x.next = null), (i.lastBaseUpdate = x), (i.shared.pending = null))
      }
    } while (!0)
    if (
      (y === null && (f = w),
      (i.baseState = f),
      (i.firstBaseUpdate = p),
      (i.lastBaseUpdate = y),
      (e = i.shared.interleaved),
      e !== null)
    ) {
      i = e
      do ((c |= i.lane), (i = i.next))
      while (i !== e)
    } else s === null && (i.shared.lanes = 0)
    ;((vo |= c), (t.lanes = c), (t.memoizedState = w))
  }
}
function Cg(t, e, n) {
  if (((t = e.effects), (e.effects = null), t !== null))
    for (e = 0; e < t.length; e++) {
      var r = t[e],
        i = r.callback
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != 'function')) throw Error(tt(191, i))
        i.call(r)
      }
    }
}
var Ll = {},
  kr = Fi(Ll),
  dl = Fi(Ll),
  fl = Fi(Ll)
function ao(t) {
  if (t === Ll) throw Error(tt(174))
  return t
}
function Qf(t, e) {
  switch (($t(fl, e), $t(dl, t), $t(kr, Ll), (t = e.nodeType), t)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : r1(null, '')
      break
    default:
      ;((t = t === 8 ? e.parentNode : e),
        (e = t.namespaceURI || null),
        (t = t.tagName),
        (e = r1(e, t)))
  }
  ;(ne(kr), $t(kr, e))
}
function Ps() {
  ;(ne(kr), ne(dl), ne(fl))
}
function f4(t) {
  ao(fl.current)
  var e = ao(kr.current),
    n = r1(e, t.type)
  e !== n && ($t(dl, t), $t(kr, n))
}
function $f(t) {
  dl.current === t && (ne(kr), ne(dl))
}
var ae = Fi(0)
function vu(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var n = e.memoizedState
      if (n !== null && ((n = n.dehydrated), n === null || n.data === '$?' || n.data === '$!'))
        return e
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e
    } else if (e.child !== null) {
      ;((e.child.return = e), (e = e.child))
      continue
    }
    if (e === t) break
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null
      e = e.return
    }
    ;((e.sibling.return = e.return), (e = e.sibling))
  }
  return null
}
var hd = []
function Jf() {
  for (var t = 0; t < hd.length; t++) hd[t]._workInProgressVersionPrimary = null
  hd.length = 0
}
var Uc = Kr.ReactCurrentDispatcher,
  dd = Kr.ReactCurrentBatchConfig,
  bo = 0,
  ue = null,
  _e = null,
  Pe = null,
  xu = !1,
  Wa = !1,
  pl = 0,
  Lx = 0
function qe() {
  throw Error(tt(321))
}
function t0(t, e) {
  if (e === null) return !1
  for (var n = 0; n < e.length && n < t.length; n++) if (!hr(t[n], e[n])) return !1
  return !0
}
function e0(t, e, n, r, i, s) {
  if (
    ((bo = s),
    (ue = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Uc.current = t === null || t.memoizedState === null ? jx : Vx),
    (t = n(r, i)),
    Wa)
  ) {
    s = 0
    do {
      if (((Wa = !1), (pl = 0), 25 <= s)) throw Error(tt(301))
      ;((s += 1), (Pe = _e = null), (e.updateQueue = null), (Uc.current = Wx), (t = n(r, i)))
    } while (Wa)
  }
  if (
    ((Uc.current = Eu),
    (e = _e !== null && _e.next !== null),
    (bo = 0),
    (Pe = _e = ue = null),
    (xu = !1),
    e)
  )
    throw Error(tt(300))
  return t
}
function n0() {
  var t = pl !== 0
  return ((pl = 0), t)
}
function Er() {
  var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
  return (Pe === null ? (ue.memoizedState = Pe = t) : (Pe = Pe.next = t), Pe)
}
function Jn() {
  if (_e === null) {
    var t = ue.alternate
    t = t !== null ? t.memoizedState : null
  } else t = _e.next
  var e = Pe === null ? ue.memoizedState : Pe.next
  if (e !== null) ((Pe = e), (_e = t))
  else {
    if (t === null) throw Error(tt(310))
    ;((_e = t),
      (t = {
        memoizedState: _e.memoizedState,
        baseState: _e.baseState,
        baseQueue: _e.baseQueue,
        queue: _e.queue,
        next: null,
      }),
      Pe === null ? (ue.memoizedState = Pe = t) : (Pe = Pe.next = t))
  }
  return Pe
}
function gl(t, e) {
  return typeof e == 'function' ? e(t) : e
}
function fd(t) {
  var e = Jn(),
    n = e.queue
  if (n === null) throw Error(tt(311))
  n.lastRenderedReducer = t
  var r = _e,
    i = r.baseQueue,
    s = n.pending
  if (s !== null) {
    if (i !== null) {
      var c = i.next
      ;((i.next = s.next), (s.next = c))
    }
    ;((r.baseQueue = i = s), (n.pending = null))
  }
  if (i !== null) {
    ;((s = i.next), (r = r.baseState))
    var h = (c = null),
      f = null,
      p = s
    do {
      var y = p.lane
      if ((bo & y) === y)
        (f !== null &&
          (f = f.next =
            {
              lane: 0,
              action: p.action,
              hasEagerState: p.hasEagerState,
              eagerState: p.eagerState,
              next: null,
            }),
          (r = p.hasEagerState ? p.eagerState : t(r, p.action)))
      else {
        var w = {
          lane: y,
          action: p.action,
          hasEagerState: p.hasEagerState,
          eagerState: p.eagerState,
          next: null,
        }
        ;(f === null ? ((h = f = w), (c = r)) : (f = f.next = w), (ue.lanes |= y), (vo |= y))
      }
      p = p.next
    } while (p !== null && p !== s)
    ;(f === null ? (c = r) : (f.next = h),
      hr(r, e.memoizedState) || (bn = !0),
      (e.memoizedState = r),
      (e.baseState = c),
      (e.baseQueue = f),
      (n.lastRenderedState = r))
  }
  if (((t = n.interleaved), t !== null)) {
    i = t
    do ((s = i.lane), (ue.lanes |= s), (vo |= s), (i = i.next))
    while (i !== t)
  } else i === null && (n.lanes = 0)
  return [e.memoizedState, n.dispatch]
}
function pd(t) {
  var e = Jn(),
    n = e.queue
  if (n === null) throw Error(tt(311))
  n.lastRenderedReducer = t
  var r = n.dispatch,
    i = n.pending,
    s = e.memoizedState
  if (i !== null) {
    n.pending = null
    var c = (i = i.next)
    do ((s = t(s, c.action)), (c = c.next))
    while (c !== i)
    ;(hr(s, e.memoizedState) || (bn = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (n.lastRenderedState = s))
  }
  return [s, r]
}
function p4() {}
function g4(t, e) {
  var n = ue,
    r = Jn(),
    i = e(),
    s = !hr(r.memoizedState, i)
  if (
    (s && ((r.memoizedState = i), (bn = !0)),
    (r = r.queue),
    r0(w4.bind(null, n, r, t), [t]),
    r.getSnapshot !== e || s || (Pe !== null && Pe.memoizedState.tag & 1))
  ) {
    if (((n.flags |= 2048), ml(9, y4.bind(null, n, r, i, e), void 0, null), Le === null))
      throw Error(tt(349))
    bo & 30 || m4(n, e, i)
  }
  return i
}
function m4(t, e, n) {
  ;((t.flags |= 16384),
    (t = { getSnapshot: e, value: n }),
    (e = ue.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }), (ue.updateQueue = e), (e.stores = [t]))
      : ((n = e.stores), n === null ? (e.stores = [t]) : n.push(t)))
}
function y4(t, e, n, r) {
  ;((e.value = n), (e.getSnapshot = r), b4(e) && v4(t))
}
function w4(t, e, n) {
  return n(function () {
    b4(e) && v4(t)
  })
}
function b4(t) {
  var e = t.getSnapshot
  t = t.value
  try {
    var n = e()
    return !hr(t, n)
  } catch {
    return !0
  }
}
function v4(t) {
  var e = Yr(t, 1)
  e !== null && ur(e, t, 1, -1)
}
function Sg(t) {
  var e = Er()
  return (
    typeof t == 'function' && (t = t()),
    (e.memoizedState = e.baseState = t),
    (t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: gl,
      lastRenderedState: t,
    }),
    (e.queue = t),
    (t = t.dispatch = Fx.bind(null, ue, t)),
    [e.memoizedState, t]
  )
}
function ml(t, e, n, r) {
  return (
    (t = { tag: t, create: e, destroy: n, deps: r, next: null }),
    (e = ue.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (ue.updateQueue = e),
        (e.lastEffect = t.next = t))
      : ((n = e.lastEffect),
        n === null
          ? (e.lastEffect = t.next = t)
          : ((r = n.next), (n.next = t), (t.next = r), (e.lastEffect = t))),
    t
  )
}
function x4() {
  return Jn().memoizedState
}
function zc(t, e, n, r) {
  var i = Er()
  ;((ue.flags |= t), (i.memoizedState = ml(1 | e, n, void 0, r === void 0 ? null : r)))
}
function eh(t, e, n, r) {
  var i = Jn()
  r = r === void 0 ? null : r
  var s = void 0
  if (_e !== null) {
    var c = _e.memoizedState
    if (((s = c.destroy), r !== null && t0(r, c.deps))) {
      i.memoizedState = ml(e, n, s, r)
      return
    }
  }
  ;((ue.flags |= t), (i.memoizedState = ml(1 | e, n, s, r)))
}
function Ag(t, e) {
  return zc(8390656, 8, t, e)
}
function r0(t, e) {
  return eh(2048, 8, t, e)
}
function E4(t, e) {
  return eh(4, 2, t, e)
}
function C4(t, e) {
  return eh(4, 4, t, e)
}
function S4(t, e) {
  if (typeof e == 'function')
    return (
      (t = t()),
      e(t),
      function () {
        e(null)
      }
    )
  if (e != null)
    return (
      (t = t()),
      (e.current = t),
      function () {
        e.current = null
      }
    )
}
function A4(t, e, n) {
  return ((n = n != null ? n.concat([t]) : null), eh(4, 4, S4.bind(null, e, t), n))
}
function i0() {}
function k4(t, e) {
  var n = Jn()
  e = e === void 0 ? null : e
  var r = n.memoizedState
  return r !== null && e !== null && t0(e, r[1]) ? r[0] : ((n.memoizedState = [t, e]), t)
}
function I4(t, e) {
  var n = Jn()
  e = e === void 0 ? null : e
  var r = n.memoizedState
  return r !== null && e !== null && t0(e, r[1]) ? r[0] : ((t = t()), (n.memoizedState = [t, e]), t)
}
function _4(t, e, n) {
  return bo & 21
    ? (hr(n, e) || ((n = D8()), (ue.lanes |= n), (vo |= n), (t.baseState = !0)), e)
    : (t.baseState && ((t.baseState = !1), (bn = !0)), (t.memoizedState = n))
}
function Ox(t, e) {
  var n = Ht
  ;((Ht = n !== 0 && 4 > n ? n : 4), t(!0))
  var r = dd.transition
  dd.transition = {}
  try {
    ;(t(!1), e())
  } finally {
    ;((Ht = n), (dd.transition = r))
  }
}
function R4() {
  return Jn().memoizedState
}
function Bx(t, e, n) {
  var r = _i(t)
  if (((n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }), T4(t)))
    N4(e, n)
  else if (((n = h4(t, e, n, r)), n !== null)) {
    var i = on()
    ;(ur(n, t, r, i), M4(n, e, r))
  }
}
function Fx(t, e, n) {
  var r = _i(t),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }
  if (T4(t)) N4(e, i)
  else {
    var s = t.alternate
    if (t.lanes === 0 && (s === null || s.lanes === 0) && ((s = e.lastRenderedReducer), s !== null))
      try {
        var c = e.lastRenderedState,
          h = s(c, n)
        if (((i.hasEagerState = !0), (i.eagerState = h), hr(h, c))) {
          var f = e.interleaved
          ;(f === null ? ((i.next = i), qf(e)) : ((i.next = f.next), (f.next = i)),
            (e.interleaved = i))
          return
        }
      } catch {
      } finally {
      }
    ;((n = h4(t, e, i, r)), n !== null && ((i = on()), ur(n, t, r, i), M4(n, e, r)))
  }
}
function T4(t) {
  var e = t.alternate
  return t === ue || (e !== null && e === ue)
}
function N4(t, e) {
  Wa = xu = !0
  var n = t.pending
  ;(n === null ? (e.next = e) : ((e.next = n.next), (n.next = e)), (t.pending = e))
}
function M4(t, e, n) {
  if (n & 4194240) {
    var r = e.lanes
    ;((r &= t.pendingLanes), (n |= r), (e.lanes = n), Lf(t, n))
  }
}
var Eu = {
    readContext: $n,
    useCallback: qe,
    useContext: qe,
    useEffect: qe,
    useImperativeHandle: qe,
    useInsertionEffect: qe,
    useLayoutEffect: qe,
    useMemo: qe,
    useReducer: qe,
    useRef: qe,
    useState: qe,
    useDebugValue: qe,
    useDeferredValue: qe,
    useTransition: qe,
    useMutableSource: qe,
    useSyncExternalStore: qe,
    useId: qe,
    unstable_isNewReconciler: !1,
  },
  jx = {
    readContext: $n,
    useCallback: function (t, e) {
      return ((Er().memoizedState = [t, e === void 0 ? null : e]), t)
    },
    useContext: $n,
    useEffect: Ag,
    useImperativeHandle: function (t, e, n) {
      return ((n = n != null ? n.concat([t]) : null), zc(4194308, 4, S4.bind(null, e, t), n))
    },
    useLayoutEffect: function (t, e) {
      return zc(4194308, 4, t, e)
    },
    useInsertionEffect: function (t, e) {
      return zc(4, 2, t, e)
    },
    useMemo: function (t, e) {
      var n = Er()
      return ((e = e === void 0 ? null : e), (t = t()), (n.memoizedState = [t, e]), t)
    },
    useReducer: function (t, e, n) {
      var r = Er()
      return (
        (e = n !== void 0 ? n(e) : e),
        (r.memoizedState = r.baseState = e),
        (t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: e,
        }),
        (r.queue = t),
        (t = t.dispatch = Bx.bind(null, ue, t)),
        [r.memoizedState, t]
      )
    },
    useRef: function (t) {
      var e = Er()
      return ((t = { current: t }), (e.memoizedState = t))
    },
    useState: Sg,
    useDebugValue: i0,
    useDeferredValue: function (t) {
      return (Er().memoizedState = t)
    },
    useTransition: function () {
      var t = Sg(!1),
        e = t[0]
      return ((t = Ox.bind(null, t[1])), (Er().memoizedState = t), [e, t])
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (t, e, n) {
      var r = ue,
        i = Er()
      if (oe) {
        if (n === void 0) throw Error(tt(407))
        n = n()
      } else {
        if (((n = e()), Le === null)) throw Error(tt(349))
        bo & 30 || m4(r, e, n)
      }
      i.memoizedState = n
      var s = { value: n, getSnapshot: e }
      return (
        (i.queue = s),
        Ag(w4.bind(null, r, s, t), [t]),
        (r.flags |= 2048),
        ml(9, y4.bind(null, r, s, n, e), void 0, null),
        n
      )
    },
    useId: function () {
      var t = Er(),
        e = Le.identifierPrefix
      if (oe) {
        var n = jr,
          r = Fr
        ;((n = (r & ~(1 << (32 - cr(r) - 1))).toString(32) + n),
          (e = ':' + e + 'R' + n),
          (n = pl++),
          0 < n && (e += 'H' + n.toString(32)),
          (e += ':'))
      } else ((n = Lx++), (e = ':' + e + 'r' + n.toString(32) + ':'))
      return (t.memoizedState = e)
    },
    unstable_isNewReconciler: !1,
  },
  Vx = {
    readContext: $n,
    useCallback: k4,
    useContext: $n,
    useEffect: r0,
    useImperativeHandle: A4,
    useInsertionEffect: E4,
    useLayoutEffect: C4,
    useMemo: I4,
    useReducer: fd,
    useRef: x4,
    useState: function () {
      return fd(gl)
    },
    useDebugValue: i0,
    useDeferredValue: function (t) {
      var e = Jn()
      return _4(e, _e.memoizedState, t)
    },
    useTransition: function () {
      var t = fd(gl)[0],
        e = Jn().memoizedState
      return [t, e]
    },
    useMutableSource: p4,
    useSyncExternalStore: g4,
    useId: R4,
    unstable_isNewReconciler: !1,
  },
  Wx = {
    readContext: $n,
    useCallback: k4,
    useContext: $n,
    useEffect: r0,
    useImperativeHandle: A4,
    useInsertionEffect: E4,
    useLayoutEffect: C4,
    useMemo: I4,
    useReducer: pd,
    useRef: x4,
    useState: function () {
      return pd(gl)
    },
    useDebugValue: i0,
    useDeferredValue: function (t) {
      var e = Jn()
      return _e === null ? (e.memoizedState = t) : _4(e, _e.memoizedState, t)
    },
    useTransition: function () {
      var t = pd(gl)[0],
        e = Jn().memoizedState
      return [t, e]
    },
    useMutableSource: p4,
    useSyncExternalStore: g4,
    useId: R4,
    unstable_isNewReconciler: !1,
  }
function sr(t, e) {
  if (t && t.defaultProps) {
    ;((e = de({}, e)), (t = t.defaultProps))
    for (var n in t) e[n] === void 0 && (e[n] = t[n])
    return e
  }
  return e
}
function S1(t, e, n, r) {
  ;((e = t.memoizedState),
    (n = n(r, e)),
    (n = n == null ? e : de({}, e, n)),
    (t.memoizedState = n),
    t.lanes === 0 && (t.updateQueue.baseState = n))
}
var nh = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? Io(t) === t : !1
  },
  enqueueSetState: function (t, e, n) {
    t = t._reactInternals
    var r = on(),
      i = _i(t),
      s = Ur(r, i)
    ;((s.payload = e),
      n != null && (s.callback = n),
      (e = ki(t, s, i)),
      e !== null && (ur(e, t, i, r), Wc(e, t, i)))
  },
  enqueueReplaceState: function (t, e, n) {
    t = t._reactInternals
    var r = on(),
      i = _i(t),
      s = Ur(r, i)
    ;((s.tag = 1),
      (s.payload = e),
      n != null && (s.callback = n),
      (e = ki(t, s, i)),
      e !== null && (ur(e, t, i, r), Wc(e, t, i)))
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals
    var n = on(),
      r = _i(t),
      i = Ur(n, r)
    ;((i.tag = 2),
      e != null && (i.callback = e),
      (e = ki(t, i, r)),
      e !== null && (ur(e, t, r, n), Wc(e, t, r)))
  },
}
function kg(t, e, n, r, i, s, c) {
  return (
    (t = t.stateNode),
    typeof t.shouldComponentUpdate == 'function'
      ? t.shouldComponentUpdate(r, s, c)
      : e.prototype && e.prototype.isPureReactComponent
        ? !ll(n, r) || !ll(i, s)
        : !0
  )
}
function D4(t, e, n) {
  var r = !1,
    i = Di,
    s = e.contextType
  return (
    typeof s == 'object' && s !== null
      ? (s = $n(s))
      : ((i = xn(e) ? yo : tn.current),
        (r = e.contextTypes),
        (s = (r = r != null) ? Ns(t, i) : Di)),
    (e = new e(n, s)),
    (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = nh),
    (t.stateNode = e),
    (e._reactInternals = t),
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = i),
      (t.__reactInternalMemoizedMaskedChildContext = s)),
    e
  )
}
function Ig(t, e, n, r) {
  ;((t = e.state),
    typeof e.componentWillReceiveProps == 'function' && e.componentWillReceiveProps(n, r),
    typeof e.UNSAFE_componentWillReceiveProps == 'function' &&
      e.UNSAFE_componentWillReceiveProps(n, r),
    e.state !== t && nh.enqueueReplaceState(e, e.state, null))
}
function A1(t, e, n, r) {
  var i = t.stateNode
  ;((i.props = n), (i.state = t.memoizedState), (i.refs = {}), Kf(t))
  var s = e.contextType
  ;(typeof s == 'object' && s !== null
    ? (i.context = $n(s))
    : ((s = xn(e) ? yo : tn.current), (i.context = Ns(t, s))),
    (i.state = t.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == 'function' && (S1(t, e, s, n), (i.state = t.memoizedState)),
    typeof e.getDerivedStateFromProps == 'function' ||
      typeof i.getSnapshotBeforeUpdate == 'function' ||
      (typeof i.UNSAFE_componentWillMount != 'function' &&
        typeof i.componentWillMount != 'function') ||
      ((e = i.state),
      typeof i.componentWillMount == 'function' && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == 'function' && i.UNSAFE_componentWillMount(),
      e !== i.state && nh.enqueueReplaceState(i, i.state, null),
      bu(t, n, i, r),
      (i.state = t.memoizedState)),
    typeof i.componentDidMount == 'function' && (t.flags |= 4194308))
}
function Ls(t, e) {
  try {
    var n = '',
      r = e
    do ((n += gv(r)), (r = r.return))
    while (r)
    var i = n
  } catch (s) {
    i =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack
  }
  return { value: t, source: e, stack: i, digest: null }
}
function gd(t, e, n) {
  return { value: t, source: null, stack: n ?? null, digest: e ?? null }
}
function k1(t, e) {
  try {
    console.error(e.value)
  } catch (n) {
    setTimeout(function () {
      throw n
    })
  }
}
var Ux = typeof WeakMap == 'function' ? WeakMap : Map
function P4(t, e, n) {
  ;((n = Ur(-1, n)), (n.tag = 3), (n.payload = { element: null }))
  var r = e.value
  return (
    (n.callback = function () {
      ;(Su || ((Su = !0), (L1 = r)), k1(t, e))
    }),
    n
  )
}
function L4(t, e, n) {
  ;((n = Ur(-1, n)), (n.tag = 3))
  var r = t.type.getDerivedStateFromError
  if (typeof r == 'function') {
    var i = e.value
    ;((n.payload = function () {
      return r(i)
    }),
      (n.callback = function () {
        k1(t, e)
      }))
  }
  var s = t.stateNode
  return (
    s !== null &&
      typeof s.componentDidCatch == 'function' &&
      (n.callback = function () {
        ;(k1(t, e), typeof r != 'function' && (Ii === null ? (Ii = new Set([this])) : Ii.add(this)))
        var c = e.stack
        this.componentDidCatch(e.value, { componentStack: c !== null ? c : '' })
      }),
    n
  )
}
function _g(t, e, n) {
  var r = t.pingCache
  if (r === null) {
    r = t.pingCache = new Ux()
    var i = new Set()
    r.set(e, i)
  } else ((i = r.get(e)), i === void 0 && ((i = new Set()), r.set(e, i)))
  i.has(n) || (i.add(n), (t = nE.bind(null, t, e, n)), e.then(t, t))
}
function Rg(t) {
  do {
    var e
    if (
      ((e = t.tag === 13) && ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return t
    t = t.return
  } while (t !== null)
  return null
}
function Tg(t, e, n, r, i) {
  return t.mode & 1
    ? ((t.flags |= 65536), (t.lanes = i), t)
    : (t === e
        ? (t.flags |= 65536)
        : ((t.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null ? (n.tag = 17) : ((e = Ur(-1, 1)), (e.tag = 2), ki(n, e, 1))),
          (n.lanes |= 1)),
      t)
}
var zx = Kr.ReactCurrentOwner,
  bn = !1
function rn(t, e, n, r) {
  e.child = t === null ? u4(e, null, n, r) : Ds(e, t.child, n, r)
}
function Ng(t, e, n, r, i) {
  n = n.render
  var s = e.ref
  return (
    Is(e, i),
    (r = e0(t, e, n, r, s, i)),
    (n = n0()),
    t !== null && !bn
      ? ((e.updateQueue = t.updateQueue), (e.flags &= -2053), (t.lanes &= ~i), Zr(t, e, i))
      : (oe && n && zf(e), (e.flags |= 1), rn(t, e, r, i), e.child)
  )
}
function Mg(t, e, n, r, i) {
  if (t === null) {
    var s = n.type
    return typeof s == 'function' &&
      !d0(s) &&
      s.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), O4(t, e, s, r, i))
      : ((t = Yc(n.type, null, r, e, e.mode, i)), (t.ref = e.ref), (t.return = e), (e.child = t))
  }
  if (((s = t.child), !(t.lanes & i))) {
    var c = s.memoizedProps
    if (((n = n.compare), (n = n !== null ? n : ll), n(c, r) && t.ref === e.ref)) return Zr(t, e, i)
  }
  return ((e.flags |= 1), (t = Ri(s, r)), (t.ref = e.ref), (t.return = e), (e.child = t))
}
function O4(t, e, n, r, i) {
  if (t !== null) {
    var s = t.memoizedProps
    if (ll(s, r) && t.ref === e.ref)
      if (((bn = !1), (e.pendingProps = r = s), (t.lanes & i) !== 0)) t.flags & 131072 && (bn = !0)
      else return ((e.lanes = t.lanes), Zr(t, e, i))
  }
  return I1(t, e, n, r, i)
}
function B4(t, e, n) {
  var r = e.pendingProps,
    i = r.children,
    s = t !== null ? t.memoizedState : null
  if (r.mode === 'hidden')
    if (!(e.mode & 1))
      ((e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        $t(gs, _n),
        (_n |= n))
    else {
      if (!(n & 1073741824))
        return (
          (t = s !== null ? s.baseLanes | n : n),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }),
          (e.updateQueue = null),
          $t(gs, _n),
          (_n |= t),
          null
        )
      ;((e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = s !== null ? s.baseLanes : n),
        $t(gs, _n),
        (_n |= r))
    }
  else
    (s !== null ? ((r = s.baseLanes | n), (e.memoizedState = null)) : (r = n),
      $t(gs, _n),
      (_n |= r))
  return (rn(t, e, i, n), e.child)
}
function F4(t, e) {
  var n = e.ref
  ;((t === null && n !== null) || (t !== null && t.ref !== n)) &&
    ((e.flags |= 512), (e.flags |= 2097152))
}
function I1(t, e, n, r, i) {
  var s = xn(n) ? yo : tn.current
  return (
    (s = Ns(e, s)),
    Is(e, i),
    (n = e0(t, e, n, r, s, i)),
    (r = n0()),
    t !== null && !bn
      ? ((e.updateQueue = t.updateQueue), (e.flags &= -2053), (t.lanes &= ~i), Zr(t, e, i))
      : (oe && r && zf(e), (e.flags |= 1), rn(t, e, n, i), e.child)
  )
}
function Dg(t, e, n, r, i) {
  if (xn(n)) {
    var s = !0
    pu(e)
  } else s = !1
  if ((Is(e, i), e.stateNode === null)) (Hc(t, e), D4(e, n, r), A1(e, n, r, i), (r = !0))
  else if (t === null) {
    var c = e.stateNode,
      h = e.memoizedProps
    c.props = h
    var f = c.context,
      p = n.contextType
    typeof p == 'object' && p !== null
      ? (p = $n(p))
      : ((p = xn(n) ? yo : tn.current), (p = Ns(e, p)))
    var y = n.getDerivedStateFromProps,
      w = typeof y == 'function' || typeof c.getSnapshotBeforeUpdate == 'function'
    ;(w ||
      (typeof c.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof c.componentWillReceiveProps != 'function') ||
      ((h !== r || f !== p) && Ig(e, c, r, p)),
      (ui = !1))
    var x = e.memoizedState
    ;((c.state = x),
      bu(e, r, c, i),
      (f = e.memoizedState),
      h !== r || x !== f || vn.current || ui
        ? (typeof y == 'function' && (S1(e, n, y, r), (f = e.memoizedState)),
          (h = ui || kg(e, n, h, r, x, f, p))
            ? (w ||
                (typeof c.UNSAFE_componentWillMount != 'function' &&
                  typeof c.componentWillMount != 'function') ||
                (typeof c.componentWillMount == 'function' && c.componentWillMount(),
                typeof c.UNSAFE_componentWillMount == 'function' && c.UNSAFE_componentWillMount()),
              typeof c.componentDidMount == 'function' && (e.flags |= 4194308))
            : (typeof c.componentDidMount == 'function' && (e.flags |= 4194308),
              (e.memoizedProps = r),
              (e.memoizedState = f)),
          (c.props = r),
          (c.state = f),
          (c.context = p),
          (r = h))
        : (typeof c.componentDidMount == 'function' && (e.flags |= 4194308), (r = !1)))
  } else {
    ;((c = e.stateNode),
      d4(t, e),
      (h = e.memoizedProps),
      (p = e.type === e.elementType ? h : sr(e.type, h)),
      (c.props = p),
      (w = e.pendingProps),
      (x = c.context),
      (f = n.contextType),
      typeof f == 'object' && f !== null
        ? (f = $n(f))
        : ((f = xn(n) ? yo : tn.current), (f = Ns(e, f))))
    var E = n.getDerivedStateFromProps
    ;((y = typeof E == 'function' || typeof c.getSnapshotBeforeUpdate == 'function') ||
      (typeof c.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof c.componentWillReceiveProps != 'function') ||
      ((h !== w || x !== f) && Ig(e, c, r, f)),
      (ui = !1),
      (x = e.memoizedState),
      (c.state = x),
      bu(e, r, c, i))
    var S = e.memoizedState
    h !== w || x !== S || vn.current || ui
      ? (typeof E == 'function' && (S1(e, n, E, r), (S = e.memoizedState)),
        (p = ui || kg(e, n, p, r, x, S, f) || !1)
          ? (y ||
              (typeof c.UNSAFE_componentWillUpdate != 'function' &&
                typeof c.componentWillUpdate != 'function') ||
              (typeof c.componentWillUpdate == 'function' && c.componentWillUpdate(r, S, f),
              typeof c.UNSAFE_componentWillUpdate == 'function' &&
                c.UNSAFE_componentWillUpdate(r, S, f)),
            typeof c.componentDidUpdate == 'function' && (e.flags |= 4),
            typeof c.getSnapshotBeforeUpdate == 'function' && (e.flags |= 1024))
          : (typeof c.componentDidUpdate != 'function' ||
              (h === t.memoizedProps && x === t.memoizedState) ||
              (e.flags |= 4),
            typeof c.getSnapshotBeforeUpdate != 'function' ||
              (h === t.memoizedProps && x === t.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = r),
            (e.memoizedState = S)),
        (c.props = r),
        (c.state = S),
        (c.context = f),
        (r = p))
      : (typeof c.componentDidUpdate != 'function' ||
          (h === t.memoizedProps && x === t.memoizedState) ||
          (e.flags |= 4),
        typeof c.getSnapshotBeforeUpdate != 'function' ||
          (h === t.memoizedProps && x === t.memoizedState) ||
          (e.flags |= 1024),
        (r = !1))
  }
  return _1(t, e, n, r, s, i)
}
function _1(t, e, n, r, i, s) {
  F4(t, e)
  var c = (e.flags & 128) !== 0
  if (!r && !c) return (i && wg(e, n, !1), Zr(t, e, s))
  ;((r = e.stateNode), (zx.current = e))
  var h = c && typeof n.getDerivedStateFromError != 'function' ? null : r.render()
  return (
    (e.flags |= 1),
    t !== null && c
      ? ((e.child = Ds(e, t.child, null, s)), (e.child = Ds(e, null, h, s)))
      : rn(t, e, h, s),
    (e.memoizedState = r.state),
    i && wg(e, n, !0),
    e.child
  )
}
function j4(t) {
  var e = t.stateNode
  ;(e.pendingContext
    ? yg(t, e.pendingContext, e.pendingContext !== e.context)
    : e.context && yg(t, e.context, !1),
    Qf(t, e.containerInfo))
}
function Pg(t, e, n, r, i) {
  return (Ms(), Xf(i), (e.flags |= 256), rn(t, e, n, r), e.child)
}
var R1 = { dehydrated: null, treeContext: null, retryLane: 0 }
function T1(t) {
  return { baseLanes: t, cachePool: null, transitions: null }
}
function V4(t, e, n) {
  var r = e.pendingProps,
    i = ae.current,
    s = !1,
    c = (e.flags & 128) !== 0,
    h
  if (
    ((h = c) || (h = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0),
    h ? ((s = !0), (e.flags &= -129)) : (t === null || t.memoizedState !== null) && (i |= 1),
    $t(ae, i & 1),
    t === null)
  )
    return (
      E1(e),
      (t = e.memoizedState),
      t !== null && ((t = t.dehydrated), t !== null)
        ? (e.mode & 1 ? (t.data === '$!' ? (e.lanes = 8) : (e.lanes = 1073741824)) : (e.lanes = 1),
          null)
        : ((c = r.children),
          (t = r.fallback),
          s
            ? ((r = e.mode),
              (s = e.child),
              (c = { mode: 'hidden', children: c }),
              !(r & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = c))
                : (s = oh(c, r, 0, null)),
              (t = ho(t, r, n, null)),
              (s.return = e),
              (t.return = e),
              (s.sibling = t),
              (e.child = s),
              (e.child.memoizedState = T1(n)),
              (e.memoizedState = R1),
              t)
            : o0(e, c))
    )
  if (((i = t.memoizedState), i !== null && ((h = i.dehydrated), h !== null)))
    return Hx(t, e, c, r, h, i, n)
  if (s) {
    ;((s = r.fallback), (c = e.mode), (i = t.child), (h = i.sibling))
    var f = { mode: 'hidden', children: r.children }
    return (
      !(c & 1) && e.child !== i
        ? ((r = e.child), (r.childLanes = 0), (r.pendingProps = f), (e.deletions = null))
        : ((r = Ri(i, f)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      h !== null ? (s = Ri(h, s)) : ((s = ho(s, c, n, null)), (s.flags |= 2)),
      (s.return = e),
      (r.return = e),
      (r.sibling = s),
      (e.child = r),
      (r = s),
      (s = e.child),
      (c = t.child.memoizedState),
      (c =
        c === null
          ? T1(n)
          : { baseLanes: c.baseLanes | n, cachePool: null, transitions: c.transitions }),
      (s.memoizedState = c),
      (s.childLanes = t.childLanes & ~n),
      (e.memoizedState = R1),
      r
    )
  }
  return (
    (s = t.child),
    (t = s.sibling),
    (r = Ri(s, { mode: 'visible', children: r.children })),
    !(e.mode & 1) && (r.lanes = n),
    (r.return = e),
    (r.sibling = null),
    t !== null &&
      ((n = e.deletions), n === null ? ((e.deletions = [t]), (e.flags |= 16)) : n.push(t)),
    (e.child = r),
    (e.memoizedState = null),
    r
  )
}
function o0(t, e) {
  return (
    (e = oh({ mode: 'visible', children: e }, t.mode, 0, null)),
    (e.return = t),
    (t.child = e)
  )
}
function gc(t, e, n, r) {
  return (
    r !== null && Xf(r),
    Ds(e, t.child, null, n),
    (t = o0(e, e.pendingProps.children)),
    (t.flags |= 2),
    (e.memoizedState = null),
    t
  )
}
function Hx(t, e, n, r, i, s, c) {
  if (n)
    return e.flags & 256
      ? ((e.flags &= -257), (r = gd(Error(tt(422)))), gc(t, e, c, r))
      : e.memoizedState !== null
        ? ((e.child = t.child), (e.flags |= 128), null)
        : ((s = r.fallback),
          (i = e.mode),
          (r = oh({ mode: 'visible', children: r.children }, i, 0, null)),
          (s = ho(s, i, c, null)),
          (s.flags |= 2),
          (r.return = e),
          (s.return = e),
          (r.sibling = s),
          (e.child = r),
          e.mode & 1 && Ds(e, t.child, null, c),
          (e.child.memoizedState = T1(c)),
          (e.memoizedState = R1),
          s)
  if (!(e.mode & 1)) return gc(t, e, c, null)
  if (i.data === '$!') {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var h = r.dgst
    return ((r = h), (s = Error(tt(419))), (r = gd(s, r, void 0)), gc(t, e, c, r))
  }
  if (((h = (c & t.childLanes) !== 0), bn || h)) {
    if (((r = Le), r !== null)) {
      switch (c & -c) {
        case 4:
          i = 2
          break
        case 16:
          i = 8
          break
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32
          break
        case 536870912:
          i = 268435456
          break
        default:
          i = 0
      }
      ;((i = i & (r.suspendedLanes | c) ? 0 : i),
        i !== 0 && i !== s.retryLane && ((s.retryLane = i), Yr(t, i), ur(r, t, i, -1)))
    }
    return (h0(), (r = gd(Error(tt(421)))), gc(t, e, c, r))
  }
  return i.data === '$?'
    ? ((e.flags |= 128), (e.child = t.child), (e = rE.bind(null, t)), (i._reactRetry = e), null)
    : ((t = s.treeContext),
      (Tn = Ai(i.nextSibling)),
      (Dn = e),
      (oe = !0),
      (lr = null),
      t !== null &&
        ((Yn[Zn++] = Fr),
        (Yn[Zn++] = jr),
        (Yn[Zn++] = wo),
        (Fr = t.id),
        (jr = t.overflow),
        (wo = e)),
      (e = o0(e, r.children)),
      (e.flags |= 4096),
      e)
}
function Lg(t, e, n) {
  t.lanes |= e
  var r = t.alternate
  ;(r !== null && (r.lanes |= e), C1(t.return, e, n))
}
function md(t, e, n, r, i) {
  var s = t.memoizedState
  s === null
    ? (t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = r),
      (s.tail = n),
      (s.tailMode = i))
}
function W4(t, e, n) {
  var r = e.pendingProps,
    i = r.revealOrder,
    s = r.tail
  if ((rn(t, e, r.children, n), (r = ae.current), r & 2)) ((r = (r & 1) | 2), (e.flags |= 128))
  else {
    if (t !== null && t.flags & 128)
      t: for (t = e.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && Lg(t, n, e)
        else if (t.tag === 19) Lg(t, n, e)
        else if (t.child !== null) {
          ;((t.child.return = t), (t = t.child))
          continue
        }
        if (t === e) break t
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) break t
          t = t.return
        }
        ;((t.sibling.return = t.return), (t = t.sibling))
      }
    r &= 1
  }
  if (($t(ae, r), !(e.mode & 1))) e.memoizedState = null
  else
    switch (i) {
      case 'forwards':
        for (n = e.child, i = null; n !== null; )
          ((t = n.alternate), t !== null && vu(t) === null && (i = n), (n = n.sibling))
        ;((n = i),
          n === null ? ((i = e.child), (e.child = null)) : ((i = n.sibling), (n.sibling = null)),
          md(e, !1, i, n, s))
        break
      case 'backwards':
        for (n = null, i = e.child, e.child = null; i !== null; ) {
          if (((t = i.alternate), t !== null && vu(t) === null)) {
            e.child = i
            break
          }
          ;((t = i.sibling), (i.sibling = n), (n = i), (i = t))
        }
        md(e, !0, n, null, s)
        break
      case 'together':
        md(e, !1, null, null, void 0)
        break
      default:
        e.memoizedState = null
    }
  return e.child
}
function Hc(t, e) {
  !(e.mode & 1) && t !== null && ((t.alternate = null), (e.alternate = null), (e.flags |= 2))
}
function Zr(t, e, n) {
  if ((t !== null && (e.dependencies = t.dependencies), (vo |= e.lanes), !(n & e.childLanes)))
    return null
  if (t !== null && e.child !== t.child) throw Error(tt(153))
  if (e.child !== null) {
    for (t = e.child, n = Ri(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null; )
      ((t = t.sibling), (n = n.sibling = Ri(t, t.pendingProps)), (n.return = e))
    n.sibling = null
  }
  return e.child
}
function Xx(t, e, n) {
  switch (e.tag) {
    case 3:
      ;(j4(e), Ms())
      break
    case 5:
      f4(e)
      break
    case 1:
      xn(e.type) && pu(e)
      break
    case 4:
      Qf(e, e.stateNode.containerInfo)
      break
    case 10:
      var r = e.type._context,
        i = e.memoizedProps.value
      ;($t(yu, r._currentValue), (r._currentValue = i))
      break
    case 13:
      if (((r = e.memoizedState), r !== null))
        return r.dehydrated !== null
          ? ($t(ae, ae.current & 1), (e.flags |= 128), null)
          : n & e.child.childLanes
            ? V4(t, e, n)
            : ($t(ae, ae.current & 1), (t = Zr(t, e, n)), t !== null ? t.sibling : null)
      $t(ae, ae.current & 1)
      break
    case 19:
      if (((r = (n & e.childLanes) !== 0), t.flags & 128)) {
        if (r) return W4(t, e, n)
        e.flags |= 128
      }
      if (
        ((i = e.memoizedState),
        i !== null && ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        $t(ae, ae.current),
        r)
      )
        break
      return null
    case 22:
    case 23:
      return ((e.lanes = 0), B4(t, e, n))
  }
  return Zr(t, e, n)
}
var U4, N1, z4, H4
U4 = function (t, e) {
  for (var n = e.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode)
    else if (n.tag !== 4 && n.child !== null) {
      ;((n.child.return = n), (n = n.child))
      continue
    }
    if (n === e) break
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === e) return
      n = n.return
    }
    ;((n.sibling.return = n.return), (n = n.sibling))
  }
}
N1 = function () {}
z4 = function (t, e, n, r) {
  var i = t.memoizedProps
  if (i !== r) {
    ;((t = e.stateNode), ao(kr.current))
    var s = null
    switch (n) {
      case 'input':
        ;((i = Jd(t, i)), (r = Jd(t, r)), (s = []))
        break
      case 'select':
        ;((i = de({}, i, { value: void 0 })), (r = de({}, r, { value: void 0 })), (s = []))
        break
      case 'textarea':
        ;((i = n1(t, i)), (r = n1(t, r)), (s = []))
        break
      default:
        typeof i.onClick != 'function' && typeof r.onClick == 'function' && (t.onclick = du)
    }
    i1(n, r)
    var c
    n = null
    for (p in i)
      if (!r.hasOwnProperty(p) && i.hasOwnProperty(p) && i[p] != null)
        if (p === 'style') {
          var h = i[p]
          for (c in h) h.hasOwnProperty(c) && (n || (n = {}), (n[c] = ''))
        } else
          p !== 'dangerouslySetInnerHTML' &&
            p !== 'children' &&
            p !== 'suppressContentEditableWarning' &&
            p !== 'suppressHydrationWarning' &&
            p !== 'autoFocus' &&
            (el.hasOwnProperty(p) ? s || (s = []) : (s = s || []).push(p, null))
    for (p in r) {
      var f = r[p]
      if (
        ((h = i != null ? i[p] : void 0),
        r.hasOwnProperty(p) && f !== h && (f != null || h != null))
      )
        if (p === 'style')
          if (h) {
            for (c in h)
              !h.hasOwnProperty(c) || (f && f.hasOwnProperty(c)) || (n || (n = {}), (n[c] = ''))
            for (c in f) f.hasOwnProperty(c) && h[c] !== f[c] && (n || (n = {}), (n[c] = f[c]))
          } else (n || (s || (s = []), s.push(p, n)), (n = f))
        else
          p === 'dangerouslySetInnerHTML'
            ? ((f = f ? f.__html : void 0),
              (h = h ? h.__html : void 0),
              f != null && h !== f && (s = s || []).push(p, f))
            : p === 'children'
              ? (typeof f != 'string' && typeof f != 'number') || (s = s || []).push(p, '' + f)
              : p !== 'suppressContentEditableWarning' &&
                p !== 'suppressHydrationWarning' &&
                (el.hasOwnProperty(p)
                  ? (f != null && p === 'onScroll' && te('scroll', t), s || h === f || (s = []))
                  : (s = s || []).push(p, f))
    }
    n && (s = s || []).push('style', n)
    var p = s
    ;(e.updateQueue = p) && (e.flags |= 4)
  }
}
H4 = function (t, e, n, r) {
  n !== r && (e.flags |= 4)
}
function wa(t, e) {
  if (!oe)
    switch (t.tailMode) {
      case 'hidden':
        e = t.tail
        for (var n = null; e !== null; ) (e.alternate !== null && (n = e), (e = e.sibling))
        n === null ? (t.tail = null) : (n.sibling = null)
        break
      case 'collapsed':
        n = t.tail
        for (var r = null; n !== null; ) (n.alternate !== null && (r = n), (n = n.sibling))
        r === null
          ? e || t.tail === null
            ? (t.tail = null)
            : (t.tail.sibling = null)
          : (r.sibling = null)
    }
}
function Ke(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    n = 0,
    r = 0
  if (e)
    for (var i = t.child; i !== null; )
      ((n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = t),
        (i = i.sibling))
  else
    for (i = t.child; i !== null; )
      ((n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = t),
        (i = i.sibling))
  return ((t.subtreeFlags |= r), (t.childLanes = n), e)
}
function Gx(t, e, n) {
  var r = e.pendingProps
  switch ((Hf(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return (Ke(e), null)
    case 1:
      return (xn(e.type) && fu(), Ke(e), null)
    case 3:
      return (
        (r = e.stateNode),
        Ps(),
        ne(vn),
        ne(tn),
        Jf(),
        r.pendingContext && ((r.context = r.pendingContext), (r.pendingContext = null)),
        (t === null || t.child === null) &&
          (fc(e)
            ? (e.flags |= 4)
            : t === null ||
              (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), lr !== null && (F1(lr), (lr = null)))),
        N1(t, e),
        Ke(e),
        null
      )
    case 5:
      $f(e)
      var i = ao(fl.current)
      if (((n = e.type), t !== null && e.stateNode != null))
        (z4(t, e, n, r, i), t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152)))
      else {
        if (!r) {
          if (e.stateNode === null) throw Error(tt(166))
          return (Ke(e), null)
        }
        if (((t = ao(kr.current)), fc(e))) {
          ;((r = e.stateNode), (n = e.type))
          var s = e.memoizedProps
          switch (((r[Sr] = e), (r[hl] = s), (t = (e.mode & 1) !== 0), n)) {
            case 'dialog':
              ;(te('cancel', r), te('close', r))
              break
            case 'iframe':
            case 'object':
            case 'embed':
              te('load', r)
              break
            case 'video':
            case 'audio':
              for (i = 0; i < Ra.length; i++) te(Ra[i], r)
              break
            case 'source':
              te('error', r)
              break
            case 'img':
            case 'image':
            case 'link':
              ;(te('error', r), te('load', r))
              break
            case 'details':
              te('toggle', r)
              break
            case 'input':
              ;(Hp(r, s), te('invalid', r))
              break
            case 'select':
              ;((r._wrapperState = { wasMultiple: !!s.multiple }), te('invalid', r))
              break
            case 'textarea':
              ;(Gp(r, s), te('invalid', r))
          }
          ;(i1(n, s), (i = null))
          for (var c in s)
            if (s.hasOwnProperty(c)) {
              var h = s[c]
              c === 'children'
                ? typeof h == 'string'
                  ? r.textContent !== h &&
                    (s.suppressHydrationWarning !== !0 && dc(r.textContent, h, t),
                    (i = ['children', h]))
                  : typeof h == 'number' &&
                    r.textContent !== '' + h &&
                    (s.suppressHydrationWarning !== !0 && dc(r.textContent, h, t),
                    (i = ['children', '' + h]))
                : el.hasOwnProperty(c) && h != null && c === 'onScroll' && te('scroll', r)
            }
          switch (n) {
            case 'input':
              ;(ic(r), Xp(r, s, !0))
              break
            case 'textarea':
              ;(ic(r), Yp(r))
              break
            case 'select':
            case 'option':
              break
            default:
              typeof s.onClick == 'function' && (r.onclick = du)
          }
          ;((r = i), (e.updateQueue = r), r !== null && (e.flags |= 4))
        } else {
          ;((c = i.nodeType === 9 ? i : i.ownerDocument),
            t === 'http://www.w3.org/1999/xhtml' && (t = w8(n)),
            t === 'http://www.w3.org/1999/xhtml'
              ? n === 'script'
                ? ((t = c.createElement('div')),
                  (t.innerHTML = '<script><\/script>'),
                  (t = t.removeChild(t.firstChild)))
                : typeof r.is == 'string'
                  ? (t = c.createElement(n, { is: r.is }))
                  : ((t = c.createElement(n)),
                    n === 'select' &&
                      ((c = t), r.multiple ? (c.multiple = !0) : r.size && (c.size = r.size)))
              : (t = c.createElementNS(t, n)),
            (t[Sr] = e),
            (t[hl] = r),
            U4(t, e, !1, !1),
            (e.stateNode = t))
          t: {
            switch (((c = o1(n, r)), n)) {
              case 'dialog':
                ;(te('cancel', t), te('close', t), (i = r))
                break
              case 'iframe':
              case 'object':
              case 'embed':
                ;(te('load', t), (i = r))
                break
              case 'video':
              case 'audio':
                for (i = 0; i < Ra.length; i++) te(Ra[i], t)
                i = r
                break
              case 'source':
                ;(te('error', t), (i = r))
                break
              case 'img':
              case 'image':
              case 'link':
                ;(te('error', t), te('load', t), (i = r))
                break
              case 'details':
                ;(te('toggle', t), (i = r))
                break
              case 'input':
                ;(Hp(t, r), (i = Jd(t, r)), te('invalid', t))
                break
              case 'option':
                i = r
                break
              case 'select':
                ;((t._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = de({}, r, { value: void 0 })),
                  te('invalid', t))
                break
              case 'textarea':
                ;(Gp(t, r), (i = n1(t, r)), te('invalid', t))
                break
              default:
                i = r
            }
            ;(i1(n, i), (h = i))
            for (s in h)
              if (h.hasOwnProperty(s)) {
                var f = h[s]
                s === 'style'
                  ? x8(t, f)
                  : s === 'dangerouslySetInnerHTML'
                    ? ((f = f ? f.__html : void 0), f != null && b8(t, f))
                    : s === 'children'
                      ? typeof f == 'string'
                        ? (n !== 'textarea' || f !== '') && nl(t, f)
                        : typeof f == 'number' && nl(t, '' + f)
                      : s !== 'suppressContentEditableWarning' &&
                        s !== 'suppressHydrationWarning' &&
                        s !== 'autoFocus' &&
                        (el.hasOwnProperty(s)
                          ? f != null && s === 'onScroll' && te('scroll', t)
                          : f != null && Rf(t, s, f, c))
              }
            switch (n) {
              case 'input':
                ;(ic(t), Xp(t, r, !1))
                break
              case 'textarea':
                ;(ic(t), Yp(t))
                break
              case 'option':
                r.value != null && t.setAttribute('value', '' + Mi(r.value))
                break
              case 'select':
                ;((t.multiple = !!r.multiple),
                  (s = r.value),
                  s != null
                    ? Cs(t, !!r.multiple, s, !1)
                    : r.defaultValue != null && Cs(t, !!r.multiple, r.defaultValue, !0))
                break
              default:
                typeof i.onClick == 'function' && (t.onclick = du)
            }
            switch (n) {
              case 'button':
              case 'input':
              case 'select':
              case 'textarea':
                r = !!r.autoFocus
                break t
              case 'img':
                r = !0
                break t
              default:
                r = !1
            }
          }
          r && (e.flags |= 4)
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152))
      }
      return (Ke(e), null)
    case 6:
      if (t && e.stateNode != null) H4(t, e, t.memoizedProps, r)
      else {
        if (typeof r != 'string' && e.stateNode === null) throw Error(tt(166))
        if (((n = ao(fl.current)), ao(kr.current), fc(e))) {
          if (
            ((r = e.stateNode),
            (n = e.memoizedProps),
            (r[Sr] = e),
            (s = r.nodeValue !== n) && ((t = Dn), t !== null))
          )
            switch (t.tag) {
              case 3:
                dc(r.nodeValue, n, (t.mode & 1) !== 0)
                break
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 &&
                  dc(r.nodeValue, n, (t.mode & 1) !== 0)
            }
          s && (e.flags |= 4)
        } else
          ((r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[Sr] = e),
            (e.stateNode = r))
      }
      return (Ke(e), null)
    case 13:
      if (
        (ne(ae),
        (r = e.memoizedState),
        t === null || (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
      ) {
        if (oe && Tn !== null && e.mode & 1 && !(e.flags & 128))
          (l4(), Ms(), (e.flags |= 98560), (s = !1))
        else if (((s = fc(e)), r !== null && r.dehydrated !== null)) {
          if (t === null) {
            if (!s) throw Error(tt(318))
            if (((s = e.memoizedState), (s = s !== null ? s.dehydrated : null), !s))
              throw Error(tt(317))
            s[Sr] = e
          } else (Ms(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4))
          ;(Ke(e), (s = !1))
        } else (lr !== null && (F1(lr), (lr = null)), (s = !0))
        if (!s) return e.flags & 65536 ? e : null
      }
      return e.flags & 128
        ? ((e.lanes = n), e)
        : ((r = r !== null),
          r !== (t !== null && t.memoizedState !== null) &&
            r &&
            ((e.child.flags |= 8192),
            e.mode & 1 && (t === null || ae.current & 1 ? Re === 0 && (Re = 3) : h0())),
          e.updateQueue !== null && (e.flags |= 4),
          Ke(e),
          null)
    case 4:
      return (Ps(), N1(t, e), t === null && cl(e.stateNode.containerInfo), Ke(e), null)
    case 10:
      return (Zf(e.type._context), Ke(e), null)
    case 17:
      return (xn(e.type) && fu(), Ke(e), null)
    case 19:
      if ((ne(ae), (s = e.memoizedState), s === null)) return (Ke(e), null)
      if (((r = (e.flags & 128) !== 0), (c = s.rendering), c === null))
        if (r) wa(s, !1)
        else {
          if (Re !== 0 || (t !== null && t.flags & 128))
            for (t = e.child; t !== null; ) {
              if (((c = vu(t)), c !== null)) {
                for (
                  e.flags |= 128,
                    wa(s, !1),
                    r = c.updateQueue,
                    r !== null && ((e.updateQueue = r), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    r = n,
                    n = e.child;
                  n !== null;

                )
                  ((s = n),
                    (t = r),
                    (s.flags &= 14680066),
                    (c = s.alternate),
                    c === null
                      ? ((s.childLanes = 0),
                        (s.lanes = t),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = c.childLanes),
                        (s.lanes = c.lanes),
                        (s.child = c.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = c.memoizedProps),
                        (s.memoizedState = c.memoizedState),
                        (s.updateQueue = c.updateQueue),
                        (s.type = c.type),
                        (t = c.dependencies),
                        (s.dependencies =
                          t === null ? null : { lanes: t.lanes, firstContext: t.firstContext })),
                    (n = n.sibling))
                return ($t(ae, (ae.current & 1) | 2), e.child)
              }
              t = t.sibling
            }
          s.tail !== null &&
            Ee() > Os &&
            ((e.flags |= 128), (r = !0), wa(s, !1), (e.lanes = 4194304))
        }
      else {
        if (!r)
          if (((t = vu(c)), t !== null)) {
            if (
              ((e.flags |= 128),
              (r = !0),
              (n = t.updateQueue),
              n !== null && ((e.updateQueue = n), (e.flags |= 4)),
              wa(s, !0),
              s.tail === null && s.tailMode === 'hidden' && !c.alternate && !oe)
            )
              return (Ke(e), null)
          } else
            2 * Ee() - s.renderingStartTime > Os &&
              n !== 1073741824 &&
              ((e.flags |= 128), (r = !0), wa(s, !1), (e.lanes = 4194304))
        s.isBackwards
          ? ((c.sibling = e.child), (e.child = c))
          : ((n = s.last), n !== null ? (n.sibling = c) : (e.child = c), (s.last = c))
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = Ee()),
          (e.sibling = null),
          (n = ae.current),
          $t(ae, r ? (n & 1) | 2 : n & 1),
          e)
        : (Ke(e), null)
    case 22:
    case 23:
      return (
        u0(),
        (r = e.memoizedState !== null),
        t !== null && (t.memoizedState !== null) !== r && (e.flags |= 8192),
        r && e.mode & 1
          ? _n & 1073741824 && (Ke(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : Ke(e),
        null
      )
    case 24:
      return null
    case 25:
      return null
  }
  throw Error(tt(156, e.tag))
}
function Yx(t, e) {
  switch ((Hf(e), e.tag)) {
    case 1:
      return (
        xn(e.type) && fu(),
        (t = e.flags),
        t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      )
    case 3:
      return (
        Ps(),
        ne(vn),
        ne(tn),
        Jf(),
        (t = e.flags),
        t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
      )
    case 5:
      return ($f(e), null)
    case 13:
      if ((ne(ae), (t = e.memoizedState), t !== null && t.dehydrated !== null)) {
        if (e.alternate === null) throw Error(tt(340))
        Ms()
      }
      return ((t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null)
    case 19:
      return (ne(ae), null)
    case 4:
      return (Ps(), null)
    case 10:
      return (Zf(e.type._context), null)
    case 22:
    case 23:
      return (u0(), null)
    case 24:
      return null
    default:
      return null
  }
}
var mc = !1,
  $e = !1,
  Zx = typeof WeakSet == 'function' ? WeakSet : Set,
  ct = null
function ps(t, e) {
  var n = t.ref
  if (n !== null)
    if (typeof n == 'function')
      try {
        n(null)
      } catch (r) {
        we(t, e, r)
      }
    else n.current = null
}
function X4(t, e, n) {
  try {
    n()
  } catch (r) {
    we(t, e, r)
  }
}
var Og = !1
function qx(t, e) {
  if (((g1 = cu), (t = q8()), Uf(t))) {
    if ('selectionStart' in t) var n = { start: t.selectionStart, end: t.selectionEnd }
    else
      t: {
        n = ((n = t.ownerDocument) && n.defaultView) || window
        var r = n.getSelection && n.getSelection()
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode
          var i = r.anchorOffset,
            s = r.focusNode
          r = r.focusOffset
          try {
            ;(n.nodeType, s.nodeType)
          } catch {
            n = null
            break t
          }
          var c = 0,
            h = -1,
            f = -1,
            p = 0,
            y = 0,
            w = t,
            x = null
          e: for (;;) {
            for (
              var E;
              w !== n || (i !== 0 && w.nodeType !== 3) || (h = c + i),
                w !== s || (r !== 0 && w.nodeType !== 3) || (f = c + r),
                w.nodeType === 3 && (c += w.nodeValue.length),
                (E = w.firstChild) !== null;

            )
              ((x = w), (w = E))
            for (;;) {
              if (w === t) break e
              if (
                (x === n && ++p === i && (h = c),
                x === s && ++y === r && (f = c),
                (E = w.nextSibling) !== null)
              )
                break
              ;((w = x), (x = w.parentNode))
            }
            w = E
          }
          n = h === -1 || f === -1 ? null : { start: h, end: f }
        } else n = null
      }
    n = n || { start: 0, end: 0 }
  } else n = null
  for (m1 = { focusedElem: t, selectionRange: n }, cu = !1, ct = e; ct !== null; )
    if (((e = ct), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null))
      ((t.return = e), (ct = t))
    else
      for (; ct !== null; ) {
        e = ct
        try {
          var S = e.alternate
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break
              case 1:
                if (S !== null) {
                  var k = S.memoizedProps,
                    D = S.memoizedState,
                    _ = e.stateNode,
                    N = _.getSnapshotBeforeUpdate(e.elementType === e.type ? k : sr(e.type, k), D)
                  _.__reactInternalSnapshotBeforeUpdate = N
                }
                break
              case 3:
                var M = e.stateNode.containerInfo
                M.nodeType === 1
                  ? (M.textContent = '')
                  : M.nodeType === 9 && M.documentElement && M.removeChild(M.documentElement)
                break
              case 5:
              case 6:
              case 4:
              case 17:
                break
              default:
                throw Error(tt(163))
            }
        } catch (O) {
          we(e, e.return, O)
        }
        if (((t = e.sibling), t !== null)) {
          ;((t.return = e.return), (ct = t))
          break
        }
        ct = e.return
      }
  return ((S = Og), (Og = !1), S)
}
function Ua(t, e, n) {
  var r = e.updateQueue
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next)
    do {
      if ((i.tag & t) === t) {
        var s = i.destroy
        ;((i.destroy = void 0), s !== void 0 && X4(e, n, s))
      }
      i = i.next
    } while (i !== r)
  }
}
function rh(t, e) {
  if (((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)) {
    var n = (e = e.next)
    do {
      if ((n.tag & t) === t) {
        var r = n.create
        n.destroy = r()
      }
      n = n.next
    } while (n !== e)
  }
}
function M1(t) {
  var e = t.ref
  if (e !== null) {
    var n = t.stateNode
    switch (t.tag) {
      case 5:
        t = n
        break
      default:
        t = n
    }
    typeof e == 'function' ? e(t) : (e.current = t)
  }
}
function G4(t) {
  var e = t.alternate
  ;(e !== null && ((t.alternate = null), G4(e)),
    (t.child = null),
    (t.deletions = null),
    (t.sibling = null),
    t.tag === 5 &&
      ((e = t.stateNode),
      e !== null && (delete e[Sr], delete e[hl], delete e[b1], delete e[Nx], delete e[Mx])),
    (t.stateNode = null),
    (t.return = null),
    (t.dependencies = null),
    (t.memoizedProps = null),
    (t.memoizedState = null),
    (t.pendingProps = null),
    (t.stateNode = null),
    (t.updateQueue = null))
}
function Y4(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4
}
function Bg(t) {
  t: for (;;) {
    for (; t.sibling === null; ) {
      if (t.return === null || Y4(t.return)) return null
      t = t.return
    }
    for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue t
      ;((t.child.return = t), (t = t.child))
    }
    if (!(t.flags & 2)) return t.stateNode
  }
}
function D1(t, e, n) {
  var r = t.tag
  if (r === 5 || r === 6)
    ((t = t.stateNode),
      e
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(t, e)
          : n.insertBefore(t, e)
        : (n.nodeType === 8
            ? ((e = n.parentNode), e.insertBefore(t, n))
            : ((e = n), e.appendChild(t)),
          (n = n._reactRootContainer),
          n != null || e.onclick !== null || (e.onclick = du)))
  else if (r !== 4 && ((t = t.child), t !== null))
    for (D1(t, e, n), t = t.sibling; t !== null; ) (D1(t, e, n), (t = t.sibling))
}
function P1(t, e, n) {
  var r = t.tag
  if (r === 5 || r === 6) ((t = t.stateNode), e ? n.insertBefore(t, e) : n.appendChild(t))
  else if (r !== 4 && ((t = t.child), t !== null))
    for (P1(t, e, n), t = t.sibling; t !== null; ) (P1(t, e, n), (t = t.sibling))
}
var Ue = null,
  ar = !1
function si(t, e, n) {
  for (n = n.child; n !== null; ) (Z4(t, e, n), (n = n.sibling))
}
function Z4(t, e, n) {
  if (Ar && typeof Ar.onCommitFiberUnmount == 'function')
    try {
      Ar.onCommitFiberUnmount(qu, n)
    } catch {}
  switch (n.tag) {
    case 5:
      $e || ps(n, e)
    case 6:
      var r = Ue,
        i = ar
      ;((Ue = null),
        si(t, e, n),
        (Ue = r),
        (ar = i),
        Ue !== null &&
          (ar
            ? ((t = Ue),
              (n = n.stateNode),
              t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n))
            : Ue.removeChild(n.stateNode)))
      break
    case 18:
      Ue !== null &&
        (ar
          ? ((t = Ue),
            (n = n.stateNode),
            t.nodeType === 8 ? cd(t.parentNode, n) : t.nodeType === 1 && cd(t, n),
            sl(t))
          : cd(Ue, n.stateNode))
      break
    case 4:
      ;((r = Ue),
        (i = ar),
        (Ue = n.stateNode.containerInfo),
        (ar = !0),
        si(t, e, n),
        (Ue = r),
        (ar = i))
      break
    case 0:
    case 11:
    case 14:
    case 15:
      if (!$e && ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))) {
        i = r = r.next
        do {
          var s = i,
            c = s.destroy
          ;((s = s.tag), c !== void 0 && (s & 2 || s & 4) && X4(n, e, c), (i = i.next))
        } while (i !== r)
      }
      si(t, e, n)
      break
    case 1:
      if (!$e && (ps(n, e), (r = n.stateNode), typeof r.componentWillUnmount == 'function'))
        try {
          ;((r.props = n.memoizedProps), (r.state = n.memoizedState), r.componentWillUnmount())
        } catch (h) {
          we(n, e, h)
        }
      si(t, e, n)
      break
    case 21:
      si(t, e, n)
      break
    case 22:
      n.mode & 1
        ? (($e = (r = $e) || n.memoizedState !== null), si(t, e, n), ($e = r))
        : si(t, e, n)
      break
    default:
      si(t, e, n)
  }
}
function Fg(t) {
  var e = t.updateQueue
  if (e !== null) {
    t.updateQueue = null
    var n = t.stateNode
    ;(n === null && (n = t.stateNode = new Zx()),
      e.forEach(function (r) {
        var i = iE.bind(null, t, r)
        n.has(r) || (n.add(r), r.then(i, i))
      }))
  }
}
function ir(t, e) {
  var n = e.deletions
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r]
      try {
        var s = t,
          c = e,
          h = c
        t: for (; h !== null; ) {
          switch (h.tag) {
            case 5:
              ;((Ue = h.stateNode), (ar = !1))
              break t
            case 3:
              ;((Ue = h.stateNode.containerInfo), (ar = !0))
              break t
            case 4:
              ;((Ue = h.stateNode.containerInfo), (ar = !0))
              break t
          }
          h = h.return
        }
        if (Ue === null) throw Error(tt(160))
        ;(Z4(s, c, i), (Ue = null), (ar = !1))
        var f = i.alternate
        ;(f !== null && (f.return = null), (i.return = null))
      } catch (p) {
        we(i, e, p)
      }
    }
  if (e.subtreeFlags & 12854) for (e = e.child; e !== null; ) (q4(e, t), (e = e.sibling))
}
function q4(t, e) {
  var n = t.alternate,
    r = t.flags
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((ir(e, t), br(t), r & 4)) {
        try {
          ;(Ua(3, t, t.return), rh(3, t))
        } catch (k) {
          we(t, t.return, k)
        }
        try {
          Ua(5, t, t.return)
        } catch (k) {
          we(t, t.return, k)
        }
      }
      break
    case 1:
      ;(ir(e, t), br(t), r & 512 && n !== null && ps(n, n.return))
      break
    case 5:
      if ((ir(e, t), br(t), r & 512 && n !== null && ps(n, n.return), t.flags & 32)) {
        var i = t.stateNode
        try {
          nl(i, '')
        } catch (k) {
          we(t, t.return, k)
        }
      }
      if (r & 4 && ((i = t.stateNode), i != null)) {
        var s = t.memoizedProps,
          c = n !== null ? n.memoizedProps : s,
          h = t.type,
          f = t.updateQueue
        if (((t.updateQueue = null), f !== null))
          try {
            ;(h === 'input' && s.type === 'radio' && s.name != null && m8(i, s), o1(h, c))
            var p = o1(h, s)
            for (c = 0; c < f.length; c += 2) {
              var y = f[c],
                w = f[c + 1]
              y === 'style'
                ? x8(i, w)
                : y === 'dangerouslySetInnerHTML'
                  ? b8(i, w)
                  : y === 'children'
                    ? nl(i, w)
                    : Rf(i, y, w, p)
            }
            switch (h) {
              case 'input':
                t1(i, s)
                break
              case 'textarea':
                y8(i, s)
                break
              case 'select':
                var x = i._wrapperState.wasMultiple
                i._wrapperState.wasMultiple = !!s.multiple
                var E = s.value
                E != null
                  ? Cs(i, !!s.multiple, E, !1)
                  : x !== !!s.multiple &&
                    (s.defaultValue != null
                      ? Cs(i, !!s.multiple, s.defaultValue, !0)
                      : Cs(i, !!s.multiple, s.multiple ? [] : '', !1))
            }
            i[hl] = s
          } catch (k) {
            we(t, t.return, k)
          }
      }
      break
    case 6:
      if ((ir(e, t), br(t), r & 4)) {
        if (t.stateNode === null) throw Error(tt(162))
        ;((i = t.stateNode), (s = t.memoizedProps))
        try {
          i.nodeValue = s
        } catch (k) {
          we(t, t.return, k)
        }
      }
      break
    case 3:
      if ((ir(e, t), br(t), r & 4 && n !== null && n.memoizedState.isDehydrated))
        try {
          sl(e.containerInfo)
        } catch (k) {
          we(t, t.return, k)
        }
      break
    case 4:
      ;(ir(e, t), br(t))
      break
    case 13:
      ;(ir(e, t),
        br(t),
        (i = t.child),
        i.flags & 8192 &&
          ((s = i.memoizedState !== null),
          (i.stateNode.isHidden = s),
          !s || (i.alternate !== null && i.alternate.memoizedState !== null) || (l0 = Ee())),
        r & 4 && Fg(t))
      break
    case 22:
      if (
        ((y = n !== null && n.memoizedState !== null),
        t.mode & 1 ? (($e = (p = $e) || y), ir(e, t), ($e = p)) : ir(e, t),
        br(t),
        r & 8192)
      ) {
        if (((p = t.memoizedState !== null), (t.stateNode.isHidden = p) && !y && t.mode & 1))
          for (ct = t, y = t.child; y !== null; ) {
            for (w = ct = y; ct !== null; ) {
              switch (((x = ct), (E = x.child), x.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Ua(4, x, x.return)
                  break
                case 1:
                  ps(x, x.return)
                  var S = x.stateNode
                  if (typeof S.componentWillUnmount == 'function') {
                    ;((r = x), (n = x.return))
                    try {
                      ;((e = r),
                        (S.props = e.memoizedProps),
                        (S.state = e.memoizedState),
                        S.componentWillUnmount())
                    } catch (k) {
                      we(r, n, k)
                    }
                  }
                  break
                case 5:
                  ps(x, x.return)
                  break
                case 22:
                  if (x.memoizedState !== null) {
                    Vg(w)
                    continue
                  }
              }
              E !== null ? ((E.return = x), (ct = E)) : Vg(w)
            }
            y = y.sibling
          }
        t: for (y = null, w = t; ; ) {
          if (w.tag === 5) {
            if (y === null) {
              y = w
              try {
                ;((i = w.stateNode),
                  p
                    ? ((s = i.style),
                      typeof s.setProperty == 'function'
                        ? s.setProperty('display', 'none', 'important')
                        : (s.display = 'none'))
                    : ((h = w.stateNode),
                      (f = w.memoizedProps.style),
                      (c = f != null && f.hasOwnProperty('display') ? f.display : null),
                      (h.style.display = v8('display', c))))
              } catch (k) {
                we(t, t.return, k)
              }
            }
          } else if (w.tag === 6) {
            if (y === null)
              try {
                w.stateNode.nodeValue = p ? '' : w.memoizedProps
              } catch (k) {
                we(t, t.return, k)
              }
          } else if (
            ((w.tag !== 22 && w.tag !== 23) || w.memoizedState === null || w === t) &&
            w.child !== null
          ) {
            ;((w.child.return = w), (w = w.child))
            continue
          }
          if (w === t) break t
          for (; w.sibling === null; ) {
            if (w.return === null || w.return === t) break t
            ;(y === w && (y = null), (w = w.return))
          }
          ;(y === w && (y = null), (w.sibling.return = w.return), (w = w.sibling))
        }
      }
      break
    case 19:
      ;(ir(e, t), br(t), r & 4 && Fg(t))
      break
    case 21:
      break
    default:
      ;(ir(e, t), br(t))
  }
}
function br(t) {
  var e = t.flags
  if (e & 2) {
    try {
      t: {
        for (var n = t.return; n !== null; ) {
          if (Y4(n)) {
            var r = n
            break t
          }
          n = n.return
        }
        throw Error(tt(160))
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode
          r.flags & 32 && (nl(i, ''), (r.flags &= -33))
          var s = Bg(t)
          P1(t, s, i)
          break
        case 3:
        case 4:
          var c = r.stateNode.containerInfo,
            h = Bg(t)
          D1(t, h, c)
          break
        default:
          throw Error(tt(161))
      }
    } catch (f) {
      we(t, t.return, f)
    }
    t.flags &= -3
  }
  e & 4096 && (t.flags &= -4097)
}
function Kx(t, e, n) {
  ;((ct = t), K4(t))
}
function K4(t, e, n) {
  for (var r = (t.mode & 1) !== 0; ct !== null; ) {
    var i = ct,
      s = i.child
    if (i.tag === 22 && r) {
      var c = i.memoizedState !== null || mc
      if (!c) {
        var h = i.alternate,
          f = (h !== null && h.memoizedState !== null) || $e
        h = mc
        var p = $e
        if (((mc = c), ($e = f) && !p))
          for (ct = i; ct !== null; )
            ((c = ct),
              (f = c.child),
              c.tag === 22 && c.memoizedState !== null
                ? Wg(i)
                : f !== null
                  ? ((f.return = c), (ct = f))
                  : Wg(i))
        for (; s !== null; ) ((ct = s), K4(s), (s = s.sibling))
        ;((ct = i), (mc = h), ($e = p))
      }
      jg(t)
    } else i.subtreeFlags & 8772 && s !== null ? ((s.return = i), (ct = s)) : jg(t)
  }
}
function jg(t) {
  for (; ct !== null; ) {
    var e = ct
    if (e.flags & 8772) {
      var n = e.alternate
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              $e || rh(5, e)
              break
            case 1:
              var r = e.stateNode
              if (e.flags & 4 && !$e)
                if (n === null) r.componentDidMount()
                else {
                  var i = e.elementType === e.type ? n.memoizedProps : sr(e.type, n.memoizedProps)
                  r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                }
              var s = e.updateQueue
              s !== null && Cg(e, s, r)
              break
            case 3:
              var c = e.updateQueue
              if (c !== null) {
                if (((n = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      n = e.child.stateNode
                      break
                    case 1:
                      n = e.child.stateNode
                  }
                Cg(e, c, n)
              }
              break
            case 5:
              var h = e.stateNode
              if (n === null && e.flags & 4) {
                n = h
                var f = e.memoizedProps
                switch (e.type) {
                  case 'button':
                  case 'input':
                  case 'select':
                  case 'textarea':
                    f.autoFocus && n.focus()
                    break
                  case 'img':
                    f.src && (n.src = f.src)
                }
              }
              break
            case 6:
              break
            case 4:
              break
            case 12:
              break
            case 13:
              if (e.memoizedState === null) {
                var p = e.alternate
                if (p !== null) {
                  var y = p.memoizedState
                  if (y !== null) {
                    var w = y.dehydrated
                    w !== null && sl(w)
                  }
                }
              }
              break
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break
            default:
              throw Error(tt(163))
          }
        $e || (e.flags & 512 && M1(e))
      } catch (x) {
        we(e, e.return, x)
      }
    }
    if (e === t) {
      ct = null
      break
    }
    if (((n = e.sibling), n !== null)) {
      ;((n.return = e.return), (ct = n))
      break
    }
    ct = e.return
  }
}
function Vg(t) {
  for (; ct !== null; ) {
    var e = ct
    if (e === t) {
      ct = null
      break
    }
    var n = e.sibling
    if (n !== null) {
      ;((n.return = e.return), (ct = n))
      break
    }
    ct = e.return
  }
}
function Wg(t) {
  for (; ct !== null; ) {
    var e = ct
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var n = e.return
          try {
            rh(4, e)
          } catch (f) {
            we(e, n, f)
          }
          break
        case 1:
          var r = e.stateNode
          if (typeof r.componentDidMount == 'function') {
            var i = e.return
            try {
              r.componentDidMount()
            } catch (f) {
              we(e, i, f)
            }
          }
          var s = e.return
          try {
            M1(e)
          } catch (f) {
            we(e, s, f)
          }
          break
        case 5:
          var c = e.return
          try {
            M1(e)
          } catch (f) {
            we(e, c, f)
          }
      }
    } catch (f) {
      we(e, e.return, f)
    }
    if (e === t) {
      ct = null
      break
    }
    var h = e.sibling
    if (h !== null) {
      ;((h.return = e.return), (ct = h))
      break
    }
    ct = e.return
  }
}
var Qx = Math.ceil,
  Cu = Kr.ReactCurrentDispatcher,
  s0 = Kr.ReactCurrentOwner,
  Qn = Kr.ReactCurrentBatchConfig,
  Lt = 0,
  Le = null,
  Se = null,
  Xe = 0,
  _n = 0,
  gs = Fi(0),
  Re = 0,
  yl = null,
  vo = 0,
  ih = 0,
  a0 = 0,
  za = null,
  yn = null,
  l0 = 0,
  Os = 1 / 0,
  Lr = null,
  Su = !1,
  L1 = null,
  Ii = null,
  yc = !1,
  pi = null,
  Au = 0,
  Ha = 0,
  O1 = null,
  Xc = -1,
  Gc = 0
function on() {
  return Lt & 6 ? Ee() : Xc !== -1 ? Xc : (Xc = Ee())
}
function _i(t) {
  return t.mode & 1
    ? Lt & 2 && Xe !== 0
      ? Xe & -Xe
      : Px.transition !== null
        ? (Gc === 0 && (Gc = D8()), Gc)
        : ((t = Ht), t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : V8(t.type))), t)
    : 1
}
function ur(t, e, n, r) {
  if (50 < Ha) throw ((Ha = 0), (O1 = null), Error(tt(185)))
  ;(Ml(t, n, r),
    (!(Lt & 2) || t !== Le) &&
      (t === Le && (!(Lt & 2) && (ih |= n), Re === 4 && di(t, Xe)),
      En(t, r),
      n === 1 && Lt === 0 && !(e.mode & 1) && ((Os = Ee() + 500), th && ji())))
}
function En(t, e) {
  var n = t.callbackNode
  Pv(t, e)
  var r = lu(t, t === Le ? Xe : 0)
  if (r === 0) (n !== null && Kp(n), (t.callbackNode = null), (t.callbackPriority = 0))
  else if (((e = r & -r), t.callbackPriority !== e)) {
    if ((n != null && Kp(n), e === 1))
      (t.tag === 0 ? Dx(Ug.bind(null, t)) : o4(Ug.bind(null, t)),
        Rx(function () {
          !(Lt & 6) && ji()
        }),
        (n = null))
    else {
      switch (P8(r)) {
        case 1:
          n = Pf
          break
        case 4:
          n = N8
          break
        case 16:
          n = au
          break
        case 536870912:
          n = M8
          break
        default:
          n = au
      }
      n = iw(n, Q4.bind(null, t))
    }
    ;((t.callbackPriority = e), (t.callbackNode = n))
  }
}
function Q4(t, e) {
  if (((Xc = -1), (Gc = 0), Lt & 6)) throw Error(tt(327))
  var n = t.callbackNode
  if (_s() && t.callbackNode !== n) return null
  var r = lu(t, t === Le ? Xe : 0)
  if (r === 0) return null
  if (r & 30 || r & t.expiredLanes || e) e = ku(t, r)
  else {
    e = r
    var i = Lt
    Lt |= 2
    var s = J4()
    ;(Le !== t || Xe !== e) && ((Lr = null), (Os = Ee() + 500), uo(t, e))
    do
      try {
        tE()
        break
      } catch (h) {
        $4(t, h)
      }
    while (!0)
    ;(Yf(), (Cu.current = s), (Lt = i), Se !== null ? (e = 0) : ((Le = null), (Xe = 0), (e = Re)))
  }
  if (e !== 0) {
    if ((e === 2 && ((i = u1(t)), i !== 0 && ((r = i), (e = B1(t, i)))), e === 1))
      throw ((n = yl), uo(t, 0), di(t, r), En(t, Ee()), n)
    if (e === 6) di(t, r)
    else {
      if (
        ((i = t.current.alternate),
        !(r & 30) &&
          !$x(i) &&
          ((e = ku(t, r)), e === 2 && ((s = u1(t)), s !== 0 && ((r = s), (e = B1(t, s)))), e === 1))
      )
        throw ((n = yl), uo(t, 0), di(t, r), En(t, Ee()), n)
      switch (((t.finishedWork = i), (t.finishedLanes = r), e)) {
        case 0:
        case 1:
          throw Error(tt(345))
        case 2:
          to(t, yn, Lr)
          break
        case 3:
          if ((di(t, r), (r & 130023424) === r && ((e = l0 + 500 - Ee()), 10 < e))) {
            if (lu(t, 0) !== 0) break
            if (((i = t.suspendedLanes), (i & r) !== r)) {
              ;(on(), (t.pingedLanes |= t.suspendedLanes & i))
              break
            }
            t.timeoutHandle = w1(to.bind(null, t, yn, Lr), e)
            break
          }
          to(t, yn, Lr)
          break
        case 4:
          if ((di(t, r), (r & 4194240) === r)) break
          for (e = t.eventTimes, i = -1; 0 < r; ) {
            var c = 31 - cr(r)
            ;((s = 1 << c), (c = e[c]), c > i && (i = c), (r &= ~s))
          }
          if (
            ((r = i),
            (r = Ee() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                  ? 480
                  : 1080 > r
                    ? 1080
                    : 1920 > r
                      ? 1920
                      : 3e3 > r
                        ? 3e3
                        : 4320 > r
                          ? 4320
                          : 1960 * Qx(r / 1960)) - r),
            10 < r)
          ) {
            t.timeoutHandle = w1(to.bind(null, t, yn, Lr), r)
            break
          }
          to(t, yn, Lr)
          break
        case 5:
          to(t, yn, Lr)
          break
        default:
          throw Error(tt(329))
      }
    }
  }
  return (En(t, Ee()), t.callbackNode === n ? Q4.bind(null, t) : null)
}
function B1(t, e) {
  var n = za
  return (
    t.current.memoizedState.isDehydrated && (uo(t, e).flags |= 256),
    (t = ku(t, e)),
    t !== 2 && ((e = yn), (yn = n), e !== null && F1(e)),
    t
  )
}
function F1(t) {
  yn === null ? (yn = t) : yn.push.apply(yn, t)
}
function $x(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var n = e.updateQueue
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            s = i.getSnapshot
          i = i.value
          try {
            if (!hr(s(), i)) return !1
          } catch {
            return !1
          }
        }
    }
    if (((n = e.child), e.subtreeFlags & 16384 && n !== null)) ((n.return = e), (e = n))
    else {
      if (e === t) break
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0
        e = e.return
      }
      ;((e.sibling.return = e.return), (e = e.sibling))
    }
  }
  return !0
}
function di(t, e) {
  for (
    e &= ~a0, e &= ~ih, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes;
    0 < e;

  ) {
    var n = 31 - cr(e),
      r = 1 << n
    ;((t[n] = -1), (e &= ~r))
  }
}
function Ug(t) {
  if (Lt & 6) throw Error(tt(327))
  _s()
  var e = lu(t, 0)
  if (!(e & 1)) return (En(t, Ee()), null)
  var n = ku(t, e)
  if (t.tag !== 0 && n === 2) {
    var r = u1(t)
    r !== 0 && ((e = r), (n = B1(t, r)))
  }
  if (n === 1) throw ((n = yl), uo(t, 0), di(t, e), En(t, Ee()), n)
  if (n === 6) throw Error(tt(345))
  return (
    (t.finishedWork = t.current.alternate),
    (t.finishedLanes = e),
    to(t, yn, Lr),
    En(t, Ee()),
    null
  )
}
function c0(t, e) {
  var n = Lt
  Lt |= 1
  try {
    return t(e)
  } finally {
    ;((Lt = n), Lt === 0 && ((Os = Ee() + 500), th && ji()))
  }
}
function xo(t) {
  pi !== null && pi.tag === 0 && !(Lt & 6) && _s()
  var e = Lt
  Lt |= 1
  var n = Qn.transition,
    r = Ht
  try {
    if (((Qn.transition = null), (Ht = 1), t)) return t()
  } finally {
    ;((Ht = r), (Qn.transition = n), (Lt = e), !(Lt & 6) && ji())
  }
}
function u0() {
  ;((_n = gs.current), ne(gs))
}
function uo(t, e) {
  ;((t.finishedWork = null), (t.finishedLanes = 0))
  var n = t.timeoutHandle
  if ((n !== -1 && ((t.timeoutHandle = -1), _x(n)), Se !== null))
    for (n = Se.return; n !== null; ) {
      var r = n
      switch ((Hf(r), r.tag)) {
        case 1:
          ;((r = r.type.childContextTypes), r != null && fu())
          break
        case 3:
          ;(Ps(), ne(vn), ne(tn), Jf())
          break
        case 5:
          $f(r)
          break
        case 4:
          Ps()
          break
        case 13:
          ne(ae)
          break
        case 19:
          ne(ae)
          break
        case 10:
          Zf(r.type._context)
          break
        case 22:
        case 23:
          u0()
      }
      n = n.return
    }
  if (
    ((Le = t),
    (Se = t = Ri(t.current, null)),
    (Xe = _n = e),
    (Re = 0),
    (yl = null),
    (a0 = ih = vo = 0),
    (yn = za = null),
    so !== null)
  ) {
    for (e = 0; e < so.length; e++)
      if (((n = so[e]), (r = n.interleaved), r !== null)) {
        n.interleaved = null
        var i = r.next,
          s = n.pending
        if (s !== null) {
          var c = s.next
          ;((s.next = i), (r.next = c))
        }
        n.pending = r
      }
    so = null
  }
  return t
}
function $4(t, e) {
  do {
    var n = Se
    try {
      if ((Yf(), (Uc.current = Eu), xu)) {
        for (var r = ue.memoizedState; r !== null; ) {
          var i = r.queue
          ;(i !== null && (i.pending = null), (r = r.next))
        }
        xu = !1
      }
      if (
        ((bo = 0),
        (Pe = _e = ue = null),
        (Wa = !1),
        (pl = 0),
        (s0.current = null),
        n === null || n.return === null)
      ) {
        ;((Re = 1), (yl = e), (Se = null))
        break
      }
      t: {
        var s = t,
          c = n.return,
          h = n,
          f = e
        if (
          ((e = Xe),
          (h.flags |= 32768),
          f !== null && typeof f == 'object' && typeof f.then == 'function')
        ) {
          var p = f,
            y = h,
            w = y.tag
          if (!(y.mode & 1) && (w === 0 || w === 11 || w === 15)) {
            var x = y.alternate
            x
              ? ((y.updateQueue = x.updateQueue),
                (y.memoizedState = x.memoizedState),
                (y.lanes = x.lanes))
              : ((y.updateQueue = null), (y.memoizedState = null))
          }
          var E = Rg(c)
          if (E !== null) {
            ;((E.flags &= -257), Tg(E, c, h, s, e), E.mode & 1 && _g(s, p, e), (e = E), (f = p))
            var S = e.updateQueue
            if (S === null) {
              var k = new Set()
              ;(k.add(f), (e.updateQueue = k))
            } else S.add(f)
            break t
          } else {
            if (!(e & 1)) {
              ;(_g(s, p, e), h0())
              break t
            }
            f = Error(tt(426))
          }
        } else if (oe && h.mode & 1) {
          var D = Rg(c)
          if (D !== null) {
            ;(!(D.flags & 65536) && (D.flags |= 256), Tg(D, c, h, s, e), Xf(Ls(f, h)))
            break t
          }
        }
        ;((s = f = Ls(f, h)), Re !== 4 && (Re = 2), za === null ? (za = [s]) : za.push(s), (s = c))
        do {
          switch (s.tag) {
            case 3:
              ;((s.flags |= 65536), (e &= -e), (s.lanes |= e))
              var _ = P4(s, f, e)
              Eg(s, _)
              break t
            case 1:
              h = f
              var N = s.type,
                M = s.stateNode
              if (
                !(s.flags & 128) &&
                (typeof N.getDerivedStateFromError == 'function' ||
                  (M !== null &&
                    typeof M.componentDidCatch == 'function' &&
                    (Ii === null || !Ii.has(M))))
              ) {
                ;((s.flags |= 65536), (e &= -e), (s.lanes |= e))
                var O = L4(s, h, e)
                Eg(s, O)
                break t
              }
          }
          s = s.return
        } while (s !== null)
      }
      ew(n)
    } catch (F) {
      ;((e = F), Se === n && n !== null && (Se = n = n.return))
      continue
    }
    break
  } while (!0)
}
function J4() {
  var t = Cu.current
  return ((Cu.current = Eu), t === null ? Eu : t)
}
function h0() {
  ;((Re === 0 || Re === 3 || Re === 2) && (Re = 4),
    Le === null || (!(vo & 268435455) && !(ih & 268435455)) || di(Le, Xe))
}
function ku(t, e) {
  var n = Lt
  Lt |= 2
  var r = J4()
  ;(Le !== t || Xe !== e) && ((Lr = null), uo(t, e))
  do
    try {
      Jx()
      break
    } catch (i) {
      $4(t, i)
    }
  while (!0)
  if ((Yf(), (Lt = n), (Cu.current = r), Se !== null)) throw Error(tt(261))
  return ((Le = null), (Xe = 0), Re)
}
function Jx() {
  for (; Se !== null; ) tw(Se)
}
function tE() {
  for (; Se !== null && !Av(); ) tw(Se)
}
function tw(t) {
  var e = rw(t.alternate, t, _n)
  ;((t.memoizedProps = t.pendingProps), e === null ? ew(t) : (Se = e), (s0.current = null))
}
function ew(t) {
  var e = t
  do {
    var n = e.alternate
    if (((t = e.return), e.flags & 32768)) {
      if (((n = Yx(n, e)), n !== null)) {
        ;((n.flags &= 32767), (Se = n))
        return
      }
      if (t !== null) ((t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null))
      else {
        ;((Re = 6), (Se = null))
        return
      }
    } else if (((n = Gx(n, e, _n)), n !== null)) {
      Se = n
      return
    }
    if (((e = e.sibling), e !== null)) {
      Se = e
      return
    }
    Se = e = t
  } while (e !== null)
  Re === 0 && (Re = 5)
}
function to(t, e, n) {
  var r = Ht,
    i = Qn.transition
  try {
    ;((Qn.transition = null), (Ht = 1), eE(t, e, n, r))
  } finally {
    ;((Qn.transition = i), (Ht = r))
  }
  return null
}
function eE(t, e, n, r) {
  do _s()
  while (pi !== null)
  if (Lt & 6) throw Error(tt(327))
  n = t.finishedWork
  var i = t.finishedLanes
  if (n === null) return null
  if (((t.finishedWork = null), (t.finishedLanes = 0), n === t.current)) throw Error(tt(177))
  ;((t.callbackNode = null), (t.callbackPriority = 0))
  var s = n.lanes | n.childLanes
  if (
    (Lv(t, s),
    t === Le && ((Se = Le = null), (Xe = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      yc ||
      ((yc = !0),
      iw(au, function () {
        return (_s(), null)
      })),
    (s = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || s)
  ) {
    ;((s = Qn.transition), (Qn.transition = null))
    var c = Ht
    Ht = 1
    var h = Lt
    ;((Lt |= 4),
      (s0.current = null),
      qx(t, n),
      q4(n, t),
      xx(m1),
      (cu = !!g1),
      (m1 = g1 = null),
      (t.current = n),
      Kx(n),
      kv(),
      (Lt = h),
      (Ht = c),
      (Qn.transition = s))
  } else t.current = n
  if (
    (yc && ((yc = !1), (pi = t), (Au = i)),
    (s = t.pendingLanes),
    s === 0 && (Ii = null),
    Rv(n.stateNode),
    En(t, Ee()),
    e !== null)
  )
    for (r = t.onRecoverableError, n = 0; n < e.length; n++)
      ((i = e[n]), r(i.value, { componentStack: i.stack, digest: i.digest }))
  if (Su) throw ((Su = !1), (t = L1), (L1 = null), t)
  return (
    Au & 1 && t.tag !== 0 && _s(),
    (s = t.pendingLanes),
    s & 1 ? (t === O1 ? Ha++ : ((Ha = 0), (O1 = t))) : (Ha = 0),
    ji(),
    null
  )
}
function _s() {
  if (pi !== null) {
    var t = P8(Au),
      e = Qn.transition,
      n = Ht
    try {
      if (((Qn.transition = null), (Ht = 16 > t ? 16 : t), pi === null)) var r = !1
      else {
        if (((t = pi), (pi = null), (Au = 0), Lt & 6)) throw Error(tt(331))
        var i = Lt
        for (Lt |= 4, ct = t.current; ct !== null; ) {
          var s = ct,
            c = s.child
          if (ct.flags & 16) {
            var h = s.deletions
            if (h !== null) {
              for (var f = 0; f < h.length; f++) {
                var p = h[f]
                for (ct = p; ct !== null; ) {
                  var y = ct
                  switch (y.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ua(8, y, s)
                  }
                  var w = y.child
                  if (w !== null) ((w.return = y), (ct = w))
                  else
                    for (; ct !== null; ) {
                      y = ct
                      var x = y.sibling,
                        E = y.return
                      if ((G4(y), y === p)) {
                        ct = null
                        break
                      }
                      if (x !== null) {
                        ;((x.return = E), (ct = x))
                        break
                      }
                      ct = E
                    }
                }
              }
              var S = s.alternate
              if (S !== null) {
                var k = S.child
                if (k !== null) {
                  S.child = null
                  do {
                    var D = k.sibling
                    ;((k.sibling = null), (k = D))
                  } while (k !== null)
                }
              }
              ct = s
            }
          }
          if (s.subtreeFlags & 2064 && c !== null) ((c.return = s), (ct = c))
          else
            t: for (; ct !== null; ) {
              if (((s = ct), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Ua(9, s, s.return)
                }
              var _ = s.sibling
              if (_ !== null) {
                ;((_.return = s.return), (ct = _))
                break t
              }
              ct = s.return
            }
        }
        var N = t.current
        for (ct = N; ct !== null; ) {
          c = ct
          var M = c.child
          if (c.subtreeFlags & 2064 && M !== null) ((M.return = c), (ct = M))
          else
            t: for (c = N; ct !== null; ) {
              if (((h = ct), h.flags & 2048))
                try {
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      rh(9, h)
                  }
                } catch (F) {
                  we(h, h.return, F)
                }
              if (h === c) {
                ct = null
                break t
              }
              var O = h.sibling
              if (O !== null) {
                ;((O.return = h.return), (ct = O))
                break t
              }
              ct = h.return
            }
        }
        if (((Lt = i), ji(), Ar && typeof Ar.onPostCommitFiberRoot == 'function'))
          try {
            Ar.onPostCommitFiberRoot(qu, t)
          } catch {}
        r = !0
      }
      return r
    } finally {
      ;((Ht = n), (Qn.transition = e))
    }
  }
  return !1
}
function zg(t, e, n) {
  ;((e = Ls(n, e)),
    (e = P4(t, e, 1)),
    (t = ki(t, e, 1)),
    (e = on()),
    t !== null && (Ml(t, 1, e), En(t, e)))
}
function we(t, e, n) {
  if (t.tag === 3) zg(t, t, n)
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        zg(e, t, n)
        break
      } else if (e.tag === 1) {
        var r = e.stateNode
        if (
          typeof e.type.getDerivedStateFromError == 'function' ||
          (typeof r.componentDidCatch == 'function' && (Ii === null || !Ii.has(r)))
        ) {
          ;((t = Ls(n, t)),
            (t = L4(e, t, 1)),
            (e = ki(e, t, 1)),
            (t = on()),
            e !== null && (Ml(e, 1, t), En(e, t)))
          break
        }
      }
      e = e.return
    }
}
function nE(t, e, n) {
  var r = t.pingCache
  ;(r !== null && r.delete(e),
    (e = on()),
    (t.pingedLanes |= t.suspendedLanes & n),
    Le === t &&
      (Xe & n) === n &&
      (Re === 4 || (Re === 3 && (Xe & 130023424) === Xe && 500 > Ee() - l0) ? uo(t, 0) : (a0 |= n)),
    En(t, e))
}
function nw(t, e) {
  e === 0 && (t.mode & 1 ? ((e = ac), (ac <<= 1), !(ac & 130023424) && (ac = 4194304)) : (e = 1))
  var n = on()
  ;((t = Yr(t, e)), t !== null && (Ml(t, e, n), En(t, n)))
}
function rE(t) {
  var e = t.memoizedState,
    n = 0
  ;(e !== null && (n = e.retryLane), nw(t, n))
}
function iE(t, e) {
  var n = 0
  switch (t.tag) {
    case 13:
      var r = t.stateNode,
        i = t.memoizedState
      i !== null && (n = i.retryLane)
      break
    case 19:
      r = t.stateNode
      break
    default:
      throw Error(tt(314))
  }
  ;(r !== null && r.delete(e), nw(t, n))
}
var rw
rw = function (t, e, n) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || vn.current) bn = !0
    else {
      if (!(t.lanes & n) && !(e.flags & 128)) return ((bn = !1), Xx(t, e, n))
      bn = !!(t.flags & 131072)
    }
  else ((bn = !1), oe && e.flags & 1048576 && s4(e, mu, e.index))
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var r = e.type
      ;(Hc(t, e), (t = e.pendingProps))
      var i = Ns(e, tn.current)
      ;(Is(e, n), (i = e0(null, e, r, t, i, n)))
      var s = n0()
      return (
        (e.flags |= 1),
        typeof i == 'object' && i !== null && typeof i.render == 'function' && i.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            xn(r) ? ((s = !0), pu(e)) : (s = !1),
            (e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null),
            Kf(e),
            (i.updater = nh),
            (e.stateNode = i),
            (i._reactInternals = e),
            A1(e, r, t, n),
            (e = _1(null, e, r, !0, s, n)))
          : ((e.tag = 0), oe && s && zf(e), rn(null, e, i, n), (e = e.child)),
        e
      )
    case 16:
      r = e.elementType
      t: {
        switch (
          (Hc(t, e),
          (t = e.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (e.type = r),
          (i = e.tag = sE(r)),
          (t = sr(r, t)),
          i)
        ) {
          case 0:
            e = I1(null, e, r, t, n)
            break t
          case 1:
            e = Dg(null, e, r, t, n)
            break t
          case 11:
            e = Ng(null, e, r, t, n)
            break t
          case 14:
            e = Mg(null, e, r, sr(r.type, t), n)
            break t
        }
        throw Error(tt(306, r, ''))
      }
      return e
    case 0:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : sr(r, i)),
        I1(t, e, r, i, n)
      )
    case 1:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : sr(r, i)),
        Dg(t, e, r, i, n)
      )
    case 3:
      t: {
        if ((j4(e), t === null)) throw Error(tt(387))
        ;((r = e.pendingProps), (s = e.memoizedState), (i = s.element), d4(t, e), bu(e, r, null, n))
        var c = e.memoizedState
        if (((r = c.element), s.isDehydrated))
          if (
            ((s = {
              element: r,
              isDehydrated: !1,
              cache: c.cache,
              pendingSuspenseBoundaries: c.pendingSuspenseBoundaries,
              transitions: c.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            ;((i = Ls(Error(tt(423)), e)), (e = Pg(t, e, r, n, i)))
            break t
          } else if (r !== i) {
            ;((i = Ls(Error(tt(424)), e)), (e = Pg(t, e, r, n, i)))
            break t
          } else
            for (
              Tn = Ai(e.stateNode.containerInfo.firstChild),
                Dn = e,
                oe = !0,
                lr = null,
                n = u4(e, null, r, n),
                e.child = n;
              n;

            )
              ((n.flags = (n.flags & -3) | 4096), (n = n.sibling))
        else {
          if ((Ms(), r === i)) {
            e = Zr(t, e, n)
            break t
          }
          rn(t, e, r, n)
        }
        e = e.child
      }
      return e
    case 5:
      return (
        f4(e),
        t === null && E1(e),
        (r = e.type),
        (i = e.pendingProps),
        (s = t !== null ? t.memoizedProps : null),
        (c = i.children),
        y1(r, i) ? (c = null) : s !== null && y1(r, s) && (e.flags |= 32),
        F4(t, e),
        rn(t, e, c, n),
        e.child
      )
    case 6:
      return (t === null && E1(e), null)
    case 13:
      return V4(t, e, n)
    case 4:
      return (
        Qf(e, e.stateNode.containerInfo),
        (r = e.pendingProps),
        t === null ? (e.child = Ds(e, null, r, n)) : rn(t, e, r, n),
        e.child
      )
    case 11:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : sr(r, i)),
        Ng(t, e, r, i, n)
      )
    case 7:
      return (rn(t, e, e.pendingProps, n), e.child)
    case 8:
      return (rn(t, e, e.pendingProps.children, n), e.child)
    case 12:
      return (rn(t, e, e.pendingProps.children, n), e.child)
    case 10:
      t: {
        if (
          ((r = e.type._context),
          (i = e.pendingProps),
          (s = e.memoizedProps),
          (c = i.value),
          $t(yu, r._currentValue),
          (r._currentValue = c),
          s !== null)
        )
          if (hr(s.value, c)) {
            if (s.children === i.children && !vn.current) {
              e = Zr(t, e, n)
              break t
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var h = s.dependencies
              if (h !== null) {
                c = s.child
                for (var f = h.firstContext; f !== null; ) {
                  if (f.context === r) {
                    if (s.tag === 1) {
                      ;((f = Ur(-1, n & -n)), (f.tag = 2))
                      var p = s.updateQueue
                      if (p !== null) {
                        p = p.shared
                        var y = p.pending
                        ;(y === null ? (f.next = f) : ((f.next = y.next), (y.next = f)),
                          (p.pending = f))
                      }
                    }
                    ;((s.lanes |= n),
                      (f = s.alternate),
                      f !== null && (f.lanes |= n),
                      C1(s.return, n, e),
                      (h.lanes |= n))
                    break
                  }
                  f = f.next
                }
              } else if (s.tag === 10) c = s.type === e.type ? null : s.child
              else if (s.tag === 18) {
                if (((c = s.return), c === null)) throw Error(tt(341))
                ;((c.lanes |= n),
                  (h = c.alternate),
                  h !== null && (h.lanes |= n),
                  C1(c, n, e),
                  (c = s.sibling))
              } else c = s.child
              if (c !== null) c.return = s
              else
                for (c = s; c !== null; ) {
                  if (c === e) {
                    c = null
                    break
                  }
                  if (((s = c.sibling), s !== null)) {
                    ;((s.return = c.return), (c = s))
                    break
                  }
                  c = c.return
                }
              s = c
            }
        ;(rn(t, e, i.children, n), (e = e.child))
      }
      return e
    case 9:
      return (
        (i = e.type),
        (r = e.pendingProps.children),
        Is(e, n),
        (i = $n(i)),
        (r = r(i)),
        (e.flags |= 1),
        rn(t, e, r, n),
        e.child
      )
    case 14:
      return ((r = e.type), (i = sr(r, e.pendingProps)), (i = sr(r.type, i)), Mg(t, e, r, i, n))
    case 15:
      return O4(t, e, e.type, e.pendingProps, n)
    case 17:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : sr(r, i)),
        Hc(t, e),
        (e.tag = 1),
        xn(r) ? ((t = !0), pu(e)) : (t = !1),
        Is(e, n),
        D4(e, r, i),
        A1(e, r, i, n),
        _1(null, e, r, !0, t, n)
      )
    case 19:
      return W4(t, e, n)
    case 22:
      return B4(t, e, n)
  }
  throw Error(tt(156, e.tag))
}
function iw(t, e) {
  return T8(t, e)
}
function oE(t, e, n, r) {
  ;((this.tag = t),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null))
}
function qn(t, e, n, r) {
  return new oE(t, e, n, r)
}
function d0(t) {
  return ((t = t.prototype), !(!t || !t.isReactComponent))
}
function sE(t) {
  if (typeof t == 'function') return d0(t) ? 1 : 0
  if (t != null) {
    if (((t = t.$$typeof), t === Nf)) return 11
    if (t === Mf) return 14
  }
  return 2
}
function Ri(t, e) {
  var n = t.alternate
  return (
    n === null
      ? ((n = qn(t.tag, e, t.key, t.mode)),
        (n.elementType = t.elementType),
        (n.type = t.type),
        (n.stateNode = t.stateNode),
        (n.alternate = t),
        (t.alternate = n))
      : ((n.pendingProps = e),
        (n.type = t.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = t.flags & 14680064),
    (n.childLanes = t.childLanes),
    (n.lanes = t.lanes),
    (n.child = t.child),
    (n.memoizedProps = t.memoizedProps),
    (n.memoizedState = t.memoizedState),
    (n.updateQueue = t.updateQueue),
    (e = t.dependencies),
    (n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (n.sibling = t.sibling),
    (n.index = t.index),
    (n.ref = t.ref),
    n
  )
}
function Yc(t, e, n, r, i, s) {
  var c = 2
  if (((r = t), typeof t == 'function')) d0(t) && (c = 1)
  else if (typeof t == 'string') c = 5
  else
    t: switch (t) {
      case os:
        return ho(n.children, i, s, e)
      case Tf:
        ;((c = 8), (i |= 8))
        break
      case qd:
        return ((t = qn(12, n, e, i | 2)), (t.elementType = qd), (t.lanes = s), t)
      case Kd:
        return ((t = qn(13, n, e, i)), (t.elementType = Kd), (t.lanes = s), t)
      case Qd:
        return ((t = qn(19, n, e, i)), (t.elementType = Qd), (t.lanes = s), t)
      case f8:
        return oh(n, i, s, e)
      default:
        if (typeof t == 'object' && t !== null)
          switch (t.$$typeof) {
            case h8:
              c = 10
              break t
            case d8:
              c = 9
              break t
            case Nf:
              c = 11
              break t
            case Mf:
              c = 14
              break t
            case ci:
              ;((c = 16), (r = null))
              break t
          }
        throw Error(tt(130, t == null ? t : typeof t, ''))
    }
  return ((e = qn(c, n, e, i)), (e.elementType = t), (e.type = r), (e.lanes = s), e)
}
function ho(t, e, n, r) {
  return ((t = qn(7, t, r, e)), (t.lanes = n), t)
}
function oh(t, e, n, r) {
  return (
    (t = qn(22, t, r, e)),
    (t.elementType = f8),
    (t.lanes = n),
    (t.stateNode = { isHidden: !1 }),
    t
  )
}
function yd(t, e, n) {
  return ((t = qn(6, t, null, e)), (t.lanes = n), t)
}
function wd(t, e, n) {
  return (
    (e = qn(4, t.children !== null ? t.children : [], t.key, e)),
    (e.lanes = n),
    (e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation,
    }),
    e
  )
}
function aE(t, e, n, r, i) {
  ;((this.tag = e),
    (this.containerInfo = t),
    (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = $h(0)),
    (this.expirationTimes = $h(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = $h(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null))
}
function f0(t, e, n, r, i, s, c, h, f) {
  return (
    (t = new aE(t, e, n, h, f)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = qn(3, null, null, e)),
    (t.current = s),
    (s.stateNode = t),
    (s.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    Kf(s),
    t
  )
}
function lE(t, e, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
  return {
    $$typeof: is,
    key: r == null ? null : '' + r,
    children: t,
    containerInfo: e,
    implementation: n,
  }
}
function ow(t) {
  if (!t) return Di
  t = t._reactInternals
  t: {
    if (Io(t) !== t || t.tag !== 1) throw Error(tt(170))
    var e = t
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context
          break t
        case 1:
          if (xn(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext
            break t
          }
      }
      e = e.return
    } while (e !== null)
    throw Error(tt(171))
  }
  if (t.tag === 1) {
    var n = t.type
    if (xn(n)) return i4(t, n, e)
  }
  return e
}
function sw(t, e, n, r, i, s, c, h, f) {
  return (
    (t = f0(n, r, !0, t, i, s, c, h, f)),
    (t.context = ow(null)),
    (n = t.current),
    (r = on()),
    (i = _i(n)),
    (s = Ur(r, i)),
    (s.callback = e ?? null),
    ki(n, s, i),
    (t.current.lanes = i),
    Ml(t, i, r),
    En(t, r),
    t
  )
}
function sh(t, e, n, r) {
  var i = e.current,
    s = on(),
    c = _i(i)
  return (
    (n = ow(n)),
    e.context === null ? (e.context = n) : (e.pendingContext = n),
    (e = Ur(s, c)),
    (e.payload = { element: t }),
    (r = r === void 0 ? null : r),
    r !== null && (e.callback = r),
    (t = ki(i, e, c)),
    t !== null && (ur(t, i, c, s), Wc(t, i, c)),
    c
  )
}
function Iu(t) {
  if (((t = t.current), !t.child)) return null
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode
    default:
      return t.child.stateNode
  }
}
function Hg(t, e) {
  if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
    var n = t.retryLane
    t.retryLane = n !== 0 && n < e ? n : e
  }
}
function p0(t, e) {
  ;(Hg(t, e), (t = t.alternate) && Hg(t, e))
}
function cE() {
  return null
}
var aw =
  typeof reportError == 'function'
    ? reportError
    : function (t) {
        console.error(t)
      }
function g0(t) {
  this._internalRoot = t
}
ah.prototype.render = g0.prototype.render = function (t) {
  var e = this._internalRoot
  if (e === null) throw Error(tt(409))
  sh(t, e, null, null)
}
ah.prototype.unmount = g0.prototype.unmount = function () {
  var t = this._internalRoot
  if (t !== null) {
    this._internalRoot = null
    var e = t.containerInfo
    ;(xo(function () {
      sh(null, t, null, null)
    }),
      (e[Gr] = null))
  }
}
function ah(t) {
  this._internalRoot = t
}
ah.prototype.unstable_scheduleHydration = function (t) {
  if (t) {
    var e = B8()
    t = { blockedOn: null, target: t, priority: e }
    for (var n = 0; n < hi.length && e !== 0 && e < hi[n].priority; n++);
    ;(hi.splice(n, 0, t), n === 0 && j8(t))
  }
}
function m0(t) {
  return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11))
}
function lh(t) {
  return !(
    !t ||
    (t.nodeType !== 1 &&
      t.nodeType !== 9 &&
      t.nodeType !== 11 &&
      (t.nodeType !== 8 || t.nodeValue !== ' react-mount-point-unstable '))
  )
}
function Xg() {}
function uE(t, e, n, r, i) {
  if (i) {
    if (typeof r == 'function') {
      var s = r
      r = function () {
        var p = Iu(c)
        s.call(p)
      }
    }
    var c = sw(e, r, t, 0, null, !1, !1, '', Xg)
    return (
      (t._reactRootContainer = c),
      (t[Gr] = c.current),
      cl(t.nodeType === 8 ? t.parentNode : t),
      xo(),
      c
    )
  }
  for (; (i = t.lastChild); ) t.removeChild(i)
  if (typeof r == 'function') {
    var h = r
    r = function () {
      var p = Iu(f)
      h.call(p)
    }
  }
  var f = f0(t, 0, !1, null, null, !1, !1, '', Xg)
  return (
    (t._reactRootContainer = f),
    (t[Gr] = f.current),
    cl(t.nodeType === 8 ? t.parentNode : t),
    xo(function () {
      sh(e, f, n, r)
    }),
    f
  )
}
function ch(t, e, n, r, i) {
  var s = n._reactRootContainer
  if (s) {
    var c = s
    if (typeof i == 'function') {
      var h = i
      i = function () {
        var f = Iu(c)
        h.call(f)
      }
    }
    sh(e, c, t, i)
  } else c = uE(n, e, t, i, r)
  return Iu(c)
}
L8 = function (t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode
      if (e.current.memoizedState.isDehydrated) {
        var n = _a(e.pendingLanes)
        n !== 0 && (Lf(e, n | 1), En(e, Ee()), !(Lt & 6) && ((Os = Ee() + 500), ji()))
      }
      break
    case 13:
      ;(xo(function () {
        var r = Yr(t, 1)
        if (r !== null) {
          var i = on()
          ur(r, t, 1, i)
        }
      }),
        p0(t, 1))
  }
}
Of = function (t) {
  if (t.tag === 13) {
    var e = Yr(t, 134217728)
    if (e !== null) {
      var n = on()
      ur(e, t, 134217728, n)
    }
    p0(t, 134217728)
  }
}
O8 = function (t) {
  if (t.tag === 13) {
    var e = _i(t),
      n = Yr(t, e)
    if (n !== null) {
      var r = on()
      ur(n, t, e, r)
    }
    p0(t, e)
  }
}
B8 = function () {
  return Ht
}
F8 = function (t, e) {
  var n = Ht
  try {
    return ((Ht = t), e())
  } finally {
    Ht = n
  }
}
a1 = function (t, e, n) {
  switch (e) {
    case 'input':
      if ((t1(t, n), (e = n.name), n.type === 'radio' && e != null)) {
        for (n = t; n.parentNode; ) n = n.parentNode
        for (
          n = n.querySelectorAll('input[name=' + JSON.stringify('' + e) + '][type="radio"]'), e = 0;
          e < n.length;
          e++
        ) {
          var r = n[e]
          if (r !== t && r.form === t.form) {
            var i = Ju(r)
            if (!i) throw Error(tt(90))
            ;(g8(r), t1(r, i))
          }
        }
      }
      break
    case 'textarea':
      y8(t, n)
      break
    case 'select':
      ;((e = n.value), e != null && Cs(t, !!n.multiple, e, !1))
  }
}
S8 = c0
A8 = xo
var hE = { usingClientEntryPoint: !1, Events: [Pl, cs, Ju, E8, C8, c0] },
  ba = {
    findFiberByHostInstance: oo,
    bundleType: 0,
    version: '18.3.1',
    rendererPackageName: 'react-dom',
  },
  dE = {
    bundleType: ba.bundleType,
    version: ba.version,
    rendererPackageName: ba.rendererPackageName,
    rendererConfig: ba.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Kr.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return ((t = _8(t)), t === null ? null : t.stateNode)
    },
    findFiberByHostInstance: ba.findFiberByHostInstance || cE,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: '18.3.1-next-f1338f8080-20240426',
  }
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
  var wc = __REACT_DEVTOOLS_GLOBAL_HOOK__
  if (!wc.isDisabled && wc.supportsFiber)
    try {
      ;((qu = wc.inject(dE)), (Ar = wc))
    } catch {}
}
Fn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hE
Fn.createPortal = function (t, e) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
  if (!m0(e)) throw Error(tt(200))
  return lE(t, e, null, n)
}
Fn.createRoot = function (t, e) {
  if (!m0(t)) throw Error(tt(299))
  var n = !1,
    r = '',
    i = aw
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (n = !0),
      e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    (e = f0(t, 1, !1, null, null, n, !1, r, i)),
    (t[Gr] = e.current),
    cl(t.nodeType === 8 ? t.parentNode : t),
    new g0(e)
  )
}
Fn.findDOMNode = function (t) {
  if (t == null) return null
  if (t.nodeType === 1) return t
  var e = t._reactInternals
  if (e === void 0)
    throw typeof t.render == 'function'
      ? Error(tt(188))
      : ((t = Object.keys(t).join(',')), Error(tt(268, t)))
  return ((t = _8(e)), (t = t === null ? null : t.stateNode), t)
}
Fn.flushSync = function (t) {
  return xo(t)
}
Fn.hydrate = function (t, e, n) {
  if (!lh(e)) throw Error(tt(200))
  return ch(null, t, e, !0, n)
}
Fn.hydrateRoot = function (t, e, n) {
  if (!m0(t)) throw Error(tt(405))
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    s = '',
    c = aw
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (c = n.onRecoverableError)),
    (e = sw(e, null, t, 1, n ?? null, i, !1, s, c)),
    (t[Gr] = e.current),
    cl(t),
    r)
  )
    for (t = 0; t < r.length; t++)
      ((n = r[t]),
        (i = n._getVersion),
        (i = i(n._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [n, i])
          : e.mutableSourceEagerHydrationData.push(n, i))
  return new ah(e)
}
Fn.render = function (t, e, n) {
  if (!lh(e)) throw Error(tt(200))
  return ch(null, t, e, !1, n)
}
Fn.unmountComponentAtNode = function (t) {
  if (!lh(t)) throw Error(tt(40))
  return t._reactRootContainer
    ? (xo(function () {
        ch(null, null, t, !1, function () {
          ;((t._reactRootContainer = null), (t[Gr] = null))
        })
      }),
      !0)
    : !1
}
Fn.unstable_batchedUpdates = c0
Fn.unstable_renderSubtreeIntoContainer = function (t, e, n, r) {
  if (!lh(n)) throw Error(tt(200))
  if (t == null || t._reactInternals === void 0) throw Error(tt(38))
  return ch(t, e, n, !1, r)
}
Fn.version = '18.3.1-next-f1338f8080-20240426'
function lw() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(lw)
    } catch (t) {
      console.error(t)
    }
}
;(lw(), (a8.exports = Fn))
var fE = a8.exports,
  cw,
  Gg = fE
;((cw = Gg.createRoot), Gg.hydrateRoot)
/**
 * @remix-run/router v1.23.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function wl() {
  return (
    (wl = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e]
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
          }
          return t
        }),
    wl.apply(this, arguments)
  )
}
var gi
;(function (t) {
  ;((t.Pop = 'POP'), (t.Push = 'PUSH'), (t.Replace = 'REPLACE'))
})(gi || (gi = {}))
const Yg = 'popstate'
function pE(t) {
  t === void 0 && (t = {})
  function e(i, s) {
    let { pathname: c = '/', search: h = '', hash: f = '' } = _o(i.location.hash.substr(1))
    return (
      !c.startsWith('/') && !c.startsWith('.') && (c = '/' + c),
      j1(
        '',
        { pathname: c, search: h, hash: f },
        (s.state && s.state.usr) || null,
        (s.state && s.state.key) || 'default'
      )
    )
  }
  function n(i, s) {
    let c = i.document.querySelector('base'),
      h = ''
    if (c && c.getAttribute('href')) {
      let f = i.location.href,
        p = f.indexOf('#')
      h = p === -1 ? f : f.slice(0, p)
    }
    return h + '#' + (typeof s == 'string' ? s : _u(s))
  }
  function r(i, s) {
    uh(
      i.pathname.charAt(0) === '/',
      'relative pathnames are not supported in hash history.push(' + JSON.stringify(s) + ')'
    )
  }
  return mE(e, n, r, t)
}
function he(t, e) {
  if (t === !1 || t === null || typeof t > 'u') throw new Error(e)
}
function uh(t, e) {
  if (!t) {
    typeof console < 'u' && console.warn(e)
    try {
      throw new Error(e)
    } catch {}
  }
}
function gE() {
  return Math.random().toString(36).substr(2, 8)
}
function Zg(t, e) {
  return { usr: t.state, key: t.key, idx: e }
}
function j1(t, e, n, r) {
  return (
    n === void 0 && (n = null),
    wl(
      { pathname: typeof t == 'string' ? t : t.pathname, search: '', hash: '' },
      typeof e == 'string' ? _o(e) : e,
      { state: n, key: (e && e.key) || r || gE() }
    )
  )
}
function _u(t) {
  let { pathname: e = '/', search: n = '', hash: r = '' } = t
  return (
    n && n !== '?' && (e += n.charAt(0) === '?' ? n : '?' + n),
    r && r !== '#' && (e += r.charAt(0) === '#' ? r : '#' + r),
    e
  )
}
function _o(t) {
  let e = {}
  if (t) {
    let n = t.indexOf('#')
    n >= 0 && ((e.hash = t.substr(n)), (t = t.substr(0, n)))
    let r = t.indexOf('?')
    ;(r >= 0 && ((e.search = t.substr(r)), (t = t.substr(0, r))), t && (e.pathname = t))
  }
  return e
}
function mE(t, e, n, r) {
  r === void 0 && (r = {})
  let { window: i = document.defaultView, v5Compat: s = !1 } = r,
    c = i.history,
    h = gi.Pop,
    f = null,
    p = y()
  p == null && ((p = 0), c.replaceState(wl({}, c.state, { idx: p }), ''))
  function y() {
    return (c.state || { idx: null }).idx
  }
  function w() {
    h = gi.Pop
    let D = y(),
      _ = D == null ? null : D - p
    ;((p = D), f && f({ action: h, location: k.location, delta: _ }))
  }
  function x(D, _) {
    h = gi.Push
    let N = j1(k.location, D, _)
    ;(n && n(N, D), (p = y() + 1))
    let M = Zg(N, p),
      O = k.createHref(N)
    try {
      c.pushState(M, '', O)
    } catch (F) {
      if (F instanceof DOMException && F.name === 'DataCloneError') throw F
      i.location.assign(O)
    }
    s && f && f({ action: h, location: k.location, delta: 1 })
  }
  function E(D, _) {
    h = gi.Replace
    let N = j1(k.location, D, _)
    ;(n && n(N, D), (p = y()))
    let M = Zg(N, p),
      O = k.createHref(N)
    ;(c.replaceState(M, '', O), s && f && f({ action: h, location: k.location, delta: 0 }))
  }
  function S(D) {
    let _ = i.location.origin !== 'null' ? i.location.origin : i.location.href,
      N = typeof D == 'string' ? D : _u(D)
    return (
      (N = N.replace(/ $/, '%20')),
      he(_, 'No window.location.(origin|href) available to create URL for href: ' + N),
      new URL(N, _)
    )
  }
  let k = {
    get action() {
      return h
    },
    get location() {
      return t(i, c)
    },
    listen(D) {
      if (f) throw new Error('A history only accepts one active listener')
      return (
        i.addEventListener(Yg, w),
        (f = D),
        () => {
          ;(i.removeEventListener(Yg, w), (f = null))
        }
      )
    },
    createHref(D) {
      return e(i, D)
    },
    createURL: S,
    encodeLocation(D) {
      let _ = S(D)
      return { pathname: _.pathname, search: _.search, hash: _.hash }
    },
    push: x,
    replace: E,
    go(D) {
      return c.go(D)
    },
  }
  return k
}
var qg
;(function (t) {
  ;((t.data = 'data'), (t.deferred = 'deferred'), (t.redirect = 'redirect'), (t.error = 'error'))
})(qg || (qg = {}))
function yE(t, e, n) {
  return (n === void 0 && (n = '/'), wE(t, e, n))
}
function wE(t, e, n, r) {
  let i = typeof e == 'string' ? _o(e) : e,
    s = Bs(i.pathname || '/', n)
  if (s == null) return null
  let c = uw(t)
  bE(c)
  let h = null
  for (let f = 0; h == null && f < c.length; ++f) {
    let p = TE(s)
    h = _E(c[f], p)
  }
  return h
}
function uw(t, e, n, r) {
  ;(e === void 0 && (e = []), n === void 0 && (n = []), r === void 0 && (r = ''))
  let i = (s, c, h) => {
    let f = {
      relativePath: h === void 0 ? s.path || '' : h,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: c,
      route: s,
    }
    f.relativePath.startsWith('/') &&
      (he(
        f.relativePath.startsWith(r),
        'Absolute route path "' +
          f.relativePath +
          '" nested under path ' +
          ('"' + r + '" is not valid. An absolute child route path ') +
          'must start with the combined path of all its parent routes.'
      ),
      (f.relativePath = f.relativePath.slice(r.length)))
    let p = Ti([r, f.relativePath]),
      y = n.concat(f)
    ;(s.children &&
      s.children.length > 0 &&
      (he(
        s.index !== !0,
        'Index routes must not have child routes. Please remove ' +
          ('all child routes from route path "' + p + '".')
      ),
      uw(s.children, e, y, p)),
      !(s.path == null && !s.index) && e.push({ path: p, score: kE(p, s.index), routesMeta: y }))
  }
  return (
    t.forEach((s, c) => {
      var h
      if (s.path === '' || !((h = s.path) != null && h.includes('?'))) i(s, c)
      else for (let f of hw(s.path)) i(s, c, f)
    }),
    e
  )
}
function hw(t) {
  let e = t.split('/')
  if (e.length === 0) return []
  let [n, ...r] = e,
    i = n.endsWith('?'),
    s = n.replace(/\?$/, '')
  if (r.length === 0) return i ? [s, ''] : [s]
  let c = hw(r.join('/')),
    h = []
  return (
    h.push(...c.map((f) => (f === '' ? s : [s, f].join('/')))),
    i && h.push(...c),
    h.map((f) => (t.startsWith('/') && f === '' ? '/' : f))
  )
}
function bE(t) {
  t.sort((e, n) =>
    e.score !== n.score
      ? n.score - e.score
      : IE(
          e.routesMeta.map((r) => r.childrenIndex),
          n.routesMeta.map((r) => r.childrenIndex)
        )
  )
}
const vE = /^:[\w-]+$/,
  xE = 3,
  EE = 2,
  CE = 1,
  SE = 10,
  AE = -2,
  Kg = (t) => t === '*'
function kE(t, e) {
  let n = t.split('/'),
    r = n.length
  return (
    n.some(Kg) && (r += AE),
    e && (r += EE),
    n.filter((i) => !Kg(i)).reduce((i, s) => i + (vE.test(s) ? xE : s === '' ? CE : SE), r)
  )
}
function IE(t, e) {
  return t.length === e.length && t.slice(0, -1).every((n, r) => n === e[r])
    ? t[t.length - 1] - e[e.length - 1]
    : 0
}
function _E(t, e, n) {
  let { routesMeta: r } = t,
    i = {},
    s = '/',
    c = []
  for (let h = 0; h < r.length; ++h) {
    let f = r[h],
      p = h === r.length - 1,
      y = s === '/' ? e : e.slice(s.length) || '/',
      w = V1({ path: f.relativePath, caseSensitive: f.caseSensitive, end: p }, y),
      x = f.route
    if (!w) return null
    ;(Object.assign(i, w.params),
      c.push({
        params: i,
        pathname: Ti([s, w.pathname]),
        pathnameBase: LE(Ti([s, w.pathnameBase])),
        route: x,
      }),
      w.pathnameBase !== '/' && (s = Ti([s, w.pathnameBase])))
  }
  return c
}
function V1(t, e) {
  typeof t == 'string' && (t = { path: t, caseSensitive: !1, end: !0 })
  let [n, r] = RE(t.path, t.caseSensitive, t.end),
    i = e.match(n)
  if (!i) return null
  let s = i[0],
    c = s.replace(/(.)\/+$/, '$1'),
    h = i.slice(1)
  return {
    params: r.reduce((f, p, y) => {
      let { paramName: w, isOptional: x } = p
      if (w === '*') {
        let S = h[y] || ''
        c = s.slice(0, s.length - S.length).replace(/(.)\/+$/, '$1')
      }
      const E = h[y]
      return (x && !E ? (f[w] = void 0) : (f[w] = (E || '').replace(/%2F/g, '/')), f)
    }, {}),
    pathname: s,
    pathnameBase: c,
    pattern: t,
  }
}
function RE(t, e, n) {
  ;(e === void 0 && (e = !1),
    n === void 0 && (n = !0),
    uh(
      t === '*' || !t.endsWith('*') || t.endsWith('/*'),
      'Route path "' +
        t +
        '" will be treated as if it were ' +
        ('"' + t.replace(/\*$/, '/*') + '" because the `*` character must ') +
        'always follow a `/` in the pattern. To get rid of this warning, ' +
        ('please change the route path to "' + t.replace(/\*$/, '/*') + '".')
    ))
  let r = [],
    i =
      '^' +
      t
        .replace(/\/*\*?$/, '')
        .replace(/^\/*/, '/')
        .replace(/[\\.*+^${}|()[\]]/g, '\\$&')
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (s, c, h) => (
            r.push({ paramName: c, isOptional: h != null }),
            h ? '/?([^\\/]+)?' : '/([^\\/]+)'
          )
        )
  return (
    t.endsWith('*')
      ? (r.push({ paramName: '*' }), (i += t === '*' || t === '/*' ? '(.*)$' : '(?:\\/(.+)|\\/*)$'))
      : n
        ? (i += '\\/*$')
        : t !== '' && t !== '/' && (i += '(?:(?=\\/|$))'),
    [new RegExp(i, e ? void 0 : 'i'), r]
  )
}
function TE(t) {
  try {
    return t
      .split('/')
      .map((e) => decodeURIComponent(e).replace(/\//g, '%2F'))
      .join('/')
  } catch (e) {
    return (
      uh(
        !1,
        'The URL path "' +
          t +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ('encoding (' + e + ').')
      ),
      t
    )
  }
}
function Bs(t, e) {
  if (e === '/') return t
  if (!t.toLowerCase().startsWith(e.toLowerCase())) return null
  let n = e.endsWith('/') ? e.length - 1 : e.length,
    r = t.charAt(n)
  return r && r !== '/' ? null : t.slice(n) || '/'
}
const NE = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  ME = (t) => NE.test(t)
function DE(t, e) {
  e === void 0 && (e = '/')
  let { pathname: n, search: r = '', hash: i = '' } = typeof t == 'string' ? _o(t) : t,
    s
  if (n)
    if (ME(n)) s = n
    else {
      if (n.includes('//')) {
        let c = n
        ;((n = n.replace(/\/\/+/g, '/')),
          uh(!1, 'Pathnames cannot have embedded double slashes - normalizing ' + (c + ' -> ' + n)))
      }
      n.startsWith('/') ? (s = Qg(n.substring(1), '/')) : (s = Qg(n, e))
    }
  else s = e
  return { pathname: s, search: OE(r), hash: BE(i) }
}
function Qg(t, e) {
  let n = e.replace(/\/+$/, '').split('/')
  return (
    t.split('/').forEach((r) => {
      r === '..' ? n.length > 1 && n.pop() : r !== '.' && n.push(r)
    }),
    n.length > 1 ? n.join('/') : '/'
  )
}
function bd(t, e, n, r) {
  return (
    "Cannot include a '" +
    t +
    "' character in a manually specified " +
    ('`to.' + e + '` field [' + JSON.stringify(r) + '].  Please separate it out to the ') +
    ('`to.' + n + '` field. Alternatively you may provide the full path as ') +
    'a string in <Link to="..."> and the router will parse it for you.'
  )
}
function PE(t) {
  return t.filter((e, n) => n === 0 || (e.route.path && e.route.path.length > 0))
}
function y0(t, e) {
  let n = PE(t)
  return e
    ? n.map((r, i) => (i === n.length - 1 ? r.pathname : r.pathnameBase))
    : n.map((r) => r.pathnameBase)
}
function w0(t, e, n, r) {
  r === void 0 && (r = !1)
  let i
  typeof t == 'string'
    ? (i = _o(t))
    : ((i = wl({}, t)),
      he(!i.pathname || !i.pathname.includes('?'), bd('?', 'pathname', 'search', i)),
      he(!i.pathname || !i.pathname.includes('#'), bd('#', 'pathname', 'hash', i)),
      he(!i.search || !i.search.includes('#'), bd('#', 'search', 'hash', i)))
  let s = t === '' || i.pathname === '',
    c = s ? '/' : i.pathname,
    h
  if (c == null) h = n
  else {
    let w = e.length - 1
    if (!r && c.startsWith('..')) {
      let x = c.split('/')
      for (; x[0] === '..'; ) (x.shift(), (w -= 1))
      i.pathname = x.join('/')
    }
    h = w >= 0 ? e[w] : '/'
  }
  let f = DE(i, h),
    p = c && c !== '/' && c.endsWith('/'),
    y = (s || c === '.') && n.endsWith('/')
  return (!f.pathname.endsWith('/') && (p || y) && (f.pathname += '/'), f)
}
const Ti = (t) => t.join('/').replace(/\/\/+/g, '/'),
  LE = (t) => t.replace(/\/+$/, '').replace(/^\/*/, '/'),
  OE = (t) => (!t || t === '?' ? '' : t.startsWith('?') ? t : '?' + t),
  BE = (t) => (!t || t === '#' ? '' : t.startsWith('#') ? t : '#' + t)
function FE(t) {
  return (
    t != null &&
    typeof t.status == 'number' &&
    typeof t.statusText == 'string' &&
    typeof t.internal == 'boolean' &&
    'data' in t
  )
}
const dw = ['post', 'put', 'patch', 'delete']
new Set(dw)
const jE = ['get', ...dw]
new Set(jE)
/**
 * React Router v6.30.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function bl() {
  return (
    (bl = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e]
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
          }
          return t
        }),
    bl.apply(this, arguments)
  )
}
const hh = X.createContext(null),
  fw = X.createContext(null),
  Qr = X.createContext(null),
  dh = X.createContext(null),
  Vi = X.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
  pw = X.createContext(null)
function VE(t, e) {
  let { relative: n } = e === void 0 ? {} : e
  Ys() || he(!1)
  let { basename: r, navigator: i } = X.useContext(Qr),
    { hash: s, pathname: c, search: h } = fh(t, { relative: n }),
    f = c
  return (
    r !== '/' && (f = c === '/' ? r : Ti([r, c])),
    i.createHref({ pathname: f, search: h, hash: s })
  )
}
function Ys() {
  return X.useContext(dh) != null
}
function Zs() {
  return (Ys() || he(!1), X.useContext(dh).location)
}
function gw(t) {
  X.useContext(Qr).static || X.useLayoutEffect(t)
}
function b0() {
  let { isDataRoute: t } = X.useContext(Vi)
  return t ? JE() : WE()
}
function WE() {
  Ys() || he(!1)
  let t = X.useContext(hh),
    { basename: e, future: n, navigator: r } = X.useContext(Qr),
    { matches: i } = X.useContext(Vi),
    { pathname: s } = Zs(),
    c = JSON.stringify(y0(i, n.v7_relativeSplatPath)),
    h = X.useRef(!1)
  return (
    gw(() => {
      h.current = !0
    }),
    X.useCallback(
      function (f, p) {
        if ((p === void 0 && (p = {}), !h.current)) return
        if (typeof f == 'number') {
          r.go(f)
          return
        }
        let y = w0(f, JSON.parse(c), s, p.relative === 'path')
        ;(t == null && e !== '/' && (y.pathname = y.pathname === '/' ? e : Ti([e, y.pathname])),
          (p.replace ? r.replace : r.push)(y, p.state, p))
      },
      [e, r, c, s, t]
    )
  )
}
function fh(t, e) {
  let { relative: n } = e === void 0 ? {} : e,
    { future: r } = X.useContext(Qr),
    { matches: i } = X.useContext(Vi),
    { pathname: s } = Zs(),
    c = JSON.stringify(y0(i, r.v7_relativeSplatPath))
  return X.useMemo(() => w0(t, JSON.parse(c), s, n === 'path'), [t, c, s, n])
}
function UE(t, e) {
  return zE(t, e)
}
function zE(t, e, n, r) {
  Ys() || he(!1)
  let { navigator: i } = X.useContext(Qr),
    { matches: s } = X.useContext(Vi),
    c = s[s.length - 1],
    h = c ? c.params : {}
  c && c.pathname
  let f = c ? c.pathnameBase : '/'
  c && c.route
  let p = Zs(),
    y
  if (e) {
    var w
    let D = typeof e == 'string' ? _o(e) : e
    ;(f === '/' || ((w = D.pathname) != null && w.startsWith(f)) || he(!1), (y = D))
  } else y = p
  let x = y.pathname || '/',
    E = x
  if (f !== '/') {
    let D = f.replace(/^\//, '').split('/')
    E = '/' + x.replace(/^\//, '').split('/').slice(D.length).join('/')
  }
  let S = yE(t, { pathname: E }),
    k = ZE(
      S &&
        S.map((D) =>
          Object.assign({}, D, {
            params: Object.assign({}, h, D.params),
            pathname: Ti([
              f,
              i.encodeLocation ? i.encodeLocation(D.pathname).pathname : D.pathname,
            ]),
            pathnameBase:
              D.pathnameBase === '/'
                ? f
                : Ti([
                    f,
                    i.encodeLocation ? i.encodeLocation(D.pathnameBase).pathname : D.pathnameBase,
                  ]),
          })
        ),
      s,
      n,
      r
    )
  return e && k
    ? X.createElement(
        dh.Provider,
        {
          value: {
            location: bl({ pathname: '/', search: '', hash: '', state: null, key: 'default' }, y),
            navigationType: gi.Pop,
          },
        },
        k
      )
    : k
}
function HE() {
  let t = $E(),
    e = FE(t) ? t.status + ' ' + t.statusText : t instanceof Error ? t.message : JSON.stringify(t),
    n = t instanceof Error ? t.stack : null,
    r = { padding: '0.5rem', backgroundColor: 'rgba(200,200,200, 0.5)' }
  return X.createElement(
    X.Fragment,
    null,
    X.createElement('h2', null, 'Unexpected Application Error!'),
    X.createElement('h3', { style: { fontStyle: 'italic' } }, e),
    n ? X.createElement('pre', { style: r }, n) : null,
    null
  )
}
const XE = X.createElement(HE, null)
class GE extends X.Component {
  constructor(e) {
    ;(super(e),
      (this.state = { location: e.location, revalidation: e.revalidation, error: e.error }))
  }
  static getDerivedStateFromError(e) {
    return { error: e }
  }
  static getDerivedStateFromProps(e, n) {
    return n.location !== e.location || (n.revalidation !== 'idle' && e.revalidation === 'idle')
      ? { error: e.error, location: e.location, revalidation: e.revalidation }
      : {
          error: e.error !== void 0 ? e.error : n.error,
          location: n.location,
          revalidation: e.revalidation || n.revalidation,
        }
  }
  componentDidCatch(e, n) {
    console.error('React Router caught the following error during render', e, n)
  }
  render() {
    return this.state.error !== void 0
      ? X.createElement(
          Vi.Provider,
          { value: this.props.routeContext },
          X.createElement(pw.Provider, { value: this.state.error, children: this.props.component })
        )
      : this.props.children
  }
}
function YE(t) {
  let { routeContext: e, match: n, children: r } = t,
    i = X.useContext(hh)
  return (
    i &&
      i.static &&
      i.staticContext &&
      (n.route.errorElement || n.route.ErrorBoundary) &&
      (i.staticContext._deepestRenderedBoundaryId = n.route.id),
    X.createElement(Vi.Provider, { value: e }, r)
  )
}
function ZE(t, e, n, r) {
  var i
  if (
    (e === void 0 && (e = []), n === void 0 && (n = null), r === void 0 && (r = null), t == null)
  ) {
    var s
    if (!n) return null
    if (n.errors) t = n.matches
    else if (
      (s = r) != null &&
      s.v7_partialHydration &&
      e.length === 0 &&
      !n.initialized &&
      n.matches.length > 0
    )
      t = n.matches
    else return null
  }
  let c = t,
    h = (i = n) == null ? void 0 : i.errors
  if (h != null) {
    let y = c.findIndex((w) => w.route.id && (h == null ? void 0 : h[w.route.id]) !== void 0)
    ;(y >= 0 || he(!1), (c = c.slice(0, Math.min(c.length, y + 1))))
  }
  let f = !1,
    p = -1
  if (n && r && r.v7_partialHydration)
    for (let y = 0; y < c.length; y++) {
      let w = c[y]
      if (((w.route.HydrateFallback || w.route.hydrateFallbackElement) && (p = y), w.route.id)) {
        let { loaderData: x, errors: E } = n,
          S = w.route.loader && x[w.route.id] === void 0 && (!E || E[w.route.id] === void 0)
        if (w.route.lazy || S) {
          ;((f = !0), p >= 0 ? (c = c.slice(0, p + 1)) : (c = [c[0]]))
          break
        }
      }
    }
  return c.reduceRight((y, w, x) => {
    let E,
      S = !1,
      k = null,
      D = null
    n &&
      ((E = h && w.route.id ? h[w.route.id] : void 0),
      (k = w.route.errorElement || XE),
      f &&
        (p < 0 && x === 0
          ? (tC('route-fallback'), (S = !0), (D = null))
          : p === x && ((S = !0), (D = w.route.hydrateFallbackElement || null))))
    let _ = e.concat(c.slice(0, x + 1)),
      N = () => {
        let M
        return (
          E
            ? (M = k)
            : S
              ? (M = D)
              : w.route.Component
                ? (M = X.createElement(w.route.Component, null))
                : w.route.element
                  ? (M = w.route.element)
                  : (M = y),
          X.createElement(YE, {
            match: w,
            routeContext: { outlet: y, matches: _, isDataRoute: n != null },
            children: M,
          })
        )
      }
    return n && (w.route.ErrorBoundary || w.route.errorElement || x === 0)
      ? X.createElement(GE, {
          location: n.location,
          revalidation: n.revalidation,
          component: k,
          error: E,
          children: N(),
          routeContext: { outlet: null, matches: _, isDataRoute: !0 },
        })
      : N()
  }, null)
}
var mw = (function (t) {
    return (
      (t.UseBlocker = 'useBlocker'),
      (t.UseRevalidator = 'useRevalidator'),
      (t.UseNavigateStable = 'useNavigate'),
      t
    )
  })(mw || {}),
  yw = (function (t) {
    return (
      (t.UseBlocker = 'useBlocker'),
      (t.UseLoaderData = 'useLoaderData'),
      (t.UseActionData = 'useActionData'),
      (t.UseRouteError = 'useRouteError'),
      (t.UseNavigation = 'useNavigation'),
      (t.UseRouteLoaderData = 'useRouteLoaderData'),
      (t.UseMatches = 'useMatches'),
      (t.UseRevalidator = 'useRevalidator'),
      (t.UseNavigateStable = 'useNavigate'),
      (t.UseRouteId = 'useRouteId'),
      t
    )
  })(yw || {})
function qE(t) {
  let e = X.useContext(hh)
  return (e || he(!1), e)
}
function KE(t) {
  let e = X.useContext(fw)
  return (e || he(!1), e)
}
function QE(t) {
  let e = X.useContext(Vi)
  return (e || he(!1), e)
}
function ww(t) {
  let e = QE(),
    n = e.matches[e.matches.length - 1]
  return (n.route.id || he(!1), n.route.id)
}
function $E() {
  var t
  let e = X.useContext(pw),
    n = KE(),
    r = ww()
  return e !== void 0 ? e : (t = n.errors) == null ? void 0 : t[r]
}
function JE() {
  let { router: t } = qE(mw.UseNavigateStable),
    e = ww(yw.UseNavigateStable),
    n = X.useRef(!1)
  return (
    gw(() => {
      n.current = !0
    }),
    X.useCallback(
      function (r, i) {
        ;(i === void 0 && (i = {}),
          n.current &&
            (typeof r == 'number' ? t.navigate(r) : t.navigate(r, bl({ fromRouteId: e }, i))))
      },
      [t, e]
    )
  )
}
const $g = {}
function tC(t, e, n) {
  $g[t] || ($g[t] = !0)
}
function eC(t, e) {
  ;(t == null || t.v7_startTransition, t == null || t.v7_relativeSplatPath)
}
function nC(t) {
  let { to: e, replace: n, state: r, relative: i } = t
  Ys() || he(!1)
  let { future: s, static: c } = X.useContext(Qr),
    { matches: h } = X.useContext(Vi),
    { pathname: f } = Zs(),
    p = b0(),
    y = w0(e, y0(h, s.v7_relativeSplatPath), f, i === 'path'),
    w = JSON.stringify(y)
  return (
    X.useEffect(() => p(JSON.parse(w), { replace: n, state: r, relative: i }), [p, w, i, n, r]),
    null
  )
}
function rs(t) {
  he(!1)
}
function rC(t) {
  let {
    basename: e = '/',
    children: n = null,
    location: r,
    navigationType: i = gi.Pop,
    navigator: s,
    static: c = !1,
    future: h,
  } = t
  Ys() && he(!1)
  let f = e.replace(/^\/*/, '/'),
    p = X.useMemo(
      () => ({ basename: f, navigator: s, static: c, future: bl({ v7_relativeSplatPath: !1 }, h) }),
      [f, h, s, c]
    )
  typeof r == 'string' && (r = _o(r))
  let { pathname: y = '/', search: w = '', hash: x = '', state: E = null, key: S = 'default' } = r,
    k = X.useMemo(() => {
      let D = Bs(y, f)
      return D == null
        ? null
        : { location: { pathname: D, search: w, hash: x, state: E, key: S }, navigationType: i }
    }, [f, y, w, x, E, S, i])
  return k == null
    ? null
    : X.createElement(
        Qr.Provider,
        { value: p },
        X.createElement(dh.Provider, { children: n, value: k })
      )
}
function iC(t) {
  let { children: e, location: n } = t
  return UE(W1(e), n)
}
new Promise(() => {})
function W1(t, e) {
  e === void 0 && (e = [])
  let n = []
  return (
    X.Children.forEach(t, (r, i) => {
      if (!X.isValidElement(r)) return
      let s = [...e, i]
      if (r.type === X.Fragment) {
        n.push.apply(n, W1(r.props.children, s))
        return
      }
      ;(r.type !== rs && he(!1), !r.props.index || !r.props.children || he(!1))
      let c = {
        id: r.props.id || s.join('-'),
        caseSensitive: r.props.caseSensitive,
        element: r.props.element,
        Component: r.props.Component,
        index: r.props.index,
        path: r.props.path,
        loader: r.props.loader,
        action: r.props.action,
        errorElement: r.props.errorElement,
        ErrorBoundary: r.props.ErrorBoundary,
        hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
        shouldRevalidate: r.props.shouldRevalidate,
        handle: r.props.handle,
        lazy: r.props.lazy,
      }
      ;(r.props.children && (c.children = W1(r.props.children, s)), n.push(c))
    }),
    n
  )
}
/**
 * React Router DOM v6.30.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Ru() {
  return (
    (Ru = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e]
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
          }
          return t
        }),
    Ru.apply(this, arguments)
  )
}
function bw(t, e) {
  if (t == null) return {}
  var n = {},
    r = Object.keys(t),
    i,
    s
  for (s = 0; s < r.length; s++) ((i = r[s]), !(e.indexOf(i) >= 0) && (n[i] = t[i]))
  return n
}
function oC(t) {
  return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey)
}
function sC(t, e) {
  return t.button === 0 && (!e || e === '_self') && !oC(t)
}
const aC = [
    'onClick',
    'relative',
    'reloadDocument',
    'replace',
    'state',
    'target',
    'to',
    'preventScrollReset',
    'viewTransition',
  ],
  lC = [
    'aria-current',
    'caseSensitive',
    'className',
    'end',
    'style',
    'to',
    'viewTransition',
    'children',
  ],
  cC = '6'
try {
  window.__reactRouterVersion = cC
} catch {}
const uC = X.createContext({ isTransitioning: !1 }),
  hC = 'startTransition',
  Jg = nv[hC]
function dC(t) {
  let { basename: e, children: n, future: r, window: i } = t,
    s = X.useRef()
  s.current == null && (s.current = pE({ window: i, v5Compat: !0 }))
  let c = s.current,
    [h, f] = X.useState({ action: c.action, location: c.location }),
    { v7_startTransition: p } = r || {},
    y = X.useCallback(
      (w) => {
        p && Jg ? Jg(() => f(w)) : f(w)
      },
      [f, p]
    )
  return (
    X.useLayoutEffect(() => c.listen(y), [c, y]),
    X.useEffect(() => eC(r), [r]),
    X.createElement(rC, {
      basename: e,
      children: n,
      location: h.location,
      navigationType: h.action,
      navigator: c,
      future: r,
    })
  )
}
const fC =
    typeof window < 'u' &&
    typeof window.document < 'u' &&
    typeof window.document.createElement < 'u',
  pC = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  tr = X.forwardRef(function (t, e) {
    let {
        onClick: n,
        relative: r,
        reloadDocument: i,
        replace: s,
        state: c,
        target: h,
        to: f,
        preventScrollReset: p,
        viewTransition: y,
      } = t,
      w = bw(t, aC),
      { basename: x } = X.useContext(Qr),
      E,
      S = !1
    if (typeof f == 'string' && pC.test(f) && ((E = f), fC))
      try {
        let N = new URL(window.location.href),
          M = f.startsWith('//') ? new URL(N.protocol + f) : new URL(f),
          O = Bs(M.pathname, x)
        M.origin === N.origin && O != null ? (f = O + M.search + M.hash) : (S = !0)
      } catch {}
    let k = VE(f, { relative: r }),
      D = yC(f, {
        replace: s,
        state: c,
        target: h,
        preventScrollReset: p,
        relative: r,
        viewTransition: y,
      })
    function _(N) {
      ;(n && n(N), N.defaultPrevented || D(N))
    }
    return X.createElement(
      'a',
      Ru({}, w, { href: E || k, onClick: S || i ? n : _, ref: e, target: h })
    )
  }),
  gC = X.forwardRef(function (t, e) {
    let {
        'aria-current': n = 'page',
        caseSensitive: r = !1,
        className: i = '',
        end: s = !1,
        style: c,
        to: h,
        viewTransition: f,
        children: p,
      } = t,
      y = bw(t, lC),
      w = fh(h, { relative: y.relative }),
      x = Zs(),
      E = X.useContext(fw),
      { navigator: S, basename: k } = X.useContext(Qr),
      D = E != null && wC(w) && f === !0,
      _ = S.encodeLocation ? S.encodeLocation(w).pathname : w.pathname,
      N = x.pathname,
      M = E && E.navigation && E.navigation.location ? E.navigation.location.pathname : null
    ;(r || ((N = N.toLowerCase()), (M = M ? M.toLowerCase() : null), (_ = _.toLowerCase())),
      M && k && (M = Bs(M, k) || M))
    const O = _ !== '/' && _.endsWith('/') ? _.length - 1 : _.length
    let F = N === _ || (!s && N.startsWith(_) && N.charAt(O) === '/'),
      z = M != null && (M === _ || (!s && M.startsWith(_) && M.charAt(_.length) === '/')),
      V = { isActive: F, isPending: z, isTransitioning: D },
      W = F ? n : void 0,
      Z
    typeof i == 'function'
      ? (Z = i(V))
      : (Z = [i, F ? 'active' : null, z ? 'pending' : null, D ? 'transitioning' : null]
          .filter(Boolean)
          .join(' '))
    let J = typeof c == 'function' ? c(V) : c
    return X.createElement(
      tr,
      Ru({}, y, { 'aria-current': W, className: Z, ref: e, style: J, to: h, viewTransition: f }),
      typeof p == 'function' ? p(V) : p
    )
  })
var U1
;(function (t) {
  ;((t.UseScrollRestoration = 'useScrollRestoration'),
    (t.UseSubmit = 'useSubmit'),
    (t.UseSubmitFetcher = 'useSubmitFetcher'),
    (t.UseFetcher = 'useFetcher'),
    (t.useViewTransitionState = 'useViewTransitionState'))
})(U1 || (U1 = {}))
var t2
;(function (t) {
  ;((t.UseFetcher = 'useFetcher'),
    (t.UseFetchers = 'useFetchers'),
    (t.UseScrollRestoration = 'useScrollRestoration'))
})(t2 || (t2 = {}))
function mC(t) {
  let e = X.useContext(hh)
  return (e || he(!1), e)
}
function yC(t, e) {
  let {
      target: n,
      replace: r,
      state: i,
      preventScrollReset: s,
      relative: c,
      viewTransition: h,
    } = e === void 0 ? {} : e,
    f = b0(),
    p = Zs(),
    y = fh(t, { relative: c })
  return X.useCallback(
    (w) => {
      if (sC(w, n)) {
        w.preventDefault()
        let x = r !== void 0 ? r : _u(p) === _u(y)
        f(t, { replace: x, state: i, preventScrollReset: s, relative: c, viewTransition: h })
      }
    },
    [p, f, y, r, i, n, t, s, c, h]
  )
}
function wC(t, e) {
  e === void 0 && (e = {})
  let n = X.useContext(uC)
  n == null && he(!1)
  let { basename: r } = mC(U1.useViewTransitionState),
    i = fh(t, { relative: e.relative })
  if (!n.isTransitioning) return !1
  let s = Bs(n.currentLocation.pathname, r) || n.currentLocation.pathname,
    c = Bs(n.nextLocation.pathname, r) || n.nextLocation.pathname
  return V1(i.pathname, c) != null || V1(i.pathname, s) != null
}
const vw = X.createContext({})
function bC(t) {
  const e = X.useRef(null)
  return (e.current === null && (e.current = t()), e.current)
}
const v0 = X.createContext(null),
  xw = X.createContext({ transformPagePoint: (t) => t, isStatic: !1, reducedMotion: 'never' })
function vC(t = !0) {
  const e = X.useContext(v0)
  if (e === null) return [!0, null]
  const { isPresent: n, onExitComplete: r, register: i } = e,
    s = X.useId()
  X.useEffect(() => {
    t && i(s)
  }, [t])
  const c = X.useCallback(() => t && r && r(s), [s, r, t])
  return !n && r ? [!1, c] : [!0]
}
const x0 = typeof window < 'u',
  xC = x0 ? X.useLayoutEffect : X.useEffect,
  Pn = (t) => t
let Ew = Pn
function E0(t) {
  let e
  return () => (e === void 0 && (e = t()), e)
}
const Fs = (t, e, n) => {
    const r = e - t
    return r === 0 ? 1 : (n - t) / r
  },
  zr = (t) => t * 1e3,
  Hr = (t) => t / 1e3,
  EC = { useManualTiming: !1 }
function CC(t) {
  let e = new Set(),
    n = new Set(),
    r = !1,
    i = !1
  const s = new WeakSet()
  let c = { delta: 0, timestamp: 0, isProcessing: !1 }
  function h(p) {
    ;(s.has(p) && (f.schedule(p), t()), p(c))
  }
  const f = {
    schedule: (p, y = !1, w = !1) => {
      const x = w && r ? e : n
      return (y && s.add(p), x.has(p) || x.add(p), p)
    },
    cancel: (p) => {
      ;(n.delete(p), s.delete(p))
    },
    process: (p) => {
      if (((c = p), r)) {
        i = !0
        return
      }
      ;((r = !0),
        ([e, n] = [n, e]),
        e.forEach(h),
        e.clear(),
        (r = !1),
        i && ((i = !1), f.process(p)))
    },
  }
  return f
}
const bc = ['read', 'resolveKeyframes', 'update', 'preRender', 'render', 'postRender'],
  SC = 40
function Cw(t, e) {
  let n = !1,
    r = !0
  const i = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = () => (n = !0),
    c = bc.reduce((k, D) => ((k[D] = CC(s)), k), {}),
    { read: h, resolveKeyframes: f, update: p, preRender: y, render: w, postRender: x } = c,
    E = () => {
      const k = performance.now()
      ;((n = !1),
        (i.delta = r ? 1e3 / 60 : Math.max(Math.min(k - i.timestamp, SC), 1)),
        (i.timestamp = k),
        (i.isProcessing = !0),
        h.process(i),
        f.process(i),
        p.process(i),
        y.process(i),
        w.process(i),
        x.process(i),
        (i.isProcessing = !1),
        n && e && ((r = !1), t(E)))
    },
    S = () => {
      ;((n = !0), (r = !0), i.isProcessing || t(E))
    }
  return {
    schedule: bc.reduce((k, D) => {
      const _ = c[D]
      return ((k[D] = (N, M = !1, O = !1) => (n || S(), _.schedule(N, M, O))), k)
    }, {}),
    cancel: (k) => {
      for (let D = 0; D < bc.length; D++) c[bc[D]].cancel(k)
    },
    state: i,
    steps: c,
  }
}
const {
    schedule: re,
    cancel: Pi,
    state: ze,
    steps: vd,
  } = Cw(typeof requestAnimationFrame < 'u' ? requestAnimationFrame : Pn, !0),
  Sw = X.createContext({ strict: !1 }),
  e2 = {
    animation: [
      'animate',
      'variants',
      'whileHover',
      'whileTap',
      'exit',
      'whileInView',
      'whileFocus',
      'whileDrag',
    ],
    exit: ['exit'],
    drag: ['drag', 'dragControls'],
    focus: ['whileFocus'],
    hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
    tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
    pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
    inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
    layout: ['layout', 'layoutId'],
  },
  js = {}
for (const t in e2) js[t] = { isEnabled: (e) => e2[t].some((n) => !!e[n]) }
function AC(t) {
  for (const e in t) js[e] = { ...js[e], ...t[e] }
}
const kC = new Set([
  'animate',
  'exit',
  'variants',
  'initial',
  'style',
  'values',
  'variants',
  'transition',
  'transformTemplate',
  'custom',
  'inherit',
  'onBeforeLayoutMeasure',
  'onAnimationStart',
  'onAnimationComplete',
  'onUpdate',
  'onDragStart',
  'onDrag',
  'onDragEnd',
  'onMeasureDragConstraints',
  'onDirectionLock',
  'onDragTransitionEnd',
  '_dragX',
  '_dragY',
  'onHoverStart',
  'onHoverEnd',
  'onViewportEnter',
  'onViewportLeave',
  'globalTapTarget',
  'ignoreStrict',
  'viewport',
])
function Tu(t) {
  return (
    t.startsWith('while') ||
    (t.startsWith('drag') && t !== 'draggable') ||
    t.startsWith('layout') ||
    t.startsWith('onTap') ||
    t.startsWith('onPan') ||
    t.startsWith('onLayout') ||
    kC.has(t)
  )
}
let Aw = (t) => !Tu(t)
function IC(t) {
  t && (Aw = (e) => (e.startsWith('on') ? !Tu(e) : t(e)))
}
try {
  IC(require('@emotion/is-prop-valid').default)
} catch {}
function _C(t, e, n) {
  const r = {}
  for (const i in t)
    (i === 'values' && typeof t.values == 'object') ||
      ((Aw(i) ||
        (n === !0 && Tu(i)) ||
        (!e && !Tu(i)) ||
        (t.draggable && i.startsWith('onDrag'))) &&
        (r[i] = t[i]))
  return r
}
function RC(t) {
  if (typeof Proxy > 'u') return t
  const e = new Map(),
    n = (...r) => t(...r)
  return new Proxy(n, {
    get: (r, i) => (i === 'create' ? t : (e.has(i) || e.set(i, t(i)), e.get(i))),
  })
}
const ph = X.createContext({})
function vl(t) {
  return typeof t == 'string' || Array.isArray(t)
}
function gh(t) {
  return t !== null && typeof t == 'object' && typeof t.start == 'function'
}
const C0 = ['animate', 'whileInView', 'whileFocus', 'whileHover', 'whileTap', 'whileDrag', 'exit'],
  S0 = ['initial', ...C0]
function mh(t) {
  return gh(t.animate) || S0.some((e) => vl(t[e]))
}
function kw(t) {
  return !!(mh(t) || t.variants)
}
function TC(t, e) {
  if (mh(t)) {
    const { initial: n, animate: r } = t
    return { initial: n === !1 || vl(n) ? n : void 0, animate: vl(r) ? r : void 0 }
  }
  return t.inherit !== !1 ? e : {}
}
function NC(t) {
  const { initial: e, animate: n } = TC(t, X.useContext(ph))
  return X.useMemo(() => ({ initial: e, animate: n }), [n2(e), n2(n)])
}
function n2(t) {
  return Array.isArray(t) ? t.join(' ') : t
}
const MC = Symbol.for('motionComponentSymbol')
function ms(t) {
  return t && typeof t == 'object' && Object.prototype.hasOwnProperty.call(t, 'current')
}
function DC(t, e, n) {
  return X.useCallback(
    (r) => {
      ;(r && t.onMount && t.onMount(r),
        e && (r ? e.mount(r) : e.unmount()),
        n && (typeof n == 'function' ? n(r) : ms(n) && (n.current = r)))
    },
    [e]
  )
}
const A0 = (t) => t.replace(/([a-z])([A-Z])/gu, '$1-$2').toLowerCase(),
  PC = 'framerAppearId',
  Iw = 'data-' + A0(PC),
  { schedule: k0 } = Cw(queueMicrotask, !1),
  _w = X.createContext({})
function LC(t, e, n, r, i) {
  var s, c
  const { visualElement: h } = X.useContext(ph),
    f = X.useContext(Sw),
    p = X.useContext(v0),
    y = X.useContext(xw).reducedMotion,
    w = X.useRef(null)
  ;((r = r || f.renderer),
    !w.current &&
      r &&
      (w.current = r(t, {
        visualState: e,
        parent: h,
        props: n,
        presenceContext: p,
        blockInitialAnimation: p ? p.initial === !1 : !1,
        reducedMotionConfig: y,
      })))
  const x = w.current,
    E = X.useContext(_w)
  x && !x.projection && i && (x.type === 'html' || x.type === 'svg') && OC(w.current, n, i, E)
  const S = X.useRef(!1)
  X.useInsertionEffect(() => {
    x && S.current && x.update(n, p)
  })
  const k = n[Iw],
    D = X.useRef(
      !!k &&
        !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, k)) &&
        ((c = window.MotionHasOptimisedAnimation) === null || c === void 0
          ? void 0
          : c.call(window, k))
    )
  return (
    xC(() => {
      x &&
        ((S.current = !0),
        (window.MotionIsMounted = !0),
        x.updateFeatures(),
        k0.render(x.render),
        D.current && x.animationState && x.animationState.animateChanges())
    }),
    X.useEffect(() => {
      x &&
        (!D.current && x.animationState && x.animationState.animateChanges(),
        D.current &&
          (queueMicrotask(() => {
            var _
            ;(_ = window.MotionHandoffMarkAsComplete) === null || _ === void 0 || _.call(window, k)
          }),
          (D.current = !1)))
    }),
    x
  )
}
function OC(t, e, n, r) {
  const { layoutId: i, layout: s, drag: c, dragConstraints: h, layoutScroll: f, layoutRoot: p } = e
  ;((t.projection = new n(t.latestValues, e['data-framer-portal-id'] ? void 0 : Rw(t.parent))),
    t.projection.setOptions({
      layoutId: i,
      layout: s,
      alwaysMeasureLayout: !!c || (h && ms(h)),
      visualElement: t,
      animationType: typeof s == 'string' ? s : 'both',
      initialPromotionConfig: r,
      layoutScroll: f,
      layoutRoot: p,
    }))
}
function Rw(t) {
  if (t) return t.options.allowProjection !== !1 ? t.projection : Rw(t.parent)
}
function BC({
  preloadedFeatures: t,
  createVisualElement: e,
  useRender: n,
  useVisualState: r,
  Component: i,
}) {
  var s, c
  t && AC(t)
  function h(p, y) {
    let w
    const x = { ...X.useContext(xw), ...p, layoutId: FC(p) },
      { isStatic: E } = x,
      S = NC(p),
      k = r(p, E)
    if (!E && x0) {
      jC()
      const D = VC(x)
      ;((w = D.MeasureLayout), (S.visualElement = LC(i, k, x, e, D.ProjectionNode)))
    }
    return R.jsxs(ph.Provider, {
      value: S,
      children: [
        w && S.visualElement ? R.jsx(w, { visualElement: S.visualElement, ...x }) : null,
        n(i, p, DC(k, S.visualElement, y), k, E, S.visualElement),
      ],
    })
  }
  h.displayName = `motion.${typeof i == 'string' ? i : `create(${(c = (s = i.displayName) !== null && s !== void 0 ? s : i.name) !== null && c !== void 0 ? c : ''})`}`
  const f = X.forwardRef(h)
  return ((f[MC] = i), f)
}
function FC({ layoutId: t }) {
  const e = X.useContext(vw).id
  return e && t !== void 0 ? e + '-' + t : t
}
function jC(t, e) {
  X.useContext(Sw).strict
}
function VC(t) {
  const { drag: e, layout: n } = js
  if (!e && !n) return {}
  const r = { ...e, ...n }
  return {
    MeasureLayout:
      (e != null && e.isEnabled(t)) || (n != null && n.isEnabled(t)) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode,
  }
}
const WC = [
  'animate',
  'circle',
  'defs',
  'desc',
  'ellipse',
  'g',
  'image',
  'line',
  'filter',
  'marker',
  'mask',
  'metadata',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'rect',
  'stop',
  'switch',
  'symbol',
  'svg',
  'text',
  'tspan',
  'use',
  'view',
]
function I0(t) {
  return typeof t != 'string' || t.includes('-') ? !1 : !!(WC.indexOf(t) > -1 || /[A-Z]/u.test(t))
}
function r2(t) {
  const e = [{}, {}]
  return (
    t == null ||
      t.values.forEach((n, r) => {
        ;((e[0][r] = n.get()), (e[1][r] = n.getVelocity()))
      }),
    e
  )
}
function _0(t, e, n, r) {
  if (typeof e == 'function') {
    const [i, s] = r2(r)
    e = e(n !== void 0 ? n : t.custom, i, s)
  }
  if ((typeof e == 'string' && (e = t.variants && t.variants[e]), typeof e == 'function')) {
    const [i, s] = r2(r)
    e = e(n !== void 0 ? n : t.custom, i, s)
  }
  return e
}
const z1 = (t) => Array.isArray(t),
  UC = (t) => !!(t && typeof t == 'object' && t.mix && t.toValue),
  zC = (t) => (z1(t) ? t[t.length - 1] || 0 : t),
  Je = (t) => !!(t && t.getVelocity)
function Zc(t) {
  const e = Je(t) ? t.get() : t
  return UC(e) ? e.toValue() : e
}
function HC({ scrapeMotionValuesFromProps: t, createRenderState: e, onUpdate: n }, r, i, s) {
  const c = { latestValues: XC(r, i, s, t), renderState: e() }
  return (
    n && ((c.onMount = (h) => n({ props: r, current: h, ...c })), (c.onUpdate = (h) => n(h))),
    c
  )
}
const Tw = (t) => (e, n) => {
  const r = X.useContext(ph),
    i = X.useContext(v0),
    s = () => HC(t, e, r, i)
  return n ? s() : bC(s)
}
function XC(t, e, n, r) {
  const i = {},
    s = r(t, {})
  for (const x in s) i[x] = Zc(s[x])
  let { initial: c, animate: h } = t
  const f = mh(t),
    p = kw(t)
  e &&
    p &&
    !f &&
    t.inherit !== !1 &&
    (c === void 0 && (c = e.initial), h === void 0 && (h = e.animate))
  let y = n ? n.initial === !1 : !1
  y = y || c === !1
  const w = y ? h : c
  if (w && typeof w != 'boolean' && !gh(w)) {
    const x = Array.isArray(w) ? w : [w]
    for (let E = 0; E < x.length; E++) {
      const S = _0(t, x[E])
      if (S) {
        const { transitionEnd: k, transition: D, ..._ } = S
        for (const N in _) {
          let M = _[N]
          if (Array.isArray(M)) {
            const O = y ? M.length - 1 : 0
            M = M[O]
          }
          M !== null && (i[N] = M)
        }
        for (const N in k) i[N] = k[N]
      }
    }
  }
  return i
}
const qs = [
    'transformPerspective',
    'x',
    'y',
    'z',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY',
  ],
  Ro = new Set(qs),
  Nw = (t) => (e) => typeof e == 'string' && e.startsWith(t),
  Mw = Nw('--'),
  GC = Nw('var(--'),
  R0 = (t) => (GC(t) ? YC.test(t.split('/*')[0].trim()) : !1),
  YC = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  Dw = (t, e) => (e && typeof t == 'number' ? e.transform(t) : t),
  qr = (t, e, n) => (n > e ? e : n < t ? t : n),
  Ks = { test: (t) => typeof t == 'number', parse: parseFloat, transform: (t) => t },
  xl = { ...Ks, transform: (t) => qr(0, 1, t) },
  vc = { ...Ks, default: 1 },
  Ol = (t) => ({
    test: (e) => typeof e == 'string' && e.endsWith(t) && e.split(' ').length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${t}`,
  }),
  li = Ol('deg'),
  Ir = Ol('%'),
  bt = Ol('px'),
  ZC = Ol('vh'),
  qC = Ol('vw'),
  i2 = { ...Ir, parse: (t) => Ir.parse(t) / 100, transform: (t) => Ir.transform(t * 100) },
  KC = {
    borderWidth: bt,
    borderTopWidth: bt,
    borderRightWidth: bt,
    borderBottomWidth: bt,
    borderLeftWidth: bt,
    borderRadius: bt,
    radius: bt,
    borderTopLeftRadius: bt,
    borderTopRightRadius: bt,
    borderBottomRightRadius: bt,
    borderBottomLeftRadius: bt,
    width: bt,
    maxWidth: bt,
    height: bt,
    maxHeight: bt,
    top: bt,
    right: bt,
    bottom: bt,
    left: bt,
    padding: bt,
    paddingTop: bt,
    paddingRight: bt,
    paddingBottom: bt,
    paddingLeft: bt,
    margin: bt,
    marginTop: bt,
    marginRight: bt,
    marginBottom: bt,
    marginLeft: bt,
    backgroundPositionX: bt,
    backgroundPositionY: bt,
  },
  QC = {
    rotate: li,
    rotateX: li,
    rotateY: li,
    rotateZ: li,
    scale: vc,
    scaleX: vc,
    scaleY: vc,
    scaleZ: vc,
    skew: li,
    skewX: li,
    skewY: li,
    distance: bt,
    translateX: bt,
    translateY: bt,
    translateZ: bt,
    x: bt,
    y: bt,
    z: bt,
    perspective: bt,
    transformPerspective: bt,
    opacity: xl,
    originX: i2,
    originY: i2,
    originZ: bt,
  },
  o2 = { ...Ks, transform: Math.round },
  T0 = { ...KC, ...QC, zIndex: o2, size: bt, fillOpacity: xl, strokeOpacity: xl, numOctaves: o2 },
  $C = { x: 'translateX', y: 'translateY', z: 'translateZ', transformPerspective: 'perspective' },
  JC = qs.length
function t5(t, e, n) {
  let r = '',
    i = !0
  for (let s = 0; s < JC; s++) {
    const c = qs[s],
      h = t[c]
    if (h === void 0) continue
    let f = !0
    if (
      (typeof h == 'number'
        ? (f = h === (c.startsWith('scale') ? 1 : 0))
        : (f = parseFloat(h) === 0),
      !f || n)
    ) {
      const p = Dw(h, T0[c])
      if (!f) {
        i = !1
        const y = $C[c] || c
        r += `${y}(${p}) `
      }
      n && (e[c] = p)
    }
  }
  return ((r = r.trim()), n ? (r = n(e, i ? '' : r)) : i && (r = 'none'), r)
}
function N0(t, e, n) {
  const { style: r, vars: i, transformOrigin: s } = t
  let c = !1,
    h = !1
  for (const f in e) {
    const p = e[f]
    if (Ro.has(f)) {
      c = !0
      continue
    } else if (Mw(f)) {
      i[f] = p
      continue
    } else {
      const y = Dw(p, T0[f])
      f.startsWith('origin') ? ((h = !0), (s[f] = y)) : (r[f] = y)
    }
  }
  if (
    (e.transform ||
      (c || n ? (r.transform = t5(e, t.transform, n)) : r.transform && (r.transform = 'none')),
    h)
  ) {
    const { originX: f = '50%', originY: p = '50%', originZ: y = 0 } = s
    r.transformOrigin = `${f} ${p} ${y}`
  }
}
const e5 = { offset: 'stroke-dashoffset', array: 'stroke-dasharray' },
  n5 = { offset: 'strokeDashoffset', array: 'strokeDasharray' }
function r5(t, e, n = 1, r = 0, i = !0) {
  t.pathLength = 1
  const s = i ? e5 : n5
  t[s.offset] = bt.transform(-r)
  const c = bt.transform(e),
    h = bt.transform(n)
  t[s.array] = `${c} ${h}`
}
function s2(t, e, n) {
  return typeof t == 'string' ? t : bt.transform(e + n * t)
}
function i5(t, e, n) {
  const r = s2(e, t.x, t.width),
    i = s2(n, t.y, t.height)
  return `${r} ${i}`
}
function M0(
  t,
  {
    attrX: e,
    attrY: n,
    attrScale: r,
    originX: i,
    originY: s,
    pathLength: c,
    pathSpacing: h = 1,
    pathOffset: f = 0,
    ...p
  },
  y,
  w
) {
  if ((N0(t, p, w), y)) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox)
    return
  }
  ;((t.attrs = t.style), (t.style = {}))
  const { attrs: x, style: E, dimensions: S } = t
  ;(x.transform && (S && (E.transform = x.transform), delete x.transform),
    S &&
      (i !== void 0 || s !== void 0 || E.transform) &&
      (E.transformOrigin = i5(S, i !== void 0 ? i : 0.5, s !== void 0 ? s : 0.5)),
    e !== void 0 && (x.x = e),
    n !== void 0 && (x.y = n),
    r !== void 0 && (x.scale = r),
    c !== void 0 && r5(x, c, h, f, !1))
}
const D0 = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }),
  Pw = () => ({ ...D0(), attrs: {} }),
  P0 = (t) => typeof t == 'string' && t.toLowerCase() === 'svg'
function Lw(t, { style: e, vars: n }, r, i) {
  Object.assign(t.style, e, i && i.getProjectionStyles(r))
  for (const s in n) t.style.setProperty(s, n[s])
}
const Ow = new Set([
  'baseFrequency',
  'diffuseConstant',
  'kernelMatrix',
  'kernelUnitLength',
  'keySplines',
  'keyTimes',
  'limitingConeAngle',
  'markerHeight',
  'markerWidth',
  'numOctaves',
  'targetX',
  'targetY',
  'surfaceScale',
  'specularConstant',
  'specularExponent',
  'stdDeviation',
  'tableValues',
  'viewBox',
  'gradientTransform',
  'pathLength',
  'startOffset',
  'textLength',
  'lengthAdjust',
])
function Bw(t, e, n, r) {
  Lw(t, e, void 0, r)
  for (const i in e.attrs) t.setAttribute(Ow.has(i) ? i : A0(i), e.attrs[i])
}
const Nu = {}
function o5(t) {
  Object.assign(Nu, t)
}
function Fw(t, { layout: e, layoutId: n }) {
  return (
    Ro.has(t) || t.startsWith('origin') || ((e || n !== void 0) && (!!Nu[t] || t === 'opacity'))
  )
}
function L0(t, e, n) {
  var r
  const { style: i } = t,
    s = {}
  for (const c in i)
    (Je(i[c]) ||
      (e.style && Je(e.style[c])) ||
      Fw(c, t) ||
      ((r = n == null ? void 0 : n.getValue(c)) === null || r === void 0 ? void 0 : r.liveStyle) !==
        void 0) &&
      (s[c] = i[c])
  return s
}
function jw(t, e, n) {
  const r = L0(t, e, n)
  for (const i in t)
    if (Je(t[i]) || Je(e[i])) {
      const s = qs.indexOf(i) !== -1 ? 'attr' + i.charAt(0).toUpperCase() + i.substring(1) : i
      r[s] = t[i]
    }
  return r
}
function s5(t, e) {
  try {
    e.dimensions = typeof t.getBBox == 'function' ? t.getBBox() : t.getBoundingClientRect()
  } catch {
    e.dimensions = { x: 0, y: 0, width: 0, height: 0 }
  }
}
const a2 = ['x', 'y', 'width', 'height', 'cx', 'cy', 'r'],
  a5 = {
    useVisualState: Tw({
      scrapeMotionValuesFromProps: jw,
      createRenderState: Pw,
      onUpdate: ({ props: t, prevProps: e, current: n, renderState: r, latestValues: i }) => {
        if (!n) return
        let s = !!t.drag
        if (!s) {
          for (const h in i)
            if (Ro.has(h)) {
              s = !0
              break
            }
        }
        if (!s) return
        let c = !e
        if (e)
          for (let h = 0; h < a2.length; h++) {
            const f = a2[h]
            t[f] !== e[f] && (c = !0)
          }
        c &&
          re.read(() => {
            ;(s5(n, r),
              re.render(() => {
                ;(M0(r, i, P0(n.tagName), t.transformTemplate), Bw(n, r))
              }))
          })
      },
    }),
  },
  l5 = { useVisualState: Tw({ scrapeMotionValuesFromProps: L0, createRenderState: D0 }) }
function Vw(t, e, n) {
  for (const r in e) !Je(e[r]) && !Fw(r, n) && (t[r] = e[r])
}
function c5({ transformTemplate: t }, e) {
  return X.useMemo(() => {
    const n = D0()
    return (N0(n, e, t), Object.assign({}, n.vars, n.style))
  }, [e])
}
function u5(t, e) {
  const n = t.style || {},
    r = {}
  return (Vw(r, n, t), Object.assign(r, c5(t, e)), r)
}
function h5(t, e) {
  const n = {},
    r = u5(t, e)
  return (
    t.drag &&
      t.dragListener !== !1 &&
      ((n.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = 'none'),
      (r.touchAction = t.drag === !0 ? 'none' : `pan-${t.drag === 'x' ? 'y' : 'x'}`)),
    t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0),
    (n.style = r),
    n
  )
}
function d5(t, e, n, r) {
  const i = X.useMemo(() => {
    const s = Pw()
    return (M0(s, e, P0(r), t.transformTemplate), { ...s.attrs, style: { ...s.style } })
  }, [e])
  if (t.style) {
    const s = {}
    ;(Vw(s, t.style, t), (i.style = { ...s, ...i.style }))
  }
  return i
}
function f5(t = !1) {
  return (e, n, r, { latestValues: i }, s) => {
    const c = (I0(e) ? d5 : h5)(n, i, s, e),
      h = _C(n, typeof e == 'string', t),
      f = e !== X.Fragment ? { ...h, ...c, ref: r } : {},
      { children: p } = n,
      y = X.useMemo(() => (Je(p) ? p.get() : p), [p])
    return X.createElement(e, { ...f, children: y })
  }
}
function p5(t, e) {
  return function (n, { forwardMotionProps: r } = { forwardMotionProps: !1 }) {
    const i = {
      ...(I0(n) ? a5 : l5),
      preloadedFeatures: t,
      useRender: f5(r),
      createVisualElement: e,
      Component: n,
    }
    return BC(i)
  }
}
function Ww(t, e) {
  if (!Array.isArray(e)) return !1
  const n = e.length
  if (n !== t.length) return !1
  for (let r = 0; r < n; r++) if (e[r] !== t[r]) return !1
  return !0
}
function yh(t, e, n) {
  const r = t.getProps()
  return _0(r, e, n !== void 0 ? n : r.custom, t)
}
const g5 = E0(() => window.ScrollTimeline !== void 0)
class m5 {
  constructor(e) {
    ;((this.stop = () => this.runAll('stop')), (this.animations = e.filter(Boolean)))
  }
  get finished() {
    return Promise.all(this.animations.map((e) => ('finished' in e ? e.finished : e)))
  }
  getAll(e) {
    return this.animations[0][e]
  }
  setAll(e, n) {
    for (let r = 0; r < this.animations.length; r++) this.animations[r][e] = n
  }
  attachTimeline(e, n) {
    const r = this.animations.map((i) => {
      if (g5() && i.attachTimeline) return i.attachTimeline(e)
      if (typeof n == 'function') return n(i)
    })
    return () => {
      r.forEach((i, s) => {
        ;(i && i(), this.animations[s].stop())
      })
    }
  }
  get time() {
    return this.getAll('time')
  }
  set time(e) {
    this.setAll('time', e)
  }
  get speed() {
    return this.getAll('speed')
  }
  set speed(e) {
    this.setAll('speed', e)
  }
  get startTime() {
    return this.getAll('startTime')
  }
  get duration() {
    let e = 0
    for (let n = 0; n < this.animations.length; n++) e = Math.max(e, this.animations[n].duration)
    return e
  }
  runAll(e) {
    this.animations.forEach((n) => n[e]())
  }
  flatten() {
    this.runAll('flatten')
  }
  play() {
    this.runAll('play')
  }
  pause() {
    this.runAll('pause')
  }
  cancel() {
    this.runAll('cancel')
  }
  complete() {
    this.runAll('complete')
  }
}
class y5 extends m5 {
  then(e, n) {
    return Promise.all(this.animations).then(e).catch(n)
  }
}
function O0(t, e) {
  return t ? t[e] || t.default || t : void 0
}
const H1 = 2e4
function Uw(t) {
  let e = 0
  const n = 50
  let r = t.next(e)
  for (; !r.done && e < H1; ) ((e += n), (r = t.next(e)))
  return e >= H1 ? 1 / 0 : e
}
function B0(t) {
  return typeof t == 'function'
}
function l2(t, e) {
  ;((t.timeline = e), (t.onfinish = null))
}
const F0 = (t) => Array.isArray(t) && typeof t[0] == 'number',
  w5 = { linearEasing: void 0 }
function b5(t, e) {
  const n = E0(t)
  return () => {
    var r
    return (r = w5[e]) !== null && r !== void 0 ? r : n()
  }
}
const Mu = b5(() => {
    try {
      document.createElement('div').animate({ opacity: 0 }, { easing: 'linear(0, 1)' })
    } catch {
      return !1
    }
    return !0
  }, 'linearEasing'),
  zw = (t, e, n = 10) => {
    let r = ''
    const i = Math.max(Math.round(e / n), 2)
    for (let s = 0; s < i; s++) r += t(Fs(0, i - 1, s)) + ', '
    return `linear(${r.substring(0, r.length - 2)})`
  }
function Hw(t) {
  return !!(
    (typeof t == 'function' && Mu()) ||
    !t ||
    (typeof t == 'string' && (t in X1 || Mu())) ||
    F0(t) ||
    (Array.isArray(t) && t.every(Hw))
  )
}
const Ta = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`,
  X1 = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'ease-in',
    easeOut: 'ease-out',
    easeInOut: 'ease-in-out',
    circIn: Ta([0, 0.65, 0.55, 1]),
    circOut: Ta([0.55, 0, 1, 0.45]),
    backIn: Ta([0.31, 0.01, 0.66, -0.59]),
    backOut: Ta([0.33, 1.53, 0.69, 0.99]),
  }
function Xw(t, e) {
  if (t)
    return typeof t == 'function' && Mu()
      ? zw(t, e)
      : F0(t)
        ? Ta(t)
        : Array.isArray(t)
          ? t.map((n) => Xw(n, e) || X1.easeOut)
          : X1[t]
}
const or = { x: !1, y: !1 }
function Gw() {
  return or.x || or.y
}
function v5(t, e, n) {
  var r
  if (t instanceof Element) return [t]
  if (typeof t == 'string') {
    let i = document
    const s = (r = void 0) !== null && r !== void 0 ? r : i.querySelectorAll(t)
    return s ? Array.from(s) : []
  }
  return Array.from(t)
}
function Yw(t, e) {
  const n = v5(t),
    r = new AbortController(),
    i = { passive: !0, ...e, signal: r.signal }
  return [n, i, () => r.abort()]
}
function c2(t) {
  return (e) => {
    e.pointerType === 'touch' || Gw() || t(e)
  }
}
function x5(t, e, n = {}) {
  const [r, i, s] = Yw(t, n),
    c = c2((h) => {
      const { target: f } = h,
        p = e(h)
      if (typeof p != 'function' || !f) return
      const y = c2((w) => {
        ;(p(w), f.removeEventListener('pointerleave', y))
      })
      f.addEventListener('pointerleave', y, i)
    })
  return (
    r.forEach((h) => {
      h.addEventListener('pointerenter', c, i)
    }),
    s
  )
}
const Zw = (t, e) => (e ? (t === e ? !0 : Zw(t, e.parentElement)) : !1),
  j0 = (t) =>
    t.pointerType === 'mouse' ? typeof t.button != 'number' || t.button <= 0 : t.isPrimary !== !1,
  E5 = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'])
function C5(t) {
  return E5.has(t.tagName) || t.tabIndex !== -1
}
const Na = new WeakSet()
function u2(t) {
  return (e) => {
    e.key === 'Enter' && t(e)
  }
}
function xd(t, e) {
  t.dispatchEvent(new PointerEvent('pointer' + e, { isPrimary: !0, bubbles: !0 }))
}
const S5 = (t, e) => {
  const n = t.currentTarget
  if (!n) return
  const r = u2(() => {
    if (Na.has(n)) return
    xd(n, 'down')
    const i = u2(() => {
        xd(n, 'up')
      }),
      s = () => xd(n, 'cancel')
    ;(n.addEventListener('keyup', i, e), n.addEventListener('blur', s, e))
  })
  ;(n.addEventListener('keydown', r, e),
    n.addEventListener('blur', () => n.removeEventListener('keydown', r), e))
}
function h2(t) {
  return j0(t) && !Gw()
}
function A5(t, e, n = {}) {
  const [r, i, s] = Yw(t, n),
    c = (h) => {
      const f = h.currentTarget
      if (!h2(h) || Na.has(f)) return
      Na.add(f)
      const p = e(h),
        y = (E, S) => {
          ;(window.removeEventListener('pointerup', w),
            window.removeEventListener('pointercancel', x),
            !(!h2(E) || !Na.has(f)) &&
              (Na.delete(f), typeof p == 'function' && p(E, { success: S })))
        },
        w = (E) => {
          y(E, n.useGlobalTarget || Zw(f, E.target))
        },
        x = (E) => {
          y(E, !1)
        }
      ;(window.addEventListener('pointerup', w, i), window.addEventListener('pointercancel', x, i))
    }
  return (
    r.forEach((h) => {
      ;(!C5(h) && h.getAttribute('tabindex') === null && (h.tabIndex = 0),
        (n.useGlobalTarget ? window : h).addEventListener('pointerdown', c, i),
        h.addEventListener('focus', (f) => S5(f, i), i))
    }),
    s
  )
}
function k5(t) {
  return t === 'x' || t === 'y'
    ? or[t]
      ? null
      : ((or[t] = !0),
        () => {
          or[t] = !1
        })
    : or.x || or.y
      ? null
      : ((or.x = or.y = !0),
        () => {
          or.x = or.y = !1
        })
}
const qw = new Set(['width', 'height', 'top', 'left', 'right', 'bottom', ...qs])
let qc
function I5() {
  qc = void 0
}
const _r = {
  now: () => (
    qc === void 0 &&
      _r.set(ze.isProcessing || EC.useManualTiming ? ze.timestamp : performance.now()),
    qc
  ),
  set: (t) => {
    ;((qc = t), queueMicrotask(I5))
  },
}
function V0(t, e) {
  t.indexOf(e) === -1 && t.push(e)
}
function W0(t, e) {
  const n = t.indexOf(e)
  n > -1 && t.splice(n, 1)
}
class U0 {
  constructor() {
    this.subscriptions = []
  }
  add(e) {
    return (V0(this.subscriptions, e), () => W0(this.subscriptions, e))
  }
  notify(e, n, r) {
    const i = this.subscriptions.length
    if (i)
      if (i === 1) this.subscriptions[0](e, n, r)
      else
        for (let s = 0; s < i; s++) {
          const c = this.subscriptions[s]
          c && c(e, n, r)
        }
  }
  getSize() {
    return this.subscriptions.length
  }
  clear() {
    this.subscriptions.length = 0
  }
}
function Kw(t, e) {
  return e ? t * (1e3 / e) : 0
}
const d2 = 30,
  _5 = (t) => !isNaN(parseFloat(t))
class R5 {
  constructor(e, n = {}) {
    ;((this.version = '11.18.2'),
      (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (r, i = !0) => {
        const s = _r.now()
        ;(this.updatedAt !== s && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(r),
          this.current !== this.prev &&
            this.events.change &&
            this.events.change.notify(this.current),
          i && this.events.renderRequest && this.events.renderRequest.notify(this.current))
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = n.owner))
  }
  setCurrent(e) {
    ;((this.current = e),
      (this.updatedAt = _r.now()),
      this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = _5(this.current)))
  }
  setPrevFrameValue(e = this.current) {
    ;((this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt))
  }
  onChange(e) {
    return this.on('change', e)
  }
  on(e, n) {
    this.events[e] || (this.events[e] = new U0())
    const r = this.events[e].add(n)
    return e === 'change'
      ? () => {
          ;(r(),
            re.read(() => {
              this.events.change.getSize() || this.stop()
            }))
        }
      : r
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear()
  }
  attach(e, n) {
    ;((this.passiveEffect = e), (this.stopPassiveEffect = n))
  }
  set(e, n = !0) {
    !n || !this.passiveEffect
      ? this.updateAndNotify(e, n)
      : this.passiveEffect(e, this.updateAndNotify)
  }
  setWithVelocity(e, n, r) {
    ;(this.set(n),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - r))
  }
  jump(e, n = !0) {
    ;(this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      n && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect())
  }
  get() {
    return this.current
  }
  getPrevious() {
    return this.prev
  }
  getVelocity() {
    const e = _r.now()
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > d2)
      return 0
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, d2)
    return Kw(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
  }
  start(e) {
    return (
      this.stop(),
      new Promise((n) => {
        ;((this.hasAnimated = !0),
          (this.animation = e(n)),
          this.events.animationStart && this.events.animationStart.notify())
      }).then(() => {
        ;(this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation())
      })
    )
  }
  stop() {
    ;(this.animation &&
      (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation())
  }
  isAnimating() {
    return !!this.animation
  }
  clearAnimation() {
    delete this.animation
  }
  destroy() {
    ;(this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect())
  }
}
function El(t, e) {
  return new R5(t, e)
}
function T5(t, e, n) {
  t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, El(n))
}
function N5(t, e) {
  const n = yh(t, e)
  let { transitionEnd: r = {}, transition: i = {}, ...s } = n || {}
  s = { ...s, ...r }
  for (const c in s) {
    const h = zC(s[c])
    T5(t, c, h)
  }
}
function M5(t) {
  return !!(Je(t) && t.add)
}
function G1(t, e) {
  const n = t.getValue('willChange')
  if (M5(n)) return n.add(e)
}
function Qw(t) {
  return t.props[Iw]
}
const $w = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t,
  D5 = 1e-7,
  P5 = 12
function L5(t, e, n, r, i) {
  let s,
    c,
    h = 0
  do ((c = e + (n - e) / 2), (s = $w(c, r, i) - t), s > 0 ? (n = c) : (e = c))
  while (Math.abs(s) > D5 && ++h < P5)
  return c
}
function Bl(t, e, n, r) {
  if (t === e && n === r) return Pn
  const i = (s) => L5(s, 0, 1, t, n)
  return (s) => (s === 0 || s === 1 ? s : $w(i(s), e, r))
}
const Jw = (t) => (e) => (e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2),
  t6 = (t) => (e) => 1 - t(1 - e),
  e6 = Bl(0.33, 1.53, 0.69, 0.99),
  z0 = t6(e6),
  n6 = Jw(z0),
  r6 = (t) => ((t *= 2) < 1 ? 0.5 * z0(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1)))),
  H0 = (t) => 1 - Math.sin(Math.acos(t)),
  i6 = t6(H0),
  o6 = Jw(H0),
  s6 = (t) => /^0[^.\s]+$/u.test(t)
function O5(t) {
  return typeof t == 'number' ? t === 0 : t !== null ? t === 'none' || t === '0' || s6(t) : !0
}
const Xa = (t) => Math.round(t * 1e5) / 1e5,
  X0 = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu
function B5(t) {
  return t == null
}
const F5 =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  G0 = (t, e) => (n) =>
    !!(
      (typeof n == 'string' && F5.test(n) && n.startsWith(t)) ||
      (e && !B5(n) && Object.prototype.hasOwnProperty.call(n, e))
    ),
  a6 = (t, e, n) => (r) => {
    if (typeof r != 'string') return r
    const [i, s, c, h] = r.match(X0)
    return {
      [t]: parseFloat(i),
      [e]: parseFloat(s),
      [n]: parseFloat(c),
      alpha: h !== void 0 ? parseFloat(h) : 1,
    }
  },
  j5 = (t) => qr(0, 255, t),
  Ed = { ...Ks, transform: (t) => Math.round(j5(t)) },
  lo = {
    test: G0('rgb', 'red'),
    parse: a6('red', 'green', 'blue'),
    transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) =>
      'rgba(' +
      Ed.transform(t) +
      ', ' +
      Ed.transform(e) +
      ', ' +
      Ed.transform(n) +
      ', ' +
      Xa(xl.transform(r)) +
      ')',
  }
function V5(t) {
  let e = '',
    n = '',
    r = '',
    i = ''
  return (
    t.length > 5
      ? ((e = t.substring(1, 3)),
        (n = t.substring(3, 5)),
        (r = t.substring(5, 7)),
        (i = t.substring(7, 9)))
      : ((e = t.substring(1, 2)),
        (n = t.substring(2, 3)),
        (r = t.substring(3, 4)),
        (i = t.substring(4, 5)),
        (e += e),
        (n += n),
        (r += r),
        (i += i)),
    {
      red: parseInt(e, 16),
      green: parseInt(n, 16),
      blue: parseInt(r, 16),
      alpha: i ? parseInt(i, 16) / 255 : 1,
    }
  )
}
const Y1 = { test: G0('#'), parse: V5, transform: lo.transform },
  ys = {
    test: G0('hsl', 'hue'),
    parse: a6('hue', 'saturation', 'lightness'),
    transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) =>
      'hsla(' +
      Math.round(t) +
      ', ' +
      Ir.transform(Xa(e)) +
      ', ' +
      Ir.transform(Xa(n)) +
      ', ' +
      Xa(xl.transform(r)) +
      ')',
  },
  Qe = {
    test: (t) => lo.test(t) || Y1.test(t) || ys.test(t),
    parse: (t) => (lo.test(t) ? lo.parse(t) : ys.test(t) ? ys.parse(t) : Y1.parse(t)),
    transform: (t) =>
      typeof t == 'string' ? t : t.hasOwnProperty('red') ? lo.transform(t) : ys.transform(t),
  },
  W5 =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu
function U5(t) {
  var e, n
  return (
    isNaN(t) &&
    typeof t == 'string' &&
    (((e = t.match(X0)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((n = t.match(W5)) === null || n === void 0 ? void 0 : n.length) || 0) >
      0
  )
}
const l6 = 'number',
  c6 = 'color',
  z5 = 'var',
  H5 = 'var(',
  f2 = '${}',
  X5 =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu
function Cl(t) {
  const e = t.toString(),
    n = [],
    r = { color: [], number: [], var: [] },
    i = []
  let s = 0
  const c = e
    .replace(
      X5,
      (h) => (
        Qe.test(h)
          ? (r.color.push(s), i.push(c6), n.push(Qe.parse(h)))
          : h.startsWith(H5)
            ? (r.var.push(s), i.push(z5), n.push(h))
            : (r.number.push(s), i.push(l6), n.push(parseFloat(h))),
        ++s,
        f2
      )
    )
    .split(f2)
  return { values: n, split: c, indexes: r, types: i }
}
function u6(t) {
  return Cl(t).values
}
function h6(t) {
  const { split: e, types: n } = Cl(t),
    r = e.length
  return (i) => {
    let s = ''
    for (let c = 0; c < r; c++)
      if (((s += e[c]), i[c] !== void 0)) {
        const h = n[c]
        h === l6 ? (s += Xa(i[c])) : h === c6 ? (s += Qe.transform(i[c])) : (s += i[c])
      }
    return s
  }
}
const G5 = (t) => (typeof t == 'number' ? 0 : t)
function Y5(t) {
  const e = u6(t)
  return h6(t)(e.map(G5))
}
const Li = { test: U5, parse: u6, createTransformer: h6, getAnimatableNone: Y5 },
  Z5 = new Set(['brightness', 'contrast', 'saturate', 'opacity'])
function q5(t) {
  const [e, n] = t.slice(0, -1).split('(')
  if (e === 'drop-shadow') return t
  const [r] = n.match(X0) || []
  if (!r) return t
  const i = n.replace(r, '')
  let s = Z5.has(e) ? 1 : 0
  return (r !== n && (s *= 100), e + '(' + s + i + ')')
}
const K5 = /\b([a-z-]*)\(.*?\)/gu,
  Z1 = {
    ...Li,
    getAnimatableNone: (t) => {
      const e = t.match(K5)
      return e ? e.map(q5).join(' ') : t
    },
  },
  Q5 = {
    ...T0,
    color: Qe,
    backgroundColor: Qe,
    outlineColor: Qe,
    fill: Qe,
    stroke: Qe,
    borderColor: Qe,
    borderTopColor: Qe,
    borderRightColor: Qe,
    borderBottomColor: Qe,
    borderLeftColor: Qe,
    filter: Z1,
    WebkitFilter: Z1,
  },
  Y0 = (t) => Q5[t]
function d6(t, e) {
  let n = Y0(t)
  return (n !== Z1 && (n = Li), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0)
}
const $5 = new Set(['auto', 'none', '0'])
function J5(t, e, n) {
  let r = 0,
    i
  for (; r < t.length && !i; ) {
    const s = t[r]
    ;(typeof s == 'string' && !$5.has(s) && Cl(s).values.length && (i = t[r]), r++)
  }
  if (i && n) for (const s of e) t[s] = d6(n, i)
}
const p2 = (t) => t === Ks || t === bt,
  g2 = (t, e) => parseFloat(t.split(', ')[e]),
  m2 =
    (t, e) =>
    (n, { transform: r }) => {
      if (r === 'none' || !r) return 0
      const i = r.match(/^matrix3d\((.+)\)$/u)
      if (i) return g2(i[1], e)
      {
        const s = r.match(/^matrix\((.+)\)$/u)
        return s ? g2(s[1], t) : 0
      }
    },
  tS = new Set(['x', 'y', 'z']),
  eS = qs.filter((t) => !tS.has(t))
function nS(t) {
  const e = []
  return (
    eS.forEach((n) => {
      const r = t.getValue(n)
      r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith('scale') ? 1 : 0))
    }),
    e
  )
}
const Vs = {
  width: ({ x: t }, { paddingLeft: e = '0', paddingRight: n = '0' }) =>
    t.max - t.min - parseFloat(e) - parseFloat(n),
  height: ({ y: t }, { paddingTop: e = '0', paddingBottom: n = '0' }) =>
    t.max - t.min - parseFloat(e) - parseFloat(n),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  x: m2(4, 13),
  y: m2(5, 14),
}
Vs.translateX = Vs.x
Vs.translateY = Vs.y
const fo = new Set()
let q1 = !1,
  K1 = !1
function f6() {
  if (K1) {
    const t = Array.from(fo).filter((r) => r.needsMeasurement),
      e = new Set(t.map((r) => r.element)),
      n = new Map()
    ;(e.forEach((r) => {
      const i = nS(r)
      i.length && (n.set(r, i), r.render())
    }),
      t.forEach((r) => r.measureInitialState()),
      e.forEach((r) => {
        r.render()
        const i = n.get(r)
        i &&
          i.forEach(([s, c]) => {
            var h
            ;(h = r.getValue(s)) === null || h === void 0 || h.set(c)
          })
      }),
      t.forEach((r) => r.measureEndState()),
      t.forEach((r) => {
        r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY)
      }))
  }
  ;((K1 = !1), (q1 = !1), fo.forEach((t) => t.complete()), fo.clear())
}
function p6() {
  fo.forEach((t) => {
    ;(t.readKeyframes(), t.needsMeasurement && (K1 = !0))
  })
}
function rS() {
  ;(p6(), f6())
}
class Z0 {
  constructor(e, n, r, i, s, c = !1) {
    ;((this.isComplete = !1),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.isScheduled = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = n),
      (this.name = r),
      (this.motionValue = i),
      (this.element = s),
      (this.isAsync = c))
  }
  scheduleResolve() {
    ;((this.isScheduled = !0),
      this.isAsync
        ? (fo.add(this), q1 || ((q1 = !0), re.read(p6), re.resolveKeyframes(f6)))
        : (this.readKeyframes(), this.complete()))
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: n, element: r, motionValue: i } = this
    for (let s = 0; s < e.length; s++)
      if (e[s] === null)
        if (s === 0) {
          const c = i == null ? void 0 : i.get(),
            h = e[e.length - 1]
          if (c !== void 0) e[0] = c
          else if (r && n) {
            const f = r.readValue(n, h)
            f != null && (e[0] = f)
          }
          ;(e[0] === void 0 && (e[0] = h), i && c === void 0 && i.set(e[0]))
        } else e[s] = e[s - 1]
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    ;((this.isComplete = !0),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
      fo.delete(this))
  }
  cancel() {
    this.isComplete || ((this.isScheduled = !1), fo.delete(this))
  }
  resume() {
    this.isComplete || this.scheduleResolve()
  }
}
const g6 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),
  iS = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
function oS(t) {
  const e = iS.exec(t)
  if (!e) return [,]
  const [, n, r, i] = e
  return [`--${n ?? r}`, i]
}
function m6(t, e, n = 1) {
  const [r, i] = oS(t)
  if (!r) return
  const s = window.getComputedStyle(e).getPropertyValue(r)
  if (s) {
    const c = s.trim()
    return g6(c) ? parseFloat(c) : c
  }
  return R0(i) ? m6(i, e, n + 1) : i
}
const y6 = (t) => (e) => e.test(t),
  sS = { test: (t) => t === 'auto', parse: (t) => t },
  w6 = [Ks, bt, Ir, li, qC, ZC, sS],
  y2 = (t) => w6.find(y6(t))
class b6 extends Z0 {
  constructor(e, n, r, i, s) {
    super(e, n, r, i, s, !0)
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: n, name: r } = this
    if (!n || !n.current) return
    super.readKeyframes()
    for (let f = 0; f < e.length; f++) {
      let p = e[f]
      if (typeof p == 'string' && ((p = p.trim()), R0(p))) {
        const y = m6(p, n.current)
        ;(y !== void 0 && (e[f] = y), f === e.length - 1 && (this.finalKeyframe = p))
      }
    }
    if ((this.resolveNoneKeyframes(), !qw.has(r) || e.length !== 2)) return
    const [i, s] = e,
      c = y2(i),
      h = y2(s)
    if (c !== h)
      if (p2(c) && p2(h))
        for (let f = 0; f < e.length; f++) {
          const p = e[f]
          typeof p == 'string' && (e[f] = parseFloat(p))
        }
      else this.needsMeasurement = !0
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: n } = this,
      r = []
    for (let i = 0; i < e.length; i++) O5(e[i]) && r.push(i)
    r.length && J5(e, r, n)
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: n, name: r } = this
    if (!e || !e.current) return
    ;(r === 'height' && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = Vs[r](e.measureViewportBox(), window.getComputedStyle(e.current))),
      (n[0] = this.measuredOrigin))
    const i = n[n.length - 1]
    i !== void 0 && e.getValue(r, i).jump(i, !1)
  }
  measureEndState() {
    var e
    const { element: n, name: r, unresolvedKeyframes: i } = this
    if (!n || !n.current) return
    const s = n.getValue(r)
    s && s.jump(this.measuredOrigin, !1)
    const c = i.length - 1,
      h = i[c]
    ;((i[c] = Vs[r](n.measureViewportBox(), window.getComputedStyle(n.current))),
      h !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = h),
      !((e = this.removedTransforms) === null || e === void 0) &&
        e.length &&
        this.removedTransforms.forEach(([f, p]) => {
          n.getValue(f).set(p)
        }),
      this.resolveNoneKeyframes())
  }
}
const w2 = (t, e) =>
  e === 'zIndex'
    ? !1
    : !!(
        typeof t == 'number' ||
        Array.isArray(t) ||
        (typeof t == 'string' && (Li.test(t) || t === '0') && !t.startsWith('url('))
      )
function aS(t) {
  const e = t[0]
  if (t.length === 1) return !0
  for (let n = 0; n < t.length; n++) if (t[n] !== e) return !0
}
function lS(t, e, n, r) {
  const i = t[0]
  if (i === null) return !1
  if (e === 'display' || e === 'visibility') return !0
  const s = t[t.length - 1],
    c = w2(i, e),
    h = w2(s, e)
  return !c || !h ? !1 : aS(t) || ((n === 'spring' || B0(n)) && r)
}
const cS = (t) => t !== null
function wh(t, { repeat: e, repeatType: n = 'loop' }, r) {
  const i = t.filter(cS),
    s = e && n !== 'loop' && e % 2 === 1 ? 0 : i.length - 1
  return !s || r === void 0 ? i[s] : r
}
const uS = 40
class v6 {
  constructor({
    autoplay: e = !0,
    delay: n = 0,
    type: r = 'keyframes',
    repeat: i = 0,
    repeatDelay: s = 0,
    repeatType: c = 'loop',
    ...h
  }) {
    ;((this.isStopped = !1),
      (this.hasAttemptedResolve = !1),
      (this.createdAt = _r.now()),
      (this.options = {
        autoplay: e,
        delay: n,
        type: r,
        repeat: i,
        repeatDelay: s,
        repeatType: c,
        ...h,
      }),
      this.updateFinishedPromise())
  }
  calcStartTime() {
    return this.resolvedAt
      ? this.resolvedAt - this.createdAt > uS
        ? this.resolvedAt
        : this.createdAt
      : this.createdAt
  }
  get resolved() {
    return (!this._resolved && !this.hasAttemptedResolve && rS(), this._resolved)
  }
  onKeyframesResolved(e, n) {
    ;((this.resolvedAt = _r.now()), (this.hasAttemptedResolve = !0))
    const {
      name: r,
      type: i,
      velocity: s,
      delay: c,
      onComplete: h,
      onUpdate: f,
      isGenerator: p,
    } = this.options
    if (!p && !lS(e, r, i, s))
      if (c) this.options.duration = 0
      else {
        ;(f && f(wh(e, this.options, n)), h && h(), this.resolveFinishedPromise())
        return
      }
    const y = this.initPlayback(e, n)
    y !== !1 && ((this._resolved = { keyframes: e, finalKeyframe: n, ...y }), this.onPostResolved())
  }
  onPostResolved() {}
  then(e, n) {
    return this.currentFinishedPromise.then(e, n)
  }
  flatten() {
    ;((this.options.type = 'keyframes'), (this.options.ease = 'linear'))
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e
    })
  }
}
const le = (t, e, n) => t + (e - t) * n
function Cd(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
  )
}
function hS({ hue: t, saturation: e, lightness: n, alpha: r }) {
  ;((t /= 360), (e /= 100), (n /= 100))
  let i = 0,
    s = 0,
    c = 0
  if (!e) i = s = c = n
  else {
    const h = n < 0.5 ? n * (1 + e) : n + e - n * e,
      f = 2 * n - h
    ;((i = Cd(f, h, t + 1 / 3)), (s = Cd(f, h, t)), (c = Cd(f, h, t - 1 / 3)))
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(c * 255),
    alpha: r,
  }
}
function Du(t, e) {
  return (n) => (n > 0 ? e : t)
}
const Sd = (t, e, n) => {
    const r = t * t,
      i = n * (e * e - r) + r
    return i < 0 ? 0 : Math.sqrt(i)
  },
  dS = [Y1, lo, ys],
  fS = (t) => dS.find((e) => e.test(t))
function b2(t) {
  const e = fS(t)
  if (!e) return !1
  let n = e.parse(t)
  return (e === ys && (n = hS(n)), n)
}
const v2 = (t, e) => {
    const n = b2(t),
      r = b2(e)
    if (!n || !r) return Du(t, e)
    const i = { ...n }
    return (s) => (
      (i.red = Sd(n.red, r.red, s)),
      (i.green = Sd(n.green, r.green, s)),
      (i.blue = Sd(n.blue, r.blue, s)),
      (i.alpha = le(n.alpha, r.alpha, s)),
      lo.transform(i)
    )
  },
  pS = (t, e) => (n) => e(t(n)),
  Fl = (...t) => t.reduce(pS),
  Q1 = new Set(['none', 'hidden'])
function gS(t, e) {
  return Q1.has(t) ? (n) => (n <= 0 ? t : e) : (n) => (n >= 1 ? e : t)
}
function mS(t, e) {
  return (n) => le(t, e, n)
}
function q0(t) {
  return typeof t == 'number'
    ? mS
    : typeof t == 'string'
      ? R0(t)
        ? Du
        : Qe.test(t)
          ? v2
          : bS
      : Array.isArray(t)
        ? x6
        : typeof t == 'object'
          ? Qe.test(t)
            ? v2
            : yS
          : Du
}
function x6(t, e) {
  const n = [...t],
    r = n.length,
    i = t.map((s, c) => q0(s)(s, e[c]))
  return (s) => {
    for (let c = 0; c < r; c++) n[c] = i[c](s)
    return n
  }
}
function yS(t, e) {
  const n = { ...t, ...e },
    r = {}
  for (const i in n) t[i] !== void 0 && e[i] !== void 0 && (r[i] = q0(t[i])(t[i], e[i]))
  return (i) => {
    for (const s in r) n[s] = r[s](i)
    return n
  }
}
function wS(t, e) {
  var n
  const r = [],
    i = { color: 0, var: 0, number: 0 }
  for (let s = 0; s < e.values.length; s++) {
    const c = e.types[s],
      h = t.indexes[c][i[c]],
      f = (n = t.values[h]) !== null && n !== void 0 ? n : 0
    ;((r[s] = f), i[c]++)
  }
  return r
}
const bS = (t, e) => {
  const n = Li.createTransformer(e),
    r = Cl(t),
    i = Cl(e)
  return r.indexes.var.length === i.indexes.var.length &&
    r.indexes.color.length === i.indexes.color.length &&
    r.indexes.number.length >= i.indexes.number.length
    ? (Q1.has(t) && !i.values.length) || (Q1.has(e) && !r.values.length)
      ? gS(t, e)
      : Fl(x6(wS(r, i), i.values), n)
    : Du(t, e)
}
function E6(t, e, n) {
  return typeof t == 'number' && typeof e == 'number' && typeof n == 'number'
    ? le(t, e, n)
    : q0(t)(t, e)
}
const vS = 5
function C6(t, e, n) {
  const r = Math.max(e - vS, 0)
  return Kw(n - t(r), e - r)
}
const ye = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  Ad = 0.001
function xS({
  duration: t = ye.duration,
  bounce: e = ye.bounce,
  velocity: n = ye.velocity,
  mass: r = ye.mass,
}) {
  let i,
    s,
    c = 1 - e
  ;((c = qr(ye.minDamping, ye.maxDamping, c)),
    (t = qr(ye.minDuration, ye.maxDuration, Hr(t))),
    c < 1
      ? ((i = (p) => {
          const y = p * c,
            w = y * t,
            x = y - n,
            E = $1(p, c),
            S = Math.exp(-w)
          return Ad - (x / E) * S
        }),
        (s = (p) => {
          const y = p * c * t,
            w = y * n + n,
            x = Math.pow(c, 2) * Math.pow(p, 2) * t,
            E = Math.exp(-y),
            S = $1(Math.pow(p, 2), c)
          return ((-i(p) + Ad > 0 ? -1 : 1) * ((w - x) * E)) / S
        }))
      : ((i = (p) => {
          const y = Math.exp(-p * t),
            w = (p - n) * t + 1
          return -Ad + y * w
        }),
        (s = (p) => {
          const y = Math.exp(-p * t),
            w = (n - p) * (t * t)
          return y * w
        })))
  const h = 5 / t,
    f = CS(i, s, h)
  if (((t = zr(t)), isNaN(f))) return { stiffness: ye.stiffness, damping: ye.damping, duration: t }
  {
    const p = Math.pow(f, 2) * r
    return { stiffness: p, damping: c * 2 * Math.sqrt(r * p), duration: t }
  }
}
const ES = 12
function CS(t, e, n) {
  let r = n
  for (let i = 1; i < ES; i++) r = r - t(r) / e(r)
  return r
}
function $1(t, e) {
  return t * Math.sqrt(1 - e * e)
}
const SS = ['duration', 'bounce'],
  AS = ['stiffness', 'damping', 'mass']
function x2(t, e) {
  return e.some((n) => t[n] !== void 0)
}
function kS(t) {
  let e = {
    velocity: ye.velocity,
    stiffness: ye.stiffness,
    damping: ye.damping,
    mass: ye.mass,
    isResolvedFromDuration: !1,
    ...t,
  }
  if (!x2(t, AS) && x2(t, SS))
    if (t.visualDuration) {
      const n = t.visualDuration,
        r = (2 * Math.PI) / (n * 1.2),
        i = r * r,
        s = 2 * qr(0.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(i)
      e = { ...e, mass: ye.mass, stiffness: i, damping: s }
    } else {
      const n = xS(t)
      ;((e = { ...e, ...n, mass: ye.mass }), (e.isResolvedFromDuration = !0))
    }
  return e
}
function S6(t = ye.visualDuration, e = ye.bounce) {
  const n = typeof t != 'object' ? { visualDuration: t, keyframes: [0, 1], bounce: e } : t
  let { restSpeed: r, restDelta: i } = n
  const s = n.keyframes[0],
    c = n.keyframes[n.keyframes.length - 1],
    h = { done: !1, value: s },
    {
      stiffness: f,
      damping: p,
      mass: y,
      duration: w,
      velocity: x,
      isResolvedFromDuration: E,
    } = kS({ ...n, velocity: -Hr(n.velocity || 0) }),
    S = x || 0,
    k = p / (2 * Math.sqrt(f * y)),
    D = c - s,
    _ = Hr(Math.sqrt(f / y)),
    N = Math.abs(D) < 5
  ;(r || (r = N ? ye.restSpeed.granular : ye.restSpeed.default),
    i || (i = N ? ye.restDelta.granular : ye.restDelta.default))
  let M
  if (k < 1) {
    const F = $1(_, k)
    M = (z) => {
      const V = Math.exp(-k * _ * z)
      return c - V * (((S + k * _ * D) / F) * Math.sin(F * z) + D * Math.cos(F * z))
    }
  } else if (k === 1) M = (F) => c - Math.exp(-_ * F) * (D + (S + _ * D) * F)
  else {
    const F = _ * Math.sqrt(k * k - 1)
    M = (z) => {
      const V = Math.exp(-k * _ * z),
        W = Math.min(F * z, 300)
      return c - (V * ((S + k * _ * D) * Math.sinh(W) + F * D * Math.cosh(W))) / F
    }
  }
  const O = {
    calculatedDuration: (E && w) || null,
    next: (F) => {
      const z = M(F)
      if (E) h.done = F >= w
      else {
        let V = 0
        k < 1 && (V = F === 0 ? zr(S) : C6(M, F, z))
        const W = Math.abs(V) <= r,
          Z = Math.abs(c - z) <= i
        h.done = W && Z
      }
      return ((h.value = h.done ? c : z), h)
    },
    toString: () => {
      const F = Math.min(Uw(O), H1),
        z = zw((V) => O.next(F * V).value, F, 30)
      return F + 'ms ' + z
    },
  }
  return O
}
function E2({
  keyframes: t,
  velocity: e = 0,
  power: n = 0.8,
  timeConstant: r = 325,
  bounceDamping: i = 10,
  bounceStiffness: s = 500,
  modifyTarget: c,
  min: h,
  max: f,
  restDelta: p = 0.5,
  restSpeed: y,
}) {
  const w = t[0],
    x = { done: !1, value: w },
    E = (W) => (h !== void 0 && W < h) || (f !== void 0 && W > f),
    S = (W) => (h === void 0 ? f : f === void 0 || Math.abs(h - W) < Math.abs(f - W) ? h : f)
  let k = n * e
  const D = w + k,
    _ = c === void 0 ? D : c(D)
  _ !== D && (k = _ - w)
  const N = (W) => -k * Math.exp(-W / r),
    M = (W) => _ + N(W),
    O = (W) => {
      const Z = N(W),
        J = M(W)
      ;((x.done = Math.abs(Z) <= p), (x.value = x.done ? _ : J))
    }
  let F, z
  const V = (W) => {
    E(x.value) &&
      ((F = W),
      (z = S6({
        keyframes: [x.value, S(x.value)],
        velocity: C6(M, W, x.value),
        damping: i,
        stiffness: s,
        restDelta: p,
        restSpeed: y,
      })))
  }
  return (
    V(0),
    {
      calculatedDuration: null,
      next: (W) => {
        let Z = !1
        return (
          !z && F === void 0 && ((Z = !0), O(W), V(W)),
          F !== void 0 && W >= F ? z.next(W - F) : (!Z && O(W), x)
        )
      },
    }
  )
}
const IS = Bl(0.42, 0, 1, 1),
  _S = Bl(0, 0, 0.58, 1),
  A6 = Bl(0.42, 0, 0.58, 1),
  RS = (t) => Array.isArray(t) && typeof t[0] != 'number',
  TS = {
    linear: Pn,
    easeIn: IS,
    easeInOut: A6,
    easeOut: _S,
    circIn: H0,
    circInOut: o6,
    circOut: i6,
    backIn: z0,
    backInOut: n6,
    backOut: e6,
    anticipate: r6,
  },
  C2 = (t) => {
    if (F0(t)) {
      Ew(t.length === 4)
      const [e, n, r, i] = t
      return Bl(e, n, r, i)
    } else if (typeof t == 'string') return TS[t]
    return t
  }
function NS(t, e, n) {
  const r = [],
    i = n || E6,
    s = t.length - 1
  for (let c = 0; c < s; c++) {
    let h = i(t[c], t[c + 1])
    if (e) {
      const f = Array.isArray(e) ? e[c] || Pn : e
      h = Fl(f, h)
    }
    r.push(h)
  }
  return r
}
function MS(t, e, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const s = t.length
  if ((Ew(s === e.length), s === 1)) return () => e[0]
  if (s === 2 && e[0] === e[1]) return () => e[1]
  const c = t[0] === t[1]
  t[0] > t[s - 1] && ((t = [...t].reverse()), (e = [...e].reverse()))
  const h = NS(e, r, i),
    f = h.length,
    p = (y) => {
      if (c && y < t[0]) return e[0]
      let w = 0
      if (f > 1) for (; w < t.length - 2 && !(y < t[w + 1]); w++);
      const x = Fs(t[w], t[w + 1], y)
      return h[w](x)
    }
  return n ? (y) => p(qr(t[0], t[s - 1], y)) : p
}
function DS(t, e) {
  const n = t[t.length - 1]
  for (let r = 1; r <= e; r++) {
    const i = Fs(0, e, r)
    t.push(le(n, 1, i))
  }
}
function PS(t) {
  const e = [0]
  return (DS(e, t.length - 1), e)
}
function LS(t, e) {
  return t.map((n) => n * e)
}
function OS(t, e) {
  return t.map(() => e || A6).splice(0, t.length - 1)
}
function Pu({ duration: t = 300, keyframes: e, times: n, ease: r = 'easeInOut' }) {
  const i = RS(r) ? r.map(C2) : C2(r),
    s = { done: !1, value: e[0] },
    c = LS(n && n.length === e.length ? n : PS(e), t),
    h = MS(c, e, { ease: Array.isArray(i) ? i : OS(e, i) })
  return { calculatedDuration: t, next: (f) => ((s.value = h(f)), (s.done = f >= t), s) }
}
const BS = (t) => {
    const e = ({ timestamp: n }) => t(n)
    return {
      start: () => re.update(e, !0),
      stop: () => Pi(e),
      now: () => (ze.isProcessing ? ze.timestamp : _r.now()),
    }
  },
  FS = { decay: E2, inertia: E2, tween: Pu, keyframes: Pu, spring: S6 },
  jS = (t) => t / 100
class K0 extends v6 {
  constructor(e) {
    ;(super(e),
      (this.holdTime = null),
      (this.cancelTime = null),
      (this.currentTime = 0),
      (this.playbackSpeed = 1),
      (this.pendingPlayState = 'running'),
      (this.startTime = null),
      (this.state = 'idle'),
      (this.stop = () => {
        if ((this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle')) return
        this.teardown()
        const { onStop: f } = this.options
        f && f()
      }))
    const { name: n, motionValue: r, element: i, keyframes: s } = this.options,
      c = (i == null ? void 0 : i.KeyframeResolver) || Z0,
      h = (f, p) => this.onKeyframesResolved(f, p)
    ;((this.resolver = new c(s, h, n, r, i)), this.resolver.scheduleResolve())
  }
  flatten() {
    ;(super.flatten(),
      this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)))
  }
  initPlayback(e) {
    const {
        type: n = 'keyframes',
        repeat: r = 0,
        repeatDelay: i = 0,
        repeatType: s,
        velocity: c = 0,
      } = this.options,
      h = B0(n) ? n : FS[n] || Pu
    let f, p
    h !== Pu && typeof e[0] != 'number' && ((f = Fl(jS, E6(e[0], e[1]))), (e = [0, 100]))
    const y = h({ ...this.options, keyframes: e })
    ;(s === 'mirror' && (p = h({ ...this.options, keyframes: [...e].reverse(), velocity: -c })),
      y.calculatedDuration === null && (y.calculatedDuration = Uw(y)))
    const { calculatedDuration: w } = y,
      x = w + i,
      E = x * (r + 1) - i
    return {
      generator: y,
      mirroredGenerator: p,
      mapPercentToKeyframes: f,
      calculatedDuration: w,
      resolvedDuration: x,
      totalDuration: E,
    }
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options
    ;(this.play(),
      this.pendingPlayState === 'paused' || !e
        ? this.pause()
        : (this.state = this.pendingPlayState))
  }
  tick(e, n = !1) {
    const { resolved: r } = this
    if (!r) {
      const { keyframes: W } = this.options
      return { done: !0, value: W[W.length - 1] }
    }
    const {
      finalKeyframe: i,
      generator: s,
      mirroredGenerator: c,
      mapPercentToKeyframes: h,
      keyframes: f,
      calculatedDuration: p,
      totalDuration: y,
      resolvedDuration: w,
    } = r
    if (this.startTime === null) return s.next(0)
    const { delay: x, repeat: E, repeatType: S, repeatDelay: k, onUpdate: D } = this.options
    ;(this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 && (this.startTime = Math.min(e - y / this.speed, this.startTime)),
      n
        ? (this.currentTime = e)
        : this.holdTime !== null
          ? (this.currentTime = this.holdTime)
          : (this.currentTime = Math.round(e - this.startTime) * this.speed))
    const _ = this.currentTime - x * (this.speed >= 0 ? 1 : -1),
      N = this.speed >= 0 ? _ < 0 : _ > y
    ;((this.currentTime = Math.max(_, 0)),
      this.state === 'finished' && this.holdTime === null && (this.currentTime = y))
    let M = this.currentTime,
      O = s
    if (E) {
      const W = Math.min(this.currentTime, y) / w
      let Z = Math.floor(W),
        J = W % 1
      ;(!J && W >= 1 && (J = 1),
        J === 1 && Z--,
        (Z = Math.min(Z, E + 1)),
        Z % 2 && (S === 'reverse' ? ((J = 1 - J), k && (J -= k / w)) : S === 'mirror' && (O = c)),
        (M = qr(0, 1, J) * w))
    }
    const F = N ? { done: !1, value: f[0] } : O.next(M)
    h && (F.value = h(F.value))
    let { done: z } = F
    !N && p !== null && (z = this.speed >= 0 ? this.currentTime >= y : this.currentTime <= 0)
    const V =
      this.holdTime === null && (this.state === 'finished' || (this.state === 'running' && z))
    return (
      V && i !== void 0 && (F.value = wh(f, this.options, i)),
      D && D(F.value),
      V && this.finish(),
      F
    )
  }
  get duration() {
    const { resolved: e } = this
    return e ? Hr(e.calculatedDuration) : 0
  }
  get time() {
    return Hr(this.currentTime)
  }
  set time(e) {
    ;((e = zr(e)),
      (this.currentTime = e),
      this.holdTime !== null || this.speed === 0
        ? (this.holdTime = e)
        : this.driver && (this.startTime = this.driver.now() - e / this.speed))
  }
  get speed() {
    return this.playbackSpeed
  }
  set speed(e) {
    const n = this.playbackSpeed !== e
    ;((this.playbackSpeed = e), n && (this.time = Hr(this.currentTime)))
  }
  play() {
    if ((this.resolver.isScheduled || this.resolver.resume(), !this._resolved)) {
      this.pendingPlayState = 'running'
      return
    }
    if (this.isStopped) return
    const { driver: e = BS, onPlay: n, startTime: r } = this.options
    ;(this.driver || (this.driver = e((s) => this.tick(s))), n && n())
    const i = this.driver.now()
    ;(this.holdTime !== null
      ? (this.startTime = i - this.holdTime)
      : this.startTime
        ? this.state === 'finished' && (this.startTime = i)
        : (this.startTime = r ?? this.calcStartTime()),
      this.state === 'finished' && this.updateFinishedPromise(),
      (this.cancelTime = this.startTime),
      (this.holdTime = null),
      (this.state = 'running'),
      this.driver.start())
  }
  pause() {
    var e
    if (!this._resolved) {
      this.pendingPlayState = 'paused'
      return
    }
    ;((this.state = 'paused'),
      (this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0))
  }
  complete() {
    ;(this.state !== 'running' && this.play(),
      (this.pendingPlayState = this.state = 'finished'),
      (this.holdTime = null))
  }
  finish() {
    ;(this.teardown(), (this.state = 'finished'))
    const { onComplete: e } = this.options
    e && e()
  }
  cancel() {
    ;(this.cancelTime !== null && this.tick(this.cancelTime),
      this.teardown(),
      this.updateFinishedPromise())
  }
  teardown() {
    ;((this.state = 'idle'),
      this.stopDriver(),
      this.resolveFinishedPromise(),
      this.updateFinishedPromise(),
      (this.startTime = this.cancelTime = null),
      this.resolver.cancel())
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0))
  }
  sample(e) {
    return ((this.startTime = 0), this.tick(e, !0))
  }
}
const VS = new Set(['opacity', 'clipPath', 'filter', 'transform'])
function WS(
  t,
  e,
  n,
  {
    delay: r = 0,
    duration: i = 300,
    repeat: s = 0,
    repeatType: c = 'loop',
    ease: h = 'easeInOut',
    times: f,
  } = {}
) {
  const p = { [e]: n }
  f && (p.offset = f)
  const y = Xw(h, i)
  return (
    Array.isArray(y) && (p.easing = y),
    t.animate(p, {
      delay: r,
      duration: i,
      easing: Array.isArray(y) ? 'linear' : y,
      fill: 'both',
      iterations: s + 1,
      direction: c === 'reverse' ? 'alternate' : 'normal',
    })
  )
}
const US = E0(() => Object.hasOwnProperty.call(Element.prototype, 'animate')),
  Lu = 10,
  zS = 2e4
function HS(t) {
  return B0(t.type) || t.type === 'spring' || !Hw(t.ease)
}
function XS(t, e) {
  const n = new K0({ ...e, keyframes: t, repeat: 0, delay: 0, isGenerator: !0 })
  let r = { done: !1, value: t[0] }
  const i = []
  let s = 0
  for (; !r.done && s < zS; ) ((r = n.sample(s)), i.push(r.value), (s += Lu))
  return { times: void 0, keyframes: i, duration: s - Lu, ease: 'linear' }
}
const k6 = { anticipate: r6, backInOut: n6, circInOut: o6 }
function GS(t) {
  return t in k6
}
class S2 extends v6 {
  constructor(e) {
    super(e)
    const { name: n, motionValue: r, element: i, keyframes: s } = this.options
    ;((this.resolver = new b6(s, (c, h) => this.onKeyframesResolved(c, h), n, r, i)),
      this.resolver.scheduleResolve())
  }
  initPlayback(e, n) {
    let {
      duration: r = 300,
      times: i,
      ease: s,
      type: c,
      motionValue: h,
      name: f,
      startTime: p,
    } = this.options
    if (!h.owner || !h.owner.current) return !1
    if ((typeof s == 'string' && Mu() && GS(s) && (s = k6[s]), HS(this.options))) {
      const { onComplete: w, onUpdate: x, motionValue: E, element: S, ...k } = this.options,
        D = XS(e, k)
      ;((e = D.keyframes),
        e.length === 1 && (e[1] = e[0]),
        (r = D.duration),
        (i = D.times),
        (s = D.ease),
        (c = 'keyframes'))
    }
    const y = WS(h.owner.current, f, e, { ...this.options, duration: r, times: i, ease: s })
    return (
      (y.startTime = p ?? this.calcStartTime()),
      this.pendingTimeline
        ? (l2(y, this.pendingTimeline), (this.pendingTimeline = void 0))
        : (y.onfinish = () => {
            const { onComplete: w } = this.options
            ;(h.set(wh(e, this.options, n)), w && w(), this.cancel(), this.resolveFinishedPromise())
          }),
      { animation: y, duration: r, times: i, type: c, ease: s, keyframes: e }
    )
  }
  get duration() {
    const { resolved: e } = this
    if (!e) return 0
    const { duration: n } = e
    return Hr(n)
  }
  get time() {
    const { resolved: e } = this
    if (!e) return 0
    const { animation: n } = e
    return Hr(n.currentTime || 0)
  }
  set time(e) {
    const { resolved: n } = this
    if (!n) return
    const { animation: r } = n
    r.currentTime = zr(e)
  }
  get speed() {
    const { resolved: e } = this
    if (!e) return 1
    const { animation: n } = e
    return n.playbackRate
  }
  set speed(e) {
    const { resolved: n } = this
    if (!n) return
    const { animation: r } = n
    r.playbackRate = e
  }
  get state() {
    const { resolved: e } = this
    if (!e) return 'idle'
    const { animation: n } = e
    return n.playState
  }
  get startTime() {
    const { resolved: e } = this
    if (!e) return null
    const { animation: n } = e
    return n.startTime
  }
  attachTimeline(e) {
    if (!this._resolved) this.pendingTimeline = e
    else {
      const { resolved: n } = this
      if (!n) return Pn
      const { animation: r } = n
      l2(r, e)
    }
    return Pn
  }
  play() {
    if (this.isStopped) return
    const { resolved: e } = this
    if (!e) return
    const { animation: n } = e
    ;(n.playState === 'finished' && this.updateFinishedPromise(), n.play())
  }
  pause() {
    const { resolved: e } = this
    if (!e) return
    const { animation: n } = e
    n.pause()
  }
  stop() {
    if ((this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle')) return
    ;(this.resolveFinishedPromise(), this.updateFinishedPromise())
    const { resolved: e } = this
    if (!e) return
    const { animation: n, keyframes: r, duration: i, type: s, ease: c, times: h } = e
    if (n.playState === 'idle' || n.playState === 'finished') return
    if (this.time) {
      const { motionValue: p, onUpdate: y, onComplete: w, element: x, ...E } = this.options,
        S = new K0({
          ...E,
          keyframes: r,
          duration: i,
          type: s,
          ease: c,
          times: h,
          isGenerator: !0,
        }),
        k = zr(this.time)
      p.setWithVelocity(S.sample(k - Lu).value, S.sample(k).value, Lu)
    }
    const { onStop: f } = this.options
    ;(f && f(), this.cancel())
  }
  complete() {
    const { resolved: e } = this
    e && e.animation.finish()
  }
  cancel() {
    const { resolved: e } = this
    e && e.animation.cancel()
  }
  static supports(e) {
    const { motionValue: n, name: r, repeatDelay: i, repeatType: s, damping: c, type: h } = e
    if (!n || !n.owner || !(n.owner.current instanceof HTMLElement)) return !1
    const { onUpdate: f, transformTemplate: p } = n.owner.getProps()
    return US() && r && VS.has(r) && !f && !p && !i && s !== 'mirror' && c !== 0 && h !== 'inertia'
  }
}
const YS = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10 },
  ZS = (t) => ({
    type: 'spring',
    stiffness: 550,
    damping: t === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  qS = { type: 'keyframes', duration: 0.8 },
  KS = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  QS = (t, { keyframes: e }) =>
    e.length > 2 ? qS : Ro.has(t) ? (t.startsWith('scale') ? ZS(e[1]) : YS) : KS
function $S({
  when: t,
  delay: e,
  delayChildren: n,
  staggerChildren: r,
  staggerDirection: i,
  repeat: s,
  repeatType: c,
  repeatDelay: h,
  from: f,
  elapsed: p,
  ...y
}) {
  return !!Object.keys(y).length
}
const Q0 =
  (t, e, n, r = {}, i, s) =>
  (c) => {
    const h = O0(r, t) || {},
      f = h.delay || r.delay || 0
    let { elapsed: p = 0 } = r
    p = p - zr(f)
    let y = {
      keyframes: Array.isArray(n) ? n : [null, n],
      ease: 'easeOut',
      velocity: e.getVelocity(),
      ...h,
      delay: -p,
      onUpdate: (x) => {
        ;(e.set(x), h.onUpdate && h.onUpdate(x))
      },
      onComplete: () => {
        ;(c(), h.onComplete && h.onComplete())
      },
      name: t,
      motionValue: e,
      element: s ? void 0 : i,
    }
    ;($S(h) || (y = { ...y, ...QS(t, y) }),
      y.duration && (y.duration = zr(y.duration)),
      y.repeatDelay && (y.repeatDelay = zr(y.repeatDelay)),
      y.from !== void 0 && (y.keyframes[0] = y.from))
    let w = !1
    if (
      ((y.type === !1 || (y.duration === 0 && !y.repeatDelay)) &&
        ((y.duration = 0), y.delay === 0 && (w = !0)),
      w && !s && e.get() !== void 0)
    ) {
      const x = wh(y.keyframes, h)
      if (x !== void 0)
        return (
          re.update(() => {
            ;(y.onUpdate(x), y.onComplete())
          }),
          new y5([])
        )
    }
    return !s && S2.supports(y) ? new S2(y) : new K0(y)
  }
function JS({ protectedKeys: t, needsAnimating: e }, n) {
  const r = t.hasOwnProperty(n) && e[n] !== !0
  return ((e[n] = !1), r)
}
function I6(t, e, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  var s
  let { transition: c = t.getDefaultTransition(), transitionEnd: h, ...f } = e
  r && (c = r)
  const p = [],
    y = i && t.animationState && t.animationState.getState()[i]
  for (const w in f) {
    const x = t.getValue(w, (s = t.latestValues[w]) !== null && s !== void 0 ? s : null),
      E = f[w]
    if (E === void 0 || (y && JS(y, w))) continue
    const S = { delay: n, ...O0(c || {}, w) }
    let k = !1
    if (window.MotionHandoffAnimation) {
      const _ = Qw(t)
      if (_) {
        const N = window.MotionHandoffAnimation(_, w, re)
        N !== null && ((S.startTime = N), (k = !0))
      }
    }
    ;(G1(t, w), x.start(Q0(w, x, E, t.shouldReduceMotion && qw.has(w) ? { type: !1 } : S, t, k)))
    const D = x.animation
    D && p.push(D)
  }
  return (
    h &&
      Promise.all(p).then(() => {
        re.update(() => {
          h && N5(t, h)
        })
      }),
    p
  )
}
function J1(t, e, n = {}) {
  var r
  const i = yh(
    t,
    e,
    n.type === 'exit'
      ? (r = t.presenceContext) === null || r === void 0
        ? void 0
        : r.custom
      : void 0
  )
  let { transition: s = t.getDefaultTransition() || {} } = i || {}
  n.transitionOverride && (s = n.transitionOverride)
  const c = i ? () => Promise.all(I6(t, i, n)) : () => Promise.resolve(),
    h =
      t.variantChildren && t.variantChildren.size
        ? (p = 0) => {
            const { delayChildren: y = 0, staggerChildren: w, staggerDirection: x } = s
            return tA(t, e, y + p, w, x, n)
          }
        : () => Promise.resolve(),
    { when: f } = s
  if (f) {
    const [p, y] = f === 'beforeChildren' ? [c, h] : [h, c]
    return p().then(() => y())
  } else return Promise.all([c(), h(n.delay)])
}
function tA(t, e, n = 0, r = 0, i = 1, s) {
  const c = [],
    h = (t.variantChildren.size - 1) * r,
    f = i === 1 ? (p = 0) => p * r : (p = 0) => h - p * r
  return (
    Array.from(t.variantChildren)
      .sort(eA)
      .forEach((p, y) => {
        ;(p.notify('AnimationStart', e),
          c.push(J1(p, e, { ...s, delay: n + f(y) }).then(() => p.notify('AnimationComplete', e))))
      }),
    Promise.all(c)
  )
}
function eA(t, e) {
  return t.sortNodePosition(e)
}
function nA(t, e, n = {}) {
  t.notify('AnimationStart', e)
  let r
  if (Array.isArray(e)) {
    const i = e.map((s) => J1(t, s, n))
    r = Promise.all(i)
  } else if (typeof e == 'string') r = J1(t, e, n)
  else {
    const i = typeof e == 'function' ? yh(t, e, n.custom) : e
    r = Promise.all(I6(t, i, n))
  }
  return r.then(() => {
    t.notify('AnimationComplete', e)
  })
}
const rA = S0.length
function _6(t) {
  if (!t) return
  if (!t.isControllingVariants) {
    const n = t.parent ? _6(t.parent) || {} : {}
    return (t.props.initial !== void 0 && (n.initial = t.props.initial), n)
  }
  const e = {}
  for (let n = 0; n < rA; n++) {
    const r = S0[n],
      i = t.props[r]
    ;(vl(i) || i === !1) && (e[r] = i)
  }
  return e
}
const iA = [...C0].reverse(),
  oA = C0.length
function sA(t) {
  return (e) => Promise.all(e.map(({ animation: n, options: r }) => nA(t, n, r)))
}
function aA(t) {
  let e = sA(t),
    n = A2(),
    r = !0
  const i = (f) => (p, y) => {
    var w
    const x = yh(
      t,
      y,
      f === 'exit' ? ((w = t.presenceContext) === null || w === void 0 ? void 0 : w.custom) : void 0
    )
    if (x) {
      const { transition: E, transitionEnd: S, ...k } = x
      p = { ...p, ...k, ...S }
    }
    return p
  }
  function s(f) {
    e = f(t)
  }
  function c(f) {
    const { props: p } = t,
      y = _6(t.parent) || {},
      w = [],
      x = new Set()
    let E = {},
      S = 1 / 0
    for (let D = 0; D < oA; D++) {
      const _ = iA[D],
        N = n[_],
        M = p[_] !== void 0 ? p[_] : y[_],
        O = vl(M),
        F = _ === f ? N.isActive : null
      F === !1 && (S = D)
      let z = M === y[_] && M !== p[_] && O
      if (
        (z && r && t.manuallyAnimateOnMount && (z = !1),
        (N.protectedKeys = { ...E }),
        (!N.isActive && F === null) || (!M && !N.prevProp) || gh(M) || typeof M == 'boolean')
      )
        continue
      const V = lA(N.prevProp, M)
      let W = V || (_ === f && N.isActive && !z && O) || (D > S && O),
        Z = !1
      const J = Array.isArray(M) ? M : [M]
      let st = J.reduce(i(_), {})
      F === !1 && (st = {})
      const { prevResolvedValues: rt = {} } = N,
        vt = { ...rt, ...st },
        _t = (H) => {
          ;((W = !0), x.has(H) && ((Z = !0), x.delete(H)), (N.needsAnimating[H] = !0))
          const xt = t.getValue(H)
          xt && (xt.liveStyle = !1)
        }
      for (const H in vt) {
        const xt = st[H],
          gt = rt[H]
        if (E.hasOwnProperty(H)) continue
        let ot = !1
        ;(z1(xt) && z1(gt) ? (ot = !Ww(xt, gt)) : (ot = xt !== gt),
          ot
            ? xt != null
              ? _t(H)
              : x.add(H)
            : xt !== void 0 && x.has(H)
              ? _t(H)
              : (N.protectedKeys[H] = !0))
      }
      ;((N.prevProp = M),
        (N.prevResolvedValues = st),
        N.isActive && (E = { ...E, ...st }),
        r && t.blockInitialAnimation && (W = !1),
        W && (!(z && V) || Z) && w.push(...J.map((H) => ({ animation: H, options: { type: _ } }))))
    }
    if (x.size) {
      const D = {}
      ;(x.forEach((_) => {
        const N = t.getBaseTarget(_),
          M = t.getValue(_)
        ;(M && (M.liveStyle = !0), (D[_] = N ?? null))
      }),
        w.push({ animation: D }))
    }
    let k = !!w.length
    return (
      r && (p.initial === !1 || p.initial === p.animate) && !t.manuallyAnimateOnMount && (k = !1),
      (r = !1),
      k ? e(w) : Promise.resolve()
    )
  }
  function h(f, p) {
    var y
    if (n[f].isActive === p) return Promise.resolve()
    ;((y = t.variantChildren) === null ||
      y === void 0 ||
      y.forEach((x) => {
        var E
        return (E = x.animationState) === null || E === void 0 ? void 0 : E.setActive(f, p)
      }),
      (n[f].isActive = p))
    const w = c(f)
    for (const x in n) n[x].protectedKeys = {}
    return w
  }
  return {
    animateChanges: c,
    setActive: h,
    setAnimateFunction: s,
    getState: () => n,
    reset: () => {
      ;((n = A2()), (r = !0))
    },
  }
}
function lA(t, e) {
  return typeof e == 'string' ? e !== t : Array.isArray(e) ? !Ww(e, t) : !1
}
function qi(t = !1) {
  return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} }
}
function A2() {
  return {
    animate: qi(!0),
    whileInView: qi(),
    whileHover: qi(),
    whileTap: qi(),
    whileDrag: qi(),
    whileFocus: qi(),
    exit: qi(),
  }
}
class Wi {
  constructor(e) {
    ;((this.isMounted = !1), (this.node = e))
  }
  update() {}
}
class cA extends Wi {
  constructor(e) {
    ;(super(e), e.animationState || (e.animationState = aA(e)))
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps()
    gh(e) && (this.unmountControls = e.subscribe(this.node))
  }
  mount() {
    this.updateAnimationControlsSubscription()
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: n } = this.node.prevProps || {}
    e !== n && this.updateAnimationControlsSubscription()
  }
  unmount() {
    var e
    ;(this.node.animationState.reset(),
      (e = this.unmountControls) === null || e === void 0 || e.call(this))
  }
}
let uA = 0
class hA extends Wi {
  constructor() {
    ;(super(...arguments), (this.id = uA++))
  }
  update() {
    if (!this.node.presenceContext) return
    const { isPresent: e, onExitComplete: n } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {}
    if (!this.node.animationState || e === r) return
    const i = this.node.animationState.setActive('exit', !e)
    n && !e && i.then(() => n(this.id))
  }
  mount() {
    const { register: e } = this.node.presenceContext || {}
    e && (this.unmount = e(this.id))
  }
  unmount() {}
}
const dA = { animation: { Feature: cA }, exit: { Feature: hA } }
function Sl(t, e, n, r = { passive: !0 }) {
  return (t.addEventListener(e, n, r), () => t.removeEventListener(e, n))
}
function jl(t) {
  return { point: { x: t.pageX, y: t.pageY } }
}
const fA = (t) => (e) => j0(e) && t(e, jl(e))
function Ga(t, e, n, r) {
  return Sl(t, e, fA(n), r)
}
const k2 = (t, e) => Math.abs(t - e)
function pA(t, e) {
  const n = k2(t.x, e.x),
    r = k2(t.y, e.y)
  return Math.sqrt(n ** 2 + r ** 2)
}
class R6 {
  constructor(e, n, { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: s = !1 } = {}) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return
        const w = Id(this.lastMoveEventInfo, this.history),
          x = this.startEvent !== null,
          E = pA(w.offset, { x: 0, y: 0 }) >= 3
        if (!x && !E) return
        const { point: S } = w,
          { timestamp: k } = ze
        this.history.push({ ...S, timestamp: k })
        const { onStart: D, onMove: _ } = this.handlers
        ;(x || (D && D(this.lastMoveEvent, w), (this.startEvent = this.lastMoveEvent)),
          _ && _(this.lastMoveEvent, w))
      }),
      (this.handlePointerMove = (w, x) => {
        ;((this.lastMoveEvent = w),
          (this.lastMoveEventInfo = kd(x, this.transformPagePoint)),
          re.update(this.updatePoint, !0))
      }),
      (this.handlePointerUp = (w, x) => {
        this.end()
        const { onEnd: E, onSessionEnd: S, resumeAnimation: k } = this.handlers
        if ((this.dragSnapToOrigin && k && k(), !(this.lastMoveEvent && this.lastMoveEventInfo)))
          return
        const D = Id(
          w.type === 'pointercancel' ? this.lastMoveEventInfo : kd(x, this.transformPagePoint),
          this.history
        )
        ;(this.startEvent && E && E(w, D), S && S(w, D))
      }),
      !j0(e))
    )
      return
    ;((this.dragSnapToOrigin = s),
      (this.handlers = n),
      (this.transformPagePoint = r),
      (this.contextWindow = i || window))
    const c = jl(e),
      h = kd(c, this.transformPagePoint),
      { point: f } = h,
      { timestamp: p } = ze
    this.history = [{ ...f, timestamp: p }]
    const { onSessionStart: y } = n
    ;(y && y(e, Id(h, this.history)),
      (this.removeListeners = Fl(
        Ga(this.contextWindow, 'pointermove', this.handlePointerMove),
        Ga(this.contextWindow, 'pointerup', this.handlePointerUp),
        Ga(this.contextWindow, 'pointercancel', this.handlePointerUp)
      )))
  }
  updateHandlers(e) {
    this.handlers = e
  }
  end() {
    ;(this.removeListeners && this.removeListeners(), Pi(this.updatePoint))
  }
}
function kd(t, e) {
  return e ? { point: e(t.point) } : t
}
function I2(t, e) {
  return { x: t.x - e.x, y: t.y - e.y }
}
function Id({ point: t }, e) {
  return { point: t, delta: I2(t, T6(e)), offset: I2(t, gA(e)), velocity: mA(e, 0.1) }
}
function gA(t) {
  return t[0]
}
function T6(t) {
  return t[t.length - 1]
}
function mA(t, e) {
  if (t.length < 2) return { x: 0, y: 0 }
  let n = t.length - 1,
    r = null
  const i = T6(t)
  for (; n >= 0 && ((r = t[n]), !(i.timestamp - r.timestamp > zr(e))); ) n--
  if (!r) return { x: 0, y: 0 }
  const s = Hr(i.timestamp - r.timestamp)
  if (s === 0) return { x: 0, y: 0 }
  const c = { x: (i.x - r.x) / s, y: (i.y - r.y) / s }
  return (c.x === 1 / 0 && (c.x = 0), c.y === 1 / 0 && (c.y = 0), c)
}
const N6 = 1e-4,
  yA = 1 - N6,
  wA = 1 + N6,
  M6 = 0.01,
  bA = 0 - M6,
  vA = 0 + M6
function Bn(t) {
  return t.max - t.min
}
function xA(t, e, n) {
  return Math.abs(t - e) <= n
}
function _2(t, e, n, r = 0.5) {
  ;((t.origin = r),
    (t.originPoint = le(e.min, e.max, t.origin)),
    (t.scale = Bn(n) / Bn(e)),
    (t.translate = le(n.min, n.max, t.origin) - t.originPoint),
    ((t.scale >= yA && t.scale <= wA) || isNaN(t.scale)) && (t.scale = 1),
    ((t.translate >= bA && t.translate <= vA) || isNaN(t.translate)) && (t.translate = 0))
}
function Ya(t, e, n, r) {
  ;(_2(t.x, e.x, n.x, r ? r.originX : void 0), _2(t.y, e.y, n.y, r ? r.originY : void 0))
}
function R2(t, e, n) {
  ;((t.min = n.min + e.min), (t.max = t.min + Bn(e)))
}
function EA(t, e, n) {
  ;(R2(t.x, e.x, n.x), R2(t.y, e.y, n.y))
}
function T2(t, e, n) {
  ;((t.min = e.min - n.min), (t.max = t.min + Bn(e)))
}
function Za(t, e, n) {
  ;(T2(t.x, e.x, n.x), T2(t.y, e.y, n.y))
}
function CA(t, { min: e, max: n }, r) {
  return (
    e !== void 0 && t < e
      ? (t = r ? le(e, t, r.min) : Math.max(t, e))
      : n !== void 0 && t > n && (t = r ? le(n, t, r.max) : Math.min(t, n)),
    t
  )
}
function N2(t, e, n) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0,
  }
}
function SA(t, { top: e, left: n, bottom: r, right: i }) {
  return { x: N2(t.x, n, i), y: N2(t.y, e, r) }
}
function M2(t, e) {
  let n = e.min - t.min,
    r = e.max - t.max
  return (e.max - e.min < t.max - t.min && ([n, r] = [r, n]), { min: n, max: r })
}
function AA(t, e) {
  return { x: M2(t.x, e.x), y: M2(t.y, e.y) }
}
function kA(t, e) {
  let n = 0.5
  const r = Bn(t),
    i = Bn(e)
  return (
    i > r ? (n = Fs(e.min, e.max - r, t.min)) : r > i && (n = Fs(t.min, t.max - i, e.min)),
    qr(0, 1, n)
  )
}
function IA(t, e) {
  const n = {}
  return (
    e.min !== void 0 && (n.min = e.min - t.min),
    e.max !== void 0 && (n.max = e.max - t.min),
    n
  )
}
const tf = 0.35
function _A(t = tf) {
  return (
    t === !1 ? (t = 0) : t === !0 && (t = tf),
    { x: D2(t, 'left', 'right'), y: D2(t, 'top', 'bottom') }
  )
}
function D2(t, e, n) {
  return { min: P2(t, e), max: P2(t, n) }
}
function P2(t, e) {
  return typeof t == 'number' ? t : t[e] || 0
}
const L2 = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  ws = () => ({ x: L2(), y: L2() }),
  O2 = () => ({ min: 0, max: 0 }),
  xe = () => ({ x: O2(), y: O2() })
function Gn(t) {
  return [t('x'), t('y')]
}
function D6({ top: t, left: e, right: n, bottom: r }) {
  return { x: { min: e, max: n }, y: { min: t, max: r } }
}
function RA({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min }
}
function TA(t, e) {
  if (!e) return t
  const n = e({ x: t.left, y: t.top }),
    r = e({ x: t.right, y: t.bottom })
  return { top: n.y, left: n.x, bottom: r.y, right: r.x }
}
function _d(t) {
  return t === void 0 || t === 1
}
function ef({ scale: t, scaleX: e, scaleY: n }) {
  return !_d(t) || !_d(e) || !_d(n)
}
function eo(t) {
  return ef(t) || P6(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY
}
function P6(t) {
  return B2(t.x) || B2(t.y)
}
function B2(t) {
  return t && t !== '0%'
}
function Ou(t, e, n) {
  const r = t - n,
    i = e * r
  return n + i
}
function F2(t, e, n, r, i) {
  return (i !== void 0 && (t = Ou(t, i, r)), Ou(t, n, r) + e)
}
function nf(t, e = 0, n = 1, r, i) {
  ;((t.min = F2(t.min, e, n, r, i)), (t.max = F2(t.max, e, n, r, i)))
}
function L6(t, { x: e, y: n }) {
  ;(nf(t.x, e.translate, e.scale, e.originPoint), nf(t.y, n.translate, n.scale, n.originPoint))
}
const j2 = 0.999999999999,
  V2 = 1.0000000000001
function NA(t, e, n, r = !1) {
  const i = n.length
  if (!i) return
  e.x = e.y = 1
  let s, c
  for (let h = 0; h < i; h++) {
    ;((s = n[h]), (c = s.projectionDelta))
    const { visualElement: f } = s.options
    ;(f && f.props.style && f.props.style.display === 'contents') ||
      (r &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        vs(t, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      c && ((e.x *= c.x.scale), (e.y *= c.y.scale), L6(t, c)),
      r && eo(s.latestValues) && vs(t, s.latestValues))
  }
  ;(e.x < V2 && e.x > j2 && (e.x = 1), e.y < V2 && e.y > j2 && (e.y = 1))
}
function bs(t, e) {
  ;((t.min = t.min + e), (t.max = t.max + e))
}
function W2(t, e, n, r, i = 0.5) {
  const s = le(t.min, t.max, i)
  nf(t, e, n, s, r)
}
function vs(t, e) {
  ;(W2(t.x, e.x, e.scaleX, e.scale, e.originX), W2(t.y, e.y, e.scaleY, e.scale, e.originY))
}
function O6(t, e) {
  return D6(TA(t.getBoundingClientRect(), e))
}
function MA(t, e, n) {
  const r = O6(t, n),
    { scroll: i } = e
  return (i && (bs(r.x, i.offset.x), bs(r.y, i.offset.y)), r)
}
const B6 = ({ current: t }) => (t ? t.ownerDocument.defaultView : null),
  DA = new WeakMap()
class PA {
  constructor(e) {
    ;((this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = xe()),
      (this.visualElement = e))
  }
  start(e, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: r } = this.visualElement
    if (r && r.isPresent === !1) return
    const i = (y) => {
        const { dragSnapToOrigin: w } = this.getProps()
        ;(w ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(jl(y).point))
      },
      s = (y, w) => {
        const { drag: x, dragPropagation: E, onDragStart: S } = this.getProps()
        if (
          x &&
          !E &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = k5(x)),
          !this.openDragLock)
        )
          return
        ;((this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          Gn((D) => {
            let _ = this.getAxisMotionValue(D).get() || 0
            if (Ir.test(_)) {
              const { projection: N } = this.visualElement
              if (N && N.layout) {
                const M = N.layout.layoutBox[D]
                M && (_ = Bn(M) * (parseFloat(_) / 100))
              }
            }
            this.originPoint[D] = _
          }),
          S && re.postRender(() => S(y, w)),
          G1(this.visualElement, 'transform'))
        const { animationState: k } = this.visualElement
        k && k.setActive('whileDrag', !0)
      },
      c = (y, w) => {
        const {
          dragPropagation: x,
          dragDirectionLock: E,
          onDirectionLock: S,
          onDrag: k,
        } = this.getProps()
        if (!x && !this.openDragLock) return
        const { offset: D } = w
        if (E && this.currentDirection === null) {
          ;((this.currentDirection = LA(D)),
            this.currentDirection !== null && S && S(this.currentDirection))
          return
        }
        ;(this.updateAxis('x', w.point, D),
          this.updateAxis('y', w.point, D),
          this.visualElement.render(),
          k && k(y, w))
      },
      h = (y, w) => this.stop(y, w),
      f = () =>
        Gn((y) => {
          var w
          return (
            this.getAnimationState(y) === 'paused' &&
            ((w = this.getAxisMotionValue(y).animation) === null || w === void 0
              ? void 0
              : w.play())
          )
        }),
      { dragSnapToOrigin: p } = this.getProps()
    this.panSession = new R6(
      e,
      { onSessionStart: i, onStart: s, onMove: c, onSessionEnd: h, resumeAnimation: f },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: p,
        contextWindow: B6(this.visualElement),
      }
    )
  }
  stop(e, n) {
    const r = this.isDragging
    if ((this.cancel(), !r)) return
    const { velocity: i } = n
    this.startAnimation(i)
    const { onDragEnd: s } = this.getProps()
    s && re.postRender(() => s(e, n))
  }
  cancel() {
    this.isDragging = !1
    const { projection: e, animationState: n } = this.visualElement
    ;(e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0))
    const { dragPropagation: r } = this.getProps()
    ;(!r && this.openDragLock && (this.openDragLock(), (this.openDragLock = null)),
      n && n.setActive('whileDrag', !1))
  }
  updateAxis(e, n, r) {
    const { drag: i } = this.getProps()
    if (!r || !xc(e, i, this.currentDirection)) return
    const s = this.getAxisMotionValue(e)
    let c = this.originPoint[e] + r[e]
    ;(this.constraints && this.constraints[e] && (c = CA(c, this.constraints[e], this.elastic[e])),
      s.set(c))
  }
  resolveConstraints() {
    var e
    const { dragConstraints: n, dragElastic: r } = this.getProps(),
      i =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (e = this.visualElement.projection) === null || e === void 0
            ? void 0
            : e.layout,
      s = this.constraints
    ;(n && ms(n)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : n && i
        ? (this.constraints = SA(i.layoutBox, n))
        : (this.constraints = !1),
      (this.elastic = _A(r)),
      s !== this.constraints &&
        i &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        Gn((c) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(c) &&
            (this.constraints[c] = IA(i.layoutBox[c], this.constraints[c]))
        }))
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps()
    if (!e || !ms(e)) return !1
    const r = e.current,
      { projection: i } = this.visualElement
    if (!i || !i.layout) return !1
    const s = MA(r, i.root, this.visualElement.getTransformPagePoint())
    let c = AA(i.layout.layoutBox, s)
    if (n) {
      const h = n(RA(c))
      ;((this.hasMutatedConstraints = !!h), h && (c = D6(h)))
    }
    return c
  }
  startAnimation(e) {
    const {
        drag: n,
        dragMomentum: r,
        dragElastic: i,
        dragTransition: s,
        dragSnapToOrigin: c,
        onDragTransitionEnd: h,
      } = this.getProps(),
      f = this.constraints || {},
      p = Gn((y) => {
        if (!xc(y, n, this.currentDirection)) return
        let w = (f && f[y]) || {}
        c && (w = { min: 0, max: 0 })
        const x = i ? 200 : 1e6,
          E = i ? 40 : 1e7,
          S = {
            type: 'inertia',
            velocity: r ? e[y] : 0,
            bounceStiffness: x,
            bounceDamping: E,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...w,
          }
        return this.startAxisValueAnimation(y, S)
      })
    return Promise.all(p).then(h)
  }
  startAxisValueAnimation(e, n) {
    const r = this.getAxisMotionValue(e)
    return (G1(this.visualElement, e), r.start(Q0(e, r, 0, n, this.visualElement, !1)))
  }
  stopAnimation() {
    Gn((e) => this.getAxisMotionValue(e).stop())
  }
  pauseAnimation() {
    Gn((e) => {
      var n
      return (n = this.getAxisMotionValue(e).animation) === null || n === void 0
        ? void 0
        : n.pause()
    })
  }
  getAnimationState(e) {
    var n
    return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.state
  }
  getAxisMotionValue(e) {
    const n = `_drag${e.toUpperCase()}`,
      r = this.visualElement.getProps()
    return r[n] || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0)
  }
  snapToCursor(e) {
    Gn((n) => {
      const { drag: r } = this.getProps()
      if (!xc(n, r, this.currentDirection)) return
      const { projection: i } = this.visualElement,
        s = this.getAxisMotionValue(n)
      if (i && i.layout) {
        const { min: c, max: h } = i.layout.layoutBox[n]
        s.set(e[n] - le(c, h, 0.5))
      }
    })
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return
    const { drag: e, dragConstraints: n } = this.getProps(),
      { projection: r } = this.visualElement
    if (!ms(n) || !r || !this.constraints) return
    this.stopAnimation()
    const i = { x: 0, y: 0 }
    Gn((c) => {
      const h = this.getAxisMotionValue(c)
      if (h && this.constraints !== !1) {
        const f = h.get()
        i[c] = kA({ min: f, max: f }, this.constraints[c])
      }
    })
    const { transformTemplate: s } = this.visualElement.getProps()
    ;((this.visualElement.current.style.transform = s ? s({}, '') : 'none'),
      r.root && r.root.updateScroll(),
      r.updateLayout(),
      this.resolveConstraints(),
      Gn((c) => {
        if (!xc(c, e, null)) return
        const h = this.getAxisMotionValue(c),
          { min: f, max: p } = this.constraints[c]
        h.set(le(f, p, i[c]))
      }))
  }
  addListeners() {
    if (!this.visualElement.current) return
    DA.set(this.visualElement, this)
    const e = this.visualElement.current,
      n = Ga(e, 'pointerdown', (f) => {
        const { drag: p, dragListener: y = !0 } = this.getProps()
        p && y && this.start(f)
      }),
      r = () => {
        const { dragConstraints: f } = this.getProps()
        ms(f) && f.current && (this.constraints = this.resolveRefConstraints())
      },
      { projection: i } = this.visualElement,
      s = i.addEventListener('measure', r)
    ;(i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), re.read(r))
    const c = Sl(window, 'resize', () => this.scalePositionWithinConstraints()),
      h = i.addEventListener('didUpdate', ({ delta: f, hasLayoutChanged: p }) => {
        this.isDragging &&
          p &&
          (Gn((y) => {
            const w = this.getAxisMotionValue(y)
            w && ((this.originPoint[y] += f[y].translate), w.set(w.get() + f[y].translate))
          }),
          this.visualElement.render())
      })
    return () => {
      ;(c(), n(), s(), h && h())
    }
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: n = !1,
        dragDirectionLock: r = !1,
        dragPropagation: i = !1,
        dragConstraints: s = !1,
        dragElastic: c = tf,
        dragMomentum: h = !0,
      } = e
    return {
      ...e,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: s,
      dragElastic: c,
      dragMomentum: h,
    }
  }
}
function xc(t, e, n) {
  return (e === !0 || e === t) && (n === null || n === t)
}
function LA(t, e = 10) {
  let n = null
  return (Math.abs(t.y) > e ? (n = 'y') : Math.abs(t.x) > e && (n = 'x'), n)
}
class OA extends Wi {
  constructor(e) {
    ;(super(e),
      (this.removeGroupControls = Pn),
      (this.removeListeners = Pn),
      (this.controls = new PA(e)))
  }
  mount() {
    const { dragControls: e } = this.node.getProps()
    ;(e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Pn))
  }
  unmount() {
    ;(this.removeGroupControls(), this.removeListeners())
  }
}
const U2 = (t) => (e, n) => {
  t && re.postRender(() => t(e, n))
}
class BA extends Wi {
  constructor() {
    ;(super(...arguments), (this.removePointerDownListener = Pn))
  }
  onPointerDown(e) {
    this.session = new R6(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: B6(this.node),
    })
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps()
    return {
      onSessionStart: U2(e),
      onStart: U2(n),
      onMove: r,
      onEnd: (s, c) => {
        ;(delete this.session, i && re.postRender(() => i(s, c)))
      },
    }
  }
  mount() {
    this.removePointerDownListener = Ga(this.node.current, 'pointerdown', (e) =>
      this.onPointerDown(e)
    )
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
    ;(this.removePointerDownListener(), this.session && this.session.end())
  }
}
const Kc = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }
function z2(t, e) {
  return e.max === e.min ? 0 : (t / (e.max - e.min)) * 100
}
const va = {
    correct: (t, e) => {
      if (!e.target) return t
      if (typeof t == 'string')
        if (bt.test(t)) t = parseFloat(t)
        else return t
      const n = z2(t, e.target.x),
        r = z2(t, e.target.y)
      return `${n}% ${r}%`
    },
  },
  FA = {
    correct: (t, { treeScale: e, projectionDelta: n }) => {
      const r = t,
        i = Li.parse(t)
      if (i.length > 5) return r
      const s = Li.createTransformer(t),
        c = typeof i[0] != 'number' ? 1 : 0,
        h = n.x.scale * e.x,
        f = n.y.scale * e.y
      ;((i[0 + c] /= h), (i[1 + c] /= f))
      const p = le(h, f, 0.5)
      return (
        typeof i[2 + c] == 'number' && (i[2 + c] /= p),
        typeof i[3 + c] == 'number' && (i[3 + c] /= p),
        s(i)
      )
    },
  }
class jA extends X.Component {
  componentDidMount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props,
      { projection: s } = e
    ;(o5(VA),
      s &&
        (n.group && n.group.add(s),
        r && r.register && i && r.register(s),
        s.root.didUpdate(),
        s.addEventListener('animationComplete', () => {
          this.safeToRemove()
        }),
        s.setOptions({ ...s.options, onExitComplete: () => this.safeToRemove() })),
      (Kc.hasEverUpdated = !0))
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: n, visualElement: r, drag: i, isPresent: s } = this.props,
      c = r.projection
    return (
      c &&
        ((c.isPresent = s),
        i || e.layoutDependency !== n || n === void 0 ? c.willUpdate() : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? c.promote()
            : c.relegate() ||
              re.postRender(() => {
                const h = c.getStack()
                ;(!h || !h.members.length) && this.safeToRemove()
              }))),
      null
    )
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement
    e &&
      (e.root.didUpdate(),
      k0.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove()
      }))
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: r } = this.props,
      { projection: i } = e
    i &&
      (i.scheduleCheckAfterUnmount(),
      n && n.group && n.group.remove(i),
      r && r.deregister && r.deregister(i))
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props
    e && e()
  }
  render() {
    return null
  }
}
function F6(t) {
  const [e, n] = vC(),
    r = X.useContext(vw)
  return R.jsx(jA, {
    ...t,
    layoutGroup: r,
    switchLayoutGroup: X.useContext(_w),
    isPresent: e,
    safeToRemove: n,
  })
}
const VA = {
  borderRadius: {
    ...va,
    applyTo: [
      'borderTopLeftRadius',
      'borderTopRightRadius',
      'borderBottomLeftRadius',
      'borderBottomRightRadius',
    ],
  },
  borderTopLeftRadius: va,
  borderTopRightRadius: va,
  borderBottomLeftRadius: va,
  borderBottomRightRadius: va,
  boxShadow: FA,
}
function WA(t, e, n) {
  const r = Je(t) ? t : El(t)
  return (r.start(Q0('', r, e, n)), r.animation)
}
function UA(t) {
  return t instanceof SVGElement && t.tagName !== 'svg'
}
const zA = (t, e) => t.depth - e.depth
class HA {
  constructor() {
    ;((this.children = []), (this.isDirty = !1))
  }
  add(e) {
    ;(V0(this.children, e), (this.isDirty = !0))
  }
  remove(e) {
    ;(W0(this.children, e), (this.isDirty = !0))
  }
  forEach(e) {
    ;(this.isDirty && this.children.sort(zA), (this.isDirty = !1), this.children.forEach(e))
  }
}
function XA(t, e) {
  const n = _r.now(),
    r = ({ timestamp: i }) => {
      const s = i - n
      s >= e && (Pi(r), t(s - e))
    }
  return (re.read(r, !0), () => Pi(r))
}
const j6 = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'],
  GA = j6.length,
  H2 = (t) => (typeof t == 'string' ? parseFloat(t) : t),
  X2 = (t) => typeof t == 'number' || bt.test(t)
function YA(t, e, n, r, i, s) {
  i
    ? ((t.opacity = le(0, n.opacity !== void 0 ? n.opacity : 1, ZA(r))),
      (t.opacityExit = le(e.opacity !== void 0 ? e.opacity : 1, 0, qA(r))))
    : s &&
      (t.opacity = le(
        e.opacity !== void 0 ? e.opacity : 1,
        n.opacity !== void 0 ? n.opacity : 1,
        r
      ))
  for (let c = 0; c < GA; c++) {
    const h = `border${j6[c]}Radius`
    let f = G2(e, h),
      p = G2(n, h)
    ;(f === void 0 && p === void 0) ||
      (f || (f = 0),
      p || (p = 0),
      f === 0 || p === 0 || X2(f) === X2(p)
        ? ((t[h] = Math.max(le(H2(f), H2(p), r), 0)), (Ir.test(p) || Ir.test(f)) && (t[h] += '%'))
        : (t[h] = p))
  }
  ;(e.rotate || n.rotate) && (t.rotate = le(e.rotate || 0, n.rotate || 0, r))
}
function G2(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius
}
const ZA = V6(0, 0.5, i6),
  qA = V6(0.5, 0.95, Pn)
function V6(t, e, n) {
  return (r) => (r < t ? 0 : r > e ? 1 : n(Fs(t, e, r)))
}
function Y2(t, e) {
  ;((t.min = e.min), (t.max = e.max))
}
function Hn(t, e) {
  ;(Y2(t.x, e.x), Y2(t.y, e.y))
}
function Z2(t, e) {
  ;((t.translate = e.translate),
    (t.scale = e.scale),
    (t.originPoint = e.originPoint),
    (t.origin = e.origin))
}
function q2(t, e, n, r, i) {
  return ((t -= e), (t = Ou(t, 1 / n, r)), i !== void 0 && (t = Ou(t, 1 / i, r)), t)
}
function KA(t, e = 0, n = 1, r = 0.5, i, s = t, c = t) {
  if (
    (Ir.test(e) && ((e = parseFloat(e)), (e = le(c.min, c.max, e / 100) - c.min)),
    typeof e != 'number')
  )
    return
  let h = le(s.min, s.max, r)
  ;(t === s && (h -= e), (t.min = q2(t.min, e, n, h, i)), (t.max = q2(t.max, e, n, h, i)))
}
function K2(t, e, [n, r, i], s, c) {
  KA(t, e[n], e[r], e[i], e.scale, s, c)
}
const QA = ['x', 'scaleX', 'originX'],
  $A = ['y', 'scaleY', 'originY']
function Q2(t, e, n, r) {
  ;(K2(t.x, e, QA, n ? n.x : void 0, r ? r.x : void 0),
    K2(t.y, e, $A, n ? n.y : void 0, r ? r.y : void 0))
}
function $2(t) {
  return t.translate === 0 && t.scale === 1
}
function W6(t) {
  return $2(t.x) && $2(t.y)
}
function J2(t, e) {
  return t.min === e.min && t.max === e.max
}
function JA(t, e) {
  return J2(t.x, e.x) && J2(t.y, e.y)
}
function tm(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max)
}
function U6(t, e) {
  return tm(t.x, e.x) && tm(t.y, e.y)
}
function em(t) {
  return Bn(t.x) / Bn(t.y)
}
function nm(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint
}
class t7 {
  constructor() {
    this.members = []
  }
  add(e) {
    ;(V0(this.members, e), e.scheduleRender())
  }
  remove(e) {
    if ((W0(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead)) {
      const n = this.members[this.members.length - 1]
      n && this.promote(n)
    }
  }
  relegate(e) {
    const n = this.members.findIndex((i) => e === i)
    if (n === 0) return !1
    let r
    for (let i = n; i >= 0; i--) {
      const s = this.members[i]
      if (s.isPresent !== !1) {
        r = s
        break
      }
    }
    return r ? (this.promote(r), !0) : !1
  }
  promote(e, n) {
    const r = this.lead
    if (e !== r && ((this.prevLead = r), (this.lead = e), e.show(), r)) {
      ;(r.instance && r.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = r),
        n && (e.resumeFrom.preserveOpacity = !0),
        r.snapshot &&
          ((e.snapshot = r.snapshot),
          (e.snapshot.latestValues = r.animationValues || r.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0))
      const { crossfade: i } = e.options
      i === !1 && r.hide()
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: n, resumingFrom: r } = e
      ;(n.onExitComplete && n.onExitComplete(),
        r && r.options.onExitComplete && r.options.onExitComplete())
    })
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1)
    })
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}
function e7(t, e, n) {
  let r = ''
  const i = t.x.translate / e.x,
    s = t.y.translate / e.y,
    c = (n == null ? void 0 : n.z) || 0
  if (
    ((i || s || c) && (r = `translate3d(${i}px, ${s}px, ${c}px) `),
    (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `),
    n)
  ) {
    const { transformPerspective: p, rotate: y, rotateX: w, rotateY: x, skewX: E, skewY: S } = n
    ;(p && (r = `perspective(${p}px) ${r}`),
      y && (r += `rotate(${y}deg) `),
      w && (r += `rotateX(${w}deg) `),
      x && (r += `rotateY(${x}deg) `),
      E && (r += `skewX(${E}deg) `),
      S && (r += `skewY(${S}deg) `))
  }
  const h = t.x.scale * e.x,
    f = t.y.scale * e.y
  return ((h !== 1 || f !== 1) && (r += `scale(${h}, ${f})`), r || 'none')
}
const no = {
    type: 'projectionFrame',
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0,
  },
  Ma = typeof window < 'u' && window.MotionDebug !== void 0,
  Rd = ['', 'X', 'Y', 'Z'],
  n7 = { visibility: 'hidden' },
  rm = 1e3
let r7 = 0
function Td(t, e, n, r) {
  const { latestValues: i } = e
  i[t] && ((n[t] = i[t]), e.setStaticValue(t, 0), r && (r[t] = 0))
}
function z6(t) {
  if (((t.hasCheckedOptimisedAppear = !0), t.root === t)) return
  const { visualElement: e } = t.options
  if (!e) return
  const n = Qw(e)
  if (window.MotionHasOptimisedAnimation(n, 'transform')) {
    const { layout: i, layoutId: s } = t.options
    window.MotionCancelOptimisedAnimation(n, 'transform', re, !(i || s))
  }
  const { parent: r } = t
  r && !r.hasCheckedOptimisedAppear && z6(r)
}
function H6({
  attachResizeListener: t,
  defaultParent: e,
  measureScroll: n,
  checkIsScrollRoot: r,
  resetTransform: i,
}) {
  return class {
    constructor(s = {}, c = e == null ? void 0 : e()) {
      ;((this.id = r7++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots())
        }),
        (this.updateProjection = () => {
          ;((this.projectionUpdateScheduled = !1),
            Ma && (no.totalNodes = no.resolvedTargetDeltas = no.recalculatedProjection = 0),
            this.nodes.forEach(s7),
            this.nodes.forEach(h7),
            this.nodes.forEach(d7),
            this.nodes.forEach(a7),
            Ma && window.MotionDebug.record(no))
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = s),
        (this.root = c ? c.root || c : this),
        (this.path = c ? [...c.path, c] : []),
        (this.parent = c),
        (this.depth = c ? c.depth + 1 : 0))
      for (let h = 0; h < this.path.length; h++) this.path[h].shouldResetTransform = !0
      this.root === this && (this.nodes = new HA())
    }
    addEventListener(s, c) {
      return (
        this.eventHandlers.has(s) || this.eventHandlers.set(s, new U0()),
        this.eventHandlers.get(s).add(c)
      )
    }
    notifyListeners(s, ...c) {
      const h = this.eventHandlers.get(s)
      h && h.notify(...c)
    }
    hasListeners(s) {
      return this.eventHandlers.has(s)
    }
    mount(s, c = this.root.hasTreeAnimated) {
      if (this.instance) return
      ;((this.isSVG = UA(s)), (this.instance = s))
      const { layoutId: h, layout: f, visualElement: p } = this.options
      if (
        (p && !p.current && p.mount(s),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        c && (f || h) && (this.isLayoutDirty = !0),
        t)
      ) {
        let y
        const w = () => (this.root.updateBlockedByResize = !1)
        t(s, () => {
          ;((this.root.updateBlockedByResize = !0),
            y && y(),
            (y = XA(w, 250)),
            Kc.hasAnimatedSinceResize && ((Kc.hasAnimatedSinceResize = !1), this.nodes.forEach(om)))
        })
      }
      ;(h && this.root.registerSharedNode(h, this),
        this.options.animate !== !1 &&
          p &&
          (h || f) &&
          this.addEventListener(
            'didUpdate',
            ({ delta: y, hasLayoutChanged: w, hasRelativeTargetChanged: x, layout: E }) => {
              if (this.isTreeAnimationBlocked()) {
                ;((this.target = void 0), (this.relativeTarget = void 0))
                return
              }
              const S = this.options.transition || p.getDefaultTransition() || y7,
                { onLayoutAnimationStart: k, onLayoutAnimationComplete: D } = p.getProps(),
                _ = !this.targetLayout || !U6(this.targetLayout, E) || x,
                N = !w && x
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                N ||
                (w && (_ || !this.currentAnimation))
              ) {
                ;(this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(y, N))
                const M = { ...O0(S, 'layout'), onPlay: k, onComplete: D }
                ;((p.shouldReduceMotion || this.options.layoutRoot) &&
                  ((M.delay = 0), (M.type = !1)),
                  this.startAnimation(M))
              } else
                (w || om(this),
                  this.isLead() && this.options.onExitComplete && this.options.onExitComplete())
              this.targetLayout = E
            }
          ))
    }
    unmount() {
      ;(this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this))
      const s = this.getStack()
      ;(s && s.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Pi(this.updateProjection))
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || (this.parent && this.parent.isTreeAnimationBlocked()) || !1
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0), this.nodes && this.nodes.forEach(f7), this.animationId++)
    }
    getTransformTemplate() {
      const { visualElement: s } = this.options
      return s && s.getProps().transformTemplate
    }
    willUpdate(s = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete()
        return
      }
      if (
        (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && z6(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return
      this.isLayoutDirty = !0
      for (let p = 0; p < this.path.length; p++) {
        const y = this.path[p]
        ;((y.shouldResetTransform = !0),
          y.updateScroll('snapshot'),
          y.options.layoutRoot && y.willUpdate(!1))
      }
      const { layoutId: c, layout: h } = this.options
      if (c === void 0 && !h) return
      const f = this.getTransformTemplate()
      ;((this.prevTransformTemplateValue = f ? f(this.latestValues, '') : void 0),
        this.updateSnapshot(),
        s && this.notifyListeners('willUpdate'))
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        ;(this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(im))
        return
      }
      ;(this.isUpdating || this.nodes.forEach(c7),
        (this.isUpdating = !1),
        this.nodes.forEach(u7),
        this.nodes.forEach(i7),
        this.nodes.forEach(o7),
        this.clearAllSnapshots())
      const s = _r.now()
      ;((ze.delta = qr(0, 1e3 / 60, s - ze.timestamp)),
        (ze.timestamp = s),
        (ze.isProcessing = !0),
        vd.update.process(ze),
        vd.preRender.process(ze),
        vd.render.process(ze),
        (ze.isProcessing = !1))
    }
    didUpdate() {
      this.updateScheduled || ((this.updateScheduled = !0), k0.read(this.scheduleUpdate))
    }
    clearAllSnapshots() {
      ;(this.nodes.forEach(l7), this.sharedNodes.forEach(p7))
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0), re.preRender(this.updateProjection, !1, !0))
    }
    scheduleCheckAfterUnmount() {
      re.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
      })
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure())
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)
      )
        return
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let h = 0; h < this.path.length; h++) this.path[h].updateScroll()
      const s = this.layout
      ;((this.layout = this.measure(!1)),
        (this.layoutCorrected = xe()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners('measure', this.layout.layoutBox))
      const { visualElement: c } = this.options
      c && c.notify('LayoutMeasure', this.layout.layoutBox, s ? s.layoutBox : void 0)
    }
    updateScroll(s = 'measure') {
      let c = !!(this.options.layoutScroll && this.instance)
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === s &&
          (c = !1),
        c)
      ) {
        const h = r(this.instance)
        this.scroll = {
          animationId: this.root.animationId,
          phase: s,
          isRoot: h,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : h,
        }
      }
    }
    resetTransform() {
      if (!i) return
      const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
        c = this.projectionDelta && !W6(this.projectionDelta),
        h = this.getTransformTemplate(),
        f = h ? h(this.latestValues, '') : void 0,
        p = f !== this.prevTransformTemplateValue
      s &&
        (c || eo(this.latestValues) || p) &&
        (i(this.instance, f), (this.shouldResetTransform = !1), this.scheduleRender())
    }
    measure(s = !0) {
      const c = this.measurePageBox()
      let h = this.removeElementScroll(c)
      return (
        s && (h = this.removeTransform(h)),
        w7(h),
        {
          animationId: this.root.animationId,
          measuredBox: c,
          layoutBox: h,
          latestValues: {},
          source: this.id,
        }
      )
    }
    measurePageBox() {
      var s
      const { visualElement: c } = this.options
      if (!c) return xe()
      const h = c.measureViewportBox()
      if (!((!((s = this.scroll) === null || s === void 0) && s.wasRoot) || this.path.some(b7))) {
        const { scroll: f } = this.root
        f && (bs(h.x, f.offset.x), bs(h.y, f.offset.y))
      }
      return h
    }
    removeElementScroll(s) {
      var c
      const h = xe()
      if ((Hn(h, s), !((c = this.scroll) === null || c === void 0) && c.wasRoot)) return h
      for (let f = 0; f < this.path.length; f++) {
        const p = this.path[f],
          { scroll: y, options: w } = p
        p !== this.root &&
          y &&
          w.layoutScroll &&
          (y.wasRoot && Hn(h, s), bs(h.x, y.offset.x), bs(h.y, y.offset.y))
      }
      return h
    }
    applyTransform(s, c = !1) {
      const h = xe()
      Hn(h, s)
      for (let f = 0; f < this.path.length; f++) {
        const p = this.path[f]
        ;(!c &&
          p.options.layoutScroll &&
          p.scroll &&
          p !== p.root &&
          vs(h, { x: -p.scroll.offset.x, y: -p.scroll.offset.y }),
          eo(p.latestValues) && vs(h, p.latestValues))
      }
      return (eo(this.latestValues) && vs(h, this.latestValues), h)
    }
    removeTransform(s) {
      const c = xe()
      Hn(c, s)
      for (let h = 0; h < this.path.length; h++) {
        const f = this.path[h]
        if (!f.instance || !eo(f.latestValues)) continue
        ef(f.latestValues) && f.updateSnapshot()
        const p = xe(),
          y = f.measurePageBox()
        ;(Hn(p, y), Q2(c, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, p))
      }
      return (eo(this.latestValues) && Q2(c, this.latestValues), c)
    }
    setTargetDelta(s) {
      ;((this.targetDelta = s), this.root.scheduleUpdateProjection(), (this.isProjectionDirty = !0))
    }
    setOptions(s) {
      this.options = { ...this.options, ...s, crossfade: s.crossfade !== void 0 ? s.crossfade : !0 }
    }
    clearMeasurements() {
      ;((this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1))
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== ze.timestamp &&
        this.relativeParent.resolveTargetDelta(!0)
    }
    resolveTargetDelta(s = !1) {
      var c
      const h = this.getLead()
      ;(this.isProjectionDirty || (this.isProjectionDirty = h.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = h.isTransformDirty),
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = h.isSharedProjectionDirty))
      const f = !!this.resumingFrom || this !== h
      if (
        !(
          s ||
          (f && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((c = this.parent) === null || c === void 0) && c.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return
      const { layout: p, layoutId: y } = this.options
      if (!(!this.layout || !(p || y))) {
        if (
          ((this.resolvedRelativeTargetAt = ze.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const w = this.getClosestProjectingParent()
          w && w.layout && this.animationProgress !== 1
            ? ((this.relativeParent = w),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = xe()),
              (this.relativeTargetOrigin = xe()),
              Za(this.relativeTargetOrigin, this.layout.layoutBox, w.layout.layoutBox),
              Hn(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target || ((this.target = xe()), (this.targetWithTransforms = xe())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                EA(this.target, this.relativeTarget, this.relativeParent.target))
              : this.targetDelta
                ? (this.resumingFrom
                    ? (this.target = this.applyTransform(this.layout.layoutBox))
                    : Hn(this.target, this.layout.layoutBox),
                  L6(this.target, this.targetDelta))
                : Hn(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1
            const w = this.getClosestProjectingParent()
            w &&
            !!w.resumingFrom == !!this.resumingFrom &&
            !w.options.layoutScroll &&
            w.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = w),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = xe()),
                (this.relativeTargetOrigin = xe()),
                Za(this.relativeTargetOrigin, this.target, w.target),
                Hn(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0)
          }
          Ma && no.resolvedTargetDeltas++
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || ef(this.parent.latestValues) || P6(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
    }
    calcProjection() {
      var s
      const c = this.getLead(),
        h = !!this.resumingFrom || this !== c
      let f = !0
      if (
        ((this.isProjectionDirty ||
          (!((s = this.parent) === null || s === void 0) && s.isProjectionDirty)) &&
          (f = !1),
        h && (this.isSharedProjectionDirty || this.isTransformDirty) && (f = !1),
        this.resolvedRelativeTargetAt === ze.timestamp && (f = !1),
        f)
      )
        return
      const { layout: p, layoutId: y } = this.options
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(p || y))
      )
        return
      Hn(this.layoutCorrected, this.layout.layoutBox)
      const w = this.treeScale.x,
        x = this.treeScale.y
      ;(NA(this.layoutCorrected, this.treeScale, this.path, h),
        c.layout &&
          !c.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((c.target = c.layout.layoutBox), (c.targetWithTransforms = xe())))
      const { target: E } = c
      if (!E) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender())
        return
      }
      ;(!this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (Z2(this.prevProjectionDelta.x, this.projectionDelta.x),
          Z2(this.prevProjectionDelta.y, this.projectionDelta.y)),
        Ya(this.projectionDelta, this.layoutCorrected, E, this.latestValues),
        (this.treeScale.x !== w ||
          this.treeScale.y !== x ||
          !nm(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !nm(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners('projectionUpdate', E)),
        Ma && no.recalculatedProjection++)
    }
    hide() {
      this.isVisible = !1
    }
    show() {
      this.isVisible = !0
    }
    scheduleRender(s = !0) {
      var c
      if (((c = this.options.visualElement) === null || c === void 0 || c.scheduleRender(), s)) {
        const h = this.getStack()
        h && h.scheduleRender()
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
    }
    createProjectionDeltas() {
      ;((this.prevProjectionDelta = ws()),
        (this.projectionDelta = ws()),
        (this.projectionDeltaWithTransform = ws()))
    }
    setAnimationOrigin(s, c = !1) {
      const h = this.snapshot,
        f = h ? h.latestValues : {},
        p = { ...this.latestValues },
        y = ws()
      ;((!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !c))
      const w = xe(),
        x = h ? h.source : void 0,
        E = this.layout ? this.layout.source : void 0,
        S = x !== E,
        k = this.getStack(),
        D = !k || k.members.length <= 1,
        _ = !!(S && !D && this.options.crossfade === !0 && !this.path.some(m7))
      this.animationProgress = 0
      let N
      ;((this.mixTargetDelta = (M) => {
        const O = M / 1e3
        ;(sm(y.x, s.x, O),
          sm(y.y, s.y, O),
          this.setTargetDelta(y),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Za(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            g7(this.relativeTarget, this.relativeTargetOrigin, w, O),
            N && JA(this.relativeTarget, N) && (this.isProjectionDirty = !1),
            N || (N = xe()),
            Hn(N, this.relativeTarget)),
          S && ((this.animationValues = p), YA(p, f, this.latestValues, O, _, D)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = O))
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0))
    }
    startAnimation(s) {
      ;(this.notifyListeners('animationStart'),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation && (Pi(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = re.update(() => {
          ;((Kc.hasAnimatedSinceResize = !0),
            (this.currentAnimation = WA(0, rm, {
              ...s,
              onUpdate: (c) => {
                ;(this.mixTargetDelta(c), s.onUpdate && s.onUpdate(c))
              },
              onComplete: () => {
                ;(s.onComplete && s.onComplete(), this.completeAnimation())
              },
            })),
            this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0))
        })))
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0))
      const s = this.getStack()
      ;(s && s.exitAnimationComplete(),
        (this.resumingFrom = this.currentAnimation = this.animationValues = void 0),
        this.notifyListeners('animationComplete'))
    }
    finishAnimation() {
      ;(this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(rm), this.currentAnimation.stop()),
        this.completeAnimation())
    }
    applyTransformsToTarget() {
      const s = this.getLead()
      let { targetWithTransforms: c, target: h, layout: f, latestValues: p } = s
      if (!(!c || !h || !f)) {
        if (
          this !== s &&
          this.layout &&
          f &&
          X6(this.options.animationType, this.layout.layoutBox, f.layoutBox)
        ) {
          h = this.target || xe()
          const y = Bn(this.layout.layoutBox.x)
          ;((h.x.min = s.target.x.min), (h.x.max = h.x.min + y))
          const w = Bn(this.layout.layoutBox.y)
          ;((h.y.min = s.target.y.min), (h.y.max = h.y.min + w))
        }
        ;(Hn(c, h), vs(c, p), Ya(this.projectionDeltaWithTransform, this.layoutCorrected, c, p))
      }
    }
    registerSharedNode(s, c) {
      ;(this.sharedNodes.has(s) || this.sharedNodes.set(s, new t7()),
        this.sharedNodes.get(s).add(c))
      const h = c.options.initialPromotionConfig
      c.promote({
        transition: h ? h.transition : void 0,
        preserveFollowOpacity:
          h && h.shouldPreserveFollowOpacity ? h.shouldPreserveFollowOpacity(c) : void 0,
      })
    }
    isLead() {
      const s = this.getStack()
      return s ? s.lead === this : !0
    }
    getLead() {
      var s
      const { layoutId: c } = this.options
      return c ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this
    }
    getPrevLead() {
      var s
      const { layoutId: c } = this.options
      return c ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead) : void 0
    }
    getStack() {
      const { layoutId: s } = this.options
      if (s) return this.root.sharedNodes.get(s)
    }
    promote({ needsReset: s, transition: c, preserveFollowOpacity: h } = {}) {
      const f = this.getStack()
      ;(f && f.promote(this, h),
        s && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        c && this.setOptions({ transition: c }))
    }
    relegate() {
      const s = this.getStack()
      return s ? s.relegate(this) : !1
    }
    resetSkewAndRotation() {
      const { visualElement: s } = this.options
      if (!s) return
      let c = !1
      const { latestValues: h } = s
      if (
        ((h.z || h.rotate || h.rotateX || h.rotateY || h.rotateZ || h.skewX || h.skewY) && (c = !0),
        !c)
      )
        return
      const f = {}
      h.z && Td('z', s, f, this.animationValues)
      for (let p = 0; p < Rd.length; p++)
        (Td(`rotate${Rd[p]}`, s, f, this.animationValues),
          Td(`skew${Rd[p]}`, s, f, this.animationValues))
      s.render()
      for (const p in f)
        (s.setStaticValue(p, f[p]), this.animationValues && (this.animationValues[p] = f[p]))
      s.scheduleRender()
    }
    getProjectionStyles(s) {
      var c, h
      if (!this.instance || this.isSVG) return
      if (!this.isVisible) return n7
      const f = { visibility: '' },
        p = this.getTransformTemplate()
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (f.opacity = ''),
          (f.pointerEvents = Zc(s == null ? void 0 : s.pointerEvents) || ''),
          (f.transform = p ? p(this.latestValues, '') : 'none'),
          f
        )
      const y = this.getLead()
      if (!this.projectionDelta || !this.layout || !y.target) {
        const S = {}
        return (
          this.options.layoutId &&
            ((S.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1),
            (S.pointerEvents = Zc(s == null ? void 0 : s.pointerEvents) || '')),
          this.hasProjected &&
            !eo(this.latestValues) &&
            ((S.transform = p ? p({}, '') : 'none'), (this.hasProjected = !1)),
          S
        )
      }
      const w = y.animationValues || y.latestValues
      ;(this.applyTransformsToTarget(),
        (f.transform = e7(this.projectionDeltaWithTransform, this.treeScale, w)),
        p && (f.transform = p(w, f.transform)))
      const { x, y: E } = this.projectionDelta
      ;((f.transformOrigin = `${x.origin * 100}% ${E.origin * 100}% 0`),
        y.animationValues
          ? (f.opacity =
              y === this
                ? (h = (c = w.opacity) !== null && c !== void 0 ? c : this.latestValues.opacity) !==
                    null && h !== void 0
                  ? h
                  : 1
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : w.opacityExit)
          : (f.opacity =
              y === this
                ? w.opacity !== void 0
                  ? w.opacity
                  : ''
                : w.opacityExit !== void 0
                  ? w.opacityExit
                  : 0))
      for (const S in Nu) {
        if (w[S] === void 0) continue
        const { correct: k, applyTo: D } = Nu[S],
          _ = f.transform === 'none' ? w[S] : k(w[S], y)
        if (D) {
          const N = D.length
          for (let M = 0; M < N; M++) f[D[M]] = _
        } else f[S] = _
      }
      return (
        this.options.layoutId &&
          (f.pointerEvents = y === this ? Zc(s == null ? void 0 : s.pointerEvents) || '' : 'none'),
        f
      )
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0
    }
    resetTree() {
      ;(this.root.nodes.forEach((s) => {
        var c
        return (c = s.currentAnimation) === null || c === void 0 ? void 0 : c.stop()
      }),
        this.root.nodes.forEach(im),
        this.root.sharedNodes.clear())
    }
  }
}
function i7(t) {
  t.updateLayout()
}
function o7(t) {
  var e
  const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot
  if (t.isLead() && t.layout && n && t.hasListeners('didUpdate')) {
    const { layoutBox: r, measuredBox: i } = t.layout,
      { animationType: s } = t.options,
      c = n.source !== t.layout.source
    s === 'size'
      ? Gn((w) => {
          const x = c ? n.measuredBox[w] : n.layoutBox[w],
            E = Bn(x)
          ;((x.min = r[w].min), (x.max = x.min + E))
        })
      : X6(s, n.layoutBox, r) &&
        Gn((w) => {
          const x = c ? n.measuredBox[w] : n.layoutBox[w],
            E = Bn(r[w])
          ;((x.max = x.min + E),
            t.relativeTarget &&
              !t.currentAnimation &&
              ((t.isProjectionDirty = !0), (t.relativeTarget[w].max = t.relativeTarget[w].min + E)))
        })
    const h = ws()
    Ya(h, r, n.layoutBox)
    const f = ws()
    c ? Ya(f, t.applyTransform(i, !0), n.measuredBox) : Ya(f, r, n.layoutBox)
    const p = !W6(h)
    let y = !1
    if (!t.resumeFrom) {
      const w = t.getClosestProjectingParent()
      if (w && !w.resumeFrom) {
        const { snapshot: x, layout: E } = w
        if (x && E) {
          const S = xe()
          Za(S, n.layoutBox, x.layoutBox)
          const k = xe()
          ;(Za(k, r, E.layoutBox),
            U6(S, k) || (y = !0),
            w.options.layoutRoot &&
              ((t.relativeTarget = k), (t.relativeTargetOrigin = S), (t.relativeParent = w)))
        }
      }
    }
    t.notifyListeners('didUpdate', {
      layout: r,
      snapshot: n,
      delta: f,
      layoutDelta: h,
      hasLayoutChanged: p,
      hasRelativeTargetChanged: y,
    })
  } else if (t.isLead()) {
    const { onExitComplete: r } = t.options
    r && r()
  }
  t.options.transition = void 0
}
function s7(t) {
  ;(Ma && no.totalNodes++,
    t.parent &&
      (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty),
      t.isSharedProjectionDirty ||
        (t.isSharedProjectionDirty = !!(
          t.isProjectionDirty ||
          t.parent.isProjectionDirty ||
          t.parent.isSharedProjectionDirty
        )),
      t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)))
}
function a7(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
}
function l7(t) {
  t.clearSnapshot()
}
function im(t) {
  t.clearMeasurements()
}
function c7(t) {
  t.isLayoutDirty = !1
}
function u7(t) {
  const { visualElement: e } = t.options
  ;(e && e.getProps().onBeforeLayoutMeasure && e.notify('BeforeLayoutMeasure'), t.resetTransform())
}
function om(t) {
  ;(t.finishAnimation(),
    (t.targetDelta = t.relativeTarget = t.target = void 0),
    (t.isProjectionDirty = !0))
}
function h7(t) {
  t.resolveTargetDelta()
}
function d7(t) {
  t.calcProjection()
}
function f7(t) {
  t.resetSkewAndRotation()
}
function p7(t) {
  t.removeLeadSnapshot()
}
function sm(t, e, n) {
  ;((t.translate = le(e.translate, 0, n)),
    (t.scale = le(e.scale, 1, n)),
    (t.origin = e.origin),
    (t.originPoint = e.originPoint))
}
function am(t, e, n, r) {
  ;((t.min = le(e.min, n.min, r)), (t.max = le(e.max, n.max, r)))
}
function g7(t, e, n, r) {
  ;(am(t.x, e.x, n.x, r), am(t.y, e.y, n.y, r))
}
function m7(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0
}
const y7 = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  lm = (t) =>
    typeof navigator < 'u' && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t),
  cm = lm('applewebkit/') && !lm('chrome/') ? Math.round : Pn
function um(t) {
  ;((t.min = cm(t.min)), (t.max = cm(t.max)))
}
function w7(t) {
  ;(um(t.x), um(t.y))
}
function X6(t, e, n) {
  return t === 'position' || (t === 'preserve-aspect' && !xA(em(e), em(n), 0.2))
}
function b7(t) {
  var e
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
}
const v7 = H6({
    attachResizeListener: (t, e) => Sl(t, 'resize', e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  Nd = { current: void 0 },
  G6 = H6({
    measureScroll: (t) => ({ x: t.scrollLeft, y: t.scrollTop }),
    defaultParent: () => {
      if (!Nd.current) {
        const t = new v7({})
        ;(t.mount(window), t.setOptions({ layoutScroll: !0 }), (Nd.current = t))
      }
      return Nd.current
    },
    resetTransform: (t, e) => {
      t.style.transform = e !== void 0 ? e : 'none'
    },
    checkIsScrollRoot: (t) => window.getComputedStyle(t).position === 'fixed',
  }),
  x7 = { pan: { Feature: BA }, drag: { Feature: OA, ProjectionNode: G6, MeasureLayout: F6 } }
function hm(t, e, n) {
  const { props: r } = t
  t.animationState && r.whileHover && t.animationState.setActive('whileHover', n === 'Start')
  const i = 'onHover' + n,
    s = r[i]
  s && re.postRender(() => s(e, jl(e)))
}
class E7 extends Wi {
  mount() {
    const { current: e } = this.node
    e && (this.unmount = x5(e, (n) => (hm(this.node, n, 'Start'), (r) => hm(this.node, r, 'End'))))
  }
  unmount() {}
}
class C7 extends Wi {
  constructor() {
    ;(super(...arguments), (this.isActive = !1))
  }
  onFocus() {
    let e = !1
    try {
      e = this.node.current.matches(':focus-visible')
    } catch {
      e = !0
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !0), (this.isActive = !0))
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !1), (this.isActive = !1))
  }
  mount() {
    this.unmount = Fl(
      Sl(this.node.current, 'focus', () => this.onFocus()),
      Sl(this.node.current, 'blur', () => this.onBlur())
    )
  }
  unmount() {}
}
function dm(t, e, n) {
  const { props: r } = t
  t.animationState && r.whileTap && t.animationState.setActive('whileTap', n === 'Start')
  const i = 'onTap' + (n === 'End' ? '' : n),
    s = r[i]
  s && re.postRender(() => s(e, jl(e)))
}
class S7 extends Wi {
  mount() {
    const { current: e } = this.node
    e &&
      (this.unmount = A5(
        e,
        (n) => (
          dm(this.node, n, 'Start'),
          (r, { success: i }) => dm(this.node, r, i ? 'End' : 'Cancel')
        ),
        { useGlobalTarget: this.node.props.globalTapTarget }
      ))
  }
  unmount() {}
}
const rf = new WeakMap(),
  Md = new WeakMap(),
  A7 = (t) => {
    const e = rf.get(t.target)
    e && e(t)
  },
  k7 = (t) => {
    t.forEach(A7)
  }
function I7({ root: t, ...e }) {
  const n = t || document
  Md.has(n) || Md.set(n, {})
  const r = Md.get(n),
    i = JSON.stringify(e)
  return (r[i] || (r[i] = new IntersectionObserver(k7, { root: t, ...e })), r[i])
}
function _7(t, e, n) {
  const r = I7(e)
  return (
    rf.set(t, n),
    r.observe(t),
    () => {
      ;(rf.delete(t), r.unobserve(t))
    }
  )
}
const R7 = { some: 0, all: 1 }
class T7 extends Wi {
  constructor() {
    ;(super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1))
  }
  startObserver() {
    this.unmount()
    const { viewport: e = {} } = this.node.getProps(),
      { root: n, margin: r, amount: i = 'some', once: s } = e,
      c = {
        root: n ? n.current : void 0,
        rootMargin: r,
        threshold: typeof i == 'number' ? i : R7[i],
      },
      h = (f) => {
        const { isIntersecting: p } = f
        if (this.isInView === p || ((this.isInView = p), s && !p && this.hasEnteredView)) return
        ;(p && (this.hasEnteredView = !0),
          this.node.animationState && this.node.animationState.setActive('whileInView', p))
        const { onViewportEnter: y, onViewportLeave: w } = this.node.getProps(),
          x = p ? y : w
        x && x(f)
      }
    return _7(this.node.current, c, h)
  }
  mount() {
    this.startObserver()
  }
  update() {
    if (typeof IntersectionObserver > 'u') return
    const { props: e, prevProps: n } = this.node
    ;['amount', 'margin', 'root'].some(N7(e, n)) && this.startObserver()
  }
  unmount() {}
}
function N7({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (n) => t[n] !== e[n]
}
const M7 = {
    inView: { Feature: T7 },
    tap: { Feature: S7 },
    focus: { Feature: C7 },
    hover: { Feature: E7 },
  },
  D7 = { layout: { ProjectionNode: G6, MeasureLayout: F6 } },
  of = { current: null },
  Y6 = { current: !1 }
function P7() {
  if (((Y6.current = !0), !!x0))
    if (window.matchMedia) {
      const t = window.matchMedia('(prefers-reduced-motion)'),
        e = () => (of.current = t.matches)
      ;(t.addListener(e), e())
    } else of.current = !1
}
const L7 = [...w6, Qe, Li],
  O7 = (t) => L7.find(y6(t)),
  fm = new WeakMap()
function B7(t, e, n) {
  for (const r in e) {
    const i = e[r],
      s = n[r]
    if (Je(i)) t.addValue(r, i)
    else if (Je(s)) t.addValue(r, El(i, { owner: t }))
    else if (s !== i)
      if (t.hasValue(r)) {
        const c = t.getValue(r)
        c.liveStyle === !0 ? c.jump(i) : c.hasAnimated || c.set(i)
      } else {
        const c = t.getStaticValue(r)
        t.addValue(r, El(c !== void 0 ? c : i, { owner: t }))
      }
  }
  for (const r in n) e[r] === void 0 && t.removeValue(r)
  return e
}
const pm = [
  'AnimationStart',
  'AnimationComplete',
  'Update',
  'BeforeLayoutMeasure',
  'LayoutMeasure',
  'LayoutAnimationStart',
  'LayoutAnimationComplete',
]
class F7 {
  scrapeMotionValuesFromProps(e, n, r) {
    return {}
  }
  constructor(
    {
      parent: e,
      props: n,
      presenceContext: r,
      reducedMotionConfig: i,
      blockInitialAnimation: s,
      visualState: c,
    },
    h = {}
  ) {
    ;((this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = Z0),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify('Update', this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const E = _r.now()
        this.renderScheduledAt < E && ((this.renderScheduledAt = E), re.render(this.render, !1, !0))
      }))
    const { latestValues: f, renderState: p, onUpdate: y } = c
    ;((this.onUpdate = y),
      (this.latestValues = f),
      (this.baseTarget = { ...f }),
      (this.initialValues = n.initial ? { ...f } : {}),
      (this.renderState = p),
      (this.parent = e),
      (this.props = n),
      (this.presenceContext = r),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = i),
      (this.options = h),
      (this.blockInitialAnimation = !!s),
      (this.isControllingVariants = mh(n)),
      (this.isVariantNode = kw(n)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current)))
    const { willChange: w, ...x } = this.scrapeMotionValuesFromProps(n, {}, this)
    for (const E in x) {
      const S = x[E]
      f[E] !== void 0 && Je(S) && S.set(f[E], !1)
    }
  }
  mount(e) {
    ;((this.current = e),
      fm.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((n, r) => this.bindToMotionValue(r, n)),
      Y6.current || P7(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === 'never'
          ? !1
          : this.reducedMotionConfig === 'always'
            ? !0
            : of.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext))
  }
  unmount() {
    ;(fm.delete(this.current),
      this.projection && this.projection.unmount(),
      Pi(this.notifyUpdate),
      Pi(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this))
    for (const e in this.events) this.events[e].clear()
    for (const e in this.features) {
      const n = this.features[e]
      n && (n.unmount(), (n.isMounted = !1))
    }
    this.current = null
  }
  bindToMotionValue(e, n) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)()
    const r = Ro.has(e),
      i = n.on('change', (h) => {
        ;((this.latestValues[e] = h),
          this.props.onUpdate && re.preRender(this.notifyUpdate),
          r && this.projection && (this.projection.isTransformDirty = !0))
      }),
      s = n.on('renderRequest', this.scheduleRender)
    let c
    ;(window.MotionCheckAppearSync && (c = window.MotionCheckAppearSync(this, e, n)),
      this.valueSubscriptions.set(e, () => {
        ;(i(), s(), c && c(), n.owner && n.stop())
      }))
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current)
  }
  updateFeatures() {
    let e = 'animation'
    for (e in js) {
      const n = js[e]
      if (!n) continue
      const { isEnabled: r, Feature: i } = n
      if (
        (!this.features[e] && i && r(this.props) && (this.features[e] = new i(this)),
        this.features[e])
      ) {
        const s = this.features[e]
        s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0))
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props)
  }
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : xe()
  }
  getStaticValue(e) {
    return this.latestValues[e]
  }
  setStaticValue(e, n) {
    this.latestValues[e] = n
  }
  update(e, n) {
    ;((e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = n))
    for (let r = 0; r < pm.length; r++) {
      const i = pm[r]
      this.propEventSubscriptions[i] &&
        (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i])
      const s = 'on' + i,
        c = e[s]
      c && (this.propEventSubscriptions[i] = this.on(i, c))
    }
    ;((this.prevMotionValues = B7(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps, this),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue(),
      this.onUpdate && this.onUpdate(this))
  }
  getProps() {
    return this.props
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0
  }
  getDefaultTransition() {
    return this.props.transition
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
  }
  addVariantChild(e) {
    const n = this.getClosestVariantNode()
    if (n) return (n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e))
  }
  addValue(e, n) {
    const r = this.values.get(e)
    n !== r &&
      (r && this.removeValue(e),
      this.bindToMotionValue(e, n),
      this.values.set(e, n),
      (this.latestValues[e] = n.get()))
  }
  removeValue(e) {
    this.values.delete(e)
    const n = this.valueSubscriptions.get(e)
    ;(n && (n(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState))
  }
  hasValue(e) {
    return this.values.has(e)
  }
  getValue(e, n) {
    if (this.props.values && this.props.values[e]) return this.props.values[e]
    let r = this.values.get(e)
    return (
      r === void 0 &&
        n !== void 0 &&
        ((r = El(n === null ? void 0 : n, { owner: this })), this.addValue(e, r)),
      r
    )
  }
  readValue(e, n) {
    var r
    let i =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : (r = this.getBaseTargetFromProps(this.props, e)) !== null && r !== void 0
          ? r
          : this.readValueFromInstance(this.current, e, this.options)
    return (
      i != null &&
        (typeof i == 'string' && (g6(i) || s6(i))
          ? (i = parseFloat(i))
          : !O7(i) && Li.test(n) && (i = d6(e, n)),
        this.setBaseTarget(e, Je(i) ? i.get() : i)),
      Je(i) ? i.get() : i
    )
  }
  setBaseTarget(e, n) {
    this.baseTarget[e] = n
  }
  getBaseTarget(e) {
    var n
    const { initial: r } = this.props
    let i
    if (typeof r == 'string' || typeof r == 'object') {
      const c = _0(
        this.props,
        r,
        (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom
      )
      c && (i = c[e])
    }
    if (r && i !== void 0) return i
    const s = this.getBaseTargetFromProps(this.props, e)
    return s !== void 0 && !Je(s)
      ? s
      : this.initialValues[e] !== void 0 && i === void 0
        ? void 0
        : this.baseTarget[e]
  }
  on(e, n) {
    return (this.events[e] || (this.events[e] = new U0()), this.events[e].add(n))
  }
  notify(e, ...n) {
    this.events[e] && this.events[e].notify(...n)
  }
}
class Z6 extends F7 {
  constructor() {
    ;(super(...arguments), (this.KeyframeResolver = b6))
  }
  sortInstanceNodePosition(e, n) {
    return e.compareDocumentPosition(n) & 2 ? 1 : -1
  }
  getBaseTargetFromProps(e, n) {
    return e.style ? e.style[n] : void 0
  }
  removeValueFromRenderState(e, { vars: n, style: r }) {
    ;(delete n[e], delete r[e])
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription)
    const { children: e } = this.props
    Je(e) &&
      (this.childSubscription = e.on('change', (n) => {
        this.current && (this.current.textContent = `${n}`)
      }))
  }
}
function j7(t) {
  return window.getComputedStyle(t)
}
class V7 extends Z6 {
  constructor() {
    ;(super(...arguments), (this.type = 'html'), (this.renderInstance = Lw))
  }
  readValueFromInstance(e, n) {
    if (Ro.has(n)) {
      const r = Y0(n)
      return (r && r.default) || 0
    } else {
      const r = j7(e),
        i = (Mw(n) ? r.getPropertyValue(n) : r[n]) || 0
      return typeof i == 'string' ? i.trim() : i
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: n }) {
    return O6(e, n)
  }
  build(e, n, r) {
    N0(e, n, r.transformTemplate)
  }
  scrapeMotionValuesFromProps(e, n, r) {
    return L0(e, n, r)
  }
}
class W7 extends Z6 {
  constructor() {
    ;(super(...arguments),
      (this.type = 'svg'),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = xe))
  }
  getBaseTargetFromProps(e, n) {
    return e[n]
  }
  readValueFromInstance(e, n) {
    if (Ro.has(n)) {
      const r = Y0(n)
      return (r && r.default) || 0
    }
    return ((n = Ow.has(n) ? n : A0(n)), e.getAttribute(n))
  }
  scrapeMotionValuesFromProps(e, n, r) {
    return jw(e, n, r)
  }
  build(e, n, r) {
    M0(e, n, this.isSVGTag, r.transformTemplate)
  }
  renderInstance(e, n, r, i) {
    Bw(e, n, r, i)
  }
  mount(e) {
    ;((this.isSVGTag = P0(e.tagName)), super.mount(e))
  }
}
const U7 = (t, e) => (I0(t) ? new W7(e) : new V7(e, { allowProjection: t !== X.Fragment })),
  z7 = p5({ ...dA, ...M7, ...x7, ...D7 }, U7),
  Kn = RC(z7)
var H7 = X.createContext({ color: 'currentColor', size: '1em', weight: 'regular', mirrored: !1 }),
  Cn = function (t, e, n) {
    var r = n.get(t)
    return r
      ? r(e)
      : (console.error(
          'Unsupported icon weight. Choose from "thin", "light", "regular", "bold", "fill", or "duotone".'
        ),
        null)
  }
function gm(t, e) {
  if (t == null) return {}
  var n = {},
    r = Object.keys(t),
    i,
    s
  for (s = 0; s < r.length; s++) ((i = r[s]), !(e.indexOf(i) >= 0) && (n[i] = t[i]))
  return n
}
var cn = X.forwardRef(function (t, e) {
  var n = t.alt,
    r = t.color,
    i = t.size,
    s = t.weight,
    c = t.mirrored,
    h = t.children,
    f = t.renderPath,
    p = gm(t, ['alt', 'color', 'size', 'weight', 'mirrored', 'children', 'renderPath']),
    y = X.useContext(H7),
    w = y.color,
    x = w === void 0 ? 'currentColor' : w,
    E = y.size,
    S = y.weight,
    k = S === void 0 ? 'regular' : S,
    D = y.mirrored,
    _ = D === void 0 ? !1 : D,
    N = gm(y, ['color', 'size', 'weight', 'mirrored'])
  return A.createElement(
    'svg',
    Object.assign(
      {
        ref: e,
        xmlns: 'http://www.w3.org/2000/svg',
        width: i ?? E,
        height: i ?? E,
        fill: r ?? x,
        viewBox: '0 0 256 256',
        transform: c || _ ? 'scale(-1, 1)' : void 0,
      },
      N,
      p
    ),
    !!n && A.createElement('title', null, n),
    h,
    A.createElement('rect', { width: '256', height: '256', fill: 'none' }),
    f(s ?? k, r ?? x)
  )
})
cn.displayName = 'IconBase'
var To = new Map()
To.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
To.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', { d: 'M128,128,44.9,176h-.1A96.1,96.1,0,0,1,128,32Z', opacity: '0.2' }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
To.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M218.3,76.4a.8.8,0,0,1-.2-.4l-.4-.5a104,104,0,0,0-180,104.1l.2.4.3.4a104,104,0,0,0,180.1-104Zm-18.4.9L136,114.1V40.4A88.2,88.2,0,0,1,199.9,77.3ZM128,216a88,88,0,0,1-71.9-37.3L207.9,91.1A88,88,0,0,1,128,216Z',
    })
  )
})
To.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
To.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
To.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '96',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '128',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '211.1',
      y1: '80',
      x2: '44.9',
      y2: '176',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var X7 = function (t, e) {
    return Cn(t, e, To)
  },
  bh = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: X7 }))
  })
bh.displayName = 'ChartPie'
var No = new Map()
No.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M184.6,128H224a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H71.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '16' })
  )
})
No.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '24',
      y: '128',
      width: '208',
      height: '80',
      rx: '8',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M176,128h48a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H80',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '12' })
  )
})
No.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M74.3,85.7A8.1,8.1,0,0,1,85.7,74.3L120,108.7V24a8,8,0,0,1,16,0v84.7l34.3-34.4a8.1,8.1,0,0,1,11.4,11.4l-48,48a8.2,8.2,0,0,1-11.4,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a3.6,3.6,0,0,1,2.8,1.2L111,145a24.1,24.1,0,0,0,34,0l23.8-23.8a3.6,3.6,0,0,1,2.8-1.2H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z',
    })
  )
})
No.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M176,128h48a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H80',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '10' })
  )
})
No.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M176,128h48a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H80',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '8' })
  )
})
No.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M176,128h48a8,8,0,0,1,8,8v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H80',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '24',
      x2: '128',
      y2: '128',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '80 80 128 128 176 80',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', { cx: '188', cy: '168', r: '12' })
  )
})
var G7 = function (t, e) {
    return Cn(t, e, No)
  },
  q6 = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: G7 }))
  })
q6.displayName = 'Download'
var Mo = new Map()
Mo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Mo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Zm0,112a40,40,0,1,1,40-40A40,40,0,0,1,128,168Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Mo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M247.3,124.8c-.3-.8-8.8-19.6-27.6-38.5C194.6,61.3,162.9,48,128,48S61.4,61.3,36.3,86.3C17.5,105.2,9,124,8.7,124.8a7.9,7.9,0,0,0,0,6.4c.3.8,8.8,19.6,27.6,38.5C61.4,194.7,93.1,208,128,208s66.6-13.3,91.7-38.3c18.8-18.9,27.3-37.7,27.6-38.5A7.9,7.9,0,0,0,247.3,124.8ZM128,92a36,36,0,1,1-36,36A36,36,0,0,1,128,92Z',
    })
  )
})
Mo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Mo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Mo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var Y7 = function (t, e) {
    return Cn(t, e, Mo)
  },
  K6 = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: Y7 }))
  })
K6.displayName = 'Eye'
var Do = new Map()
Do.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M214.4,163.6C232.1,145.7,240,128,240,128S208,56,128,56c-3.8,0-7.4.2-11,.5',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Do.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Zm0,112a40,40,0,1,1,40-40A40,40,0,0,1,128,168Z',
      opacity: '0.2',
    }),
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M154.9,157.6A39.6,39.6,0,0,1,128,168a40,40,0,0,1-26.9-69.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M208.6,169.1C230.4,149.6,240,128,240,128S208,56,128,56a123.9,123.9,0,0,0-20.7,1.7',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M135.5,88.7a39.9,39.9,0,0,1,32.3,35.5',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Do.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M247.3,124.8c-.3-.8-8.8-19.6-27.6-38.5C194.6,61.3,162.9,48,128,48a132.4,132.4,0,0,0-22,1.8,8.1,8.1,0,0,0-4.6,13.3L202.7,174.5a8,8,0,0,0,5.9,2.6,8.6,8.6,0,0,0,5.4-2c22.8-20.5,32.9-42.9,33.3-43.8A8.2,8.2,0,0,0,247.3,124.8Z',
    }),
    A.createElement('path', {
      d: 'M53.9,34.6A8,8,0,0,0,42.1,45.4L61.3,66.5C25,88.8,9.4,123.2,8.7,124.8a8.2,8.2,0,0,0,0,6.5c.3.7,8.8,19.5,27.6,38.4C61.4,194.7,93.1,208,128,208a126.9,126.9,0,0,0,52.1-10.8l22,24.2A8,8,0,0,0,208,224a8.2,8.2,0,0,0,5.4-2.1,7.9,7.9,0,0,0,.5-11.3ZM128,164a36,36,0,0,1-29.5-56.6l47.2,51.9A35.4,35.4,0,0,1,128,164Z',
    })
  )
})
Do.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M154.9,157.6A39.6,39.6,0,0,1,128,168a40,40,0,0,1-26.9-69.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M208.6,169.1C230.4,149.6,240,128,240,128S208,56,128,56a123.9,123.9,0,0,0-20.7,1.7',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M135.5,88.7a39.9,39.9,0,0,1,32.3,35.5',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Do.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M154.9,157.6A39.6,39.6,0,0,1,128,168a40,40,0,0,1-26.9-69.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M208.6,169.1C230.4,149.6,240,128,240,128S208,56,128,56a123.9,123.9,0,0,0-20.7,1.7',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M135.5,88.7a39.9,39.9,0,0,1,32.3,35.5',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Do.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '48',
      y1: '40',
      x2: '208',
      y2: '216',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M154.9,157.6A39.6,39.6,0,0,1,128,168a40,40,0,0,1-26.9-69.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M74,68.6C33.2,89.2,16,128,16,128s32,72,112,72a117.9,117.9,0,0,0,54-12.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M208.6,169.1C230.4,149.6,240,128,240,128S208,56,128,56a123.9,123.9,0,0,0-20.7,1.7',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M135.5,88.7a39.9,39.9,0,0,1,32.3,35.5',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var Z7 = function (t, e) {
    return Cn(t, e, Do)
  },
  sf = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: Z7 }))
  })
sf.displayName = 'EyeSlash'
var Po = new Map()
Po.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Po.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Po.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M240,160v24a16,16,0,0,1-16,16H115.5a4,4,0,0,1-3.2-6.4L178,108a8.2,8.2,0,0,0-1.1-11.3A7.9,7.9,0,0,0,165.5,98L88.4,198.4a3.8,3.8,0,0,1-3.1,1.6H32a16,16,0,0,1-16-16V161.1a116.1,116.1,0,0,1,2.2-22.2L40.9,145l2.1.2a8,8,0,0,0,7.8-6.2,8.1,8.1,0,0,0-6-9.6l-22.4-6C37,82,74.9,51.5,120,48.3V71.7a8.2,8.2,0,0,0,7.5,8.3,8,8,0,0,0,8.5-8V48.3a111.5,111.5,0,0,1,71.1,32.4,112.7,112.7,0,0,1,26.8,42.6l-22.7,6.1a8.1,8.1,0,0,0-6,9.6,8,8,0,0,0,7.8,6.2l2.1-.2,22.9-6.2A114.5,114.5,0,0,1,240,160Z',
    })
  )
})
Po.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Po.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Po.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M24,184V161.1C24,103.6,70.2,56.2,127.6,56A104,104,0,0,1,232,160v24a8,8,0,0,1-8,8H32A8,8,0,0,1,24,184Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '56',
      x2: '128',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '27.5',
      y1: '133.1',
      x2: '58.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '228.5',
      y1: '133.1',
      x2: '197.5',
      y2: '141.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '103.4',
      y1: '192',
      x2: '171.8',
      y2: '102.9',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var q7 = function (t, e) {
    return Cn(t, e, Po)
  },
  $0 = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: q7 }))
  })
$0.displayName = 'Gauge'
var Lo = new Map()
Lo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '60',
      height: '60',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('rect', {
      x: '48',
      y: '148',
      width: '60',
      height: '60',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('rect', {
      x: '148',
      y: '48',
      width: '60',
      height: '60',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '148',
      y1: '148',
      x2: '148',
      y2: '172',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('polyline', {
      points: '148 208 184 208 184 148',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '184',
      y1: '164',
      x2: '208',
      y2: '164',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Lo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      opacity: '0.2',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      opacity: '0.2',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      opacity: '0.2',
    }),
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '144',
      y1: '144',
      x2: '144',
      y2: '176',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '144 208 176 208 176 144',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '160',
      x2: '208',
      y2: '160',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '208',
      y1: '192',
      x2: '208',
      y2: '208',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Lo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', { x: '40', y: '40', width: '80', height: '80', rx: '16' }),
    A.createElement('rect', { x: '40', y: '136', width: '80', height: '80', rx: '16' }),
    A.createElement('rect', { x: '136', y: '40', width: '80', height: '80', rx: '16' }),
    A.createElement('path', {
      d: 'M144,184a8,8,0,0,0,8-8V144a8,8,0,0,0-16,0v32A8,8,0,0,0,144,184Z',
    }),
    A.createElement('path', {
      d: 'M208,152H184v-8a8,8,0,0,0-16,0v56H144a8,8,0,0,0,0,16h32a8,8,0,0,0,8-8V168h24a8,8,0,0,0,0-16Z',
    }),
    A.createElement('path', {
      d: 'M208,184a8,8,0,0,0-8,8v16a8,8,0,0,0,16,0V192A8,8,0,0,0,208,184Z',
    })
  )
})
Lo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '144',
      y1: '144',
      x2: '144',
      y2: '176',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('polyline', {
      points: '144 208 176 208 176 144',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '160',
      x2: '208',
      y2: '160',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '208',
      y1: '192',
      x2: '208',
      y2: '208',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Lo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '144',
      y1: '144',
      x2: '144',
      y2: '176',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('polyline', {
      points: '144 208 176 208 176 144',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '160',
      x2: '208',
      y2: '160',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '208',
      y1: '192',
      x2: '208',
      y2: '208',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Lo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('rect', {
      x: '48',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('rect', {
      x: '48',
      y: '144',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('rect', {
      x: '144',
      y: '48',
      width: '64',
      height: '64',
      rx: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '144',
      y1: '144',
      x2: '144',
      y2: '176',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '144 208 176 208 176 144',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '160',
      x2: '208',
      y2: '160',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '208',
      y1: '192',
      x2: '208',
      y2: '208',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var K7 = function (t, e) {
    return Cn(t, e, Lo)
  },
  Vl = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: K7 }))
  })
Vl.displayName = 'QrCode'
var Oo = new Map()
Oo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Oo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Oo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M208,40H48A16,16,0,0,0,32,56v58.7c0,89.4,75.8,119.1,91,124.1a16,16,0,0,0,10,0c15.2-5,91-34.7,91-124.1V56A16,16,0,0,0,208,40Z',
    })
  )
})
Oo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Oo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Oo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var Q7 = function (t, e) {
    return Cn(t, e, Oo)
  },
  Eo = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: Q7 }))
  })
Eo.displayName = 'Shield'
var Bo = new Map()
Bo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Bo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Bo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M208,40H48A16,16,0,0,0,32,56v58.7c0,89.4,75.8,119.1,91,124.1a16,16,0,0,0,10,0c15.2-5,91-34.7,91-124.1V56A16,16,0,0,0,208,40Zm-30.5,69.8-58.6,56a8.1,8.1,0,0,1-5.6,2.2,7.9,7.9,0,0,1-5.5-2.2l-29.3-28a8,8,0,1,1,11-11.6l23.8,22.7,53.2-50.7a8,8,0,0,1,11,11.6Z',
    })
  )
})
Bo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Bo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Bo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M40,114.7V56a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8v58.7c0,84-71.3,111.8-85.5,116.5a7.2,7.2,0,0,1-5,0C111.3,226.5,40,198.7,40,114.7Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '172 104 113.3 160 84 132',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var $7 = function (t, e) {
    return Cn(t, e, Bo)
  },
  Q6 = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: $7 }))
  })
Q6.displayName = 'ShieldCheck'
var Fo = new Map()
Fo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Fo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      opacity: '0.2',
    }),
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Fo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M208.9,144a15.8,15.8,0,0,1-10.5,15l-52.2,19.2L127,230.4a16,16,0,0,1-30,0L77.8,178.2,25.6,159a16,16,0,0,1,0-30l52.2-19.2L97,57.6a16,16,0,0,1,30,0l19.2,52.2L198.4,129A15.8,15.8,0,0,1,208.9,144ZM152,48h16V64a8,8,0,0,0,16,0V48h16a8,8,0,0,0,0-16H184V16a8,8,0,0,0-16,0V32H152a8,8,0,0,0,0,16Zm88,32h-8V72a8,8,0,0,0-16,0v8h-8a8,8,0,0,0,0,16h8v8a8,8,0,0,0,16,0V96h8a8,8,0,0,0,0-16Z',
    })
  )
})
Fo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Fo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Fo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M138.7,175.5l-19.2,52.1a8,8,0,0,1-15,0L85.3,175.5a8.1,8.1,0,0,0-4.8-4.8L28.4,151.5a8,8,0,0,1,0-15l52.1-19.2a8.1,8.1,0,0,0,4.8-4.8l19.2-52.1a8,8,0,0,1,15,0l19.2,52.1a8.1,8.1,0,0,0,4.8,4.8l52.1,19.2a8,8,0,0,1,0,15l-52.1,19.2A8.1,8.1,0,0,0,138.7,175.5Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '176',
      y1: '16',
      x2: '176',
      y2: '64',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '200',
      y1: '40',
      x2: '152',
      y2: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '224',
      y1: '72',
      x2: '224',
      y2: '104',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '240',
      y1: '88',
      x2: '208',
      y2: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var J7 = function (t, e) {
    return Cn(t, e, Fo)
  },
  Qs = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: J7 }))
  })
Qs.displayName = 'Sparkle'
var jo = new Map()
jo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,0,67.8,47.1,47.1,0,0,0,13.2-24.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1A96.1,96.1,0,1,0,218,94.6',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
jo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', { cx: '128', cy: '128', r: '48', opacity: '0.2' }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1a96.2,96.2,0,1,0,18.7,26.5',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,14,31.2',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
jo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M211.2,79.4a8,8,0,0,0-3.8,10.7,88,88,0,1,1-23.1-29.7L161.5,83.2a56,56,0,0,0-73.1,84.4h0a56,56,0,0,0,95.5-42.8,7.9,7.9,0,0,0-8.4-7.5,8,8,0,0,0-7.6,8.4,40,40,0,0,1-62,35.7l24-24,37.7-37.7h0l62.1-62a8.1,8.1,0,0,0-11.4-11.4L195.7,49A104,104,0,0,0,54.5,54.5a103.8,103.8,0,0,0,0,147,103.8,103.8,0,0,0,147,0A104,104,0,0,0,221.9,83.2,8,8,0,0,0,211.2,79.4Z',
    })
  )
})
jo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1a96.2,96.2,0,1,0,18.7,26.5',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,14,31.2',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
jo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1a96.2,96.2,0,1,0,18.7,26.5',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,14,31.2',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
jo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '224',
      y2: '32',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M195.9,60.1a96.2,96.2,0,1,0,18.7,26.5',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M161.9,94.1a47.9,47.9,0,1,0,14,31.2',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var tk = function (t, e) {
    return Cn(t, e, jo)
  },
  J0 = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: tk }))
  })
J0.displayName = 'Target'
var Vo = new Map()
Vo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '140',
      x2: '161.9',
      y2: '106.1',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '12',
      x2: '152',
      y2: '12',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Vo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', { cx: '128', cy: '128', r: '88', opacity: '0.2' }),
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '88',
      fill: 'none',
      stroke: t,
      strokeMiterlimit: '10',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '167.6',
      y2: '88.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '8',
      x2: '152',
      y2: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Vo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', { d: 'M104,16h48a8,8,0,0,0,0-16H104a8,8,0,0,0,0,16Z' }),
    A.createElement('path', {
      d: 'M128,32a96,96,0,1,0,96,96A96.2,96.2,0,0,0,128,32Zm45.3,62.1-39.6,39.6a8.2,8.2,0,0,1-11.4,0,8.1,8.1,0,0,1,0-11.4l39.6-39.6a8.1,8.1,0,1,1,11.4,11.4Z',
    })
  )
})
Vo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '167.6',
      y2: '88.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '8',
      x2: '152',
      y2: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Vo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '88',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '167.6',
      y2: '88.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '8',
      x2: '152',
      y2: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Vo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '128',
      r: '88',
      fill: 'none',
      stroke: t,
      strokeMiterlimit: '10',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '128',
      x2: '167.6',
      y2: '88.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('line', {
      x1: '104',
      y1: '8',
      x2: '152',
      y2: '8',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var ek = function (t, e) {
    return Cn(t, e, Vo)
  },
  $6 = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: ek }))
  })
$6.displayName = 'Timer'
var Wo = new Map()
Wo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Wo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Wo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M240,56v64a8,8,0,0,1-4.9,7.4,8.5,8.5,0,0,1-3.1.6,8.3,8.3,0,0,1-5.7-2.3L200,99.3l-58.3,58.4a8.1,8.1,0,0,1-11.4,0L96,123.3,29.7,189.7A8.3,8.3,0,0,1,24,192a8.5,8.5,0,0,1-5.7-2.3,8.1,8.1,0,0,1,0-11.4l72-72a8.1,8.1,0,0,1,11.4,0L136,140.7,188.7,88,162.3,61.7a8.4,8.4,0,0,1-1.7-8.8A8.1,8.1,0,0,1,168,48h64A8,8,0,0,1,240,56Z',
    })
  )
})
Wo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Wo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Wo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('polyline', {
      points: '232 56 136 152 96 112 24 184',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('polyline', {
      points: '232 120 232 56 168 56',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var nk = function (t, e) {
    return Cn(t, e, Wo)
  },
  tp = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: nk }))
  })
tp.displayName = 'TrendUp'
var Uo = new Map()
Uo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M204.5,116.6A60.1,60.1,0,0,1,244,140',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M167.1,70.2A32,32,0,1,1,204,115',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M52,115A32,32,0,1,1,88.9,70.2',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M12,140a60.1,60.1,0,0,1,39.5-23.4',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    })
  )
})
Uo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', { cx: '128', cy: '140', r: '40', opacity: '0.2' }),
    A.createElement('circle', { cx: '60', cy: '84', r: '32', opacity: '0.2' }),
    A.createElement('circle', { cx: '196', cy: '84', r: '32', opacity: '0.2' }),
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M196,116a59.8,59.8,0,0,1,48,24',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M12,140a59.8,59.8,0,0,1,48-24',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M60,116A32,32,0,1,1,91.4,78',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M164.6,78A32,32,0,1,1,196,116',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
Uo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M64,140a7.9,7.9,0,0,1-8,8H12a8.2,8.2,0,0,1-7.2-4.4,8.2,8.2,0,0,1,.8-8.4A67.8,67.8,0,0,1,33,113.5a40,40,0,1,1,66.3-37,8.1,8.1,0,0,1-3.8,8.4,64.3,64.3,0,0,0-27.8,33.8A61.6,61.6,0,0,0,64,140Zm186.4-4.8A67.8,67.8,0,0,0,223,113.5a40,40,0,1,0-66.3-37,8.1,8.1,0,0,0,3.8,8.4,64,64,0,0,1,27.8,33.8A61.6,61.6,0,0,1,192,140a7.9,7.9,0,0,0,8,8h44a8,8,0,0,0,6.4-12.8Zm-93.2,42.9a48,48,0,1,0-58.4,0,72.1,72.1,0,0,0-35.6,34.4,7.8,7.8,0,0,0,.5,7.7,7.8,7.8,0,0,0,6.7,3.8H185.6a7.8,7.8,0,0,0,6.7-3.8,7.8,7.8,0,0,0,.5-7.7A72.1,72.1,0,0,0,157.2,178.1Z',
    })
  )
})
Uo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M196,116a59.8,59.8,0,0,1,48,24',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M12,140a59.8,59.8,0,0,1,48-24',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M60,116A32,32,0,1,1,91.4,78',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M164.6,78A32,32,0,1,1,196,116',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    })
  )
})
Uo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M196,116a59.8,59.8,0,0,1,48,24',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M12,140a59.8,59.8,0,0,1,48-24',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M60,116A32,32,0,1,1,91.4,78',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M164.6,78A32,32,0,1,1,196,116',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    })
  )
})
Uo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('circle', {
      cx: '128',
      cy: '140',
      r: '40',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M196,116a59.8,59.8,0,0,1,48,24',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M12,140a59.8,59.8,0,0,1,48-24',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M70.4,216a64.1,64.1,0,0,1,115.2,0',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M60,116A32,32,0,1,1,91.4,78',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M164.6,78A32,32,0,1,1,196,116',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    })
  )
})
var rk = function (t, e) {
    return Cn(t, e, Uo)
  },
  J6 = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: rk }))
  })
J6.displayName = 'UsersThree'
var zo = new Map()
zo.set('bold', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '104',
      x2: '128',
      y2: '136',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '24',
    }),
    A.createElement('circle', { cx: '128', cy: '176', r: '16' })
  )
})
zo.set('duotone', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      opacity: '0.2',
    }),
    A.createElement('line', {
      x1: '128',
      y1: '112',
      x2: '128',
      y2: '144',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', { cx: '128', cy: '180', r: '12' })
  )
})
zo.set('fill', function () {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('path', {
      d: 'M236.7,188,148.8,36a24,24,0,0,0-41.6,0h0L19.3,188A23.9,23.9,0,0,0,40,224H216a23.9,23.9,0,0,0,20.7-36ZM120,104a8,8,0,0,1,16,0v40a8,8,0,0,1-16,0Zm8,88a12,12,0,1,1,12-12A12,12,0,0,1,128,192Z',
    })
  )
})
zo.set('light', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '104',
      x2: '128',
      y2: '144',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '12',
    }),
    A.createElement('circle', { cx: '128', cy: '180', r: '10' })
  )
})
zo.set('thin', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '104',
      x2: '128',
      y2: '144',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '8',
    }),
    A.createElement('circle', { cx: '128', cy: '180', r: '8' })
  )
})
zo.set('regular', function (t) {
  return A.createElement(
    A.Fragment,
    null,
    A.createElement('line', {
      x1: '128',
      y1: '104',
      x2: '128',
      y2: '144',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('path', {
      d: 'M114.2,40l-88,152A16,16,0,0,0,40,216H216a16,16,0,0,0,13.8-24l-88-152A15.9,15.9,0,0,0,114.2,40Z',
      fill: 'none',
      stroke: t,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: '16',
    }),
    A.createElement('circle', { cx: '128', cy: '180', r: '12' })
  )
})
var ik = function (t, e) {
    return Cn(t, e, zo)
  },
  Qc = X.forwardRef(function (t, e) {
    return A.createElement(cn, Object.assign({ ref: e }, t, { renderPath: ik }))
  })
Qc.displayName = 'Warning'
const ok = () =>
    R.jsxs('div', {
      className: 'mx-auto flex w-full max-w-6xl flex-col gap-16 px-6 py-16',
      children: [
        R.jsxs('header', {
          className: 'grid gap-8 lg:grid-cols-[1.1fr_0.9fr] lg:items-center',
          children: [
            R.jsxs('div', {
              children: [
                R.jsx(Kn.p, {
                  initial: { opacity: 0, y: 8 },
                  animate: { opacity: 1, y: 0 },
                  className: 'text-sm uppercase tracking-[0.3em] text-emerald-200',
                  children: 'Vibe Prism',
                }),
                R.jsx(Kn.h1, {
                  initial: { opacity: 0, y: 10 },
                  animate: { opacity: 1, y: 0 },
                  transition: { delay: 0.1 },
                  className: 'mt-4 text-4xl font-semibold text-slate-50 md:text-5xl',
                  children: 'A full-scale signal mirror for the vibe you bring into every room.',
                }),
                R.jsx(Kn.p, {
                  initial: { opacity: 0, y: 10 },
                  animate: { opacity: 1, y: 0 },
                  transition: { delay: 0.2 },
                  className: 'mt-4 text-base text-slate-300',
                  children:
                    'Nexus Who is the flagship minisite for Vibe Prism. Answer 32 calibrated questions to reveal your social style, unlock momentum insights, and generate a private token you can restore on demand.',
                }),
                R.jsxs('div', {
                  className: 'mt-8 flex flex-wrap gap-3',
                  children: [
                    R.jsxs(tr, {
                      to: '/quiz',
                      className: 'button-primary',
                      children: [R.jsx(Qs, { size: 20 }), 'Start the quiz'],
                    }),
                    R.jsxs(tr, {
                      to: '/restore',
                      className: 'button-secondary',
                      children: [R.jsx(Eo, { size: 20 }), 'Restore a profile'],
                    }),
                  ],
                }),
                R.jsx('div', {
                  className: 'mt-8 grid gap-4 sm:grid-cols-3',
                  children: [
                    { label: 'Questions', value: '32' },
                    { label: 'Persona Bands', value: '3' },
                    { label: 'Signals Measured', value: '4' },
                  ].map((t) =>
                    R.jsxs(
                      'div',
                      {
                        className: 'stat-card',
                        children: [
                          R.jsx('p', {
                            className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                            children: t.label,
                          }),
                          R.jsx('p', {
                            className: 'mt-2 text-2xl font-semibold text-slate-50',
                            children: t.value,
                          }),
                        ],
                      },
                      t.label
                    )
                  ),
                }),
              ],
            }),
            R.jsx('div', {
              className: 'glass-panel p-6',
              children: R.jsxs('div', {
                className: 'grid gap-4',
                children: [
                  R.jsxs('div', {
                    className: 'flex items-start gap-3',
                    children: [
                      R.jsx(bh, { size: 24, className: 'text-emerald-300' }),
                      R.jsxs('div', {
                        children: [
                          R.jsx('h3', {
                            className: 'text-lg font-semibold',
                            children: 'Balanced insights',
                          }),
                          R.jsx('p', {
                            className: 'text-sm text-slate-400',
                            children:
                              'See a radar snapshot of your vibe strengths without heavy jargon.',
                          }),
                        ],
                      }),
                    ],
                  }),
                  R.jsxs('div', {
                    className: 'flex items-start gap-3',
                    children: [
                      R.jsx($0, { size: 24, className: 'text-emerald-300' }),
                      R.jsxs('div', {
                        children: [
                          R.jsx('h3', {
                            className: 'text-lg font-semibold',
                            children: 'Momentum score',
                          }),
                          R.jsx('p', {
                            className: 'text-sm text-slate-400',
                            children: 'Track how your energy reads to others in social settings.',
                          }),
                        ],
                      }),
                    ],
                  }),
                  R.jsxs('div', {
                    className: 'flex items-start gap-3',
                    children: [
                      R.jsx(Vl, { size: 24, className: 'text-emerald-300' }),
                      R.jsxs('div', {
                        children: [
                          R.jsx('h3', {
                            className: 'text-lg font-semibold',
                            children: 'Portable profile',
                          }),
                          R.jsx('p', {
                            className: 'text-sm text-slate-400',
                            children:
                              'Save your results as a private QR token for later restoration.',
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            }),
          ],
        }),
        R.jsxs('section', {
          className: 'grid gap-6 lg:grid-cols-[1.1fr_0.9fr]',
          children: [
            R.jsxs('div', {
              children: [
                R.jsx('p', { className: 'section-title', children: 'How the signal gets built' }),
                R.jsx('p', {
                  className: 'section-lead',
                  children:
                    'Each section of the quiz is engineered to surface micro-decisions, composure, and directional energy.',
                }),
                R.jsx('div', {
                  className: 'mt-6 grid gap-4 md:grid-cols-3',
                  children: [
                    {
                      title: 'Pulse',
                      copy: 'Time-based responses capture your instinctive tempo.',
                    },
                    { title: 'Balance', copy: 'Reversed items measure stability under tension.' },
                    { title: 'Integrity', copy: 'Built-in flags detect masking and halo bias.' },
                  ].map((t) =>
                    R.jsxs(
                      'div',
                      {
                        className: 'glass-panel p-5',
                        children: [
                          R.jsx('h3', {
                            className: 'text-lg font-semibold text-slate-50',
                            children: t.title,
                          }),
                          R.jsx('p', {
                            className: 'mt-2 text-sm text-slate-400',
                            children: t.copy,
                          }),
                        ],
                      },
                      t.title
                    )
                  ),
                }),
              ],
            }),
            R.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                R.jsx('p', {
                  className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                  children: 'Signal Spectrum',
                }),
                R.jsx('h3', {
                  className: 'mt-2 text-xl font-semibold text-slate-50',
                  children: 'Four traits, one profile.',
                }),
                R.jsx('p', {
                  className: 'mt-3 text-sm text-slate-400',
                  children:
                    'Presence, Strategy, Composure, and Guidance form the core of the Vibe Prism scoring engine.',
                }),
                R.jsx('div', {
                  className: 'mt-6 space-y-4',
                  children: [
                    { label: 'Presence', icon: J6, copy: 'How visible and central you feel.' },
                    { label: 'Strategy', icon: J0, copy: 'How intentional your moves are.' },
                    { label: 'Composure', icon: Eo, copy: 'How calm you stay under pressure.' },
                    { label: 'Guidance', icon: tp, copy: 'How you direct group energy.' },
                  ].map((t) =>
                    R.jsxs(
                      'div',
                      {
                        className: 'flex items-start gap-3',
                        children: [
                          R.jsx(t.icon, { size: 20, className: 'text-emerald-300' }),
                          R.jsxs('div', {
                            children: [
                              R.jsx('p', {
                                className: 'text-sm font-semibold text-slate-100',
                                children: t.label,
                              }),
                              R.jsx('p', { className: 'text-xs text-slate-400', children: t.copy }),
                            ],
                          }),
                        ],
                      },
                      t.label
                    )
                  ),
                }),
              ],
            }),
          ],
        }),
        R.jsxs('section', {
          children: [
            R.jsx('p', { className: 'section-title', children: 'What you unlock' }),
            R.jsx('p', {
              className: 'section-lead',
              children:
                'The minisite is designed as a full-scale profile hub you can share with your team or keep private.',
            }),
            R.jsx('div', {
              className: 'mt-6 grid gap-6 md:grid-cols-2',
              children: [
                {
                  title: 'Social Flow',
                  copy: 'Discover the pace you set when you walk into a room.',
                },
                {
                  title: 'Connection Style',
                  copy: 'See how you naturally build rapport and alignment.',
                },
                {
                  title: 'Decision Energy',
                  copy: 'Track how you balance outcomes, feelings, and follow-through.',
                },
                {
                  title: 'Influence Pattern',
                  copy: 'Understand the way you guide group momentum.',
                },
              ].map((t) =>
                R.jsxs(
                  Kn.div,
                  {
                    initial: { opacity: 0, y: 12 },
                    whileInView: { opacity: 1, y: 0 },
                    viewport: { once: !0 },
                    className: 'glass-panel p-5',
                    children: [
                      R.jsx('h3', {
                        className: 'text-lg font-semibold text-slate-50',
                        children: t.title,
                      }),
                      R.jsx('p', { className: 'mt-2 text-sm text-slate-400', children: t.copy }),
                    ],
                  },
                  t.title
                )
              ),
            }),
          ],
        }),
        R.jsxs('section', {
          className: 'grid gap-6 lg:grid-cols-[1.1fr_0.9fr]',
          children: [
            R.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                R.jsx('p', {
                  className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                  children: 'Who it is for',
                }),
                R.jsx('h3', {
                  className: 'mt-2 text-xl font-semibold',
                  children: 'Designed for focused leaders.',
                }),
                R.jsx('ul', {
                  className: 'mt-4 space-y-3 text-sm text-slate-300',
                  children: [
                    'Founders who want to calibrate presence before a pitch.',
                    'Teams decoding momentum and friction in collaboration.',
                    'Creators tracking how their energy lands across audiences.',
                  ].map((t) => R.jsx('li', { className: 'list-item', children: t }, t)),
                }),
              ],
            }),
            R.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                R.jsx('p', {
                  className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                  children: 'Mini FAQ',
                }),
                R.jsxs('div', {
                  className: 'mt-4 space-y-4 text-sm text-slate-300',
                  children: [
                    R.jsxs('div', {
                      children: [
                        R.jsx('p', {
                          className: 'font-semibold text-slate-100',
                          children: 'Is this stored in the cloud?',
                        }),
                        R.jsx('p', {
                          className: 'mt-1 text-slate-400',
                          children:
                            'No. Tokens are stored locally in your browser and encrypted in transit.',
                        }),
                      ],
                    }),
                    R.jsxs('div', {
                      children: [
                        R.jsx('p', {
                          className: 'font-semibold text-slate-100',
                          children: 'Can I retake the quiz?',
                        }),
                        R.jsx('p', {
                          className: 'mt-1 text-slate-400',
                          children:
                            'One session per pass. Use the restore tool to revisit your profile any time.',
                        }),
                      ],
                    }),
                    R.jsxs('div', {
                      children: [
                        R.jsx('p', {
                          className: 'font-semibold text-slate-100',
                          children: 'How long does it take?',
                        }),
                        R.jsx('p', {
                          className: 'mt-1 text-slate-400',
                          children: 'Less than 6 minutes for most people.',
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
          ],
        }),
      ],
    }),
  af = [
    {
      id: 1,
      text: 'I enjoy being the person others look to for direction.',
      trait: 'N',
      rationale: 'Captures comfort with visibility and influence within groups.',
    },
    {
      id: 2,
      text: 'I plan my social moves with long-term outcomes in mind.',
      trait: 'M',
      rationale: 'Checks for strategy-driven social navigation.',
    },
    {
      id: 3,
      text: 'I can stay calm when others get emotional around me.',
      trait: 'P',
      rationale: 'Measures emotional detachment under pressure.',
    },
    {
      id: 4,
      text: 'I pay attention to how people can be guided toward a goal.',
      trait: 'MD',
      rationale: 'Tracks comfort with directing group dynamics.',
    },
    {
      id: 5,
      text: 'It feels natural to set the tone in a room.',
      trait: 'N',
      rationale: 'Assesses ease with status-setting behaviors.',
    },
    {
      id: 6,
      text: 'I keep a quiet mental map of other peoples priorities.',
      trait: 'M',
      rationale: 'Tests awareness of leverage points.',
    },
    {
      id: 7,
      text: 'I rarely feel guilty after making a hard decision.',
      trait: 'P',
      rationale: 'Signals low emotional friction after decisive actions.',
    },
    {
      id: 8,
      text: 'When needed, I can mirror someones style to build rapport.',
      trait: 'MD',
      rationale: 'Tracks adaptive influence tactics.',
    },
    {
      id: 9,
      text: 'Compliments feel better when they are public.',
      trait: 'N',
      rationale: 'Evaluates preference for public recognition.',
    },
    {
      id: 10,
      text: 'I hold back information until the timing feels right.',
      trait: 'M',
      rationale: 'Measures calculated disclosure behavior.',
    },
    {
      id: 11,
      text: 'Rules are flexible if the outcome is important enough.',
      trait: 'P',
      safetyTrigger: !0,
      rationale: 'Checks willingness to bend boundaries under pressure.',
    },
    {
      id: 12,
      text: 'I can separate feelings from outcomes with ease.',
      trait: 'P',
      rationale: 'Tests emotional compartmentalization.',
    },
    {
      id: 13,
      text: 'I prefer to be the person others consult before acting.',
      trait: 'N',
      rationale: 'Assesses influence-seeking behavior.',
    },
    {
      id: 14,
      text: 'I notice the social leverage in almost every situation.',
      trait: 'M',
      rationale: 'Tracks analytical social awareness.',
    },
    {
      id: 15,
      text: 'I am comfortable using pressure to keep things on track.',
      trait: 'MD',
      safetyTrigger: !0,
      rationale: 'Identifies comfort with forceful coordination.',
    },
    {
      id: 16,
      text: 'People describe me as intense.',
      trait: 'P',
      rationale: 'Captures intensity linked to bold decision making.',
    },
    {
      id: 17,
      text: 'I carefully manage the image people have of me.',
      trait: 'N',
      rationale: 'Tests image management orientation.',
    },
    {
      id: 18,
      text: 'I can persuade someone even when they disagree.',
      trait: 'MD',
      safetyTrigger: !0,
      rationale: 'Evaluates persuasion confidence under resistance.',
    },
    {
      id: 19,
      text: 'I keep multiple options open when negotiating.',
      trait: 'M',
      rationale: 'Measures contingency planning in negotiations.',
    },
    {
      id: 20,
      text: 'I focus on outcomes more than emotional fallout.',
      trait: 'P',
      rationale: 'Tracks priority on results over feelings.',
    },
    {
      id: 21,
      text: 'I enjoy being a visible source of momentum.',
      trait: 'N',
      rationale: 'Gauges enjoyment of being the catalyst.',
    },
    {
      id: 22,
      text: 'I notice when someone is predictable and plan around it.',
      trait: 'M',
      rationale: 'Assesses strategic adaptation to predictability.',
    },
    {
      id: 23,
      text: 'I can stay composed even when others are upset with me.',
      trait: 'P',
      rationale: 'Checks emotional steadiness under criticism.',
    },
    {
      id: 24,
      text: 'Im good at guiding a conversation toward the outcome I want.',
      trait: 'MD',
      rationale: 'Measures conversational steering confidence.',
    },
    {
      id: 25,
      text: 'I like to be recognized for my taste and standards.',
      trait: 'N',
      rationale: 'Tracks desire for recognition of discernment.',
    },
    {
      id: 26,
      text: 'I avoid showing all my cards right away.',
      trait: 'M',
      rationale: 'Checks for guarded positioning.',
    },
    {
      id: 27,
      text: 'I can disconnect from a situation if it becomes inconvenient.',
      trait: 'P',
      rationale: 'Measures ease of detachment.',
    },
    {
      id: 28,
      text: 'I adapt my approach to fit whoever Im with.',
      trait: 'MD',
      rationale: 'Tracks adaptive social shaping.',
    },
    {
      id: 29,
      text: 'Its important that others see the best version of me.',
      trait: 'N',
      rationale: 'Assesses presentation focus.',
    },
    {
      id: 30,
      text: 'I am rarely surprised by other peoples motives.',
      trait: 'M',
      rationale: 'Checks for predictive social thinking.',
    },
    {
      id: 31,
      text: 'I believe honesty should be consistent, even under pressure.',
      trait: 'M',
      reverse: !0,
      lieTrap: !0,
      rationale: 'Reverse-coded to detect contradictions with strategic behavior.',
    },
    {
      id: 32,
      text: 'I feel uneasy when someone is treated unfairly.',
      trait: 'P',
      reverse: !0,
      lieTrap: !0,
      rationale: 'Reverse-coded to detect emotional distance.',
    },
  ],
  sk = ['Not me', 'Rarely me', 'Often me', 'Definitely me'],
  ak = {
    hidden: { opacity: 0, y: 12 },
    visible: (t) => ({ opacity: 1, y: 0, transition: { delay: 0.08 * t } }),
  },
  lk = ({ question: t, sequence: e, total: n, onAnswer: r }) =>
    R.jsxs(
      Kn.div,
      {
        initial: { opacity: 0, y: 16 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: -12 },
        transition: { duration: 0.3 },
        className: 'glass-panel p-6',
        children: [
          R.jsxs('div', {
            className:
              'flex items-center justify-between text-xs uppercase tracking-[0.2em] text-slate-400',
            children: [
              R.jsxs('span', { children: ['Question ', e, ' of ', n] }),
              R.jsx('span', {
                className: 'rounded-full bg-white/10 px-3 py-1',
                children: 'Vibe Prism',
              }),
            ],
          }),
          R.jsx('h2', { className: 'mt-4 text-2xl font-semibold text-slate-50', children: t.text }),
          R.jsx('p', { className: 'mt-2 text-sm text-slate-400', children: t.rationale }),
          R.jsx('div', {
            className: 'mt-6 grid gap-3',
            children: sk.map((i, s) =>
              R.jsxs(
                Kn.button,
                {
                  type: 'button',
                  custom: s,
                  variants: ak,
                  initial: 'hidden',
                  animate: 'visible',
                  onClick: () => r(s),
                  className:
                    'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-4 py-3 text-left text-sm font-medium text-slate-100 transition hover:border-emerald-400/40 hover:bg-emerald-500/10',
                  children: [
                    R.jsx('span', { children: i }),
                    R.jsx('span', { className: 'text-xs text-slate-400', children: s }),
                  ],
                },
                i
              )
            ),
          }),
        ],
      },
      t.id
    ),
  ck = ({ value: t }) =>
    R.jsx('div', {
      className: 'h-2 w-full overflow-hidden rounded-full bg-white/10',
      children: R.jsx(Kn.div, {
        className:
          'h-full bg-gradient-to-r from-emerald-500/40 via-emerald-400/50 to-emerald-300/60',
        initial: { width: 0 },
        animate: { width: `${t}%` },
        transition: { duration: 0.4 },
      }),
    }),
  uk = (t) => {
    const e = [...t]
    for (let n = e.length - 1; n > 0; n -= 1) {
      const r = Math.floor(Math.random() * (n + 1))
      ;[e[n], e[r]] = [e[r], e[n]]
    }
    return e
  },
  Dd = (t) => Math.min(100, Math.max(0, Math.round(t))),
  hk = { N: 1, M: 1.2, P: 1.4, MD: 1.3 },
  dk = (t, e) => {
    const n = { N: 0, M: 0, P: 0, MD: 0 },
      r = { N: 0, M: 0, P: 0, MD: 0 },
      i = new Map(e.map((O) => [O.questionId, O]))
    let s = !1,
      c = !1,
      h = 0
    t.forEach((O) => {
      const F = i.get(O.id)
      if (!F) return
      const z = O.reverse ? 3 - F.answer : F.answer
      ;((n[O.trait] += z),
        (r[O.trait] += 1),
        (h += F.answer),
        F.rtMs < 450 && F.answer >= 2 && (s = !0),
        O.lieTrap && F.answer >= 2 && (c = !0))
    })
    const f = h / e.length >= 2.7,
      p = Object.keys(n).reduce(
        (O, F) => {
          const z = r[F] * 3,
            V = (z > 0 ? (n[F] / z) * 100 : 0) * hk[F]
          return ((O[F] = Dd(V)), O)
        },
        { N: 0, M: 0, P: 0, MD: 0 }
      ),
      y = { masking: s, contradictions: c, halo: f },
      w = Object.values(y).filter(Boolean).length,
      x = Math.max(70, 100 - w * 10),
      E = 0.9 * p.N + 1.1 * p.M + 1.3 * p.P,
      S = Dd(E / 3),
      k = w >= 2 ? Dd(S * 1.25) : S,
      D = t
        .filter((O) => O.safetyTrigger)
        .map((O) => {
          const F = i.get(O.id)
          return F && F.answer >= 2 ? `Q${O.id}: ${O.text}` : null
        })
        .filter((O) => !!O)
    p.P > 75 && p.MD > 60 && D.push('Trait combination: P > 75 and MD > 60')
    const _ = { triggered: D.length > 0, triggers: D }
    let N = 'GREEN'
    k >= 60 || _.triggered ? (N = 'RED') : k >= 35 && (N = 'YELLOW')
    const M =
      p.P >= 70 && p.M >= 70
        ? 'APX'
        : p.M >= 70 && p.MD >= 70
          ? 'PUP'
          : p.N >= 70
            ? 'EGO'
            : p.M >= 60 && p.N >= 55
              ? 'SMR'
              : Math.max(p.N, p.M, p.P, p.MD) < 45
                ? 'LOW'
                : 'DRM'
    return {
      scores: p,
      dtiBase: S,
      dtiFinal: k,
      band: N,
      archetype: M,
      integrity: x,
      integrityFlags: y,
      safetyOverrides: _,
    }
  },
  fk = (t) => btoa(t).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''),
  t3 = (t) => {
    const e = t.replace(/-/g, '+').replace(/_/g, '/'),
      n = (4 - (e.length % 4)) % 4,
      r = e + '='.repeat(n)
    return atob(r)
  },
  ep = async (t) => {
    const e = new TextEncoder().encode(t),
      n = await crypto.subtle.digest('SHA-256', e)
    return Array.from(new Uint8Array(n))
      .map((r) => r.toString(16).padStart(2, '0'))
      .join('')
  },
  vh = { attempt: 'VIBE_PRISM_ATTEMPT', token: 'VIBE_PRISM_LAST_TOKEN' },
  pk = () => {
    localStorage.setItem(vh.attempt, new Date().toISOString())
  },
  gk = () => !!localStorage.getItem(vh.attempt),
  mk = (t) => {
    localStorage.setItem(vh.token, t)
  },
  e3 = () => localStorage.getItem(vh.token),
  yk = () => {
    const t = b0(),
      [e, n] = X.useState(!1),
      [r, i] = X.useState(0),
      [s, c] = X.useState([]),
      h = X.useRef(crypto.randomUUID()),
      f = X.useRef(performance.now())
    X.useEffect(() => {
      n(gk())
    }, [])
    const p = X.useMemo(() => uk(af), []),
      y = ((r + 1) / p.length) * 100,
      w = async (x) => {
        const E = p[r],
          S = Math.round(performance.now() - f.current),
          k = [...s, { questionId: E.id, answer: x, rtMs: S }]
        if ((c(k), r === p.length - 1)) {
          const D = dk(af, k),
            _ = JSON.stringify(k),
            N = `masking:${D.integrityFlags.masking};contradictions:${D.integrityFlags.contradictions};halo:${D.integrityFlags.halo}`,
            M = D.safetyOverrides.triggers.join('~') || 'none',
            O = [
              'VP1',
              h.current,
              new Date().toISOString(),
              D.band,
              D.dtiBase.toString(),
              D.dtiFinal.toString(),
              D.scores.N.toString(),
              D.scores.M.toString(),
              D.scores.P.toString(),
              D.scores.MD.toString(),
              D.integrity.toString(),
              D.archetype,
              N,
              M,
              _,
            ].join('|'),
            F = (await ep(O)).slice(0, 8),
            z = fk(`${O}|${F}`)
          ;(mk(z), pk(), t('/result'))
          return
        }
        ;(i((D) => D + 1), (f.current = performance.now()))
      }
    return e
      ? R.jsx('div', {
          className: 'mx-auto flex w-full max-w-3xl flex-col gap-6 px-6 py-16',
          children: R.jsxs('div', {
            className: 'glass-panel p-6',
            children: [
              R.jsxs('div', {
                className: 'flex items-center gap-3',
                children: [
                  R.jsx(Eo, { size: 24, className: 'text-emerald-300' }),
                  R.jsxs('div', {
                    children: [
                      R.jsx('h2', {
                        className: 'text-xl font-semibold',
                        children: 'One attempt per session',
                      }),
                      R.jsx('p', {
                        className: 'text-sm text-slate-400',
                        children:
                          'This quiz allows only a single pass. You can restore your latest profile or continue to the decoder if you have a token.',
                      }),
                    ],
                  }),
                ],
              }),
              R.jsxs('div', {
                className: 'mt-6 flex flex-wrap gap-3',
                children: [
                  R.jsx(tr, {
                    to: '/result',
                    className: 'button-primary',
                    children: 'View results',
                  }),
                  R.jsx(tr, {
                    to: '/restore',
                    className: 'button-secondary',
                    children: 'Restore profile',
                  }),
                ],
              }),
            ],
          }),
        })
      : R.jsxs('div', {
          className: 'mx-auto flex w-full max-w-6xl flex-col gap-6 px-6 py-16',
          children: [
            R.jsxs('div', {
              className:
                'flex flex-wrap items-center justify-between gap-4 text-xs uppercase tracking-[0.3em] text-slate-400',
              children: [
                R.jsx('span', { children: 'Vibe Prism  quiz flow' }),
                R.jsxs('span', { children: [r + 1, ' / ', p.length] }),
              ],
            }),
            R.jsx(ck, { value: y }),
            R.jsxs('div', {
              className: 'grid gap-6 lg:grid-cols-[1.2fr_0.8fr]',
              children: [
                R.jsx(Kn.div, {
                  layout: !0,
                  children: R.jsx(lk, {
                    question: p[r],
                    sequence: r + 1,
                    total: p.length,
                    onAnswer: w,
                  }),
                }),
                R.jsxs('div', {
                  className: 'flex flex-col gap-4',
                  children: [
                    R.jsxs('div', {
                      className: 'glass-panel p-6',
                      children: [
                        R.jsxs('div', {
                          className: 'flex items-center gap-3',
                          children: [
                            R.jsx(Qs, { size: 20, className: 'text-emerald-300' }),
                            R.jsxs('div', {
                              children: [
                                R.jsx('h3', {
                                  className: 'text-lg font-semibold',
                                  children: 'Session Guidance',
                                }),
                                R.jsx('p', {
                                  className: 'text-sm text-slate-400',
                                  children:
                                    'Answer quickly, but stay honest. The system listens for clarity.',
                                }),
                              ],
                            }),
                          ],
                        }),
                        R.jsx('ul', {
                          className: 'mt-4 space-y-2 text-sm text-slate-300',
                          children: [
                            'No backtracking once you move forward.',
                            'Response timing shapes integrity scores.',
                            'Your token is stored on this device only.',
                          ].map((x) => R.jsx('li', { className: 'list-item', children: x }, x)),
                        }),
                      ],
                    }),
                    R.jsxs('div', {
                      className: 'glass-panel p-6',
                      children: [
                        R.jsxs('div', {
                          className: 'flex items-center gap-3',
                          children: [
                            R.jsx($6, { size: 20, className: 'text-emerald-300' }),
                            R.jsxs('div', {
                              children: [
                                R.jsx('h3', {
                                  className: 'text-lg font-semibold',
                                  children: 'Answer Scale',
                                }),
                                R.jsx('p', {
                                  className: 'text-sm text-slate-400',
                                  children: 'Score 0-3 based on how true each statement feels.',
                                }),
                              ],
                            }),
                          ],
                        }),
                        R.jsxs('div', {
                          className: 'mt-4 grid gap-2 text-sm text-slate-300',
                          children: [
                            R.jsxs('div', {
                              className:
                                'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                              children: [
                                R.jsx('span', { children: '0' }),
                                R.jsx('span', { className: 'text-slate-400', children: 'Not me' }),
                              ],
                            }),
                            R.jsxs('div', {
                              className:
                                'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                              children: [
                                R.jsx('span', { children: '1' }),
                                R.jsx('span', {
                                  className: 'text-slate-400',
                                  children: 'Rarely true',
                                }),
                              ],
                            }),
                            R.jsxs('div', {
                              className:
                                'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                              children: [
                                R.jsx('span', { children: '2' }),
                                R.jsx('span', {
                                  className: 'text-slate-400',
                                  children: 'Often true',
                                }),
                              ],
                            }),
                            R.jsxs('div', {
                              className:
                                'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                              children: [
                                R.jsx('span', { children: '3' }),
                                R.jsx('span', {
                                  className: 'text-slate-400',
                                  children: 'Always true',
                                }),
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
          ],
        })
  }
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */ function Wl(t) {
  return (t + 0.5) | 0
}
const mi = (t, e, n) => Math.max(Math.min(t, n), e)
function Da(t) {
  return mi(Wl(t * 2.55), 0, 255)
}
function Ni(t) {
  return mi(Wl(t * 255), 0, 255)
}
function Br(t) {
  return mi(Wl(t / 2.55) / 100, 0, 1)
}
function mm(t) {
  return mi(Wl(t * 100), 0, 100)
}
const Xn = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
  },
  lf = [...'0123456789ABCDEF'],
  wk = (t) => lf[t & 15],
  bk = (t) => lf[(t & 240) >> 4] + lf[t & 15],
  Ec = (t) => (t & 240) >> 4 === (t & 15),
  vk = (t) => Ec(t.r) && Ec(t.g) && Ec(t.b) && Ec(t.a)
function xk(t) {
  var e = t.length,
    n
  return (
    t[0] === '#' &&
      (e === 4 || e === 5
        ? (n = {
            r: 255 & (Xn[t[1]] * 17),
            g: 255 & (Xn[t[2]] * 17),
            b: 255 & (Xn[t[3]] * 17),
            a: e === 5 ? Xn[t[4]] * 17 : 255,
          })
        : (e === 7 || e === 9) &&
          (n = {
            r: (Xn[t[1]] << 4) | Xn[t[2]],
            g: (Xn[t[3]] << 4) | Xn[t[4]],
            b: (Xn[t[5]] << 4) | Xn[t[6]],
            a: e === 9 ? (Xn[t[7]] << 4) | Xn[t[8]] : 255,
          })),
    n
  )
}
const Ek = (t, e) => (t < 255 ? e(t) : '')
function Ck(t) {
  var e = vk(t) ? wk : bk
  return t ? '#' + e(t.r) + e(t.g) + e(t.b) + Ek(t.a, e) : void 0
}
const Sk =
  /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/
function n3(t, e, n) {
  const r = e * Math.min(n, 1 - n),
    i = (s, c = (s + t / 30) % 12) => n - r * Math.max(Math.min(c - 3, 9 - c, 1), -1)
  return [i(0), i(8), i(4)]
}
function Ak(t, e, n) {
  const r = (i, s = (i + t / 60) % 6) => n - n * e * Math.max(Math.min(s, 4 - s, 1), 0)
  return [r(5), r(3), r(1)]
}
function kk(t, e, n) {
  const r = n3(t, 1, 0.5)
  let i
  for (e + n > 1 && ((i = 1 / (e + n)), (e *= i), (n *= i)), i = 0; i < 3; i++)
    ((r[i] *= 1 - e - n), (r[i] += e))
  return r
}
function Ik(t, e, n, r, i) {
  return t === i ? (e - n) / r + (e < n ? 6 : 0) : e === i ? (n - t) / r + 2 : (t - e) / r + 4
}
function np(t) {
  const e = t.r / 255,
    n = t.g / 255,
    r = t.b / 255,
    i = Math.max(e, n, r),
    s = Math.min(e, n, r),
    c = (i + s) / 2
  let h, f, p
  return (
    i !== s &&
      ((p = i - s),
      (f = c > 0.5 ? p / (2 - i - s) : p / (i + s)),
      (h = Ik(e, n, r, p, i)),
      (h = h * 60 + 0.5)),
    [h | 0, f || 0, c]
  )
}
function rp(t, e, n, r) {
  return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, r)).map(Ni)
}
function ip(t, e, n) {
  return rp(n3, t, e, n)
}
function _k(t, e, n) {
  return rp(kk, t, e, n)
}
function Rk(t, e, n) {
  return rp(Ak, t, e, n)
}
function r3(t) {
  return ((t % 360) + 360) % 360
}
function Tk(t) {
  const e = Sk.exec(t)
  let n = 255,
    r
  if (!e) return
  e[5] !== r && (n = e[6] ? Da(+e[5]) : Ni(+e[5]))
  const i = r3(+e[2]),
    s = +e[3] / 100,
    c = +e[4] / 100
  return (
    e[1] === 'hwb' ? (r = _k(i, s, c)) : e[1] === 'hsv' ? (r = Rk(i, s, c)) : (r = ip(i, s, c)),
    { r: r[0], g: r[1], b: r[2], a: n }
  )
}
function Nk(t, e) {
  var n = np(t)
  ;((n[0] = r3(n[0] + e)), (n = ip(n)), (t.r = n[0]), (t.g = n[1]), (t.b = n[2]))
}
function Mk(t) {
  if (!t) return
  const e = np(t),
    n = e[0],
    r = mm(e[1]),
    i = mm(e[2])
  return t.a < 255 ? `hsla(${n}, ${r}%, ${i}%, ${Br(t.a)})` : `hsl(${n}, ${r}%, ${i}%)`
}
const ym = {
    x: 'dark',
    Z: 'light',
    Y: 're',
    X: 'blu',
    W: 'gr',
    V: 'medium',
    U: 'slate',
    A: 'ee',
    T: 'ol',
    S: 'or',
    B: 'ra',
    C: 'lateg',
    D: 'ights',
    R: 'in',
    Q: 'turquois',
    E: 'hi',
    P: 'ro',
    O: 'al',
    N: 'le',
    M: 'de',
    L: 'yello',
    F: 'en',
    K: 'ch',
    G: 'arks',
    H: 'ea',
    I: 'ightg',
    J: 'wh',
  },
  wm = {
    OiceXe: 'f0f8ff',
    antiquewEte: 'faebd7',
    aqua: 'ffff',
    aquamarRe: '7fffd4',
    azuY: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '0',
    blanKedOmond: 'ffebcd',
    Xe: 'ff',
    XeviTet: '8a2be2',
    bPwn: 'a52a2a',
    burlywood: 'deb887',
    caMtXe: '5f9ea0',
    KartYuse: '7fff00',
    KocTate: 'd2691e',
    cSO: 'ff7f50',
    cSnflowerXe: '6495ed',
    cSnsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: 'ffff',
    xXe: '8b',
    xcyan: '8b8b',
    xgTMnPd: 'b8860b',
    xWay: 'a9a9a9',
    xgYF: '6400',
    xgYy: 'a9a9a9',
    xkhaki: 'bdb76b',
    xmagFta: '8b008b',
    xTivegYF: '556b2f',
    xSange: 'ff8c00',
    xScEd: '9932cc',
    xYd: '8b0000',
    xsOmon: 'e9967a',
    xsHgYF: '8fbc8f',
    xUXe: '483d8b',
    xUWay: '2f4f4f',
    xUgYy: '2f4f4f',
    xQe: 'ced1',
    xviTet: '9400d3',
    dAppRk: 'ff1493',
    dApskyXe: 'bfff',
    dimWay: '696969',
    dimgYy: '696969',
    dodgerXe: '1e90ff',
    fiYbrick: 'b22222',
    flSOwEte: 'fffaf0',
    foYstWAn: '228b22',
    fuKsia: 'ff00ff',
    gaRsbSo: 'dcdcdc',
    ghostwEte: 'f8f8ff',
    gTd: 'ffd700',
    gTMnPd: 'daa520',
    Way: '808080',
    gYF: '8000',
    gYFLw: 'adff2f',
    gYy: '808080',
    honeyMw: 'f0fff0',
    hotpRk: 'ff69b4',
    RdianYd: 'cd5c5c',
    Rdigo: '4b0082',
    ivSy: 'fffff0',
    khaki: 'f0e68c',
    lavFMr: 'e6e6fa',
    lavFMrXsh: 'fff0f5',
    lawngYF: '7cfc00',
    NmoncEffon: 'fffacd',
    ZXe: 'add8e6',
    ZcSO: 'f08080',
    Zcyan: 'e0ffff',
    ZgTMnPdLw: 'fafad2',
    ZWay: 'd3d3d3',
    ZgYF: '90ee90',
    ZgYy: 'd3d3d3',
    ZpRk: 'ffb6c1',
    ZsOmon: 'ffa07a',
    ZsHgYF: '20b2aa',
    ZskyXe: '87cefa',
    ZUWay: '778899',
    ZUgYy: '778899',
    ZstAlXe: 'b0c4de',
    ZLw: 'ffffe0',
    lime: 'ff00',
    limegYF: '32cd32',
    lRF: 'faf0e6',
    magFta: 'ff00ff',
    maPon: '800000',
    VaquamarRe: '66cdaa',
    VXe: 'cd',
    VScEd: 'ba55d3',
    VpurpN: '9370db',
    VsHgYF: '3cb371',
    VUXe: '7b68ee',
    VsprRggYF: 'fa9a',
    VQe: '48d1cc',
    VviTetYd: 'c71585',
    midnightXe: '191970',
    mRtcYam: 'f5fffa',
    mistyPse: 'ffe4e1',
    moccasR: 'ffe4b5',
    navajowEte: 'ffdead',
    navy: '80',
    Tdlace: 'fdf5e6',
    Tive: '808000',
    TivedBb: '6b8e23',
    Sange: 'ffa500',
    SangeYd: 'ff4500',
    ScEd: 'da70d6',
    pOegTMnPd: 'eee8aa',
    pOegYF: '98fb98',
    pOeQe: 'afeeee',
    pOeviTetYd: 'db7093',
    papayawEp: 'ffefd5',
    pHKpuff: 'ffdab9',
    peru: 'cd853f',
    pRk: 'ffc0cb',
    plum: 'dda0dd',
    powMrXe: 'b0e0e6',
    purpN: '800080',
    YbeccapurpN: '663399',
    Yd: 'ff0000',
    Psybrown: 'bc8f8f',
    PyOXe: '4169e1',
    saddNbPwn: '8b4513',
    sOmon: 'fa8072',
    sandybPwn: 'f4a460',
    sHgYF: '2e8b57',
    sHshell: 'fff5ee',
    siFna: 'a0522d',
    silver: 'c0c0c0',
    skyXe: '87ceeb',
    UXe: '6a5acd',
    UWay: '708090',
    UgYy: '708090',
    snow: 'fffafa',
    sprRggYF: 'ff7f',
    stAlXe: '4682b4',
    tan: 'd2b48c',
    teO: '8080',
    tEstN: 'd8bfd8',
    tomato: 'ff6347',
    Qe: '40e0d0',
    viTet: 'ee82ee',
    JHt: 'f5deb3',
    wEte: 'ffffff',
    wEtesmoke: 'f5f5f5',
    Lw: 'ffff00',
    LwgYF: '9acd32',
  }
function Dk() {
  const t = {},
    e = Object.keys(wm),
    n = Object.keys(ym)
  let r, i, s, c, h
  for (r = 0; r < e.length; r++) {
    for (c = h = e[r], i = 0; i < n.length; i++) ((s = n[i]), (h = h.replace(s, ym[s])))
    ;((s = parseInt(wm[c], 16)), (t[h] = [(s >> 16) & 255, (s >> 8) & 255, s & 255]))
  }
  return t
}
let Cc
function Pk(t) {
  Cc || ((Cc = Dk()), (Cc.transparent = [0, 0, 0, 0]))
  const e = Cc[t.toLowerCase()]
  return e && { r: e[0], g: e[1], b: e[2], a: e.length === 4 ? e[3] : 255 }
}
const Lk =
  /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/
function Ok(t) {
  const e = Lk.exec(t)
  let n = 255,
    r,
    i,
    s
  if (e) {
    if (e[7] !== r) {
      const c = +e[7]
      n = e[8] ? Da(c) : mi(c * 255, 0, 255)
    }
    return (
      (r = +e[1]),
      (i = +e[3]),
      (s = +e[5]),
      (r = 255 & (e[2] ? Da(r) : mi(r, 0, 255))),
      (i = 255 & (e[4] ? Da(i) : mi(i, 0, 255))),
      (s = 255 & (e[6] ? Da(s) : mi(s, 0, 255))),
      { r, g: i, b: s, a: n }
    )
  }
}
function Bk(t) {
  return (
    t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${Br(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`)
  )
}
const Pd = (t) => (t <= 0.0031308 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - 0.055),
  ns = (t) => (t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4))
function Fk(t, e, n) {
  const r = ns(Br(t.r)),
    i = ns(Br(t.g)),
    s = ns(Br(t.b))
  return {
    r: Ni(Pd(r + n * (ns(Br(e.r)) - r))),
    g: Ni(Pd(i + n * (ns(Br(e.g)) - i))),
    b: Ni(Pd(s + n * (ns(Br(e.b)) - s))),
    a: t.a + n * (e.a - t.a),
  }
}
function Sc(t, e, n) {
  if (t) {
    let r = np(t)
    ;((r[e] = Math.max(0, Math.min(r[e] + r[e] * n, e === 0 ? 360 : 1))),
      (r = ip(r)),
      (t.r = r[0]),
      (t.g = r[1]),
      (t.b = r[2]))
  }
}
function i3(t, e) {
  return t && Object.assign(e || {}, t)
}
function bm(t) {
  var e = { r: 0, g: 0, b: 0, a: 255 }
  return (
    Array.isArray(t)
      ? t.length >= 3 &&
        ((e = { r: t[0], g: t[1], b: t[2], a: 255 }), t.length > 3 && (e.a = Ni(t[3])))
      : ((e = i3(t, { r: 0, g: 0, b: 0, a: 1 })), (e.a = Ni(e.a))),
    e
  )
}
function jk(t) {
  return t.charAt(0) === 'r' ? Ok(t) : Tk(t)
}
class Al {
  constructor(e) {
    if (e instanceof Al) return e
    const n = typeof e
    let r
    ;(n === 'object' ? (r = bm(e)) : n === 'string' && (r = xk(e) || Pk(e) || jk(e)),
      (this._rgb = r),
      (this._valid = !!r))
  }
  get valid() {
    return this._valid
  }
  get rgb() {
    var e = i3(this._rgb)
    return (e && (e.a = Br(e.a)), e)
  }
  set rgb(e) {
    this._rgb = bm(e)
  }
  rgbString() {
    return this._valid ? Bk(this._rgb) : void 0
  }
  hexString() {
    return this._valid ? Ck(this._rgb) : void 0
  }
  hslString() {
    return this._valid ? Mk(this._rgb) : void 0
  }
  mix(e, n) {
    if (e) {
      const r = this.rgb,
        i = e.rgb
      let s
      const c = n === s ? 0.5 : n,
        h = 2 * c - 1,
        f = r.a - i.a,
        p = ((h * f === -1 ? h : (h + f) / (1 + h * f)) + 1) / 2
      ;((s = 1 - p),
        (r.r = 255 & (p * r.r + s * i.r + 0.5)),
        (r.g = 255 & (p * r.g + s * i.g + 0.5)),
        (r.b = 255 & (p * r.b + s * i.b + 0.5)),
        (r.a = c * r.a + (1 - c) * i.a),
        (this.rgb = r))
    }
    return this
  }
  interpolate(e, n) {
    return (e && (this._rgb = Fk(this._rgb, e._rgb, n)), this)
  }
  clone() {
    return new Al(this.rgb)
  }
  alpha(e) {
    return ((this._rgb.a = Ni(e)), this)
  }
  clearer(e) {
    const n = this._rgb
    return ((n.a *= 1 - e), this)
  }
  greyscale() {
    const e = this._rgb,
      n = Wl(e.r * 0.3 + e.g * 0.59 + e.b * 0.11)
    return ((e.r = e.g = e.b = n), this)
  }
  opaquer(e) {
    const n = this._rgb
    return ((n.a *= 1 + e), this)
  }
  negate() {
    const e = this._rgb
    return ((e.r = 255 - e.r), (e.g = 255 - e.g), (e.b = 255 - e.b), this)
  }
  lighten(e) {
    return (Sc(this._rgb, 2, e), this)
  }
  darken(e) {
    return (Sc(this._rgb, 2, -e), this)
  }
  saturate(e) {
    return (Sc(this._rgb, 1, e), this)
  }
  desaturate(e) {
    return (Sc(this._rgb, 1, -e), this)
  }
  rotate(e) {
    return (Nk(this._rgb, e), this)
  }
}
/*!
 * Chart.js v4.5.1
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */ function Nr() {}
const Vk = (() => {
  let t = 0
  return () => t++
})()
function Ot(t) {
  return t == null
}
function ce(t) {
  if (Array.isArray && Array.isArray(t)) return !0
  const e = Object.prototype.toString.call(t)
  return e.slice(0, 7) === '[object' && e.slice(-6) === 'Array]'
}
function Mt(t) {
  return t !== null && Object.prototype.toString.call(t) === '[object Object]'
}
function Be(t) {
  return (typeof t == 'number' || t instanceof Number) && isFinite(+t)
}
function vr(t, e) {
  return Be(t) ? t : e
}
function It(t, e) {
  return typeof t > 'u' ? e : t
}
const Wk = (t, e) => (typeof t == 'string' && t.endsWith('%') ? (parseFloat(t) / 100) * e : +t)
function Qt(t, e, n) {
  if (t && typeof t.call == 'function') return t.apply(n, e)
}
function zt(t, e, n, r) {
  let i, s, c
  if (ce(t)) for (s = t.length, i = 0; i < s; i++) e.call(n, t[i], i)
  else if (Mt(t)) for (c = Object.keys(t), s = c.length, i = 0; i < s; i++) e.call(n, t[c[i]], c[i])
}
function Bu(t, e) {
  let n, r, i, s
  if (!t || !e || t.length !== e.length) return !1
  for (n = 0, r = t.length; n < r; ++n)
    if (((i = t[n]), (s = e[n]), i.datasetIndex !== s.datasetIndex || i.index !== s.index))
      return !1
  return !0
}
function Fu(t) {
  if (ce(t)) return t.map(Fu)
  if (Mt(t)) {
    const e = Object.create(null),
      n = Object.keys(t),
      r = n.length
    let i = 0
    for (; i < r; ++i) e[n[i]] = Fu(t[n[i]])
    return e
  }
  return t
}
function o3(t) {
  return ['__proto__', 'prototype', 'constructor'].indexOf(t) === -1
}
function Uk(t, e, n, r) {
  if (!o3(t)) return
  const i = e[t],
    s = n[t]
  Mt(i) && Mt(s) ? kl(i, s, r) : (e[t] = Fu(s))
}
function kl(t, e, n) {
  const r = ce(e) ? e : [e],
    i = r.length
  if (!Mt(t)) return t
  n = n || {}
  const s = n.merger || Uk
  let c
  for (let h = 0; h < i; ++h) {
    if (((c = r[h]), !Mt(c))) continue
    const f = Object.keys(c)
    for (let p = 0, y = f.length; p < y; ++p) s(f[p], t, c, n)
  }
  return t
}
function qa(t, e) {
  return kl(t, e, { merger: zk })
}
function zk(t, e, n) {
  if (!o3(t)) return
  const r = e[t],
    i = n[t]
  Mt(r) && Mt(i) ? qa(r, i) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = Fu(i))
}
const vm = { '': (t) => t, x: (t) => t.x, y: (t) => t.y }
function Hk(t) {
  const e = t.split('.'),
    n = []
  let r = ''
  for (const i of e)
    ((r += i), r.endsWith('\\') ? (r = r.slice(0, -1) + '.') : (n.push(r), (r = '')))
  return n
}
function Xk(t) {
  const e = Hk(t)
  return (n) => {
    for (const r of e) {
      if (r === '') break
      n = n && n[r]
    }
    return n
  }
}
function Co(t, e) {
  return (vm[e] || (vm[e] = Xk(e)))(t)
}
function op(t) {
  return t.charAt(0).toUpperCase() + t.slice(1)
}
const Il = (t) => typeof t < 'u',
  Oi = (t) => typeof t == 'function',
  xm = (t, e) => {
    if (t.size !== e.size) return !1
    for (const n of t) if (!e.has(n)) return !1
    return !0
  }
function Gk(t) {
  return t.type === 'mouseup' || t.type === 'click' || t.type === 'contextmenu'
}
const Oe = Math.PI,
  Ln = 2 * Oe,
  Yk = Ln + Oe,
  ju = Number.POSITIVE_INFINITY,
  Zk = Oe / 180,
  Nn = Oe / 2,
  Ki = Oe / 4,
  Em = (Oe * 2) / 3,
  s3 = Math.log10,
  Rr = Math.sign
function Ka(t, e, n) {
  return Math.abs(t - e) < n
}
function Cm(t) {
  const e = Math.round(t)
  t = Ka(t, e, t / 1e3) ? e : t
  const n = Math.pow(10, Math.floor(s3(t))),
    r = t / n
  return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n
}
function qk(t) {
  const e = [],
    n = Math.sqrt(t)
  let r
  for (r = 1; r < n; r++) t % r === 0 && (e.push(r), e.push(t / r))
  return (n === (n | 0) && e.push(n), e.sort((i, s) => i - s).pop(), e)
}
function Kk(t) {
  return (
    typeof t == 'symbol' ||
    (typeof t == 'object' &&
      t !== null &&
      !(Symbol.toPrimitive in t || 'toString' in t || 'valueOf' in t))
  )
}
function _l(t) {
  return !Kk(t) && !isNaN(parseFloat(t)) && isFinite(t)
}
function Qk(t, e) {
  const n = Math.round(t)
  return n - e <= t && n + e >= t
}
function $k(t, e, n) {
  let r, i, s
  for (r = 0, i = t.length; r < i; r++)
    ((s = t[r][n]), isNaN(s) || ((e.min = Math.min(e.min, s)), (e.max = Math.max(e.max, s))))
}
function yi(t) {
  return t * (Oe / 180)
}
function sp(t) {
  return t * (180 / Oe)
}
function Sm(t) {
  if (!Be(t)) return
  let e = 1,
    n = 0
  for (; Math.round(t * e) / e !== t; ) ((e *= 10), n++)
  return n
}
function Jk(t, e) {
  const n = e.x - t.x,
    r = e.y - t.y,
    i = Math.sqrt(n * n + r * r)
  let s = Math.atan2(r, n)
  return (s < -0.5 * Oe && (s += Ln), { angle: s, distance: i })
}
function cf(t, e) {
  return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
}
function t9(t, e) {
  return ((t - e + Yk) % Ln) - Oe
}
function Rn(t) {
  return ((t % Ln) + Ln) % Ln
}
function a3(t, e, n, r) {
  const i = Rn(t),
    s = Rn(e),
    c = Rn(n),
    h = Rn(s - i),
    f = Rn(c - i),
    p = Rn(i - s),
    y = Rn(i - c)
  return i === s || i === c || (r && s === c) || (h > f && p < y)
}
function Mn(t, e, n) {
  return Math.max(e, Math.min(n, t))
}
function e9(t) {
  return Mn(t, -32768, 32767)
}
function wi(t, e, n, r = 1e-6) {
  return t >= Math.min(e, n) - r && t <= Math.max(e, n) + r
}
function ap(t, e, n) {
  n = n || ((c) => t[c] < e)
  let r = t.length - 1,
    i = 0,
    s
  for (; r - i > 1; ) ((s = (i + r) >> 1), n(s) ? (i = s) : (r = s))
  return { lo: i, hi: r }
}
const co = (t, e, n, r) =>
    ap(
      t,
      n,
      r
        ? (i) => {
            const s = t[i][e]
            return s < n || (s === n && t[i + 1][e] === n)
          }
        : (i) => t[i][e] < n
    ),
  n9 = (t, e, n) => ap(t, n, (r) => t[r][e] >= n)
function r9(t, e, n) {
  let r = 0,
    i = t.length
  for (; r < i && t[r] < e; ) r++
  for (; i > r && t[i - 1] > n; ) i--
  return r > 0 || i < t.length ? t.slice(r, i) : t
}
const l3 = ['push', 'pop', 'shift', 'splice', 'unshift']
function i9(t, e) {
  if (t._chartjs) {
    t._chartjs.listeners.push(e)
    return
  }
  ;(Object.defineProperty(t, '_chartjs', {
    configurable: !0,
    enumerable: !1,
    value: { listeners: [e] },
  }),
    l3.forEach((n) => {
      const r = '_onData' + op(n),
        i = t[n]
      Object.defineProperty(t, n, {
        configurable: !0,
        enumerable: !1,
        value(...s) {
          const c = i.apply(this, s)
          return (
            t._chartjs.listeners.forEach((h) => {
              typeof h[r] == 'function' && h[r](...s)
            }),
            c
          )
        },
      })
    }))
}
function Am(t, e) {
  const n = t._chartjs
  if (!n) return
  const r = n.listeners,
    i = r.indexOf(e)
  ;(i !== -1 && r.splice(i, 1),
    !(r.length > 0) &&
      (l3.forEach((s) => {
        delete t[s]
      }),
      delete t._chartjs))
}
function c3(t) {
  const e = new Set(t)
  return e.size === t.length ? t : Array.from(e)
}
const u3 = (function () {
  return typeof window > 'u'
    ? function (t) {
        return t()
      }
    : window.requestAnimationFrame
})()
function h3(t, e) {
  let n = [],
    r = !1
  return function (...i) {
    ;((n = i),
      r ||
        ((r = !0),
        u3.call(window, () => {
          ;((r = !1), t.apply(e, n))
        })))
  }
}
function o9(t, e) {
  let n
  return function (...r) {
    return (e ? (clearTimeout(n), (n = setTimeout(t, e, r))) : t.apply(this, r), e)
  }
}
const d3 = (t) => (t === 'start' ? 'left' : t === 'end' ? 'right' : 'center'),
  kn = (t, e, n) => (t === 'start' ? e : t === 'end' ? n : (e + n) / 2),
  s9 = (t, e, n, r) => (t === (r ? 'left' : 'right') ? n : t === 'center' ? (e + n) / 2 : e)
function a9(t, e, n) {
  const r = e.length
  let i = 0,
    s = r
  if (t._sorted) {
    const { iScale: c, vScale: h, _parsed: f } = t,
      p = t.dataset && t.dataset.options ? t.dataset.options.spanGaps : null,
      y = c.axis,
      { min: w, max: x, minDefined: E, maxDefined: S } = c.getUserBounds()
    if (E) {
      if (((i = Math.min(co(f, y, w).lo, n ? r : co(e, y, c.getPixelForValue(w)).lo)), p)) {
        const k = f
          .slice(0, i + 1)
          .reverse()
          .findIndex((D) => !Ot(D[h.axis]))
        i -= Math.max(0, k)
      }
      i = Mn(i, 0, r - 1)
    }
    if (S) {
      let k = Math.max(
        co(f, c.axis, x, !0).hi + 1,
        n ? 0 : co(e, y, c.getPixelForValue(x), !0).hi + 1
      )
      if (p) {
        const D = f.slice(k - 1).findIndex((_) => !Ot(_[h.axis]))
        k += Math.max(0, D)
      }
      s = Mn(k, i, r) - i
    } else s = r - i
  }
  return { start: i, count: s }
}
function l9(t) {
  const { xScale: e, yScale: n, _scaleRanges: r } = t,
    i = { xmin: e.min, xmax: e.max, ymin: n.min, ymax: n.max }
  if (!r) return ((t._scaleRanges = i), !0)
  const s = r.xmin !== e.min || r.xmax !== e.max || r.ymin !== n.min || r.ymax !== n.max
  return (Object.assign(r, i), s)
}
const Ac = (t) => t === 0 || t === 1,
  km = (t, e, n) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - e) * Ln) / n)),
  Im = (t, e, n) => Math.pow(2, -10 * t) * Math.sin(((t - e) * Ln) / n) + 1,
  Qa = {
    linear: (t) => t,
    easeInQuad: (t) => t * t,
    easeOutQuad: (t) => -t * (t - 2),
    easeInOutQuad: (t) => ((t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1)),
    easeInCubic: (t) => t * t * t,
    easeOutCubic: (t) => (t -= 1) * t * t + 1,
    easeInOutCubic: (t) => ((t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2)),
    easeInQuart: (t) => t * t * t * t,
    easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t) =>
      (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t) => t * t * t * t * t,
    easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t) =>
      (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t) => -Math.cos(t * Nn) + 1,
    easeOutSine: (t) => Math.sin(t * Nn),
    easeInOutSine: (t) => -0.5 * (Math.cos(Oe * t) - 1),
    easeInExpo: (t) => (t === 0 ? 0 : Math.pow(2, 10 * (t - 1))),
    easeOutExpo: (t) => (t === 1 ? 1 : -Math.pow(2, -10 * t) + 1),
    easeInOutExpo: (t) =>
      Ac(t)
        ? t
        : t < 0.5
          ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))
          : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t) => (t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)),
    easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t) =>
      (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t) => (Ac(t) ? t : km(t, 0.075, 0.3)),
    easeOutElastic: (t) => (Ac(t) ? t : Im(t, 0.075, 0.3)),
    easeInOutElastic(t) {
      return Ac(t)
        ? t
        : t < 0.5
          ? 0.5 * km(t * 2, 0.1125, 0.45)
          : 0.5 + 0.5 * Im(t * 2 - 1, 0.1125, 0.45)
    },
    easeInBack(t) {
      return t * t * ((1.70158 + 1) * t - 1.70158)
    },
    easeOutBack(t) {
      return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1
    },
    easeInOutBack(t) {
      let e = 1.70158
      return (t /= 0.5) < 1
        ? 0.5 * (t * t * (((e *= 1.525) + 1) * t - e))
        : 0.5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2)
    },
    easeInBounce: (t) => 1 - Qa.easeOutBounce(1 - t),
    easeOutBounce(t) {
      return t < 1 / 2.75
        ? 7.5625 * t * t
        : t < 2 / 2.75
          ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
          : t < 2.5 / 2.75
            ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
            : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375
    },
    easeInOutBounce: (t) =>
      t < 0.5 ? Qa.easeInBounce(t * 2) * 0.5 : Qa.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,
  }
function lp(t) {
  if (t && typeof t == 'object') {
    const e = t.toString()
    return e === '[object CanvasPattern]' || e === '[object CanvasGradient]'
  }
  return !1
}
function _m(t) {
  return lp(t) ? t : new Al(t)
}
function Ld(t) {
  return lp(t) ? t : new Al(t).saturate(0.5).darken(0.1).hexString()
}
const c9 = ['x', 'y', 'borderWidth', 'radius', 'tension'],
  u9 = ['color', 'borderColor', 'backgroundColor']
function h9(t) {
  ;(t.set('animation', {
    delay: void 0,
    duration: 1e3,
    easing: 'easeOutQuart',
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0,
  }),
    t.describe('animation', {
      _fallback: !1,
      _indexable: !1,
      _scriptable: (e) => e !== 'onProgress' && e !== 'onComplete' && e !== 'fn',
    }),
    t.set('animations', {
      colors: { type: 'color', properties: u9 },
      numbers: { type: 'number', properties: c9 },
    }),
    t.describe('animations', { _fallback: 'animation' }),
    t.set('transitions', {
      active: { animation: { duration: 400 } },
      resize: { animation: { duration: 0 } },
      show: {
        animations: { colors: { from: 'transparent' }, visible: { type: 'boolean', duration: 0 } },
      },
      hide: {
        animations: {
          colors: { to: 'transparent' },
          visible: { type: 'boolean', easing: 'linear', fn: (e) => e | 0 },
        },
      },
    }))
}
function d9(t) {
  t.set('layout', { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } })
}
const Rm = new Map()
function f9(t, e) {
  e = e || {}
  const n = t + JSON.stringify(e)
  let r = Rm.get(n)
  return (r || ((r = new Intl.NumberFormat(t, e)), Rm.set(n, r)), r)
}
function f3(t, e, n) {
  return f9(e, n).format(t)
}
const p9 = {
  values(t) {
    return ce(t) ? t : '' + t
  },
  numeric(t, e, n) {
    if (t === 0) return '0'
    const r = this.chart.options.locale
    let i,
      s = t
    if (n.length > 1) {
      const p = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value))
      ;((p < 1e-4 || p > 1e15) && (i = 'scientific'), (s = g9(t, n)))
    }
    const c = s3(Math.abs(s)),
      h = isNaN(c) ? 1 : Math.max(Math.min(-1 * Math.floor(c), 20), 0),
      f = { notation: i, minimumFractionDigits: h, maximumFractionDigits: h }
    return (Object.assign(f, this.options.ticks.format), f3(t, r, f))
  },
}
function g9(t, e) {
  let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value
  return (Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t)), n)
}
var cp = { formatters: p9 }
function m9(t) {
  ;(t.set('scale', {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: 'ticks',
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (e, n) => n.lineWidth,
      tickColor: (e, n) => n.color,
      offset: !1,
    },
    border: { display: !0, dash: [], dashOffset: 0, width: 1 },
    title: { display: !1, text: '', padding: { top: 4, bottom: 4 } },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: '',
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: cp.formatters.values,
      minor: {},
      major: {},
      align: 'center',
      crossAlign: 'near',
      showLabelBackdrop: !1,
      backdropColor: 'rgba(255, 255, 255, 0.75)',
      backdropPadding: 2,
    },
  }),
    t.route('scale.ticks', 'color', '', 'color'),
    t.route('scale.grid', 'color', '', 'borderColor'),
    t.route('scale.border', 'color', '', 'borderColor'),
    t.route('scale.title', 'color', '', 'color'),
    t.describe('scale', {
      _fallback: !1,
      _scriptable: (e) =>
        !e.startsWith('before') && !e.startsWith('after') && e !== 'callback' && e !== 'parser',
      _indexable: (e) => e !== 'borderDash' && e !== 'tickBorderDash' && e !== 'dash',
    }),
    t.describe('scales', { _fallback: 'scale' }),
    t.describe('scale.ticks', {
      _scriptable: (e) => e !== 'backdropPadding' && e !== 'callback',
      _indexable: (e) => e !== 'backdropPadding',
    }))
}
const So = Object.create(null),
  uf = Object.create(null)
function $a(t, e) {
  if (!e) return t
  const n = e.split('.')
  for (let r = 0, i = n.length; r < i; ++r) {
    const s = n[r]
    t = t[s] || (t[s] = Object.create(null))
  }
  return t
}
function Od(t, e, n) {
  return typeof e == 'string' ? kl($a(t, e), n) : kl($a(t, ''), e)
}
class y9 {
  constructor(e, n) {
    ;((this.animation = void 0),
      (this.backgroundColor = 'rgba(0,0,0,0.1)'),
      (this.borderColor = 'rgba(0,0,0,0.1)'),
      (this.color = '#666'),
      (this.datasets = {}),
      (this.devicePixelRatio = (r) => r.chart.platform.getDevicePixelRatio()),
      (this.elements = {}),
      (this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove']),
      (this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: 'normal',
        lineHeight: 1.2,
        weight: null,
      }),
      (this.hover = {}),
      (this.hoverBackgroundColor = (r, i) => Ld(i.backgroundColor)),
      (this.hoverBorderColor = (r, i) => Ld(i.borderColor)),
      (this.hoverColor = (r, i) => Ld(i.color)),
      (this.indexAxis = 'x'),
      (this.interaction = { mode: 'nearest', intersect: !0, includeInvisible: !1 }),
      (this.maintainAspectRatio = !0),
      (this.onHover = null),
      (this.onClick = null),
      (this.parsing = !0),
      (this.plugins = {}),
      (this.responsive = !0),
      (this.scale = void 0),
      (this.scales = {}),
      (this.showLine = !0),
      (this.drawActiveElementsOnTop = !0),
      this.describe(e),
      this.apply(n))
  }
  set(e, n) {
    return Od(this, e, n)
  }
  get(e) {
    return $a(this, e)
  }
  describe(e, n) {
    return Od(uf, e, n)
  }
  override(e, n) {
    return Od(So, e, n)
  }
  route(e, n, r, i) {
    const s = $a(this, e),
      c = $a(this, r),
      h = '_' + n
    Object.defineProperties(s, {
      [h]: { value: s[n], writable: !0 },
      [n]: {
        enumerable: !0,
        get() {
          const f = this[h],
            p = c[i]
          return Mt(f) ? Object.assign({}, p, f) : It(f, p)
        },
        set(f) {
          this[h] = f
        },
      },
    })
  }
  apply(e) {
    e.forEach((n) => n(this))
  }
}
var be = new y9(
  {
    _scriptable: (t) => !t.startsWith('on'),
    _indexable: (t) => t !== 'events',
    hover: { _fallback: 'interaction' },
    interaction: { _scriptable: !1, _indexable: !1 },
  },
  [h9, d9, m9]
)
function w9(t) {
  return !t || Ot(t.size) || Ot(t.family)
    ? null
    : (t.style ? t.style + ' ' : '') + (t.weight ? t.weight + ' ' : '') + t.size + 'px ' + t.family
}
function Vu(t, e, n, r, i) {
  let s = e[i]
  return (s || ((s = e[i] = t.measureText(i).width), n.push(i)), s > r && (r = s), r)
}
function b9(t, e, n, r) {
  r = r || {}
  let i = (r.data = r.data || {}),
    s = (r.garbageCollect = r.garbageCollect || [])
  ;(r.font !== e && ((i = r.data = {}), (s = r.garbageCollect = []), (r.font = e)),
    t.save(),
    (t.font = e))
  let c = 0
  const h = n.length
  let f, p, y, w, x
  for (f = 0; f < h; f++)
    if (((w = n[f]), w != null && !ce(w))) c = Vu(t, i, s, c, w)
    else if (ce(w))
      for (p = 0, y = w.length; p < y; p++)
        ((x = w[p]), x != null && !ce(x) && (c = Vu(t, i, s, c, x)))
  t.restore()
  const E = s.length / 2
  if (E > n.length) {
    for (f = 0; f < E; f++) delete i[s[f]]
    s.splice(0, E)
  }
  return c
}
function Qi(t, e, n) {
  const r = t.currentDevicePixelRatio,
    i = n !== 0 ? Math.max(n / 2, 0.5) : 0
  return Math.round((e - i) * r) / r + i
}
function Tm(t, e) {
  ;(!e && !t) ||
    ((e = e || t.getContext('2d')),
    e.save(),
    e.resetTransform(),
    e.clearRect(0, 0, t.width, t.height),
    e.restore())
}
function hf(t, e, n, r) {
  p3(t, e, n, r, null)
}
function p3(t, e, n, r, i) {
  let s, c, h, f, p, y, w, x
  const E = e.pointStyle,
    S = e.rotation,
    k = e.radius
  let D = (S || 0) * Zk
  if (
    E &&
    typeof E == 'object' &&
    ((s = E.toString()), s === '[object HTMLImageElement]' || s === '[object HTMLCanvasElement]')
  ) {
    ;(t.save(),
      t.translate(n, r),
      t.rotate(D),
      t.drawImage(E, -E.width / 2, -E.height / 2, E.width, E.height),
      t.restore())
    return
  }
  if (!(isNaN(k) || k <= 0)) {
    switch ((t.beginPath(), E)) {
      default:
        ;(i ? t.ellipse(n, r, i / 2, k, 0, 0, Ln) : t.arc(n, r, k, 0, Ln), t.closePath())
        break
      case 'triangle':
        ;((y = i ? i / 2 : k),
          t.moveTo(n + Math.sin(D) * y, r - Math.cos(D) * k),
          (D += Em),
          t.lineTo(n + Math.sin(D) * y, r - Math.cos(D) * k),
          (D += Em),
          t.lineTo(n + Math.sin(D) * y, r - Math.cos(D) * k),
          t.closePath())
        break
      case 'rectRounded':
        ;((p = k * 0.516),
          (f = k - p),
          (c = Math.cos(D + Ki) * f),
          (w = Math.cos(D + Ki) * (i ? i / 2 - p : f)),
          (h = Math.sin(D + Ki) * f),
          (x = Math.sin(D + Ki) * (i ? i / 2 - p : f)),
          t.arc(n - w, r - h, p, D - Oe, D - Nn),
          t.arc(n + x, r - c, p, D - Nn, D),
          t.arc(n + w, r + h, p, D, D + Nn),
          t.arc(n - x, r + c, p, D + Nn, D + Oe),
          t.closePath())
        break
      case 'rect':
        if (!S) {
          ;((f = Math.SQRT1_2 * k), (y = i ? i / 2 : f), t.rect(n - y, r - f, 2 * y, 2 * f))
          break
        }
        D += Ki
      case 'rectRot':
        ;((w = Math.cos(D) * (i ? i / 2 : k)),
          (c = Math.cos(D) * k),
          (h = Math.sin(D) * k),
          (x = Math.sin(D) * (i ? i / 2 : k)),
          t.moveTo(n - w, r - h),
          t.lineTo(n + x, r - c),
          t.lineTo(n + w, r + h),
          t.lineTo(n - x, r + c),
          t.closePath())
        break
      case 'crossRot':
        D += Ki
      case 'cross':
        ;((w = Math.cos(D) * (i ? i / 2 : k)),
          (c = Math.cos(D) * k),
          (h = Math.sin(D) * k),
          (x = Math.sin(D) * (i ? i / 2 : k)),
          t.moveTo(n - w, r - h),
          t.lineTo(n + w, r + h),
          t.moveTo(n + x, r - c),
          t.lineTo(n - x, r + c))
        break
      case 'star':
        ;((w = Math.cos(D) * (i ? i / 2 : k)),
          (c = Math.cos(D) * k),
          (h = Math.sin(D) * k),
          (x = Math.sin(D) * (i ? i / 2 : k)),
          t.moveTo(n - w, r - h),
          t.lineTo(n + w, r + h),
          t.moveTo(n + x, r - c),
          t.lineTo(n - x, r + c),
          (D += Ki),
          (w = Math.cos(D) * (i ? i / 2 : k)),
          (c = Math.cos(D) * k),
          (h = Math.sin(D) * k),
          (x = Math.sin(D) * (i ? i / 2 : k)),
          t.moveTo(n - w, r - h),
          t.lineTo(n + w, r + h),
          t.moveTo(n + x, r - c),
          t.lineTo(n - x, r + c))
        break
      case 'line':
        ;((c = i ? i / 2 : Math.cos(D) * k),
          (h = Math.sin(D) * k),
          t.moveTo(n - c, r - h),
          t.lineTo(n + c, r + h))
        break
      case 'dash':
        ;(t.moveTo(n, r), t.lineTo(n + Math.cos(D) * (i ? i / 2 : k), r + Math.sin(D) * k))
        break
      case !1:
        t.closePath()
        break
    }
    ;(t.fill(), e.borderWidth > 0 && t.stroke())
  }
}
function Vr(t, e, n) {
  return (
    (n = n || 0.5),
    !e || (t && t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n)
  )
}
function xh(t, e) {
  ;(t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip())
}
function Eh(t) {
  t.restore()
}
function v9(t, e, n, r, i) {
  if (!e) return t.lineTo(n.x, n.y)
  if (i === 'middle') {
    const s = (e.x + n.x) / 2
    ;(t.lineTo(s, e.y), t.lineTo(s, n.y))
  } else (i === 'after') != !!r ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y)
  t.lineTo(n.x, n.y)
}
function x9(t, e, n, r) {
  if (!e) return t.lineTo(n.x, n.y)
  t.bezierCurveTo(
    r ? e.cp1x : e.cp2x,
    r ? e.cp1y : e.cp2y,
    r ? n.cp2x : n.cp1x,
    r ? n.cp2y : n.cp1y,
    n.x,
    n.y
  )
}
function E9(t, e) {
  ;(e.translation && t.translate(e.translation[0], e.translation[1]),
    Ot(e.rotation) || t.rotate(e.rotation),
    e.color && (t.fillStyle = e.color),
    e.textAlign && (t.textAlign = e.textAlign),
    e.textBaseline && (t.textBaseline = e.textBaseline))
}
function C9(t, e, n, r, i) {
  if (i.strikethrough || i.underline) {
    const s = t.measureText(r),
      c = e - s.actualBoundingBoxLeft,
      h = e + s.actualBoundingBoxRight,
      f = n - s.actualBoundingBoxAscent,
      p = n + s.actualBoundingBoxDescent,
      y = i.strikethrough ? (f + p) / 2 : p
    ;((t.strokeStyle = t.fillStyle),
      t.beginPath(),
      (t.lineWidth = i.decorationWidth || 2),
      t.moveTo(c, y),
      t.lineTo(h, y),
      t.stroke())
  }
}
function S9(t, e) {
  const n = t.fillStyle
  ;((t.fillStyle = e.color), t.fillRect(e.left, e.top, e.width, e.height), (t.fillStyle = n))
}
function Ws(t, e, n, r, i, s = {}) {
  const c = ce(e) ? e : [e],
    h = s.strokeWidth > 0 && s.strokeColor !== ''
  let f, p
  for (t.save(), t.font = i.string, E9(t, s), f = 0; f < c.length; ++f)
    ((p = c[f]),
      s.backdrop && S9(t, s.backdrop),
      h &&
        (s.strokeColor && (t.strokeStyle = s.strokeColor),
        Ot(s.strokeWidth) || (t.lineWidth = s.strokeWidth),
        t.strokeText(p, n, r, s.maxWidth)),
      t.fillText(p, n, r, s.maxWidth),
      C9(t, n, r, p, s),
      (r += Number(i.lineHeight)))
  t.restore()
}
function Rl(t, e) {
  const { x: n, y: r, w: i, h: s, radius: c } = e
  ;(t.arc(n + c.topLeft, r + c.topLeft, c.topLeft, 1.5 * Oe, Oe, !0),
    t.lineTo(n, r + s - c.bottomLeft),
    t.arc(n + c.bottomLeft, r + s - c.bottomLeft, c.bottomLeft, Oe, Nn, !0),
    t.lineTo(n + i - c.bottomRight, r + s),
    t.arc(n + i - c.bottomRight, r + s - c.bottomRight, c.bottomRight, Nn, 0, !0),
    t.lineTo(n + i, r + c.topRight),
    t.arc(n + i - c.topRight, r + c.topRight, c.topRight, 0, -Nn, !0),
    t.lineTo(n + c.topLeft, r))
}
const A9 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
  k9 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/
function I9(t, e) {
  const n = ('' + t).match(A9)
  if (!n || n[1] === 'normal') return e * 1.2
  switch (((t = +n[2]), n[3])) {
    case 'px':
      return t
    case '%':
      t /= 100
      break
  }
  return e * t
}
const _9 = (t) => +t || 0
function g3(t, e) {
  const n = {},
    r = Mt(e),
    i = r ? Object.keys(e) : e,
    s = Mt(t) ? (r ? (c) => It(t[c], t[e[c]]) : (c) => t[c]) : () => t
  for (const c of i) n[c] = _9(s(c))
  return n
}
function m3(t) {
  return g3(t, { top: 'y', right: 'x', bottom: 'y', left: 'x' })
}
function po(t) {
  return g3(t, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'])
}
function sn(t) {
  const e = m3(t)
  return ((e.width = e.left + e.right), (e.height = e.top + e.bottom), e)
}
function He(t, e) {
  ;((t = t || {}), (e = e || be.font))
  let n = It(t.size, e.size)
  typeof n == 'string' && (n = parseInt(n, 10))
  let r = It(t.style, e.style)
  r &&
    !('' + r).match(k9) &&
    (console.warn('Invalid font style specified: "' + r + '"'), (r = void 0))
  const i = {
    family: It(t.family, e.family),
    lineHeight: I9(It(t.lineHeight, e.lineHeight), n),
    size: n,
    style: r,
    weight: It(t.weight, e.weight),
    string: '',
  }
  return ((i.string = w9(i)), i)
}
function kc(t, e, n, r) {
  let i, s, c
  for (i = 0, s = t.length; i < s; ++i) if (((c = t[i]), c !== void 0 && c !== void 0)) return c
}
function R9(t, e, n) {
  const { min: r, max: i } = t,
    s = Wk(e, (i - r) / 2),
    c = (h, f) => (n && h === 0 ? 0 : h + f)
  return { min: c(r, -Math.abs(s)), max: c(i, s) }
}
function Ui(t, e) {
  return Object.assign(Object.create(t), e)
}
function up(t, e = [''], n, r, i = () => t[0]) {
  const s = n || t
  typeof r > 'u' && (r = v3('_fallback', t))
  const c = {
    [Symbol.toStringTag]: 'Object',
    _cacheable: !0,
    _scopes: t,
    _rootScopes: s,
    _fallback: r,
    _getTarget: i,
    override: (h) => up([h, ...t], e, s, r),
  }
  return new Proxy(c, {
    deleteProperty(h, f) {
      return (delete h[f], delete h._keys, delete t[0][f], !0)
    },
    get(h, f) {
      return w3(h, f, () => B9(f, e, t, h))
    },
    getOwnPropertyDescriptor(h, f) {
      return Reflect.getOwnPropertyDescriptor(h._scopes[0], f)
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t[0])
    },
    has(h, f) {
      return Mm(h).includes(f)
    },
    ownKeys(h) {
      return Mm(h)
    },
    set(h, f, p) {
      const y = h._storage || (h._storage = i())
      return ((h[f] = y[f] = p), delete h._keys, !0)
    },
  })
}
function Us(t, e, n, r) {
  const i = {
    _cacheable: !1,
    _proxy: t,
    _context: e,
    _subProxy: n,
    _stack: new Set(),
    _descriptors: y3(t, r),
    setContext: (s) => Us(t, s, n, r),
    override: (s) => Us(t.override(s), e, n, r),
  }
  return new Proxy(i, {
    deleteProperty(s, c) {
      return (delete s[c], delete t[c], !0)
    },
    get(s, c, h) {
      return w3(s, c, () => N9(s, c, h))
    },
    getOwnPropertyDescriptor(s, c) {
      return s._descriptors.allKeys
        ? Reflect.has(t, c)
          ? { enumerable: !0, configurable: !0 }
          : void 0
        : Reflect.getOwnPropertyDescriptor(t, c)
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t)
    },
    has(s, c) {
      return Reflect.has(t, c)
    },
    ownKeys() {
      return Reflect.ownKeys(t)
    },
    set(s, c, h) {
      return ((t[c] = h), delete s[c], !0)
    },
  })
}
function y3(t, e = { scriptable: !0, indexable: !0 }) {
  const { _scriptable: n = e.scriptable, _indexable: r = e.indexable, _allKeys: i = e.allKeys } = t
  return {
    allKeys: i,
    scriptable: n,
    indexable: r,
    isScriptable: Oi(n) ? n : () => n,
    isIndexable: Oi(r) ? r : () => r,
  }
}
const T9 = (t, e) => (t ? t + op(e) : e),
  hp = (t, e) =>
    Mt(e) && t !== 'adapters' && (Object.getPrototypeOf(e) === null || e.constructor === Object)
function w3(t, e, n) {
  if (Object.prototype.hasOwnProperty.call(t, e) || e === 'constructor') return t[e]
  const r = n()
  return ((t[e] = r), r)
}
function N9(t, e, n) {
  const { _proxy: r, _context: i, _subProxy: s, _descriptors: c } = t
  let h = r[e]
  return (
    Oi(h) && c.isScriptable(e) && (h = M9(e, h, t, n)),
    ce(h) && h.length && (h = D9(e, h, t, c.isIndexable)),
    hp(e, h) && (h = Us(h, i, s && s[e], c)),
    h
  )
}
function M9(t, e, n, r) {
  const { _proxy: i, _context: s, _subProxy: c, _stack: h } = n
  if (h.has(t)) throw new Error('Recursion detected: ' + Array.from(h).join('->') + '->' + t)
  h.add(t)
  let f = e(s, c || r)
  return (h.delete(t), hp(t, f) && (f = dp(i._scopes, i, t, f)), f)
}
function D9(t, e, n, r) {
  const { _proxy: i, _context: s, _subProxy: c, _descriptors: h } = n
  if (typeof s.index < 'u' && r(t)) return e[s.index % e.length]
  if (Mt(e[0])) {
    const f = e,
      p = i._scopes.filter((y) => y !== f)
    e = []
    for (const y of f) {
      const w = dp(p, i, t, y)
      e.push(Us(w, s, c && c[t], h))
    }
  }
  return e
}
function b3(t, e, n) {
  return Oi(t) ? t(e, n) : t
}
const P9 = (t, e) => (t === !0 ? e : typeof t == 'string' ? Co(e, t) : void 0)
function L9(t, e, n, r, i) {
  for (const s of e) {
    const c = P9(n, s)
    if (c) {
      t.add(c)
      const h = b3(c._fallback, n, i)
      if (typeof h < 'u' && h !== n && h !== r) return h
    } else if (c === !1 && typeof r < 'u' && n !== r) return null
  }
  return !1
}
function dp(t, e, n, r) {
  const i = e._rootScopes,
    s = b3(e._fallback, n, r),
    c = [...t, ...i],
    h = new Set()
  h.add(r)
  let f = Nm(h, c, n, s || n, r)
  return f === null || (typeof s < 'u' && s !== n && ((f = Nm(h, c, s, f, r)), f === null))
    ? !1
    : up(Array.from(h), [''], i, s, () => O9(e, n, r))
}
function Nm(t, e, n, r, i) {
  for (; n; ) n = L9(t, e, n, r, i)
  return n
}
function O9(t, e, n) {
  const r = t._getTarget()
  e in r || (r[e] = {})
  const i = r[e]
  return ce(i) && Mt(n) ? n : i || {}
}
function B9(t, e, n, r) {
  let i
  for (const s of e)
    if (((i = v3(T9(s, t), n)), typeof i < 'u')) return hp(t, i) ? dp(n, r, t, i) : i
}
function v3(t, e) {
  for (const n of e) {
    if (!n) continue
    const r = n[t]
    if (typeof r < 'u') return r
  }
}
function Mm(t) {
  let e = t._keys
  return (e || (e = t._keys = F9(t._scopes)), e)
}
function F9(t) {
  const e = new Set()
  for (const n of t) for (const r of Object.keys(n).filter((i) => !i.startsWith('_'))) e.add(r)
  return Array.from(e)
}
function j9(t, e, n, r) {
  const { iScale: i } = t,
    { key: s = 'r' } = this._parsing,
    c = new Array(r)
  let h, f, p, y
  for (h = 0, f = r; h < f; ++h) ((p = h + n), (y = e[p]), (c[h] = { r: i.parse(Co(y, s), p) }))
  return c
}
const V9 = Number.EPSILON || 1e-14,
  zs = (t, e) => e < t.length && !t[e].skip && t[e],
  x3 = (t) => (t === 'x' ? 'y' : 'x')
function W9(t, e, n, r) {
  const i = t.skip ? e : t,
    s = e,
    c = n.skip ? e : n,
    h = cf(s, i),
    f = cf(c, s)
  let p = h / (h + f),
    y = f / (h + f)
  ;((p = isNaN(p) ? 0 : p), (y = isNaN(y) ? 0 : y))
  const w = r * p,
    x = r * y
  return {
    previous: { x: s.x - w * (c.x - i.x), y: s.y - w * (c.y - i.y) },
    next: { x: s.x + x * (c.x - i.x), y: s.y + x * (c.y - i.y) },
  }
}
function U9(t, e, n) {
  const r = t.length
  let i,
    s,
    c,
    h,
    f,
    p = zs(t, 0)
  for (let y = 0; y < r - 1; ++y)
    if (((f = p), (p = zs(t, y + 1)), !(!f || !p))) {
      if (Ka(e[y], 0, V9)) {
        n[y] = n[y + 1] = 0
        continue
      }
      ;((i = n[y] / e[y]),
        (s = n[y + 1] / e[y]),
        (h = Math.pow(i, 2) + Math.pow(s, 2)),
        !(h <= 9) && ((c = 3 / Math.sqrt(h)), (n[y] = i * c * e[y]), (n[y + 1] = s * c * e[y])))
    }
}
function z9(t, e, n = 'x') {
  const r = x3(n),
    i = t.length
  let s,
    c,
    h,
    f = zs(t, 0)
  for (let p = 0; p < i; ++p) {
    if (((c = h), (h = f), (f = zs(t, p + 1)), !h)) continue
    const y = h[n],
      w = h[r]
    ;(c && ((s = (y - c[n]) / 3), (h[`cp1${n}`] = y - s), (h[`cp1${r}`] = w - s * e[p])),
      f && ((s = (f[n] - y) / 3), (h[`cp2${n}`] = y + s), (h[`cp2${r}`] = w + s * e[p])))
  }
}
function H9(t, e = 'x') {
  const n = x3(e),
    r = t.length,
    i = Array(r).fill(0),
    s = Array(r)
  let c,
    h,
    f,
    p = zs(t, 0)
  for (c = 0; c < r; ++c)
    if (((h = f), (f = p), (p = zs(t, c + 1)), !!f)) {
      if (p) {
        const y = p[e] - f[e]
        i[c] = y !== 0 ? (p[n] - f[n]) / y : 0
      }
      s[c] = h ? (p ? (Rr(i[c - 1]) !== Rr(i[c]) ? 0 : (i[c - 1] + i[c]) / 2) : i[c - 1]) : i[c]
    }
  ;(U9(t, i, s), z9(t, s, e))
}
function Ic(t, e, n) {
  return Math.max(Math.min(t, n), e)
}
function X9(t, e) {
  let n,
    r,
    i,
    s,
    c,
    h = Vr(t[0], e)
  for (n = 0, r = t.length; n < r; ++n)
    ((c = s),
      (s = h),
      (h = n < r - 1 && Vr(t[n + 1], e)),
      s &&
        ((i = t[n]),
        c && ((i.cp1x = Ic(i.cp1x, e.left, e.right)), (i.cp1y = Ic(i.cp1y, e.top, e.bottom))),
        h && ((i.cp2x = Ic(i.cp2x, e.left, e.right)), (i.cp2y = Ic(i.cp2y, e.top, e.bottom)))))
}
function G9(t, e, n, r, i) {
  let s, c, h, f
  if ((e.spanGaps && (t = t.filter((p) => !p.skip)), e.cubicInterpolationMode === 'monotone'))
    H9(t, i)
  else {
    let p = r ? t[t.length - 1] : t[0]
    for (s = 0, c = t.length; s < c; ++s)
      ((h = t[s]),
        (f = W9(p, h, t[Math.min(s + 1, c - (r ? 0 : 1)) % c], e.tension)),
        (h.cp1x = f.previous.x),
        (h.cp1y = f.previous.y),
        (h.cp2x = f.next.x),
        (h.cp2y = f.next.y),
        (p = h))
  }
  e.capBezierPoints && X9(t, n)
}
function fp() {
  return typeof window < 'u' && typeof document < 'u'
}
function pp(t) {
  let e = t.parentNode
  return (e && e.toString() === '[object ShadowRoot]' && (e = e.host), e)
}
function Wu(t, e, n) {
  let r
  return (
    typeof t == 'string'
      ? ((r = parseInt(t, 10)), t.indexOf('%') !== -1 && (r = (r / 100) * e.parentNode[n]))
      : (r = t),
    r
  )
}
const Ch = (t) => t.ownerDocument.defaultView.getComputedStyle(t, null)
function Y9(t, e) {
  return Ch(t).getPropertyValue(e)
}
const Z9 = ['top', 'right', 'bottom', 'left']
function go(t, e, n) {
  const r = {}
  n = n ? '-' + n : ''
  for (let i = 0; i < 4; i++) {
    const s = Z9[i]
    r[s] = parseFloat(t[e + '-' + s + n]) || 0
  }
  return ((r.width = r.left + r.right), (r.height = r.top + r.bottom), r)
}
const q9 = (t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot)
function K9(t, e) {
  const n = t.touches,
    r = n && n.length ? n[0] : t,
    { offsetX: i, offsetY: s } = r
  let c = !1,
    h,
    f
  if (q9(i, s, t.target)) ((h = i), (f = s))
  else {
    const p = e.getBoundingClientRect()
    ;((h = r.clientX - p.left), (f = r.clientY - p.top), (c = !0))
  }
  return { x: h, y: f, box: c }
}
function ro(t, e) {
  if ('native' in t) return t
  const { canvas: n, currentDevicePixelRatio: r } = e,
    i = Ch(n),
    s = i.boxSizing === 'border-box',
    c = go(i, 'padding'),
    h = go(i, 'border', 'width'),
    { x: f, y: p, box: y } = K9(t, n),
    w = c.left + (y && h.left),
    x = c.top + (y && h.top)
  let { width: E, height: S } = e
  return (
    s && ((E -= c.width + h.width), (S -= c.height + h.height)),
    { x: Math.round((((f - w) / E) * n.width) / r), y: Math.round((((p - x) / S) * n.height) / r) }
  )
}
function Q9(t, e, n) {
  let r, i
  if (e === void 0 || n === void 0) {
    const s = t && pp(t)
    if (!s) ((e = t.clientWidth), (n = t.clientHeight))
    else {
      const c = s.getBoundingClientRect(),
        h = Ch(s),
        f = go(h, 'border', 'width'),
        p = go(h, 'padding')
      ;((e = c.width - p.width - f.width),
        (n = c.height - p.height - f.height),
        (r = Wu(h.maxWidth, s, 'clientWidth')),
        (i = Wu(h.maxHeight, s, 'clientHeight')))
    }
  }
  return { width: e, height: n, maxWidth: r || ju, maxHeight: i || ju }
}
const bi = (t) => Math.round(t * 10) / 10
function $9(t, e, n, r) {
  const i = Ch(t),
    s = go(i, 'margin'),
    c = Wu(i.maxWidth, t, 'clientWidth') || ju,
    h = Wu(i.maxHeight, t, 'clientHeight') || ju,
    f = Q9(t, e, n)
  let { width: p, height: y } = f
  if (i.boxSizing === 'content-box') {
    const w = go(i, 'border', 'width'),
      x = go(i, 'padding')
    ;((p -= x.width + w.width), (y -= x.height + w.height))
  }
  return (
    (p = Math.max(0, p - s.width)),
    (y = Math.max(0, r ? p / r : y - s.height)),
    (p = bi(Math.min(p, c, f.maxWidth))),
    (y = bi(Math.min(y, h, f.maxHeight))),
    p && !y && (y = bi(p / 2)),
    (e !== void 0 || n !== void 0) &&
      r &&
      f.height &&
      y > f.height &&
      ((y = f.height), (p = bi(Math.floor(y * r)))),
    { width: p, height: y }
  )
}
function Dm(t, e, n) {
  const r = e || 1,
    i = bi(t.height * r),
    s = bi(t.width * r)
  ;((t.height = bi(t.height)), (t.width = bi(t.width)))
  const c = t.canvas
  return (
    c.style &&
      (n || (!c.style.height && !c.style.width)) &&
      ((c.style.height = `${t.height}px`), (c.style.width = `${t.width}px`)),
    t.currentDevicePixelRatio !== r || c.height !== i || c.width !== s
      ? ((t.currentDevicePixelRatio = r),
        (c.height = i),
        (c.width = s),
        t.ctx.setTransform(r, 0, 0, r, 0, 0),
        !0)
      : !1
  )
}
const J9 = (function () {
  let t = !1
  try {
    const e = {
      get passive() {
        return ((t = !0), !1)
      },
    }
    fp() && (window.addEventListener('test', null, e), window.removeEventListener('test', null, e))
  } catch {}
  return t
})()
function Pm(t, e) {
  const n = Y9(t, e),
    r = n && n.match(/^(\d+)(\.\d+)?px$/)
  return r ? +r[1] : void 0
}
function io(t, e, n, r) {
  return { x: t.x + n * (e.x - t.x), y: t.y + n * (e.y - t.y) }
}
function tI(t, e, n, r) {
  return {
    x: t.x + n * (e.x - t.x),
    y:
      r === 'middle'
        ? n < 0.5
          ? t.y
          : e.y
        : r === 'after'
          ? n < 1
            ? t.y
            : e.y
          : n > 0
            ? e.y
            : t.y,
  }
}
function eI(t, e, n, r) {
  const i = { x: t.cp2x, y: t.cp2y },
    s = { x: e.cp1x, y: e.cp1y },
    c = io(t, i, n),
    h = io(i, s, n),
    f = io(s, e, n),
    p = io(c, h, n),
    y = io(h, f, n)
  return io(p, y, n)
}
const nI = function (t, e) {
    return {
      x(n) {
        return t + t + e - n
      },
      setWidth(n) {
        e = n
      },
      textAlign(n) {
        return n === 'center' ? n : n === 'right' ? 'left' : 'right'
      },
      xPlus(n, r) {
        return n - r
      },
      leftForLtr(n, r) {
        return n - r
      },
    }
  },
  rI = function () {
    return {
      x(t) {
        return t
      },
      setWidth(t) {},
      textAlign(t) {
        return t
      },
      xPlus(t, e) {
        return t + e
      },
      leftForLtr(t, e) {
        return t
      },
    }
  }
function Rs(t, e, n) {
  return t ? nI(e, n) : rI()
}
function E3(t, e) {
  let n, r
  ;(e === 'ltr' || e === 'rtl') &&
    ((n = t.canvas.style),
    (r = [n.getPropertyValue('direction'), n.getPropertyPriority('direction')]),
    n.setProperty('direction', e, 'important'),
    (t.prevTextDirection = r))
}
function C3(t, e) {
  e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty('direction', e[0], e[1]))
}
function S3(t) {
  return t === 'angle'
    ? { between: a3, compare: t9, normalize: Rn }
    : { between: wi, compare: (e, n) => e - n, normalize: (e) => e }
}
function Lm({ start: t, end: e, count: n, loop: r, style: i }) {
  return { start: t % n, end: e % n, loop: r && (e - t + 1) % n === 0, style: i }
}
function iI(t, e, n) {
  const { property: r, start: i, end: s } = n,
    { between: c, normalize: h } = S3(r),
    f = e.length
  let { start: p, end: y, loop: w } = t,
    x,
    E
  if (w) {
    for (p += f, y += f, x = 0, E = f; x < E && c(h(e[p % f][r]), i, s); ++x) (p--, y--)
    ;((p %= f), (y %= f))
  }
  return (y < p && (y += f), { start: p, end: y, loop: w, style: t.style })
}
function A3(t, e, n) {
  if (!n) return [t]
  const { property: r, start: i, end: s } = n,
    c = e.length,
    { compare: h, between: f, normalize: p } = S3(r),
    { start: y, end: w, loop: x, style: E } = iI(t, e, n),
    S = []
  let k = !1,
    D = null,
    _,
    N,
    M
  const O = () => f(i, M, _) && h(i, M) !== 0,
    F = () => h(s, _) === 0 || f(s, M, _),
    z = () => k || O(),
    V = () => !k || F()
  for (let W = y, Z = y; W <= w; ++W)
    ((N = e[W % c]),
      !N.skip &&
        ((_ = p(N[r])),
        _ !== M &&
          ((k = f(_, i, s)),
          D === null && z() && (D = h(_, i) === 0 ? W : Z),
          D !== null &&
            V() &&
            (S.push(Lm({ start: D, end: W, loop: x, count: c, style: E })), (D = null)),
          (Z = W),
          (M = _))))
  return (D !== null && S.push(Lm({ start: D, end: w, loop: x, count: c, style: E })), S)
}
function k3(t, e) {
  const n = [],
    r = t.segments
  for (let i = 0; i < r.length; i++) {
    const s = A3(r[i], t.points, e)
    s.length && n.push(...s)
  }
  return n
}
function oI(t, e, n, r) {
  let i = 0,
    s = e - 1
  if (n && !r) for (; i < e && !t[i].skip; ) i++
  for (; i < e && t[i].skip; ) i++
  for (i %= e, n && (s += i); s > i && t[s % e].skip; ) s--
  return ((s %= e), { start: i, end: s })
}
function sI(t, e, n, r) {
  const i = t.length,
    s = []
  let c = e,
    h = t[e],
    f
  for (f = e + 1; f <= n; ++f) {
    const p = t[f % i]
    ;(p.skip || p.stop
      ? h.skip ||
        ((r = !1), s.push({ start: e % i, end: (f - 1) % i, loop: r }), (e = c = p.stop ? f : null))
      : ((c = f), h.skip && (e = f)),
      (h = p))
  }
  return (c !== null && s.push({ start: e % i, end: c % i, loop: r }), s)
}
function aI(t, e) {
  const n = t.points,
    r = t.options.spanGaps,
    i = n.length
  if (!i) return []
  const s = !!t._loop,
    { start: c, end: h } = oI(n, i, s, r)
  if (r === !0) return Om(t, [{ start: c, end: h, loop: s }], n, e)
  const f = h < c ? h + i : h,
    p = !!t._fullLoop && c === 0 && h === i - 1
  return Om(t, sI(n, c, f, p), n, e)
}
function Om(t, e, n, r) {
  return !r || !r.setContext || !n ? e : lI(t, e, n, r)
}
function lI(t, e, n, r) {
  const i = t._chart.getContext(),
    s = Bm(t.options),
    {
      _datasetIndex: c,
      options: { spanGaps: h },
    } = t,
    f = n.length,
    p = []
  let y = s,
    w = e[0].start,
    x = w
  function E(S, k, D, _) {
    const N = h ? -1 : 1
    if (S !== k) {
      for (S += f; n[S % f].skip; ) S -= N
      for (; n[k % f].skip; ) k += N
      S % f !== k % f &&
        (p.push({ start: S % f, end: k % f, loop: D, style: _ }), (y = _), (w = k % f))
    }
  }
  for (const S of e) {
    w = h ? w : S.start
    let k = n[w % f],
      D
    for (x = w + 1; x <= S.end; x++) {
      const _ = n[x % f]
      ;((D = Bm(
        r.setContext(
          Ui(i, {
            type: 'segment',
            p0: k,
            p1: _,
            p0DataIndex: (x - 1) % f,
            p1DataIndex: x % f,
            datasetIndex: c,
          })
        )
      )),
        cI(D, y) && E(w, x - 1, S.loop, y),
        (k = _),
        (y = D))
    }
    w < x - 1 && E(w, x - 1, S.loop, y)
  }
  return p
}
function Bm(t) {
  return {
    backgroundColor: t.backgroundColor,
    borderCapStyle: t.borderCapStyle,
    borderDash: t.borderDash,
    borderDashOffset: t.borderDashOffset,
    borderJoinStyle: t.borderJoinStyle,
    borderWidth: t.borderWidth,
    borderColor: t.borderColor,
  }
}
function cI(t, e) {
  if (!e) return !1
  const n = [],
    r = function (i, s) {
      return lp(s) ? (n.includes(s) || n.push(s), n.indexOf(s)) : s
    }
  return JSON.stringify(t, r) !== JSON.stringify(e, r)
}
function _c(t, e, n) {
  return t.options.clip ? t[n] : e[n]
}
function uI(t, e) {
  const { xScale: n, yScale: r } = t
  return n && r
    ? {
        left: _c(n, e, 'left'),
        right: _c(n, e, 'right'),
        top: _c(r, e, 'top'),
        bottom: _c(r, e, 'bottom'),
      }
    : e
}
function I3(t, e) {
  const n = e._clip
  if (n.disabled) return !1
  const r = uI(e, t.chartArea)
  return {
    left: n.left === !1 ? 0 : r.left - (n.left === !0 ? 0 : n.left),
    right: n.right === !1 ? t.width : r.right + (n.right === !0 ? 0 : n.right),
    top: n.top === !1 ? 0 : r.top - (n.top === !0 ? 0 : n.top),
    bottom: n.bottom === !1 ? t.height : r.bottom + (n.bottom === !0 ? 0 : n.bottom),
  }
}
/*!
 * Chart.js v4.5.1
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */ class hI {
  constructor() {
    ;((this._request = null),
      (this._charts = new Map()),
      (this._running = !1),
      (this._lastDate = void 0))
  }
  _notify(e, n, r, i) {
    const s = n.listeners[i],
      c = n.duration
    s.forEach((h) =>
      h({ chart: e, initial: n.initial, numSteps: c, currentStep: Math.min(r - n.start, c) })
    )
  }
  _refresh() {
    this._request ||
      ((this._running = !0),
      (this._request = u3.call(window, () => {
        ;(this._update(), (this._request = null), this._running && this._refresh())
      })))
  }
  _update(e = Date.now()) {
    let n = 0
    ;(this._charts.forEach((r, i) => {
      if (!r.running || !r.items.length) return
      const s = r.items
      let c = s.length - 1,
        h = !1,
        f
      for (; c >= 0; --c)
        ((f = s[c]),
          f._active
            ? (f._total > r.duration && (r.duration = f._total), f.tick(e), (h = !0))
            : ((s[c] = s[s.length - 1]), s.pop()))
      ;(h && (i.draw(), this._notify(i, r, e, 'progress')),
        s.length || ((r.running = !1), this._notify(i, r, e, 'complete'), (r.initial = !1)),
        (n += s.length))
    }),
      (this._lastDate = e),
      n === 0 && (this._running = !1))
  }
  _getAnims(e) {
    const n = this._charts
    let r = n.get(e)
    return (
      r ||
        ((r = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }),
        n.set(e, r)),
      r
    )
  }
  listen(e, n, r) {
    this._getAnims(e).listeners[n].push(r)
  }
  add(e, n) {
    !n || !n.length || this._getAnims(e).items.push(...n)
  }
  has(e) {
    return this._getAnims(e).items.length > 0
  }
  start(e) {
    const n = this._charts.get(e)
    n &&
      ((n.running = !0),
      (n.start = Date.now()),
      (n.duration = n.items.reduce((r, i) => Math.max(r, i._duration), 0)),
      this._refresh())
  }
  running(e) {
    if (!this._running) return !1
    const n = this._charts.get(e)
    return !(!n || !n.running || !n.items.length)
  }
  stop(e) {
    const n = this._charts.get(e)
    if (!n || !n.items.length) return
    const r = n.items
    let i = r.length - 1
    for (; i >= 0; --i) r[i].cancel()
    ;((n.items = []), this._notify(e, n, Date.now(), 'complete'))
  }
  remove(e) {
    return this._charts.delete(e)
  }
}
var Mr = new hI()
const Fm = 'transparent',
  dI = {
    boolean(t, e, n) {
      return n > 0.5 ? e : t
    },
    color(t, e, n) {
      const r = _m(t || Fm),
        i = r.valid && _m(e || Fm)
      return i && i.valid ? i.mix(r, n).hexString() : e
    },
    number(t, e, n) {
      return t + (e - t) * n
    },
  }
class fI {
  constructor(e, n, r, i) {
    const s = n[r]
    i = kc([e.to, i, s, e.from])
    const c = kc([e.from, s, i])
    ;((this._active = !0),
      (this._fn = e.fn || dI[e.type || typeof c]),
      (this._easing = Qa[e.easing] || Qa.linear),
      (this._start = Math.floor(Date.now() + (e.delay || 0))),
      (this._duration = this._total = Math.floor(e.duration)),
      (this._loop = !!e.loop),
      (this._target = n),
      (this._prop = r),
      (this._from = c),
      (this._to = i),
      (this._promises = void 0))
  }
  active() {
    return this._active
  }
  update(e, n, r) {
    if (this._active) {
      this._notify(!1)
      const i = this._target[this._prop],
        s = r - this._start,
        c = this._duration - s
      ;((this._start = r),
        (this._duration = Math.floor(Math.max(c, e.duration))),
        (this._total += s),
        (this._loop = !!e.loop),
        (this._to = kc([e.to, n, i, e.from])),
        (this._from = kc([e.from, i, n])))
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), (this._active = !1), this._notify(!1))
  }
  tick(e) {
    const n = e - this._start,
      r = this._duration,
      i = this._prop,
      s = this._from,
      c = this._loop,
      h = this._to
    let f
    if (((this._active = s !== h && (c || n < r)), !this._active)) {
      ;((this._target[i] = h), this._notify(!0))
      return
    }
    if (n < 0) {
      this._target[i] = s
      return
    }
    ;((f = (n / r) % 2),
      (f = c && f > 1 ? 2 - f : f),
      (f = this._easing(Math.min(1, Math.max(0, f)))),
      (this._target[i] = this._fn(s, h, f)))
  }
  wait() {
    const e = this._promises || (this._promises = [])
    return new Promise((n, r) => {
      e.push({ res: n, rej: r })
    })
  }
  _notify(e) {
    const n = e ? 'res' : 'rej',
      r = this._promises || []
    for (let i = 0; i < r.length; i++) r[i][n]()
  }
}
class _3 {
  constructor(e, n) {
    ;((this._chart = e), (this._properties = new Map()), this.configure(n))
  }
  configure(e) {
    if (!Mt(e)) return
    const n = Object.keys(be.animation),
      r = this._properties
    Object.getOwnPropertyNames(e).forEach((i) => {
      const s = e[i]
      if (!Mt(s)) return
      const c = {}
      for (const h of n) c[h] = s[h]
      ;((ce(s.properties) && s.properties) || [i]).forEach((h) => {
        ;(h === i || !r.has(h)) && r.set(h, c)
      })
    })
  }
  _animateOptions(e, n) {
    const r = n.options,
      i = gI(e, r)
    if (!i) return []
    const s = this._createAnimations(i, r)
    return (
      r.$shared &&
        pI(e.options.$animations, r).then(
          () => {
            e.options = r
          },
          () => {}
        ),
      s
    )
  }
  _createAnimations(e, n) {
    const r = this._properties,
      i = [],
      s = e.$animations || (e.$animations = {}),
      c = Object.keys(n),
      h = Date.now()
    let f
    for (f = c.length - 1; f >= 0; --f) {
      const p = c[f]
      if (p.charAt(0) === '$') continue
      if (p === 'options') {
        i.push(...this._animateOptions(e, n))
        continue
      }
      const y = n[p]
      let w = s[p]
      const x = r.get(p)
      if (w)
        if (x && w.active()) {
          w.update(x, y, h)
          continue
        } else w.cancel()
      if (!x || !x.duration) {
        e[p] = y
        continue
      }
      ;((s[p] = w = new fI(x, e, p, y)), i.push(w))
    }
    return i
  }
  update(e, n) {
    if (this._properties.size === 0) {
      Object.assign(e, n)
      return
    }
    const r = this._createAnimations(e, n)
    if (r.length) return (Mr.add(this._chart, r), !0)
  }
}
function pI(t, e) {
  const n = [],
    r = Object.keys(e)
  for (let i = 0; i < r.length; i++) {
    const s = t[r[i]]
    s && s.active() && n.push(s.wait())
  }
  return Promise.all(n)
}
function gI(t, e) {
  if (!e) return
  let n = t.options
  if (!n) {
    t.options = e
    return
  }
  return (n.$shared && (t.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n)
}
function jm(t, e) {
  const n = (t && t.options) || {},
    r = n.reverse,
    i = n.min === void 0 ? e : 0,
    s = n.max === void 0 ? e : 0
  return { start: r ? s : i, end: r ? i : s }
}
function mI(t, e, n) {
  if (n === !1) return !1
  const r = jm(t, n),
    i = jm(e, n)
  return { top: i.end, right: r.end, bottom: i.start, left: r.start }
}
function yI(t) {
  let e, n, r, i
  return (
    Mt(t) ? ((e = t.top), (n = t.right), (r = t.bottom), (i = t.left)) : (e = n = r = i = t),
    { top: e, right: n, bottom: r, left: i, disabled: t === !1 }
  )
}
function R3(t, e) {
  const n = [],
    r = t._getSortedDatasetMetas(e)
  let i, s
  for (i = 0, s = r.length; i < s; ++i) n.push(r[i].index)
  return n
}
function Vm(t, e, n, r = {}) {
  const i = t.keys,
    s = r.mode === 'single'
  let c, h, f, p
  if (e === null) return
  let y = !1
  for (c = 0, h = i.length; c < h; ++c) {
    if (((f = +i[c]), f === n)) {
      if (((y = !0), r.all)) continue
      break
    }
    ;((p = t.values[f]), Be(p) && (s || e === 0 || Rr(e) === Rr(p)) && (e += p))
  }
  return !y && !r.all ? 0 : e
}
function wI(t, e) {
  const { iScale: n, vScale: r } = e,
    i = n.axis === 'x' ? 'x' : 'y',
    s = r.axis === 'x' ? 'x' : 'y',
    c = Object.keys(t),
    h = new Array(c.length)
  let f, p, y
  for (f = 0, p = c.length; f < p; ++f) ((y = c[f]), (h[f] = { [i]: y, [s]: t[y] }))
  return h
}
function Bd(t, e) {
  const n = t && t.options.stacked
  return n || (n === void 0 && e.stack !== void 0)
}
function bI(t, e, n) {
  return `${t.id}.${e.id}.${n.stack || n.type}`
}
function vI(t) {
  const { min: e, max: n, minDefined: r, maxDefined: i } = t.getUserBounds()
  return { min: r ? e : Number.NEGATIVE_INFINITY, max: i ? n : Number.POSITIVE_INFINITY }
}
function xI(t, e, n) {
  const r = t[e] || (t[e] = {})
  return r[n] || (r[n] = {})
}
function Wm(t, e, n, r) {
  for (const i of e.getMatchingVisibleMetas(r).reverse()) {
    const s = t[i.index]
    if ((n && s > 0) || (!n && s < 0)) return i.index
  }
  return null
}
function Um(t, e) {
  const { chart: n, _cachedMeta: r } = t,
    i = n._stacks || (n._stacks = {}),
    { iScale: s, vScale: c, index: h } = r,
    f = s.axis,
    p = c.axis,
    y = bI(s, c, r),
    w = e.length
  let x
  for (let E = 0; E < w; ++E) {
    const S = e[E],
      { [f]: k, [p]: D } = S,
      _ = S._stacks || (S._stacks = {})
    ;((x = _[p] = xI(i, y, k)),
      (x[h] = D),
      (x._top = Wm(x, c, !0, r.type)),
      (x._bottom = Wm(x, c, !1, r.type)))
    const N = x._visualValues || (x._visualValues = {})
    N[h] = D
  }
}
function Fd(t, e) {
  const n = t.scales
  return Object.keys(n)
    .filter((r) => n[r].axis === e)
    .shift()
}
function EI(t, e) {
  return Ui(t, {
    active: !1,
    dataset: void 0,
    datasetIndex: e,
    index: e,
    mode: 'default',
    type: 'dataset',
  })
}
function CI(t, e, n) {
  return Ui(t, {
    active: !1,
    dataIndex: e,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: e,
    mode: 'default',
    type: 'data',
  })
}
function xa(t, e) {
  const n = t.controller.index,
    r = t.vScale && t.vScale.axis
  if (r) {
    e = e || t._parsed
    for (const i of e) {
      const s = i._stacks
      if (!s || s[r] === void 0 || s[r][n] === void 0) return
      ;(delete s[r][n],
        s[r]._visualValues !== void 0 &&
          s[r]._visualValues[n] !== void 0 &&
          delete s[r]._visualValues[n])
    }
  }
}
const jd = (t) => t === 'reset' || t === 'none',
  zm = (t, e) => (e ? t : Object.assign({}, t)),
  SI = (t, e, n) => t && !e.hidden && e._stacked && { keys: R3(n, !0), values: null }
class mo {
  constructor(e, n) {
    ;((this.chart = e),
      (this._ctx = e.ctx),
      (this.index = n),
      (this._cachedDataOpts = {}),
      (this._cachedMeta = this.getMeta()),
      (this._type = this._cachedMeta.type),
      (this.options = void 0),
      (this._parsing = !1),
      (this._data = void 0),
      (this._objectData = void 0),
      (this._sharedOptions = void 0),
      (this._drawStart = void 0),
      (this._drawCount = void 0),
      (this.enableOptionSharing = !1),
      (this.supportsDecimation = !1),
      (this.$context = void 0),
      (this._syncList = []),
      (this.datasetElementType = new.target.datasetElementType),
      (this.dataElementType = new.target.dataElementType),
      this.initialize())
  }
  initialize() {
    const e = this._cachedMeta
    ;(this.configure(),
      this.linkScales(),
      (e._stacked = Bd(e.vScale, e)),
      this.addElements(),
      this.options.fill &&
        !this.chart.isPluginEnabled('filler') &&
        console.warn(
          "Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options"
        ))
  }
  updateIndex(e) {
    ;(this.index !== e && xa(this._cachedMeta), (this.index = e))
  }
  linkScales() {
    const e = this.chart,
      n = this._cachedMeta,
      r = this.getDataset(),
      i = (w, x, E, S) => (w === 'x' ? x : w === 'r' ? S : E),
      s = (n.xAxisID = It(r.xAxisID, Fd(e, 'x'))),
      c = (n.yAxisID = It(r.yAxisID, Fd(e, 'y'))),
      h = (n.rAxisID = It(r.rAxisID, Fd(e, 'r'))),
      f = n.indexAxis,
      p = (n.iAxisID = i(f, s, c, h)),
      y = (n.vAxisID = i(f, c, s, h))
    ;((n.xScale = this.getScaleForId(s)),
      (n.yScale = this.getScaleForId(c)),
      (n.rScale = this.getScaleForId(h)),
      (n.iScale = this.getScaleForId(p)),
      (n.vScale = this.getScaleForId(y)))
  }
  getDataset() {
    return this.chart.data.datasets[this.index]
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index)
  }
  getScaleForId(e) {
    return this.chart.scales[e]
  }
  _getOtherScale(e) {
    const n = this._cachedMeta
    return e === n.iScale ? n.vScale : n.iScale
  }
  reset() {
    this._update('reset')
  }
  _destroy() {
    const e = this._cachedMeta
    ;(this._data && Am(this._data, this), e._stacked && xa(e))
  }
  _dataCheck() {
    const e = this.getDataset(),
      n = e.data || (e.data = []),
      r = this._data
    if (Mt(n)) {
      const i = this._cachedMeta
      this._data = wI(n, i)
    } else if (r !== n) {
      if (r) {
        Am(r, this)
        const i = this._cachedMeta
        ;(xa(i), (i._parsed = []))
      }
      ;(n && Object.isExtensible(n) && i9(n, this), (this._syncList = []), (this._data = n))
    }
  }
  addElements() {
    const e = this._cachedMeta
    ;(this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType()))
  }
  buildOrUpdateElements(e) {
    const n = this._cachedMeta,
      r = this.getDataset()
    let i = !1
    this._dataCheck()
    const s = n._stacked
    ;((n._stacked = Bd(n.vScale, n)),
      n.stack !== r.stack && ((i = !0), xa(n), (n.stack = r.stack)),
      this._resyncElements(e),
      (i || s !== n._stacked) && (Um(this, n._parsed), (n._stacked = Bd(n.vScale, n))))
  }
  configure() {
    const e = this.chart.config,
      n = e.datasetScopeKeys(this._type),
      r = e.getOptionScopes(this.getDataset(), n, !0)
    ;((this.options = e.createResolver(r, this.getContext())),
      (this._parsing = this.options.parsing),
      (this._cachedDataOpts = {}))
  }
  parse(e, n) {
    const { _cachedMeta: r, _data: i } = this,
      { iScale: s, _stacked: c } = r,
      h = s.axis
    let f = e === 0 && n === i.length ? !0 : r._sorted,
      p = e > 0 && r._parsed[e - 1],
      y,
      w,
      x
    if (this._parsing === !1) ((r._parsed = i), (r._sorted = !0), (x = i))
    else {
      ce(i[e])
        ? (x = this.parseArrayData(r, i, e, n))
        : Mt(i[e])
          ? (x = this.parseObjectData(r, i, e, n))
          : (x = this.parsePrimitiveData(r, i, e, n))
      const E = () => w[h] === null || (p && w[h] < p[h])
      for (y = 0; y < n; ++y) ((r._parsed[y + e] = w = x[y]), f && (E() && (f = !1), (p = w)))
      r._sorted = f
    }
    c && Um(this, x)
  }
  parsePrimitiveData(e, n, r, i) {
    const { iScale: s, vScale: c } = e,
      h = s.axis,
      f = c.axis,
      p = s.getLabels(),
      y = s === c,
      w = new Array(i)
    let x, E, S
    for (x = 0, E = i; x < E; ++x)
      ((S = x + r), (w[x] = { [h]: y || s.parse(p[S], S), [f]: c.parse(n[S], S) }))
    return w
  }
  parseArrayData(e, n, r, i) {
    const { xScale: s, yScale: c } = e,
      h = new Array(i)
    let f, p, y, w
    for (f = 0, p = i; f < p; ++f)
      ((y = f + r), (w = n[y]), (h[f] = { x: s.parse(w[0], y), y: c.parse(w[1], y) }))
    return h
  }
  parseObjectData(e, n, r, i) {
    const { xScale: s, yScale: c } = e,
      { xAxisKey: h = 'x', yAxisKey: f = 'y' } = this._parsing,
      p = new Array(i)
    let y, w, x, E
    for (y = 0, w = i; y < w; ++y)
      ((x = y + r), (E = n[x]), (p[y] = { x: s.parse(Co(E, h), x), y: c.parse(Co(E, f), x) }))
    return p
  }
  getParsed(e) {
    return this._cachedMeta._parsed[e]
  }
  getDataElement(e) {
    return this._cachedMeta.data[e]
  }
  applyStack(e, n, r) {
    const i = this.chart,
      s = this._cachedMeta,
      c = n[e.axis],
      h = { keys: R3(i, !0), values: n._stacks[e.axis]._visualValues }
    return Vm(h, c, s.index, { mode: r })
  }
  updateRangeFromParsed(e, n, r, i) {
    const s = r[n.axis]
    let c = s === null ? NaN : s
    const h = i && r._stacks[n.axis]
    ;(i && h && ((i.values = h), (c = Vm(i, s, this._cachedMeta.index))),
      (e.min = Math.min(e.min, c)),
      (e.max = Math.max(e.max, c)))
  }
  getMinMax(e, n) {
    const r = this._cachedMeta,
      i = r._parsed,
      s = r._sorted && e === r.iScale,
      c = i.length,
      h = this._getOtherScale(e),
      f = SI(n, r, this.chart),
      p = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },
      { min: y, max: w } = vI(h)
    let x, E
    function S() {
      E = i[x]
      const k = E[h.axis]
      return !Be(E[e.axis]) || y > k || w < k
    }
    for (x = 0; x < c && !(!S() && (this.updateRangeFromParsed(p, e, E, f), s)); ++x);
    if (s) {
      for (x = c - 1; x >= 0; --x)
        if (!S()) {
          this.updateRangeFromParsed(p, e, E, f)
          break
        }
    }
    return p
  }
  getAllParsedValues(e) {
    const n = this._cachedMeta._parsed,
      r = []
    let i, s, c
    for (i = 0, s = n.length; i < s; ++i) ((c = n[i][e.axis]), Be(c) && r.push(c))
    return r
  }
  getMaxOverflow() {
    return !1
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta,
      r = n.iScale,
      i = n.vScale,
      s = this.getParsed(e)
    return {
      label: r ? '' + r.getLabelForValue(s[r.axis]) : '',
      value: i ? '' + i.getLabelForValue(s[i.axis]) : '',
    }
  }
  _update(e) {
    const n = this._cachedMeta
    ;(this.update(e || 'default'),
      (n._clip = yI(It(this.options.clip, mI(n.xScale, n.yScale, this.getMaxOverflow())))))
  }
  update(e) {}
  draw() {
    const e = this._ctx,
      n = this.chart,
      r = this._cachedMeta,
      i = r.data || [],
      s = n.chartArea,
      c = [],
      h = this._drawStart || 0,
      f = this._drawCount || i.length - h,
      p = this.options.drawActiveElementsOnTop
    let y
    for (r.dataset && r.dataset.draw(e, s, h, f), y = h; y < h + f; ++y) {
      const w = i[y]
      w.hidden || (w.active && p ? c.push(w) : w.draw(e, s))
    }
    for (y = 0; y < c.length; ++y) c[y].draw(e, s)
  }
  getStyle(e, n) {
    const r = n ? 'active' : 'default'
    return e === void 0 && this._cachedMeta.dataset
      ? this.resolveDatasetElementOptions(r)
      : this.resolveDataElementOptions(e || 0, r)
  }
  getContext(e, n, r) {
    const i = this.getDataset()
    let s
    if (e >= 0 && e < this._cachedMeta.data.length) {
      const c = this._cachedMeta.data[e]
      ;((s = c.$context || (c.$context = CI(this.getContext(), e, c))),
        (s.parsed = this.getParsed(e)),
        (s.raw = i.data[e]),
        (s.index = s.dataIndex = e))
    } else
      ((s = this.$context || (this.$context = EI(this.chart.getContext(), this.index))),
        (s.dataset = i),
        (s.index = s.datasetIndex = this.index))
    return ((s.active = !!n), (s.mode = r), s)
  }
  resolveDatasetElementOptions(e) {
    return this._resolveElementOptions(this.datasetElementType.id, e)
  }
  resolveDataElementOptions(e, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, e)
  }
  _resolveElementOptions(e, n = 'default', r) {
    const i = n === 'active',
      s = this._cachedDataOpts,
      c = e + '-' + n,
      h = s[c],
      f = this.enableOptionSharing && Il(r)
    if (h) return zm(h, f)
    const p = this.chart.config,
      y = p.datasetElementScopeKeys(this._type, e),
      w = i ? [`${e}Hover`, 'hover', e, ''] : [e, ''],
      x = p.getOptionScopes(this.getDataset(), y),
      E = Object.keys(be.elements[e]),
      S = () => this.getContext(r, i, n),
      k = p.resolveNamedOptions(x, E, S, w)
    return (k.$shared && ((k.$shared = f), (s[c] = Object.freeze(zm(k, f)))), k)
  }
  _resolveAnimations(e, n, r) {
    const i = this.chart,
      s = this._cachedDataOpts,
      c = `animation-${n}`,
      h = s[c]
    if (h) return h
    let f
    if (i.options.animation !== !1) {
      const y = this.chart.config,
        w = y.datasetAnimationScopeKeys(this._type, n),
        x = y.getOptionScopes(this.getDataset(), w)
      f = y.createResolver(x, this.getContext(e, r, n))
    }
    const p = new _3(i, f && f.animations)
    return (f && f._cacheable && (s[c] = Object.freeze(p)), p)
  }
  getSharedOptions(e) {
    if (e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e))
  }
  includeOptions(e, n) {
    return !n || jd(e) || this.chart._animationsDisabled
  }
  _getSharedOptions(e, n) {
    const r = this.resolveDataElementOptions(e, n),
      i = this._sharedOptions,
      s = this.getSharedOptions(r),
      c = this.includeOptions(n, s) || s !== i
    return (this.updateSharedOptions(s, n, r), { sharedOptions: s, includeOptions: c })
  }
  updateElement(e, n, r, i) {
    jd(i) ? Object.assign(e, r) : this._resolveAnimations(n, i).update(e, r)
  }
  updateSharedOptions(e, n, r) {
    e && !jd(n) && this._resolveAnimations(void 0, n).update(e, r)
  }
  _setStyle(e, n, r, i) {
    e.active = i
    const s = this.getStyle(n, i)
    this._resolveAnimations(n, r, i).update(e, { options: (!i && this.getSharedOptions(s)) || s })
  }
  removeHoverStyle(e, n, r) {
    this._setStyle(e, r, 'active', !1)
  }
  setHoverStyle(e, n, r) {
    this._setStyle(e, r, 'active', !0)
  }
  _removeDatasetHoverStyle() {
    const e = this._cachedMeta.dataset
    e && this._setStyle(e, void 0, 'active', !1)
  }
  _setDatasetHoverStyle() {
    const e = this._cachedMeta.dataset
    e && this._setStyle(e, void 0, 'active', !0)
  }
  _resyncElements(e) {
    const n = this._data,
      r = this._cachedMeta.data
    for (const [h, f, p] of this._syncList) this[h](f, p)
    this._syncList = []
    const i = r.length,
      s = n.length,
      c = Math.min(s, i)
    ;(c && this.parse(0, c),
      s > i ? this._insertElements(i, s - i, e) : s < i && this._removeElements(s, i - s))
  }
  _insertElements(e, n, r = !0) {
    const i = this._cachedMeta,
      s = i.data,
      c = e + n
    let h
    const f = (p) => {
      for (p.length += n, h = p.length - 1; h >= c; h--) p[h] = p[h - n]
    }
    for (f(s), h = e; h < c; ++h) s[h] = new this.dataElementType()
    ;(this._parsing && f(i._parsed), this.parse(e, n), r && this.updateElements(s, e, n, 'reset'))
  }
  updateElements(e, n, r, i) {}
  _removeElements(e, n) {
    const r = this._cachedMeta
    if (this._parsing) {
      const i = r._parsed.splice(e, n)
      r._stacked && xa(r, i)
    }
    r.data.splice(e, n)
  }
  _sync(e) {
    if (this._parsing) this._syncList.push(e)
    else {
      const [n, r, i] = e
      this[n](r, i)
    }
    this.chart._dataChanges.push([this.index, ...e])
  }
  _onDataPush() {
    const e = arguments.length
    this._sync(['_insertElements', this.getDataset().data.length - e, e])
  }
  _onDataPop() {
    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1])
  }
  _onDataShift() {
    this._sync(['_removeElements', 0, 1])
  }
  _onDataSplice(e, n) {
    n && this._sync(['_removeElements', e, n])
    const r = arguments.length - 2
    r && this._sync(['_insertElements', e, r])
  }
  _onDataUnshift() {
    this._sync(['_insertElements', 0, arguments.length])
  }
}
;(yt(mo, 'defaults', {}), yt(mo, 'datasetElementType', null), yt(mo, 'dataElementType', null))
function AI(t, e) {
  if (!t._cache.$bar) {
    const n = t.getMatchingVisibleMetas(e)
    let r = []
    for (let i = 0, s = n.length; i < s; i++) r = r.concat(n[i].controller.getAllParsedValues(t))
    t._cache.$bar = c3(r.sort((i, s) => i - s))
  }
  return t._cache.$bar
}
function kI(t) {
  const e = t.iScale,
    n = AI(e, t.type)
  let r = e._length,
    i,
    s,
    c,
    h
  const f = () => {
    c === 32767 || c === -32768 || (Il(h) && (r = Math.min(r, Math.abs(c - h) || r)), (h = c))
  }
  for (i = 0, s = n.length; i < s; ++i) ((c = e.getPixelForValue(n[i])), f())
  for (h = void 0, i = 0, s = e.ticks.length; i < s; ++i) ((c = e.getPixelForTick(i)), f())
  return r
}
function II(t, e, n, r) {
  const i = n.barThickness
  let s, c
  return (
    Ot(i) ? ((s = e.min * n.categoryPercentage), (c = n.barPercentage)) : ((s = i * r), (c = 1)),
    { chunk: s / r, ratio: c, start: e.pixels[t] - s / 2 }
  )
}
function _I(t, e, n, r) {
  const i = e.pixels,
    s = i[t]
  let c = t > 0 ? i[t - 1] : null,
    h = t < i.length - 1 ? i[t + 1] : null
  const f = n.categoryPercentage
  ;(c === null && (c = s - (h === null ? e.end - e.start : h - s)), h === null && (h = s + s - c))
  const p = s - ((s - Math.min(c, h)) / 2) * f
  return { chunk: ((Math.abs(h - c) / 2) * f) / r, ratio: n.barPercentage, start: p }
}
function RI(t, e, n, r) {
  const i = n.parse(t[0], r),
    s = n.parse(t[1], r),
    c = Math.min(i, s),
    h = Math.max(i, s)
  let f = c,
    p = h
  ;(Math.abs(c) > Math.abs(h) && ((f = h), (p = c)),
    (e[n.axis] = p),
    (e._custom = { barStart: f, barEnd: p, start: i, end: s, min: c, max: h }))
}
function T3(t, e, n, r) {
  return (ce(t) ? RI(t, e, n, r) : (e[n.axis] = n.parse(t, r)), e)
}
function Hm(t, e, n, r) {
  const i = t.iScale,
    s = t.vScale,
    c = i.getLabels(),
    h = i === s,
    f = []
  let p, y, w, x
  for (p = n, y = n + r; p < y; ++p)
    ((x = e[p]), (w = {}), (w[i.axis] = h || i.parse(c[p], p)), f.push(T3(x, w, s, p)))
  return f
}
function Vd(t) {
  return t && t.barStart !== void 0 && t.barEnd !== void 0
}
function TI(t, e, n) {
  return t !== 0 ? Rr(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= n ? 1 : -1)
}
function NI(t) {
  let e, n, r, i, s
  return (
    t.horizontal
      ? ((e = t.base > t.x), (n = 'left'), (r = 'right'))
      : ((e = t.base < t.y), (n = 'bottom'), (r = 'top')),
    e ? ((i = 'end'), (s = 'start')) : ((i = 'start'), (s = 'end')),
    { start: n, end: r, reverse: e, top: i, bottom: s }
  )
}
function MI(t, e, n, r) {
  let i = e.borderSkipped
  const s = {}
  if (!i) {
    t.borderSkipped = s
    return
  }
  if (i === !0) {
    t.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }
    return
  }
  const { start: c, end: h, reverse: f, top: p, bottom: y } = NI(t)
  ;(i === 'middle' &&
    n &&
    ((t.enableBorderRadius = !0),
    (n._top || 0) === r
      ? (i = p)
      : (n._bottom || 0) === r
        ? (i = y)
        : ((s[Xm(y, c, h, f)] = !0), (i = p))),
    (s[Xm(i, c, h, f)] = !0),
    (t.borderSkipped = s))
}
function Xm(t, e, n, r) {
  return (r ? ((t = DI(t, e, n)), (t = Gm(t, n, e))) : (t = Gm(t, e, n)), t)
}
function DI(t, e, n) {
  return t === e ? n : t === n ? e : t
}
function Gm(t, e, n) {
  return t === 'start' ? e : t === 'end' ? n : t
}
function PI(t, { inflateAmount: e }, n) {
  t.inflateAmount = e === 'auto' ? (n === 1 ? 0.33 : 0) : e
}
class $c extends mo {
  parsePrimitiveData(e, n, r, i) {
    return Hm(e, n, r, i)
  }
  parseArrayData(e, n, r, i) {
    return Hm(e, n, r, i)
  }
  parseObjectData(e, n, r, i) {
    const { iScale: s, vScale: c } = e,
      { xAxisKey: h = 'x', yAxisKey: f = 'y' } = this._parsing,
      p = s.axis === 'x' ? h : f,
      y = c.axis === 'x' ? h : f,
      w = []
    let x, E, S, k
    for (x = r, E = r + i; x < E; ++x)
      ((k = n[x]), (S = {}), (S[s.axis] = s.parse(Co(k, p), x)), w.push(T3(Co(k, y), S, c, x)))
    return w
  }
  updateRangeFromParsed(e, n, r, i) {
    super.updateRangeFromParsed(e, n, r, i)
    const s = r._custom
    s &&
      n === this._cachedMeta.vScale &&
      ((e.min = Math.min(e.min, s.min)), (e.max = Math.max(e.max, s.max)))
  }
  getMaxOverflow() {
    return 0
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta,
      { iScale: r, vScale: i } = n,
      s = this.getParsed(e),
      c = s._custom,
      h = Vd(c) ? '[' + c.start + ', ' + c.end + ']' : '' + i.getLabelForValue(s[i.axis])
    return { label: '' + r.getLabelForValue(s[r.axis]), value: h }
  }
  initialize() {
    ;((this.enableOptionSharing = !0), super.initialize())
    const e = this._cachedMeta
    e.stack = this.getDataset().stack
  }
  update(e) {
    const n = this._cachedMeta
    this.updateElements(n.data, 0, n.data.length, e)
  }
  updateElements(e, n, r, i) {
    const s = i === 'reset',
      {
        index: c,
        _cachedMeta: { vScale: h },
      } = this,
      f = h.getBasePixel(),
      p = h.isHorizontal(),
      y = this._getRuler(),
      { sharedOptions: w, includeOptions: x } = this._getSharedOptions(n, i)
    for (let E = n; E < n + r; E++) {
      const S = this.getParsed(E),
        k = s || Ot(S[h.axis]) ? { base: f, head: f } : this._calculateBarValuePixels(E),
        D = this._calculateBarIndexPixels(E, y),
        _ = (S._stacks || {})[h.axis],
        N = {
          horizontal: p,
          base: k.base,
          enableBorderRadius: !_ || Vd(S._custom) || c === _._top || c === _._bottom,
          x: p ? k.head : D.center,
          y: p ? D.center : k.head,
          height: p ? D.size : Math.abs(k.size),
          width: p ? Math.abs(k.size) : D.size,
        }
      x && (N.options = w || this.resolveDataElementOptions(E, e[E].active ? 'active' : i))
      const M = N.options || e[E].options
      ;(MI(N, M, _, c), PI(N, M, y.ratio), this.updateElement(e[E], E, N, i))
    }
  }
  _getStacks(e, n) {
    const { iScale: r } = this._cachedMeta,
      i = r.getMatchingVisibleMetas(this._type).filter((y) => y.controller.options.grouped),
      s = r.options.stacked,
      c = [],
      h = this._cachedMeta.controller.getParsed(n),
      f = h && h[r.axis],
      p = (y) => {
        const w = y._parsed.find((E) => E[r.axis] === f),
          x = w && w[y.vScale.axis]
        if (Ot(x) || isNaN(x)) return !0
      }
    for (const y of i)
      if (
        !(n !== void 0 && p(y)) &&
        ((s === !1 || c.indexOf(y.stack) === -1 || (s === void 0 && y.stack === void 0)) &&
          c.push(y.stack),
        y.index === e)
      )
        break
    return (c.length || c.push(void 0), c)
  }
  _getStackCount(e) {
    return this._getStacks(void 0, e).length
  }
  _getAxisCount() {
    return this._getAxis().length
  }
  getFirstScaleIdForIndexAxis() {
    const e = this.chart.scales,
      n = this.chart.options.indexAxis
    return Object.keys(e)
      .filter((r) => e[r].axis === n)
      .shift()
  }
  _getAxis() {
    const e = {},
      n = this.getFirstScaleIdForIndexAxis()
    for (const r of this.chart.data.datasets)
      e[It(this.chart.options.indexAxis === 'x' ? r.xAxisID : r.yAxisID, n)] = !0
    return Object.keys(e)
  }
  _getStackIndex(e, n, r) {
    const i = this._getStacks(e, r),
      s = n !== void 0 ? i.indexOf(n) : -1
    return s === -1 ? i.length - 1 : s
  }
  _getRuler() {
    const e = this.options,
      n = this._cachedMeta,
      r = n.iScale,
      i = []
    let s, c
    for (s = 0, c = n.data.length; s < c; ++s)
      i.push(r.getPixelForValue(this.getParsed(s)[r.axis], s))
    const h = e.barThickness
    return {
      min: h || kI(n),
      pixels: i,
      start: r._startPixel,
      end: r._endPixel,
      stackCount: this._getStackCount(),
      scale: r,
      grouped: e.grouped,
      ratio: h ? 1 : e.categoryPercentage * e.barPercentage,
    }
  }
  _calculateBarValuePixels(e) {
    const {
        _cachedMeta: { vScale: n, _stacked: r, index: i },
        options: { base: s, minBarLength: c },
      } = this,
      h = s || 0,
      f = this.getParsed(e),
      p = f._custom,
      y = Vd(p)
    let w = f[n.axis],
      x = 0,
      E = r ? this.applyStack(n, f, r) : w,
      S,
      k
    ;(E !== w && ((x = E - w), (E = w)),
      y &&
        ((w = p.barStart),
        (E = p.barEnd - p.barStart),
        w !== 0 && Rr(w) !== Rr(p.barEnd) && (x = 0),
        (x += w)))
    const D = !Ot(s) && !y ? s : x
    let _ = n.getPixelForValue(D)
    if (
      (this.chart.getDataVisibility(e) ? (S = n.getPixelForValue(x + E)) : (S = _),
      (k = S - _),
      Math.abs(k) < c)
    ) {
      ;((k = TI(k, n, h) * c), w === h && (_ -= k / 2))
      const N = n.getPixelForDecimal(0),
        M = n.getPixelForDecimal(1),
        O = Math.min(N, M),
        F = Math.max(N, M)
      ;((_ = Math.max(Math.min(_, F), O)),
        (S = _ + k),
        r &&
          !y &&
          (f._stacks[n.axis]._visualValues[i] = n.getValueForPixel(S) - n.getValueForPixel(_)))
    }
    if (_ === n.getPixelForValue(h)) {
      const N = (Rr(k) * n.getLineWidthForValue(h)) / 2
      ;((_ += N), (k -= N))
    }
    return { size: k, base: _, head: S, center: S + k / 2 }
  }
  _calculateBarIndexPixels(e, n) {
    const r = n.scale,
      i = this.options,
      s = i.skipNull,
      c = It(i.maxBarThickness, 1 / 0)
    let h, f
    const p = this._getAxisCount()
    if (n.grouped) {
      const y = s ? this._getStackCount(e) : n.stackCount,
        w = i.barThickness === 'flex' ? _I(e, n, i, y * p) : II(e, n, i, y * p),
        x =
          this.chart.options.indexAxis === 'x'
            ? this.getDataset().xAxisID
            : this.getDataset().yAxisID,
        E = this._getAxis().indexOf(It(x, this.getFirstScaleIdForIndexAxis())),
        S = this._getStackIndex(this.index, this._cachedMeta.stack, s ? e : void 0) + E
      ;((h = w.start + w.chunk * S + w.chunk / 2), (f = Math.min(c, w.chunk * w.ratio)))
    } else
      ((h = r.getPixelForValue(this.getParsed(e)[r.axis], e)), (f = Math.min(c, n.min * n.ratio)))
    return { base: h - f / 2, head: h + f / 2, center: h, size: f }
  }
  draw() {
    const e = this._cachedMeta,
      n = e.vScale,
      r = e.data,
      i = r.length
    let s = 0
    for (; s < i; ++s) this.getParsed(s)[n.axis] !== null && !r[s].hidden && r[s].draw(this._ctx)
  }
}
;(yt($c, 'id', 'bar'),
  yt($c, 'defaults', {
    datasetElementType: !1,
    dataElementType: 'bar',
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: { numbers: { type: 'number', properties: ['x', 'y', 'base', 'width', 'height'] } },
  }),
  yt($c, 'overrides', {
    scales: {
      _index_: { type: 'category', offset: !0, grid: { offset: !0 } },
      _value_: { type: 'linear', beginAtZero: !0 },
    },
  }))
class Jc extends mo {
  initialize() {
    ;((this.enableOptionSharing = !0), (this.supportsDecimation = !0), super.initialize())
  }
  update(e) {
    const n = this._cachedMeta,
      { dataset: r, data: i = [], _dataset: s } = n,
      c = this.chart._animationsDisabled
    let { start: h, count: f } = a9(n, i, c)
    ;((this._drawStart = h),
      (this._drawCount = f),
      l9(n) && ((h = 0), (f = i.length)),
      (r._chart = this.chart),
      (r._datasetIndex = this.index),
      (r._decimated = !!s._decimated),
      (r.points = i))
    const p = this.resolveDatasetElementOptions(e)
    ;(this.options.showLine || (p.borderWidth = 0),
      (p.segment = this.options.segment),
      this.updateElement(r, void 0, { animated: !c, options: p }, e),
      this.updateElements(i, h, f, e))
  }
  updateElements(e, n, r, i) {
    const s = i === 'reset',
      { iScale: c, vScale: h, _stacked: f, _dataset: p } = this._cachedMeta,
      { sharedOptions: y, includeOptions: w } = this._getSharedOptions(n, i),
      x = c.axis,
      E = h.axis,
      { spanGaps: S, segment: k } = this.options,
      D = _l(S) ? S : Number.POSITIVE_INFINITY,
      _ = this.chart._animationsDisabled || s || i === 'none',
      N = n + r,
      M = e.length
    let O = n > 0 && this.getParsed(n - 1)
    for (let F = 0; F < M; ++F) {
      const z = e[F],
        V = _ ? z : {}
      if (F < n || F >= N) {
        V.skip = !0
        continue
      }
      const W = this.getParsed(F),
        Z = Ot(W[E]),
        J = (V[x] = c.getPixelForValue(W[x], F)),
        st = (V[E] =
          s || Z ? h.getBasePixel() : h.getPixelForValue(f ? this.applyStack(h, W, f) : W[E], F))
      ;((V.skip = isNaN(J) || isNaN(st) || Z),
        (V.stop = F > 0 && Math.abs(W[x] - O[x]) > D),
        k && ((V.parsed = W), (V.raw = p.data[F])),
        w && (V.options = y || this.resolveDataElementOptions(F, z.active ? 'active' : i)),
        _ || this.updateElement(z, F, V, i),
        (O = W))
    }
  }
  getMaxOverflow() {
    const e = this._cachedMeta,
      n = e.dataset,
      r = (n.options && n.options.borderWidth) || 0,
      i = e.data || []
    if (!i.length) return r
    const s = i[0].size(this.resolveDataElementOptions(0)),
      c = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1))
    return Math.max(r, s, c) / 2
  }
  draw() {
    const e = this._cachedMeta
    ;(e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw())
  }
}
;(yt(Jc, 'id', 'line'),
  yt(Jc, 'defaults', {
    datasetElementType: 'line',
    dataElementType: 'point',
    showLine: !0,
    spanGaps: !1,
  }),
  yt(Jc, 'overrides', { scales: { _index_: { type: 'category' }, _value_: { type: 'linear' } } }))
class tu extends mo {
  getLabelAndValue(e) {
    const n = this._cachedMeta.vScale,
      r = this.getParsed(e)
    return { label: n.getLabels()[e], value: '' + n.getLabelForValue(r[n.axis]) }
  }
  parseObjectData(e, n, r, i) {
    return j9.bind(this)(e, n, r, i)
  }
  update(e) {
    const n = this._cachedMeta,
      r = n.dataset,
      i = n.data || [],
      s = n.iScale.getLabels()
    if (((r.points = i), e !== 'resize')) {
      const c = this.resolveDatasetElementOptions(e)
      this.options.showLine || (c.borderWidth = 0)
      const h = { _loop: !0, _fullLoop: s.length === i.length, options: c }
      this.updateElement(r, void 0, h, e)
    }
    this.updateElements(i, 0, i.length, e)
  }
  updateElements(e, n, r, i) {
    const s = this._cachedMeta.rScale,
      c = i === 'reset'
    for (let h = n; h < n + r; h++) {
      const f = e[h],
        p = this.resolveDataElementOptions(h, f.active ? 'active' : i),
        y = s.getPointPositionForValue(h, this.getParsed(h).r),
        w = c ? s.xCenter : y.x,
        x = c ? s.yCenter : y.y,
        E = { x: w, y: x, angle: y.angle, skip: isNaN(w) || isNaN(x), options: p }
      this.updateElement(f, h, E, i)
    }
  }
}
;(yt(tu, 'id', 'radar'),
  yt(tu, 'defaults', {
    datasetElementType: 'line',
    dataElementType: 'point',
    indexAxis: 'r',
    showLine: !0,
    elements: { line: { fill: 'start' } },
  }),
  yt(tu, 'overrides', { aspectRatio: 1, scales: { r: { type: 'radialLinear' } } }))
function $i() {
  throw new Error('This method is not implemented: Check that a complete date adapter is provided.')
}
class gp {
  constructor(e) {
    ;(yt(this, 'options'), (this.options = e || {}))
  }
  static override(e) {
    Object.assign(gp.prototype, e)
  }
  init() {}
  formats() {
    return $i()
  }
  parse() {
    return $i()
  }
  format() {
    return $i()
  }
  add() {
    return $i()
  }
  diff() {
    return $i()
  }
  startOf() {
    return $i()
  }
  endOf() {
    return $i()
  }
}
var LI = { _date: gp }
function OI(t, e, n, r) {
  const { controller: i, data: s, _sorted: c } = t,
    h = i._cachedMeta.iScale,
    f = t.dataset && t.dataset.options ? t.dataset.options.spanGaps : null
  if (h && e === h.axis && e !== 'r' && c && s.length) {
    const p = h._reversePixels ? n9 : co
    if (r) {
      if (i._sharedOptions) {
        const y = s[0],
          w = typeof y.getRange == 'function' && y.getRange(e)
        if (w) {
          const x = p(s, e, n - w),
            E = p(s, e, n + w)
          return { lo: x.lo, hi: E.hi }
        }
      }
    } else {
      const y = p(s, e, n)
      if (f) {
        const { vScale: w } = i._cachedMeta,
          { _parsed: x } = t,
          E = x
            .slice(0, y.lo + 1)
            .reverse()
            .findIndex((k) => !Ot(k[w.axis]))
        y.lo -= Math.max(0, E)
        const S = x.slice(y.hi).findIndex((k) => !Ot(k[w.axis]))
        y.hi += Math.max(0, S)
      }
      return y
    }
  }
  return { lo: 0, hi: s.length - 1 }
}
function Sh(t, e, n, r, i) {
  const s = t.getSortedVisibleDatasetMetas(),
    c = n[e]
  for (let h = 0, f = s.length; h < f; ++h) {
    const { index: p, data: y } = s[h],
      { lo: w, hi: x } = OI(s[h], e, c, i)
    for (let E = w; E <= x; ++E) {
      const S = y[E]
      S.skip || r(S, p, E)
    }
  }
}
function BI(t) {
  const e = t.indexOf('x') !== -1,
    n = t.indexOf('y') !== -1
  return function (r, i) {
    const s = e ? Math.abs(r.x - i.x) : 0,
      c = n ? Math.abs(r.y - i.y) : 0
    return Math.sqrt(Math.pow(s, 2) + Math.pow(c, 2))
  }
}
function Wd(t, e, n, r, i) {
  const s = []
  return (
    (!i && !t.isPointInArea(e)) ||
      Sh(
        t,
        n,
        e,
        function (c, h, f) {
          ;(!i && !Vr(c, t.chartArea, 0)) ||
            (c.inRange(e.x, e.y, r) && s.push({ element: c, datasetIndex: h, index: f }))
        },
        !0
      ),
    s
  )
}
function FI(t, e, n, r) {
  let i = []
  function s(c, h, f) {
    const { startAngle: p, endAngle: y } = c.getProps(['startAngle', 'endAngle'], r),
      { angle: w } = Jk(c, { x: e.x, y: e.y })
    a3(w, p, y) && i.push({ element: c, datasetIndex: h, index: f })
  }
  return (Sh(t, n, e, s), i)
}
function jI(t, e, n, r, i, s) {
  let c = []
  const h = BI(n)
  let f = Number.POSITIVE_INFINITY
  function p(y, w, x) {
    const E = y.inRange(e.x, e.y, i)
    if (r && !E) return
    const S = y.getCenterPoint(i)
    if (!(s || t.isPointInArea(S)) && !E) return
    const k = h(e, S)
    k < f
      ? ((c = [{ element: y, datasetIndex: w, index: x }]), (f = k))
      : k === f && c.push({ element: y, datasetIndex: w, index: x })
  }
  return (Sh(t, n, e, p), c)
}
function Ud(t, e, n, r, i, s) {
  return !s && !t.isPointInArea(e) ? [] : n === 'r' && !r ? FI(t, e, n, i) : jI(t, e, n, r, i, s)
}
function Ym(t, e, n, r, i) {
  const s = [],
    c = n === 'x' ? 'inXRange' : 'inYRange'
  let h = !1
  return (
    Sh(t, n, e, (f, p, y) => {
      f[c] &&
        f[c](e[n], i) &&
        (s.push({ element: f, datasetIndex: p, index: y }), (h = h || f.inRange(e.x, e.y, i)))
    }),
    r && !h ? [] : s
  )
}
var VI = {
  modes: {
    index(t, e, n, r) {
      const i = ro(e, t),
        s = n.axis || 'x',
        c = n.includeInvisible || !1,
        h = n.intersect ? Wd(t, i, s, r, c) : Ud(t, i, s, !1, r, c),
        f = []
      return h.length
        ? (t.getSortedVisibleDatasetMetas().forEach((p) => {
            const y = h[0].index,
              w = p.data[y]
            w && !w.skip && f.push({ element: w, datasetIndex: p.index, index: y })
          }),
          f)
        : []
    },
    dataset(t, e, n, r) {
      const i = ro(e, t),
        s = n.axis || 'xy',
        c = n.includeInvisible || !1
      let h = n.intersect ? Wd(t, i, s, r, c) : Ud(t, i, s, !1, r, c)
      if (h.length > 0) {
        const f = h[0].datasetIndex,
          p = t.getDatasetMeta(f).data
        h = []
        for (let y = 0; y < p.length; ++y) h.push({ element: p[y], datasetIndex: f, index: y })
      }
      return h
    },
    point(t, e, n, r) {
      const i = ro(e, t),
        s = n.axis || 'xy',
        c = n.includeInvisible || !1
      return Wd(t, i, s, r, c)
    },
    nearest(t, e, n, r) {
      const i = ro(e, t),
        s = n.axis || 'xy',
        c = n.includeInvisible || !1
      return Ud(t, i, s, n.intersect, r, c)
    },
    x(t, e, n, r) {
      const i = ro(e, t)
      return Ym(t, i, 'x', n.intersect, r)
    },
    y(t, e, n, r) {
      const i = ro(e, t)
      return Ym(t, i, 'y', n.intersect, r)
    },
  },
}
const N3 = ['left', 'top', 'right', 'bottom']
function Ea(t, e) {
  return t.filter((n) => n.pos === e)
}
function Zm(t, e) {
  return t.filter((n) => N3.indexOf(n.pos) === -1 && n.box.axis === e)
}
function Ca(t, e) {
  return t.sort((n, r) => {
    const i = e ? r : n,
      s = e ? n : r
    return i.weight === s.weight ? i.index - s.index : i.weight - s.weight
  })
}
function WI(t) {
  const e = []
  let n, r, i, s, c, h
  for (n = 0, r = (t || []).length; n < r; ++n)
    ((i = t[n]),
      ({
        position: s,
        options: { stack: c, stackWeight: h = 1 },
      } = i),
      e.push({
        index: n,
        box: i,
        pos: s,
        horizontal: i.isHorizontal(),
        weight: i.weight,
        stack: c && s + c,
        stackWeight: h,
      }))
  return e
}
function UI(t) {
  const e = {}
  for (const n of t) {
    const { stack: r, pos: i, stackWeight: s } = n
    if (!r || !N3.includes(i)) continue
    const c = e[r] || (e[r] = { count: 0, placed: 0, weight: 0, size: 0 })
    ;(c.count++, (c.weight += s))
  }
  return e
}
function zI(t, e) {
  const n = UI(t),
    { vBoxMaxWidth: r, hBoxMaxHeight: i } = e
  let s, c, h
  for (s = 0, c = t.length; s < c; ++s) {
    h = t[s]
    const { fullSize: f } = h.box,
      p = n[h.stack],
      y = p && h.stackWeight / p.weight
    h.horizontal
      ? ((h.width = y ? y * r : f && e.availableWidth), (h.height = i))
      : ((h.width = r), (h.height = y ? y * i : f && e.availableHeight))
  }
  return n
}
function HI(t) {
  const e = WI(t),
    n = Ca(
      e.filter((p) => p.box.fullSize),
      !0
    ),
    r = Ca(Ea(e, 'left'), !0),
    i = Ca(Ea(e, 'right')),
    s = Ca(Ea(e, 'top'), !0),
    c = Ca(Ea(e, 'bottom')),
    h = Zm(e, 'x'),
    f = Zm(e, 'y')
  return {
    fullSize: n,
    leftAndTop: r.concat(s),
    rightAndBottom: i.concat(f).concat(c).concat(h),
    chartArea: Ea(e, 'chartArea'),
    vertical: r.concat(i).concat(f),
    horizontal: s.concat(c).concat(h),
  }
}
function qm(t, e, n, r) {
  return Math.max(t[n], e[n]) + Math.max(t[r], e[r])
}
function M3(t, e) {
  ;((t.top = Math.max(t.top, e.top)),
    (t.left = Math.max(t.left, e.left)),
    (t.bottom = Math.max(t.bottom, e.bottom)),
    (t.right = Math.max(t.right, e.right)))
}
function XI(t, e, n, r) {
  const { pos: i, box: s } = n,
    c = t.maxPadding
  if (!Mt(i)) {
    n.size && (t[i] -= n.size)
    const w = r[n.stack] || { size: 0, count: 1 }
    ;((w.size = Math.max(w.size, n.horizontal ? s.height : s.width)),
      (n.size = w.size / w.count),
      (t[i] += n.size))
  }
  s.getPadding && M3(c, s.getPadding())
  const h = Math.max(0, e.outerWidth - qm(c, t, 'left', 'right')),
    f = Math.max(0, e.outerHeight - qm(c, t, 'top', 'bottom')),
    p = h !== t.w,
    y = f !== t.h
  return ((t.w = h), (t.h = f), n.horizontal ? { same: p, other: y } : { same: y, other: p })
}
function GI(t) {
  const e = t.maxPadding
  function n(r) {
    const i = Math.max(e[r] - t[r], 0)
    return ((t[r] += i), i)
  }
  ;((t.y += n('top')), (t.x += n('left')), n('right'), n('bottom'))
}
function YI(t, e) {
  const n = e.maxPadding
  function r(i) {
    const s = { left: 0, top: 0, right: 0, bottom: 0 }
    return (
      i.forEach((c) => {
        s[c] = Math.max(e[c], n[c])
      }),
      s
    )
  }
  return r(t ? ['left', 'right'] : ['top', 'bottom'])
}
function Pa(t, e, n, r) {
  const i = []
  let s, c, h, f, p, y
  for (s = 0, c = t.length, p = 0; s < c; ++s) {
    ;((h = t[s]), (f = h.box), f.update(h.width || e.w, h.height || e.h, YI(h.horizontal, e)))
    const { same: w, other: x } = XI(e, n, h, r)
    ;((p |= w && i.length), (y = y || x), f.fullSize || i.push(h))
  }
  return (p && Pa(i, e, n, r)) || y
}
function Rc(t, e, n, r, i) {
  ;((t.top = n), (t.left = e), (t.right = e + r), (t.bottom = n + i), (t.width = r), (t.height = i))
}
function Km(t, e, n, r) {
  const i = n.padding
  let { x: s, y: c } = e
  for (const h of t) {
    const f = h.box,
      p = r[h.stack] || { placed: 0, weight: 1 },
      y = h.stackWeight / p.weight || 1
    if (h.horizontal) {
      const w = e.w * y,
        x = p.size || f.height
      ;(Il(p.start) && (c = p.start),
        f.fullSize
          ? Rc(f, i.left, c, n.outerWidth - i.right - i.left, x)
          : Rc(f, e.left + p.placed, c, w, x),
        (p.start = c),
        (p.placed += w),
        (c = f.bottom))
    } else {
      const w = e.h * y,
        x = p.size || f.width
      ;(Il(p.start) && (s = p.start),
        f.fullSize
          ? Rc(f, s, i.top, x, n.outerHeight - i.bottom - i.top)
          : Rc(f, s, e.top + p.placed, x, w),
        (p.start = s),
        (p.placed += w),
        (s = f.right))
    }
  }
  ;((e.x = s), (e.y = c))
}
var vi = {
  addBox(t, e) {
    ;(t.boxes || (t.boxes = []),
      (e.fullSize = e.fullSize || !1),
      (e.position = e.position || 'top'),
      (e.weight = e.weight || 0),
      (e._layers =
        e._layers ||
        function () {
          return [
            {
              z: 0,
              draw(n) {
                e.draw(n)
              },
            },
          ]
        }),
      t.boxes.push(e))
  },
  removeBox(t, e) {
    const n = t.boxes ? t.boxes.indexOf(e) : -1
    n !== -1 && t.boxes.splice(n, 1)
  },
  configure(t, e, n) {
    ;((e.fullSize = n.fullSize), (e.position = n.position), (e.weight = n.weight))
  },
  update(t, e, n, r) {
    if (!t) return
    const i = sn(t.options.layout.padding),
      s = Math.max(e - i.width, 0),
      c = Math.max(n - i.height, 0),
      h = HI(t.boxes),
      f = h.vertical,
      p = h.horizontal
    zt(t.boxes, (k) => {
      typeof k.beforeLayout == 'function' && k.beforeLayout()
    })
    const y =
        f.reduce((k, D) => (D.box.options && D.box.options.display === !1 ? k : k + 1), 0) || 1,
      w = Object.freeze({
        outerWidth: e,
        outerHeight: n,
        padding: i,
        availableWidth: s,
        availableHeight: c,
        vBoxMaxWidth: s / 2 / y,
        hBoxMaxHeight: c / 2,
      }),
      x = Object.assign({}, i)
    M3(x, sn(r))
    const E = Object.assign({ maxPadding: x, w: s, h: c, x: i.left, y: i.top }, i),
      S = zI(f.concat(p), w)
    ;(Pa(h.fullSize, E, w, S),
      Pa(f, E, w, S),
      Pa(p, E, w, S) && Pa(f, E, w, S),
      GI(E),
      Km(h.leftAndTop, E, w, S),
      (E.x += E.w),
      (E.y += E.h),
      Km(h.rightAndBottom, E, w, S),
      (t.chartArea = {
        left: E.left,
        top: E.top,
        right: E.left + E.w,
        bottom: E.top + E.h,
        height: E.h,
        width: E.w,
      }),
      zt(h.chartArea, (k) => {
        const D = k.box
        ;(Object.assign(D, t.chartArea),
          D.update(E.w, E.h, { left: 0, top: 0, right: 0, bottom: 0 }))
      }))
  },
}
class D3 {
  acquireContext(e, n) {}
  releaseContext(e) {
    return !1
  }
  addEventListener(e, n, r) {}
  removeEventListener(e, n, r) {}
  getDevicePixelRatio() {
    return 1
  }
  getMaximumSize(e, n, r, i) {
    return (
      (n = Math.max(0, n || e.width)),
      (r = r || e.height),
      { width: n, height: Math.max(0, i ? Math.floor(n / i) : r) }
    )
  }
  isAttached(e) {
    return !0
  }
  updateConfig(e) {}
}
class ZI extends D3 {
  acquireContext(e) {
    return (e && e.getContext && e.getContext('2d')) || null
  }
  updateConfig(e) {
    e.options.animation = !1
  }
}
const eu = '$chartjs',
  qI = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout',
  },
  Qm = (t) => t === null || t === ''
function KI(t, e) {
  const n = t.style,
    r = t.getAttribute('height'),
    i = t.getAttribute('width')
  if (
    ((t[eu] = {
      initial: {
        height: r,
        width: i,
        style: { display: n.display, height: n.height, width: n.width },
      },
    }),
    (n.display = n.display || 'block'),
    (n.boxSizing = n.boxSizing || 'border-box'),
    Qm(i))
  ) {
    const s = Pm(t, 'width')
    s !== void 0 && (t.width = s)
  }
  if (Qm(r))
    if (t.style.height === '') t.height = t.width / (e || 2)
    else {
      const s = Pm(t, 'height')
      s !== void 0 && (t.height = s)
    }
  return t
}
const P3 = J9 ? { passive: !0 } : !1
function QI(t, e, n) {
  t && t.addEventListener(e, n, P3)
}
function $I(t, e, n) {
  t && t.canvas && t.canvas.removeEventListener(e, n, P3)
}
function JI(t, e) {
  const n = qI[t.type] || t.type,
    { x: r, y: i } = ro(t, e)
  return { type: n, chart: e, native: t, x: r !== void 0 ? r : null, y: i !== void 0 ? i : null }
}
function Uu(t, e) {
  for (const n of t) if (n === e || n.contains(e)) return !0
}
function t_(t, e, n) {
  const r = t.canvas,
    i = new MutationObserver((s) => {
      let c = !1
      for (const h of s) ((c = c || Uu(h.addedNodes, r)), (c = c && !Uu(h.removedNodes, r)))
      c && n()
    })
  return (i.observe(document, { childList: !0, subtree: !0 }), i)
}
function e_(t, e, n) {
  const r = t.canvas,
    i = new MutationObserver((s) => {
      let c = !1
      for (const h of s) ((c = c || Uu(h.removedNodes, r)), (c = c && !Uu(h.addedNodes, r)))
      c && n()
    })
  return (i.observe(document, { childList: !0, subtree: !0 }), i)
}
const Tl = new Map()
let $m = 0
function L3() {
  const t = window.devicePixelRatio
  t !== $m &&
    (($m = t),
    Tl.forEach((e, n) => {
      n.currentDevicePixelRatio !== t && e()
    }))
}
function n_(t, e) {
  ;(Tl.size || window.addEventListener('resize', L3), Tl.set(t, e))
}
function r_(t) {
  ;(Tl.delete(t), Tl.size || window.removeEventListener('resize', L3))
}
function i_(t, e, n) {
  const r = t.canvas,
    i = r && pp(r)
  if (!i) return
  const s = h3((h, f) => {
      const p = i.clientWidth
      ;(n(h, f), p < i.clientWidth && n())
    }, window),
    c = new ResizeObserver((h) => {
      const f = h[0],
        p = f.contentRect.width,
        y = f.contentRect.height
      ;(p === 0 && y === 0) || s(p, y)
    })
  return (c.observe(i), n_(t, s), c)
}
function zd(t, e, n) {
  ;(n && n.disconnect(), e === 'resize' && r_(t))
}
function o_(t, e, n) {
  const r = t.canvas,
    i = h3((s) => {
      t.ctx !== null && n(JI(s, t))
    }, t)
  return (QI(r, e, i), i)
}
class s_ extends D3 {
  acquireContext(e, n) {
    const r = e && e.getContext && e.getContext('2d')
    return r && r.canvas === e ? (KI(e, n), r) : null
  }
  releaseContext(e) {
    const n = e.canvas
    if (!n[eu]) return !1
    const r = n[eu].initial
    ;['height', 'width'].forEach((s) => {
      const c = r[s]
      Ot(c) ? n.removeAttribute(s) : n.setAttribute(s, c)
    })
    const i = r.style || {}
    return (
      Object.keys(i).forEach((s) => {
        n.style[s] = i[s]
      }),
      (n.width = n.width),
      delete n[eu],
      !0
    )
  }
  addEventListener(e, n, r) {
    this.removeEventListener(e, n)
    const i = e.$proxies || (e.$proxies = {}),
      s = { attach: t_, detach: e_, resize: i_ }[n] || o_
    i[n] = s(e, n, r)
  }
  removeEventListener(e, n) {
    const r = e.$proxies || (e.$proxies = {}),
      i = r[n]
    i && (({ attach: zd, detach: zd, resize: zd }[n] || $I)(e, n, i), (r[n] = void 0))
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio
  }
  getMaximumSize(e, n, r, i) {
    return $9(e, n, r, i)
  }
  isAttached(e) {
    const n = e && pp(e)
    return !!(n && n.isConnected)
  }
}
function a_(t) {
  return !fp() || (typeof OffscreenCanvas < 'u' && t instanceof OffscreenCanvas) ? ZI : s_
}
var Tc
let Ho =
  ((Tc = class {
    constructor() {
      ;(yt(this, 'x'),
        yt(this, 'y'),
        yt(this, 'active', !1),
        yt(this, 'options'),
        yt(this, '$animations'))
    }
    tooltipPosition(t) {
      const { x: e, y: n } = this.getProps(['x', 'y'], t)
      return { x: e, y: n }
    }
    hasValue() {
      return _l(this.x) && _l(this.y)
    }
    getProps(t, e) {
      const n = this.$animations
      if (!e || !n) return this
      const r = {}
      return (
        t.forEach((i) => {
          r[i] = n[i] && n[i].active() ? n[i]._to : this[i]
        }),
        r
      )
    }
  }),
  yt(Tc, 'defaults', {}),
  yt(Tc, 'defaultRoutes'),
  Tc)
function l_(t, e) {
  const n = t.options.ticks,
    r = c_(t),
    i = Math.min(n.maxTicksLimit || r, r),
    s = n.major.enabled ? h_(e) : [],
    c = s.length,
    h = s[0],
    f = s[c - 1],
    p = []
  if (c > i) return (d_(e, p, s, c / i), p)
  const y = u_(s, e, i)
  if (c > 0) {
    let w, x
    const E = c > 1 ? Math.round((f - h) / (c - 1)) : null
    for (Nc(e, p, y, Ot(E) ? 0 : h - E, h), w = 0, x = c - 1; w < x; w++)
      Nc(e, p, y, s[w], s[w + 1])
    return (Nc(e, p, y, f, Ot(E) ? e.length : f + E), p)
  }
  return (Nc(e, p, y), p)
}
function c_(t) {
  const e = t.options.offset,
    n = t._tickSize(),
    r = t._length / n + (e ? 0 : 1),
    i = t._maxLength / n
  return Math.floor(Math.min(r, i))
}
function u_(t, e, n) {
  const r = f_(t),
    i = e.length / n
  if (!r) return Math.max(i, 1)
  const s = qk(r)
  for (let c = 0, h = s.length - 1; c < h; c++) {
    const f = s[c]
    if (f > i) return f
  }
  return Math.max(i, 1)
}
function h_(t) {
  const e = []
  let n, r
  for (n = 0, r = t.length; n < r; n++) t[n].major && e.push(n)
  return e
}
function d_(t, e, n, r) {
  let i = 0,
    s = n[0],
    c
  for (r = Math.ceil(r), c = 0; c < t.length; c++) c === s && (e.push(t[c]), i++, (s = n[i * r]))
}
function Nc(t, e, n, r, i) {
  const s = It(r, 0),
    c = Math.min(It(i, t.length), t.length)
  let h = 0,
    f,
    p,
    y
  for (n = Math.ceil(n), i && ((f = i - r), (n = f / Math.floor(f / n))), y = s; y < 0; )
    (h++, (y = Math.round(s + h * n)))
  for (p = Math.max(s, 0); p < c; p++) p === y && (e.push(t[p]), h++, (y = Math.round(s + h * n)))
}
function f_(t) {
  const e = t.length
  let n, r
  if (e < 2) return !1
  for (r = t[0], n = 1; n < e; ++n) if (t[n] - t[n - 1] !== r) return !1
  return r
}
const p_ = (t) => (t === 'left' ? 'right' : t === 'right' ? 'left' : t),
  Jm = (t, e, n) => (e === 'top' || e === 'left' ? t[e] + n : t[e] - n),
  ty = (t, e) => Math.min(e || t, t)
function ey(t, e) {
  const n = [],
    r = t.length / e,
    i = t.length
  let s = 0
  for (; s < i; s += r) n.push(t[Math.floor(s)])
  return n
}
function g_(t, e, n) {
  const r = t.ticks.length,
    i = Math.min(e, r - 1),
    s = t._startPixel,
    c = t._endPixel,
    h = 1e-6
  let f = t.getPixelForTick(i),
    p
  if (
    !(
      n &&
      (r === 1
        ? (p = Math.max(f - s, c - f))
        : e === 0
          ? (p = (t.getPixelForTick(1) - f) / 2)
          : (p = (f - t.getPixelForTick(i - 1)) / 2),
      (f += i < e ? p : -p),
      f < s - h || f > c + h)
    )
  )
    return f
}
function m_(t, e) {
  zt(t, (n) => {
    const r = n.gc,
      i = r.length / 2
    let s
    if (i > e) {
      for (s = 0; s < i; ++s) delete n.data[r[s]]
      r.splice(0, i)
    }
  })
}
function Sa(t) {
  return t.drawTicks ? t.tickLength : 0
}
function ny(t, e) {
  if (!t.display) return 0
  const n = He(t.font, e),
    r = sn(t.padding)
  return (ce(t.text) ? t.text.length : 1) * n.lineHeight + r.height
}
function y_(t, e) {
  return Ui(t, { scale: e, type: 'scale' })
}
function w_(t, e, n) {
  return Ui(t, { tick: n, index: e, type: 'tick' })
}
function b_(t, e, n) {
  let r = d3(t)
  return (((n && e !== 'right') || (!n && e === 'right')) && (r = p_(r)), r)
}
function v_(t, e, n, r) {
  const { top: i, left: s, bottom: c, right: h, chart: f } = t,
    { chartArea: p, scales: y } = f
  let w = 0,
    x,
    E,
    S
  const k = c - i,
    D = h - s
  if (t.isHorizontal()) {
    if (((E = kn(r, s, h)), Mt(n))) {
      const _ = Object.keys(n)[0],
        N = n[_]
      S = y[_].getPixelForValue(N) + k - e
    } else n === 'center' ? (S = (p.bottom + p.top) / 2 + k - e) : (S = Jm(t, n, e))
    x = h - s
  } else {
    if (Mt(n)) {
      const _ = Object.keys(n)[0],
        N = n[_]
      E = y[_].getPixelForValue(N) - D + e
    } else n === 'center' ? (E = (p.left + p.right) / 2 - D + e) : (E = Jm(t, n, e))
    ;((S = kn(r, c, i)), (w = n === 'left' ? -Nn : Nn))
  }
  return { titleX: E, titleY: S, maxWidth: x, rotation: w }
}
class $s extends Ho {
  constructor(e) {
    ;(super(),
      (this.id = e.id),
      (this.type = e.type),
      (this.options = void 0),
      (this.ctx = e.ctx),
      (this.chart = e.chart),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this._margins = { left: 0, right: 0, top: 0, bottom: 0 }),
      (this.maxWidth = void 0),
      (this.maxHeight = void 0),
      (this.paddingTop = void 0),
      (this.paddingBottom = void 0),
      (this.paddingLeft = void 0),
      (this.paddingRight = void 0),
      (this.axis = void 0),
      (this.labelRotation = void 0),
      (this.min = void 0),
      (this.max = void 0),
      (this._range = void 0),
      (this.ticks = []),
      (this._gridLineItems = null),
      (this._labelItems = null),
      (this._labelSizes = null),
      (this._length = 0),
      (this._maxLength = 0),
      (this._longestTextCache = {}),
      (this._startPixel = void 0),
      (this._endPixel = void 0),
      (this._reversePixels = !1),
      (this._userMax = void 0),
      (this._userMin = void 0),
      (this._suggestedMax = void 0),
      (this._suggestedMin = void 0),
      (this._ticksLength = 0),
      (this._borderValue = 0),
      (this._cache = {}),
      (this._dataLimitsCached = !1),
      (this.$context = void 0))
  }
  init(e) {
    ;((this.options = e.setContext(this.getContext())),
      (this.axis = e.axis),
      (this._userMin = this.parse(e.min)),
      (this._userMax = this.parse(e.max)),
      (this._suggestedMin = this.parse(e.suggestedMin)),
      (this._suggestedMax = this.parse(e.suggestedMax)))
  }
  parse(e, n) {
    return e
  }
  getUserBounds() {
    let { _userMin: e, _userMax: n, _suggestedMin: r, _suggestedMax: i } = this
    return (
      (e = vr(e, Number.POSITIVE_INFINITY)),
      (n = vr(n, Number.NEGATIVE_INFINITY)),
      (r = vr(r, Number.POSITIVE_INFINITY)),
      (i = vr(i, Number.NEGATIVE_INFINITY)),
      { min: vr(e, r), max: vr(n, i), minDefined: Be(e), maxDefined: Be(n) }
    )
  }
  getMinMax(e) {
    let { min: n, max: r, minDefined: i, maxDefined: s } = this.getUserBounds(),
      c
    if (i && s) return { min: n, max: r }
    const h = this.getMatchingVisibleMetas()
    for (let f = 0, p = h.length; f < p; ++f)
      ((c = h[f].controller.getMinMax(this, e)),
        i || (n = Math.min(n, c.min)),
        s || (r = Math.max(r, c.max)))
    return (
      (n = s && n > r ? r : n),
      (r = i && n > r ? n : r),
      { min: vr(n, vr(r, n)), max: vr(r, vr(n, r)) }
    )
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0,
    }
  }
  getTicks() {
    return this.ticks
  }
  getLabels() {
    const e = this.chart.data
    return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || []
  }
  getLabelItems(e = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(e))
  }
  beforeLayout() {
    ;((this._cache = {}), (this._dataLimitsCached = !1))
  }
  beforeUpdate() {
    Qt(this.options.beforeUpdate, [this])
  }
  update(e, n, r) {
    const { beginAtZero: i, grace: s, ticks: c } = this.options,
      h = c.sampleSize
    ;(this.beforeUpdate(),
      (this.maxWidth = e),
      (this.maxHeight = n),
      (this._margins = r = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, r)),
      (this.ticks = null),
      (this._labelSizes = null),
      (this._gridLineItems = null),
      (this._labelItems = null),
      this.beforeSetDimensions(),
      this.setDimensions(),
      this.afterSetDimensions(),
      (this._maxLength = this.isHorizontal()
        ? this.width + r.left + r.right
        : this.height + r.top + r.bottom),
      this._dataLimitsCached ||
        (this.beforeDataLimits(),
        this.determineDataLimits(),
        this.afterDataLimits(),
        (this._range = R9(this, s, i)),
        (this._dataLimitsCached = !0)),
      this.beforeBuildTicks(),
      (this.ticks = this.buildTicks() || []),
      this.afterBuildTicks())
    const f = h < this.ticks.length
    ;(this._convertTicksToLabels(f ? ey(this.ticks, h) : this.ticks),
      this.configure(),
      this.beforeCalculateLabelRotation(),
      this.calculateLabelRotation(),
      this.afterCalculateLabelRotation(),
      c.display &&
        (c.autoSkip || c.source === 'auto') &&
        ((this.ticks = l_(this, this.ticks)), (this._labelSizes = null), this.afterAutoSkip()),
      f && this._convertTicksToLabels(this.ticks),
      this.beforeFit(),
      this.fit(),
      this.afterFit(),
      this.afterUpdate())
  }
  configure() {
    let e = this.options.reverse,
      n,
      r
    ;(this.isHorizontal()
      ? ((n = this.left), (r = this.right))
      : ((n = this.top), (r = this.bottom), (e = !e)),
      (this._startPixel = n),
      (this._endPixel = r),
      (this._reversePixels = e),
      (this._length = r - n),
      (this._alignToPixels = this.options.alignToPixels))
  }
  afterUpdate() {
    Qt(this.options.afterUpdate, [this])
  }
  beforeSetDimensions() {
    Qt(this.options.beforeSetDimensions, [this])
  }
  setDimensions() {
    ;(this.isHorizontal()
      ? ((this.width = this.maxWidth), (this.left = 0), (this.right = this.width))
      : ((this.height = this.maxHeight), (this.top = 0), (this.bottom = this.height)),
      (this.paddingLeft = 0),
      (this.paddingTop = 0),
      (this.paddingRight = 0),
      (this.paddingBottom = 0))
  }
  afterSetDimensions() {
    Qt(this.options.afterSetDimensions, [this])
  }
  _callHooks(e) {
    ;(this.chart.notifyPlugins(e, this.getContext()), Qt(this.options[e], [this]))
  }
  beforeDataLimits() {
    this._callHooks('beforeDataLimits')
  }
  determineDataLimits() {}
  afterDataLimits() {
    this._callHooks('afterDataLimits')
  }
  beforeBuildTicks() {
    this._callHooks('beforeBuildTicks')
  }
  buildTicks() {
    return []
  }
  afterBuildTicks() {
    this._callHooks('afterBuildTicks')
  }
  beforeTickToLabelConversion() {
    Qt(this.options.beforeTickToLabelConversion, [this])
  }
  generateTickLabels(e) {
    const n = this.options.ticks
    let r, i, s
    for (r = 0, i = e.length; r < i; r++)
      ((s = e[r]), (s.label = Qt(n.callback, [s.value, r, e], this)))
  }
  afterTickToLabelConversion() {
    Qt(this.options.afterTickToLabelConversion, [this])
  }
  beforeCalculateLabelRotation() {
    Qt(this.options.beforeCalculateLabelRotation, [this])
  }
  calculateLabelRotation() {
    const e = this.options,
      n = e.ticks,
      r = ty(this.ticks.length, e.ticks.maxTicksLimit),
      i = n.minRotation || 0,
      s = n.maxRotation
    let c = i,
      h,
      f,
      p
    if (!this._isVisible() || !n.display || i >= s || r <= 1 || !this.isHorizontal()) {
      this.labelRotation = i
      return
    }
    const y = this._getLabelSizes(),
      w = y.widest.width,
      x = y.highest.height,
      E = Mn(this.chart.width - w, 0, this.maxWidth)
    ;((h = e.offset ? this.maxWidth / r : E / (r - 1)),
      w + 6 > h &&
        ((h = E / (r - (e.offset ? 0.5 : 1))),
        (f = this.maxHeight - Sa(e.grid) - n.padding - ny(e.title, this.chart.options.font)),
        (p = Math.sqrt(w * w + x * x)),
        (c = sp(
          Math.min(
            Math.asin(Mn((y.highest.height + 6) / h, -1, 1)),
            Math.asin(Mn(f / p, -1, 1)) - Math.asin(Mn(x / p, -1, 1))
          )
        )),
        (c = Math.max(i, Math.min(s, c)))),
      (this.labelRotation = c))
  }
  afterCalculateLabelRotation() {
    Qt(this.options.afterCalculateLabelRotation, [this])
  }
  afterAutoSkip() {}
  beforeFit() {
    Qt(this.options.beforeFit, [this])
  }
  fit() {
    const e = { width: 0, height: 0 },
      {
        chart: n,
        options: { ticks: r, title: i, grid: s },
      } = this,
      c = this._isVisible(),
      h = this.isHorizontal()
    if (c) {
      const f = ny(i, n.options.font)
      if (
        (h
          ? ((e.width = this.maxWidth), (e.height = Sa(s) + f))
          : ((e.height = this.maxHeight), (e.width = Sa(s) + f)),
        r.display && this.ticks.length)
      ) {
        const { first: p, last: y, widest: w, highest: x } = this._getLabelSizes(),
          E = r.padding * 2,
          S = yi(this.labelRotation),
          k = Math.cos(S),
          D = Math.sin(S)
        if (h) {
          const _ = r.mirror ? 0 : D * w.width + k * x.height
          e.height = Math.min(this.maxHeight, e.height + _ + E)
        } else {
          const _ = r.mirror ? 0 : k * w.width + D * x.height
          e.width = Math.min(this.maxWidth, e.width + _ + E)
        }
        this._calculatePadding(p, y, D, k)
      }
    }
    ;(this._handleMargins(),
      h
        ? ((this.width = this._length = n.width - this._margins.left - this._margins.right),
          (this.height = e.height))
        : ((this.width = e.width),
          (this.height = this._length = n.height - this._margins.top - this._margins.bottom)))
  }
  _calculatePadding(e, n, r, i) {
    const {
        ticks: { align: s, padding: c },
        position: h,
      } = this.options,
      f = this.labelRotation !== 0,
      p = h !== 'top' && this.axis === 'x'
    if (this.isHorizontal()) {
      const y = this.getPixelForTick(0) - this.left,
        w = this.right - this.getPixelForTick(this.ticks.length - 1)
      let x = 0,
        E = 0
      ;(f
        ? p
          ? ((x = i * e.width), (E = r * n.height))
          : ((x = r * e.height), (E = i * n.width))
        : s === 'start'
          ? (E = n.width)
          : s === 'end'
            ? (x = e.width)
            : s !== 'inner' && ((x = e.width / 2), (E = n.width / 2)),
        (this.paddingLeft = Math.max(((x - y + c) * this.width) / (this.width - y), 0)),
        (this.paddingRight = Math.max(((E - w + c) * this.width) / (this.width - w), 0)))
    } else {
      let y = n.height / 2,
        w = e.height / 2
      ;(s === 'start' ? ((y = 0), (w = e.height)) : s === 'end' && ((y = n.height), (w = 0)),
        (this.paddingTop = y + c),
        (this.paddingBottom = w + c))
    }
  }
  _handleMargins() {
    this._margins &&
      ((this._margins.left = Math.max(this.paddingLeft, this._margins.left)),
      (this._margins.top = Math.max(this.paddingTop, this._margins.top)),
      (this._margins.right = Math.max(this.paddingRight, this._margins.right)),
      (this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)))
  }
  afterFit() {
    Qt(this.options.afterFit, [this])
  }
  isHorizontal() {
    const { axis: e, position: n } = this.options
    return n === 'top' || n === 'bottom' || e === 'x'
  }
  isFullSize() {
    return this.options.fullSize
  }
  _convertTicksToLabels(e) {
    ;(this.beforeTickToLabelConversion(), this.generateTickLabels(e))
    let n, r
    for (n = 0, r = e.length; n < r; n++) Ot(e[n].label) && (e.splice(n, 1), r--, n--)
    this.afterTickToLabelConversion()
  }
  _getLabelSizes() {
    let e = this._labelSizes
    if (!e) {
      const n = this.options.ticks.sampleSize
      let r = this.ticks
      ;(n < r.length && (r = ey(r, n)),
        (this._labelSizes = e =
          this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit)))
    }
    return e
  }
  _computeLabelSizes(e, n, r) {
    const { ctx: i, _longestTextCache: s } = this,
      c = [],
      h = [],
      f = Math.floor(n / ty(n, r))
    let p = 0,
      y = 0,
      w,
      x,
      E,
      S,
      k,
      D,
      _,
      N,
      M,
      O,
      F
    for (w = 0; w < n; w += f) {
      if (
        ((S = e[w].label),
        (k = this._resolveTickFontOptions(w)),
        (i.font = D = k.string),
        (_ = s[D] = s[D] || { data: {}, gc: [] }),
        (N = k.lineHeight),
        (M = O = 0),
        !Ot(S) && !ce(S))
      )
        ((M = Vu(i, _.data, _.gc, M, S)), (O = N))
      else if (ce(S))
        for (x = 0, E = S.length; x < E; ++x)
          ((F = S[x]), !Ot(F) && !ce(F) && ((M = Vu(i, _.data, _.gc, M, F)), (O += N)))
      ;(c.push(M), h.push(O), (p = Math.max(M, p)), (y = Math.max(O, y)))
    }
    m_(s, n)
    const z = c.indexOf(p),
      V = h.indexOf(y),
      W = (Z) => ({ width: c[Z] || 0, height: h[Z] || 0 })
    return { first: W(0), last: W(n - 1), widest: W(z), highest: W(V), widths: c, heights: h }
  }
  getLabelForValue(e) {
    return e
  }
  getPixelForValue(e, n) {
    return NaN
  }
  getValueForPixel(e) {}
  getPixelForTick(e) {
    const n = this.ticks
    return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value)
  }
  getPixelForDecimal(e) {
    this._reversePixels && (e = 1 - e)
    const n = this._startPixel + e * this._length
    return e9(this._alignToPixels ? Qi(this.chart, n, 0) : n)
  }
  getDecimalForPixel(e) {
    const n = (e - this._startPixel) / this._length
    return this._reversePixels ? 1 - n : n
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue())
  }
  getBaseValue() {
    const { min: e, max: n } = this
    return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0
  }
  getContext(e) {
    const n = this.ticks || []
    if (e >= 0 && e < n.length) {
      const r = n[e]
      return r.$context || (r.$context = w_(this.getContext(), e, r))
    }
    return this.$context || (this.$context = y_(this.chart.getContext(), this))
  }
  _tickSize() {
    const e = this.options.ticks,
      n = yi(this.labelRotation),
      r = Math.abs(Math.cos(n)),
      i = Math.abs(Math.sin(n)),
      s = this._getLabelSizes(),
      c = e.autoSkipPadding || 0,
      h = s ? s.widest.width + c : 0,
      f = s ? s.highest.height + c : 0
    return this.isHorizontal() ? (f * r > h * i ? h / r : f / i) : f * i < h * r ? f / r : h / i
  }
  _isVisible() {
    const e = this.options.display
    return e !== 'auto' ? !!e : this.getMatchingVisibleMetas().length > 0
  }
  _computeGridLineItems(e) {
    const n = this.axis,
      r = this.chart,
      i = this.options,
      { grid: s, position: c, border: h } = i,
      f = s.offset,
      p = this.isHorizontal(),
      y = this.ticks.length + (f ? 1 : 0),
      w = Sa(s),
      x = [],
      E = h.setContext(this.getContext()),
      S = E.display ? E.width : 0,
      k = S / 2,
      D = function (H) {
        return Qi(r, H, S)
      }
    let _, N, M, O, F, z, V, W, Z, J, st, rt
    if (c === 'top')
      ((_ = D(this.bottom)),
        (z = this.bottom - w),
        (W = _ - k),
        (J = D(e.top) + k),
        (rt = e.bottom))
    else if (c === 'bottom')
      ((_ = D(this.top)), (J = e.top), (rt = D(e.bottom) - k), (z = _ + k), (W = this.top + w))
    else if (c === 'left')
      ((_ = D(this.right)), (F = this.right - w), (V = _ - k), (Z = D(e.left) + k), (st = e.right))
    else if (c === 'right')
      ((_ = D(this.left)), (Z = e.left), (st = D(e.right) - k), (F = _ + k), (V = this.left + w))
    else if (n === 'x') {
      if (c === 'center') _ = D((e.top + e.bottom) / 2 + 0.5)
      else if (Mt(c)) {
        const H = Object.keys(c)[0],
          xt = c[H]
        _ = D(this.chart.scales[H].getPixelForValue(xt))
      }
      ;((J = e.top), (rt = e.bottom), (z = _ + k), (W = z + w))
    } else if (n === 'y') {
      if (c === 'center') _ = D((e.left + e.right) / 2)
      else if (Mt(c)) {
        const H = Object.keys(c)[0],
          xt = c[H]
        _ = D(this.chart.scales[H].getPixelForValue(xt))
      }
      ;((F = _ - k), (V = F - w), (Z = e.left), (st = e.right))
    }
    const vt = It(i.ticks.maxTicksLimit, y),
      _t = Math.max(1, Math.ceil(y / vt))
    for (N = 0; N < y; N += _t) {
      const H = this.getContext(N),
        xt = s.setContext(H),
        gt = h.setContext(H),
        ot = xt.lineWidth,
        ft = xt.color,
        pt = gt.dash || [],
        Ut = gt.dashOffset,
        St = xt.tickWidth,
        Te = xt.tickColor,
        Bt = xt.tickBorderDash || [],
        Sn = xt.tickBorderDashOffset
      ;((M = g_(this, N, f)),
        M !== void 0 &&
          ((O = Qi(r, M, ot)),
          p ? (F = V = Z = st = O) : (z = W = J = rt = O),
          x.push({
            tx1: F,
            ty1: z,
            tx2: V,
            ty2: W,
            x1: Z,
            y1: J,
            x2: st,
            y2: rt,
            width: ot,
            color: ft,
            borderDash: pt,
            borderDashOffset: Ut,
            tickWidth: St,
            tickColor: Te,
            tickBorderDash: Bt,
            tickBorderDashOffset: Sn,
          })))
    }
    return ((this._ticksLength = y), (this._borderValue = _), x)
  }
  _computeLabelItems(e) {
    const n = this.axis,
      r = this.options,
      { position: i, ticks: s } = r,
      c = this.isHorizontal(),
      h = this.ticks,
      { align: f, crossAlign: p, padding: y, mirror: w } = s,
      x = Sa(r.grid),
      E = x + y,
      S = w ? -y : E,
      k = -yi(this.labelRotation),
      D = []
    let _,
      N,
      M,
      O,
      F,
      z,
      V,
      W,
      Z,
      J,
      st,
      rt,
      vt = 'middle'
    if (i === 'top') ((z = this.bottom - S), (V = this._getXAxisLabelAlignment()))
    else if (i === 'bottom') ((z = this.top + S), (V = this._getXAxisLabelAlignment()))
    else if (i === 'left') {
      const H = this._getYAxisLabelAlignment(x)
      ;((V = H.textAlign), (F = H.x))
    } else if (i === 'right') {
      const H = this._getYAxisLabelAlignment(x)
      ;((V = H.textAlign), (F = H.x))
    } else if (n === 'x') {
      if (i === 'center') z = (e.top + e.bottom) / 2 + E
      else if (Mt(i)) {
        const H = Object.keys(i)[0],
          xt = i[H]
        z = this.chart.scales[H].getPixelForValue(xt) + E
      }
      V = this._getXAxisLabelAlignment()
    } else if (n === 'y') {
      if (i === 'center') F = (e.left + e.right) / 2 - E
      else if (Mt(i)) {
        const H = Object.keys(i)[0],
          xt = i[H]
        F = this.chart.scales[H].getPixelForValue(xt)
      }
      V = this._getYAxisLabelAlignment(x).textAlign
    }
    n === 'y' && (f === 'start' ? (vt = 'top') : f === 'end' && (vt = 'bottom'))
    const _t = this._getLabelSizes()
    for (_ = 0, N = h.length; _ < N; ++_) {
      ;((M = h[_]), (O = M.label))
      const H = s.setContext(this.getContext(_))
      ;((W = this.getPixelForTick(_) + s.labelOffset),
        (Z = this._resolveTickFontOptions(_)),
        (J = Z.lineHeight),
        (st = ce(O) ? O.length : 1))
      const xt = st / 2,
        gt = H.color,
        ot = H.textStrokeColor,
        ft = H.textStrokeWidth
      let pt = V
      c
        ? ((F = W),
          V === 'inner' &&
            (_ === N - 1
              ? (pt = this.options.reverse ? 'left' : 'right')
              : _ === 0
                ? (pt = this.options.reverse ? 'right' : 'left')
                : (pt = 'center')),
          i === 'top'
            ? p === 'near' || k !== 0
              ? (rt = -st * J + J / 2)
              : p === 'center'
                ? (rt = -_t.highest.height / 2 - xt * J + J)
                : (rt = -_t.highest.height + J / 2)
            : p === 'near' || k !== 0
              ? (rt = J / 2)
              : p === 'center'
                ? (rt = _t.highest.height / 2 - xt * J)
                : (rt = _t.highest.height - st * J),
          w && (rt *= -1),
          k !== 0 && !H.showLabelBackdrop && (F += (J / 2) * Math.sin(k)))
        : ((z = W), (rt = ((1 - st) * J) / 2))
      let Ut
      if (H.showLabelBackdrop) {
        const St = sn(H.backdropPadding),
          Te = _t.heights[_],
          Bt = _t.widths[_]
        let Sn = rt - St.top,
          ut = 0 - St.left
        switch (vt) {
          case 'middle':
            Sn -= Te / 2
            break
          case 'bottom':
            Sn -= Te
            break
        }
        switch (V) {
          case 'center':
            ut -= Bt / 2
            break
          case 'right':
            ut -= Bt
            break
          case 'inner':
            _ === N - 1 ? (ut -= Bt) : _ > 0 && (ut -= Bt / 2)
            break
        }
        Ut = {
          left: ut,
          top: Sn,
          width: Bt + St.width,
          height: Te + St.height,
          color: H.backdropColor,
        }
      }
      D.push({
        label: O,
        font: Z,
        textOffset: rt,
        options: {
          rotation: k,
          color: gt,
          strokeColor: ot,
          strokeWidth: ft,
          textAlign: pt,
          textBaseline: vt,
          translation: [F, z],
          backdrop: Ut,
        },
      })
    }
    return D
  }
  _getXAxisLabelAlignment() {
    const { position: e, ticks: n } = this.options
    if (-yi(this.labelRotation)) return e === 'top' ? 'left' : 'right'
    let r = 'center'
    return (
      n.align === 'start'
        ? (r = 'left')
        : n.align === 'end'
          ? (r = 'right')
          : n.align === 'inner' && (r = 'inner'),
      r
    )
  }
  _getYAxisLabelAlignment(e) {
    const {
        position: n,
        ticks: { crossAlign: r, mirror: i, padding: s },
      } = this.options,
      c = this._getLabelSizes(),
      h = e + s,
      f = c.widest.width
    let p, y
    return (
      n === 'left'
        ? i
          ? ((y = this.right + s),
            r === 'near'
              ? (p = 'left')
              : r === 'center'
                ? ((p = 'center'), (y += f / 2))
                : ((p = 'right'), (y += f)))
          : ((y = this.right - h),
            r === 'near'
              ? (p = 'right')
              : r === 'center'
                ? ((p = 'center'), (y -= f / 2))
                : ((p = 'left'), (y = this.left)))
        : n === 'right'
          ? i
            ? ((y = this.left + s),
              r === 'near'
                ? (p = 'right')
                : r === 'center'
                  ? ((p = 'center'), (y -= f / 2))
                  : ((p = 'left'), (y -= f)))
            : ((y = this.left + h),
              r === 'near'
                ? (p = 'left')
                : r === 'center'
                  ? ((p = 'center'), (y += f / 2))
                  : ((p = 'right'), (y = this.right)))
          : (p = 'right'),
      { textAlign: p, x: y }
    )
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) return
    const e = this.chart,
      n = this.options.position
    if (n === 'left' || n === 'right')
      return { top: 0, left: this.left, bottom: e.height, right: this.right }
    if (n === 'top' || n === 'bottom')
      return { top: this.top, left: 0, bottom: this.bottom, right: e.width }
  }
  drawBackground() {
    const {
      ctx: e,
      options: { backgroundColor: n },
      left: r,
      top: i,
      width: s,
      height: c,
    } = this
    n && (e.save(), (e.fillStyle = n), e.fillRect(r, i, s, c), e.restore())
  }
  getLineWidthForValue(e) {
    const n = this.options.grid
    if (!this._isVisible() || !n.display) return 0
    const r = this.ticks.findIndex((i) => i.value === e)
    return r >= 0 ? n.setContext(this.getContext(r)).lineWidth : 0
  }
  drawGrid(e) {
    const n = this.options.grid,
      r = this.ctx,
      i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e))
    let s, c
    const h = (f, p, y) => {
      !y.width ||
        !y.color ||
        (r.save(),
        (r.lineWidth = y.width),
        (r.strokeStyle = y.color),
        r.setLineDash(y.borderDash || []),
        (r.lineDashOffset = y.borderDashOffset),
        r.beginPath(),
        r.moveTo(f.x, f.y),
        r.lineTo(p.x, p.y),
        r.stroke(),
        r.restore())
    }
    if (n.display)
      for (s = 0, c = i.length; s < c; ++s) {
        const f = i[s]
        ;(n.drawOnChartArea && h({ x: f.x1, y: f.y1 }, { x: f.x2, y: f.y2 }, f),
          n.drawTicks &&
            h(
              { x: f.tx1, y: f.ty1 },
              { x: f.tx2, y: f.ty2 },
              {
                color: f.tickColor,
                width: f.tickWidth,
                borderDash: f.tickBorderDash,
                borderDashOffset: f.tickBorderDashOffset,
              }
            ))
      }
  }
  drawBorder() {
    const {
        chart: e,
        ctx: n,
        options: { border: r, grid: i },
      } = this,
      s = r.setContext(this.getContext()),
      c = r.display ? s.width : 0
    if (!c) return
    const h = i.setContext(this.getContext(0)).lineWidth,
      f = this._borderValue
    let p, y, w, x
    ;(this.isHorizontal()
      ? ((p = Qi(e, this.left, c) - c / 2), (y = Qi(e, this.right, h) + h / 2), (w = x = f))
      : ((w = Qi(e, this.top, c) - c / 2), (x = Qi(e, this.bottom, h) + h / 2), (p = y = f)),
      n.save(),
      (n.lineWidth = s.width),
      (n.strokeStyle = s.color),
      n.beginPath(),
      n.moveTo(p, w),
      n.lineTo(y, x),
      n.stroke(),
      n.restore())
  }
  drawLabels(e) {
    if (!this.options.ticks.display) return
    const n = this.ctx,
      r = this._computeLabelArea()
    r && xh(n, r)
    const i = this.getLabelItems(e)
    for (const s of i) {
      const c = s.options,
        h = s.font,
        f = s.label,
        p = s.textOffset
      Ws(n, f, 0, p, h, c)
    }
    r && Eh(n)
  }
  drawTitle() {
    const {
      ctx: e,
      options: { position: n, title: r, reverse: i },
    } = this
    if (!r.display) return
    const s = He(r.font),
      c = sn(r.padding),
      h = r.align
    let f = s.lineHeight / 2
    n === 'bottom' || n === 'center' || Mt(n)
      ? ((f += c.bottom), ce(r.text) && (f += s.lineHeight * (r.text.length - 1)))
      : (f += c.top)
    const { titleX: p, titleY: y, maxWidth: w, rotation: x } = v_(this, f, n, h)
    Ws(e, r.text, 0, 0, s, {
      color: r.color,
      maxWidth: w,
      rotation: x,
      textAlign: b_(h, n, i),
      textBaseline: 'middle',
      translation: [p, y],
    })
  }
  draw(e) {
    this._isVisible() &&
      (this.drawBackground(),
      this.drawGrid(e),
      this.drawBorder(),
      this.drawTitle(),
      this.drawLabels(e))
  }
  _layers() {
    const e = this.options,
      n = (e.ticks && e.ticks.z) || 0,
      r = It(e.grid && e.grid.z, -1),
      i = It(e.border && e.border.z, 0)
    return !this._isVisible() || this.draw !== $s.prototype.draw
      ? [
          {
            z: n,
            draw: (s) => {
              this.draw(s)
            },
          },
        ]
      : [
          {
            z: r,
            draw: (s) => {
              ;(this.drawBackground(), this.drawGrid(s), this.drawTitle())
            },
          },
          {
            z: i,
            draw: () => {
              this.drawBorder()
            },
          },
          {
            z: n,
            draw: (s) => {
              this.drawLabels(s)
            },
          },
        ]
  }
  getMatchingVisibleMetas(e) {
    const n = this.chart.getSortedVisibleDatasetMetas(),
      r = this.axis + 'AxisID',
      i = []
    let s, c
    for (s = 0, c = n.length; s < c; ++s) {
      const h = n[s]
      h[r] === this.id && (!e || h.type === e) && i.push(h)
    }
    return i
  }
  _resolveTickFontOptions(e) {
    const n = this.options.ticks.setContext(this.getContext(e))
    return He(n.font)
  }
  _maxDigits() {
    const e = this._resolveTickFontOptions(0).lineHeight
    return (this.isHorizontal() ? this.width : this.height) / e
  }
}
class Mc {
  constructor(e, n, r) {
    ;((this.type = e), (this.scope = n), (this.override = r), (this.items = Object.create(null)))
  }
  isForType(e) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype)
  }
  register(e) {
    const n = Object.getPrototypeOf(e)
    let r
    C_(n) && (r = this.register(n))
    const i = this.items,
      s = e.id,
      c = this.scope + '.' + s
    if (!s) throw new Error('class does not have id: ' + e)
    return (s in i || ((i[s] = e), x_(e, c, r), this.override && be.override(e.id, e.overrides)), c)
  }
  get(e) {
    return this.items[e]
  }
  unregister(e) {
    const n = this.items,
      r = e.id,
      i = this.scope
    ;(r in n && delete n[r], i && r in be[i] && (delete be[i][r], this.override && delete So[r]))
  }
}
function x_(t, e, n) {
  const r = kl(Object.create(null), [n ? be.get(n) : {}, be.get(e), t.defaults])
  ;(be.set(e, r),
    t.defaultRoutes && E_(e, t.defaultRoutes),
    t.descriptors && be.describe(e, t.descriptors))
}
function E_(t, e) {
  Object.keys(e).forEach((n) => {
    const r = n.split('.'),
      i = r.pop(),
      s = [t].concat(r).join('.'),
      c = e[n].split('.'),
      h = c.pop(),
      f = c.join('.')
    be.route(s, i, f, h)
  })
}
function C_(t) {
  return 'id' in t && 'defaults' in t
}
class S_ {
  constructor() {
    ;((this.controllers = new Mc(mo, 'datasets', !0)),
      (this.elements = new Mc(Ho, 'elements')),
      (this.plugins = new Mc(Object, 'plugins')),
      (this.scales = new Mc($s, 'scales')),
      (this._typedRegistries = [this.controllers, this.scales, this.elements]))
  }
  add(...e) {
    this._each('register', e)
  }
  remove(...e) {
    this._each('unregister', e)
  }
  addControllers(...e) {
    this._each('register', e, this.controllers)
  }
  addElements(...e) {
    this._each('register', e, this.elements)
  }
  addPlugins(...e) {
    this._each('register', e, this.plugins)
  }
  addScales(...e) {
    this._each('register', e, this.scales)
  }
  getController(e) {
    return this._get(e, this.controllers, 'controller')
  }
  getElement(e) {
    return this._get(e, this.elements, 'element')
  }
  getPlugin(e) {
    return this._get(e, this.plugins, 'plugin')
  }
  getScale(e) {
    return this._get(e, this.scales, 'scale')
  }
  removeControllers(...e) {
    this._each('unregister', e, this.controllers)
  }
  removeElements(...e) {
    this._each('unregister', e, this.elements)
  }
  removePlugins(...e) {
    this._each('unregister', e, this.plugins)
  }
  removeScales(...e) {
    this._each('unregister', e, this.scales)
  }
  _each(e, n, r) {
    ;[...n].forEach((i) => {
      const s = r || this._getRegistryForType(i)
      r || s.isForType(i) || (s === this.plugins && i.id)
        ? this._exec(e, s, i)
        : zt(i, (c) => {
            const h = r || this._getRegistryForType(c)
            this._exec(e, h, c)
          })
    })
  }
  _exec(e, n, r) {
    const i = op(e)
    ;(Qt(r['before' + i], [], r), n[e](r), Qt(r['after' + i], [], r))
  }
  _getRegistryForType(e) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const r = this._typedRegistries[n]
      if (r.isForType(e)) return r
    }
    return this.plugins
  }
  _get(e, n, r) {
    const i = n.get(e)
    if (i === void 0) throw new Error('"' + e + '" is not a registered ' + r + '.')
    return i
  }
}
var Cr = new S_()
class A_ {
  constructor() {
    this._init = void 0
  }
  notify(e, n, r, i) {
    if (
      (n === 'beforeInit' &&
        ((this._init = this._createDescriptors(e, !0)), this._notify(this._init, e, 'install')),
      this._init === void 0)
    )
      return
    const s = i ? this._descriptors(e).filter(i) : this._descriptors(e),
      c = this._notify(s, e, n, r)
    return (
      n === 'afterDestroy' &&
        (this._notify(s, e, 'stop'),
        this._notify(this._init, e, 'uninstall'),
        (this._init = void 0)),
      c
    )
  }
  _notify(e, n, r, i) {
    i = i || {}
    for (const s of e) {
      const c = s.plugin,
        h = c[r],
        f = [n, i, s.options]
      if (Qt(h, f, c) === !1 && i.cancelable) return !1
    }
    return !0
  }
  invalidate() {
    Ot(this._cache) || ((this._oldCache = this._cache), (this._cache = void 0))
  }
  _descriptors(e) {
    if (this._cache) return this._cache
    const n = (this._cache = this._createDescriptors(e))
    return (this._notifyStateChanges(e), n)
  }
  _createDescriptors(e, n) {
    const r = e && e.config,
      i = It(r.options && r.options.plugins, {}),
      s = k_(r)
    return i === !1 && !n ? [] : __(e, s, i, n)
  }
  _notifyStateChanges(e) {
    const n = this._oldCache || [],
      r = this._cache,
      i = (s, c) => s.filter((h) => !c.some((f) => h.plugin.id === f.plugin.id))
    ;(this._notify(i(n, r), e, 'stop'), this._notify(i(r, n), e, 'start'))
  }
}
function k_(t) {
  const e = {},
    n = [],
    r = Object.keys(Cr.plugins.items)
  for (let s = 0; s < r.length; s++) n.push(Cr.getPlugin(r[s]))
  const i = t.plugins || []
  for (let s = 0; s < i.length; s++) {
    const c = i[s]
    n.indexOf(c) === -1 && (n.push(c), (e[c.id] = !0))
  }
  return { plugins: n, localIds: e }
}
function I_(t, e) {
  return !e && t === !1 ? null : t === !0 ? {} : t
}
function __(t, { plugins: e, localIds: n }, r, i) {
  const s = [],
    c = t.getContext()
  for (const h of e) {
    const f = h.id,
      p = I_(r[f], i)
    p !== null && s.push({ plugin: h, options: R_(t.config, { plugin: h, local: n[f] }, p, c) })
  }
  return s
}
function R_(t, { plugin: e, local: n }, r, i) {
  const s = t.pluginScopeKeys(e),
    c = t.getOptionScopes(r, s)
  return (
    n && e.defaults && c.push(e.defaults),
    t.createResolver(c, i, [''], { scriptable: !1, indexable: !1, allKeys: !0 })
  )
}
function df(t, e) {
  const n = be.datasets[t] || {}
  return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || n.indexAxis || 'x'
}
function T_(t, e) {
  let n = t
  return (t === '_index_' ? (n = e) : t === '_value_' && (n = e === 'x' ? 'y' : 'x'), n)
}
function N_(t, e) {
  return t === e ? '_index_' : '_value_'
}
function ry(t) {
  if (t === 'x' || t === 'y' || t === 'r') return t
}
function M_(t) {
  if (t === 'top' || t === 'bottom') return 'x'
  if (t === 'left' || t === 'right') return 'y'
}
function ff(t, ...e) {
  if (ry(t)) return t
  for (const n of e) {
    const r = n.axis || M_(n.position) || (t.length > 1 && ry(t[0].toLowerCase()))
    if (r) return r
  }
  throw new Error(
    `Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`
  )
}
function iy(t, e, n) {
  if (n[e + 'AxisID'] === t) return { axis: e }
}
function D_(t, e) {
  if (e.data && e.data.datasets) {
    const n = e.data.datasets.filter((r) => r.xAxisID === t || r.yAxisID === t)
    if (n.length) return iy(t, 'x', n[0]) || iy(t, 'y', n[0])
  }
  return {}
}
function P_(t, e) {
  const n = So[t.type] || { scales: {} },
    r = e.scales || {},
    i = df(t.type, e),
    s = Object.create(null)
  return (
    Object.keys(r).forEach((c) => {
      const h = r[c]
      if (!Mt(h)) return console.error(`Invalid scale configuration for scale: ${c}`)
      if (h._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${c}`)
      const f = ff(c, h, D_(c, t), be.scales[h.type]),
        p = N_(f, i),
        y = n.scales || {}
      s[c] = qa(Object.create(null), [{ axis: f }, h, y[f], y[p]])
    }),
    t.data.datasets.forEach((c) => {
      const h = c.type || t.type,
        f = c.indexAxis || df(h, e),
        p = (So[h] || {}).scales || {}
      Object.keys(p).forEach((y) => {
        const w = T_(y, f),
          x = c[w + 'AxisID'] || w
        ;((s[x] = s[x] || Object.create(null)), qa(s[x], [{ axis: w }, r[x], p[y]]))
      })
    }),
    Object.keys(s).forEach((c) => {
      const h = s[c]
      qa(h, [be.scales[h.type], be.scale])
    }),
    s
  )
}
function O3(t) {
  const e = t.options || (t.options = {})
  ;((e.plugins = It(e.plugins, {})), (e.scales = P_(t, e)))
}
function B3(t) {
  return ((t = t || {}), (t.datasets = t.datasets || []), (t.labels = t.labels || []), t)
}
function L_(t) {
  return ((t = t || {}), (t.data = B3(t.data)), O3(t), t)
}
const oy = new Map(),
  F3 = new Set()
function Dc(t, e) {
  let n = oy.get(t)
  return (n || ((n = e()), oy.set(t, n), F3.add(n)), n)
}
const Aa = (t, e, n) => {
  const r = Co(e, n)
  r !== void 0 && t.add(r)
}
class O_ {
  constructor(e) {
    ;((this._config = L_(e)), (this._scopeCache = new Map()), (this._resolverCache = new Map()))
  }
  get platform() {
    return this._config.platform
  }
  get type() {
    return this._config.type
  }
  set type(e) {
    this._config.type = e
  }
  get data() {
    return this._config.data
  }
  set data(e) {
    this._config.data = B3(e)
  }
  get options() {
    return this._config.options
  }
  set options(e) {
    this._config.options = e
  }
  get plugins() {
    return this._config.plugins
  }
  update() {
    const e = this._config
    ;(this.clearCache(), O3(e))
  }
  clearCache() {
    ;(this._scopeCache.clear(), this._resolverCache.clear())
  }
  datasetScopeKeys(e) {
    return Dc(e, () => [[`datasets.${e}`, '']])
  }
  datasetAnimationScopeKeys(e, n) {
    return Dc(`${e}.transition.${n}`, () => [
      [`datasets.${e}.transitions.${n}`, `transitions.${n}`],
      [`datasets.${e}`, ''],
    ])
  }
  datasetElementScopeKeys(e, n) {
    return Dc(`${e}-${n}`, () => [
      [`datasets.${e}.elements.${n}`, `datasets.${e}`, `elements.${n}`, ''],
    ])
  }
  pluginScopeKeys(e) {
    const n = e.id,
      r = this.type
    return Dc(`${r}-plugin-${n}`, () => [[`plugins.${n}`, ...(e.additionalOptionScopes || [])]])
  }
  _cachedScopes(e, n) {
    const r = this._scopeCache
    let i = r.get(e)
    return ((!i || n) && ((i = new Map()), r.set(e, i)), i)
  }
  getOptionScopes(e, n, r) {
    const { options: i, type: s } = this,
      c = this._cachedScopes(e, r),
      h = c.get(n)
    if (h) return h
    const f = new Set()
    n.forEach((y) => {
      ;(e && (f.add(e), y.forEach((w) => Aa(f, e, w))),
        y.forEach((w) => Aa(f, i, w)),
        y.forEach((w) => Aa(f, So[s] || {}, w)),
        y.forEach((w) => Aa(f, be, w)),
        y.forEach((w) => Aa(f, uf, w)))
    })
    const p = Array.from(f)
    return (p.length === 0 && p.push(Object.create(null)), F3.has(n) && c.set(n, p), p)
  }
  chartOptionScopes() {
    const { options: e, type: n } = this
    return [e, So[n] || {}, be.datasets[n] || {}, { type: n }, be, uf]
  }
  resolveNamedOptions(e, n, r, i = ['']) {
    const s = { $shared: !0 },
      { resolver: c, subPrefixes: h } = sy(this._resolverCache, e, i)
    let f = c
    if (F_(c, n)) {
      ;((s.$shared = !1), (r = Oi(r) ? r() : r))
      const p = this.createResolver(e, r, h)
      f = Us(c, r, p)
    }
    for (const p of n) s[p] = f[p]
    return s
  }
  createResolver(e, n, r = [''], i) {
    const { resolver: s } = sy(this._resolverCache, e, r)
    return Mt(n) ? Us(s, n, void 0, i) : s
  }
}
function sy(t, e, n) {
  let r = t.get(e)
  r || ((r = new Map()), t.set(e, r))
  const i = n.join()
  let s = r.get(i)
  return (
    s ||
      ((s = {
        resolver: up(e, n),
        subPrefixes: n.filter((c) => !c.toLowerCase().includes('hover')),
      }),
      r.set(i, s)),
    s
  )
}
const B_ = (t) => Mt(t) && Object.getOwnPropertyNames(t).some((e) => Oi(t[e]))
function F_(t, e) {
  const { isScriptable: n, isIndexable: r } = y3(t)
  for (const i of e) {
    const s = n(i),
      c = r(i),
      h = (c || s) && t[i]
    if ((s && (Oi(h) || B_(h))) || (c && ce(h))) return !0
  }
  return !1
}
var j_ = '4.5.1'
const V_ = ['top', 'bottom', 'left', 'right', 'chartArea']
function ay(t, e) {
  return t === 'top' || t === 'bottom' || (V_.indexOf(t) === -1 && e === 'x')
}
function ly(t, e) {
  return function (n, r) {
    return n[t] === r[t] ? n[e] - r[e] : n[t] - r[t]
  }
}
function cy(t) {
  const e = t.chart,
    n = e.options.animation
  ;(e.notifyPlugins('afterRender'), Qt(n && n.onComplete, [t], e))
}
function W_(t) {
  const e = t.chart,
    n = e.options.animation
  Qt(n && n.onProgress, [t], e)
}
function j3(t) {
  return (
    fp() && typeof t == 'string' ? (t = document.getElementById(t)) : t && t.length && (t = t[0]),
    t && t.canvas && (t = t.canvas),
    t
  )
}
const nu = {},
  uy = (t) => {
    const e = j3(t)
    return Object.values(nu)
      .filter((n) => n.canvas === e)
      .pop()
  }
function U_(t, e, n) {
  const r = Object.keys(t)
  for (const i of r) {
    const s = +i
    if (s >= e) {
      const c = t[i]
      ;(delete t[i], (n > 0 || s > e) && (t[s + n] = c))
    }
  }
}
function z_(t, e, n, r) {
  return !n || t.type === 'mouseout' ? null : r ? e : t
}
var ai
let Ul =
  ((ai = class {
    static register(...t) {
      ;(Cr.add(...t), hy())
    }
    static unregister(...t) {
      ;(Cr.remove(...t), hy())
    }
    constructor(t, e) {
      const n = (this.config = new O_(e)),
        r = j3(t),
        i = uy(r)
      if (i)
        throw new Error(
          "Canvas is already in use. Chart with ID '" +
            i.id +
            "' must be destroyed before the canvas with ID '" +
            i.canvas.id +
            "' can be reused."
        )
      const s = n.createResolver(n.chartOptionScopes(), this.getContext())
      ;((this.platform = new (n.platform || a_(r))()), this.platform.updateConfig(n))
      const c = this.platform.acquireContext(r, s.aspectRatio),
        h = c && c.canvas,
        f = h && h.height,
        p = h && h.width
      if (
        ((this.id = Vk()),
        (this.ctx = c),
        (this.canvas = h),
        (this.width = p),
        (this.height = f),
        (this._options = s),
        (this._aspectRatio = this.aspectRatio),
        (this._layers = []),
        (this._metasets = []),
        (this._stacks = void 0),
        (this.boxes = []),
        (this.currentDevicePixelRatio = void 0),
        (this.chartArea = void 0),
        (this._active = []),
        (this._lastEvent = void 0),
        (this._listeners = {}),
        (this._responsiveListeners = void 0),
        (this._sortedMetasets = []),
        (this.scales = {}),
        (this._plugins = new A_()),
        (this.$proxies = {}),
        (this._hiddenIndices = {}),
        (this.attached = !1),
        (this._animationsDisabled = void 0),
        (this.$context = void 0),
        (this._doResize = o9((y) => this.update(y), s.resizeDelay || 0)),
        (this._dataChanges = []),
        (nu[this.id] = this),
        !c || !h)
      ) {
        console.error("Failed to create chart: can't acquire context from the given item")
        return
      }
      ;(Mr.listen(this, 'complete', cy),
        Mr.listen(this, 'progress', W_),
        this._initialize(),
        this.attached && this.update())
    }
    get aspectRatio() {
      const {
        options: { aspectRatio: t, maintainAspectRatio: e },
        width: n,
        height: r,
        _aspectRatio: i,
      } = this
      return Ot(t) ? (e && i ? i : r ? n / r : null) : t
    }
    get data() {
      return this.config.data
    }
    set data(t) {
      this.config.data = t
    }
    get options() {
      return this._options
    }
    set options(t) {
      this.config.options = t
    }
    get registry() {
      return Cr
    }
    _initialize() {
      return (
        this.notifyPlugins('beforeInit'),
        this.options.responsive ? this.resize() : Dm(this, this.options.devicePixelRatio),
        this.bindEvents(),
        this.notifyPlugins('afterInit'),
        this
      )
    }
    clear() {
      return (Tm(this.canvas, this.ctx), this)
    }
    stop() {
      return (Mr.stop(this), this)
    }
    resize(t, e) {
      Mr.running(this) ? (this._resizeBeforeDraw = { width: t, height: e }) : this._resize(t, e)
    }
    _resize(t, e) {
      const n = this.options,
        r = this.canvas,
        i = n.maintainAspectRatio && this.aspectRatio,
        s = this.platform.getMaximumSize(r, t, e, i),
        c = n.devicePixelRatio || this.platform.getDevicePixelRatio(),
        h = this.width ? 'resize' : 'attach'
      ;((this.width = s.width),
        (this.height = s.height),
        (this._aspectRatio = this.aspectRatio),
        Dm(this, c, !0) &&
          (this.notifyPlugins('resize', { size: s }),
          Qt(n.onResize, [this, s], this),
          this.attached && this._doResize(h) && this.render()))
    }
    ensureScalesHaveIDs() {
      const t = this.options.scales || {}
      zt(t, (e, n) => {
        e.id = n
      })
    }
    buildOrUpdateScales() {
      const t = this.options,
        e = t.scales,
        n = this.scales,
        r = Object.keys(n).reduce((s, c) => ((s[c] = !1), s), {})
      let i = []
      ;(e &&
        (i = i.concat(
          Object.keys(e).map((s) => {
            const c = e[s],
              h = ff(s, c),
              f = h === 'r',
              p = h === 'x'
            return {
              options: c,
              dposition: f ? 'chartArea' : p ? 'bottom' : 'left',
              dtype: f ? 'radialLinear' : p ? 'category' : 'linear',
            }
          })
        )),
        zt(i, (s) => {
          const c = s.options,
            h = c.id,
            f = ff(h, c),
            p = It(c.type, s.dtype)
          ;((c.position === void 0 || ay(c.position, f) !== ay(s.dposition)) &&
            (c.position = s.dposition),
            (r[h] = !0))
          let y = null
          if (h in n && n[h].type === p) y = n[h]
          else {
            const w = Cr.getScale(p)
            ;((y = new w({ id: h, type: p, ctx: this.ctx, chart: this })), (n[y.id] = y))
          }
          y.init(c, t)
        }),
        zt(r, (s, c) => {
          s || delete n[c]
        }),
        zt(n, (s) => {
          ;(vi.configure(this, s, s.options), vi.addBox(this, s))
        }))
    }
    _updateMetasets() {
      const t = this._metasets,
        e = this.data.datasets.length,
        n = t.length
      if ((t.sort((r, i) => r.index - i.index), n > e)) {
        for (let r = e; r < n; ++r) this._destroyDatasetMeta(r)
        t.splice(e, n - e)
      }
      this._sortedMetasets = t.slice(0).sort(ly('order', 'index'))
    }
    _removeUnreferencedMetasets() {
      const {
        _metasets: t,
        data: { datasets: e },
      } = this
      ;(t.length > e.length && delete this._stacks,
        t.forEach((n, r) => {
          e.filter((i) => i === n._dataset).length === 0 && this._destroyDatasetMeta(r)
        }))
    }
    buildOrUpdateControllers() {
      const t = [],
        e = this.data.datasets
      let n, r
      for (this._removeUnreferencedMetasets(), n = 0, r = e.length; n < r; n++) {
        const i = e[n]
        let s = this.getDatasetMeta(n)
        const c = i.type || this.config.type
        if (
          (s.type && s.type !== c && (this._destroyDatasetMeta(n), (s = this.getDatasetMeta(n))),
          (s.type = c),
          (s.indexAxis = i.indexAxis || df(c, this.options)),
          (s.order = i.order || 0),
          (s.index = n),
          (s.label = '' + i.label),
          (s.visible = this.isDatasetVisible(n)),
          s.controller)
        )
          (s.controller.updateIndex(n), s.controller.linkScales())
        else {
          const h = Cr.getController(c),
            { datasetElementType: f, dataElementType: p } = be.datasets[c]
          ;(Object.assign(h, {
            dataElementType: Cr.getElement(p),
            datasetElementType: f && Cr.getElement(f),
          }),
            (s.controller = new h(this, n)),
            t.push(s.controller))
        }
      }
      return (this._updateMetasets(), t)
    }
    _resetElements() {
      zt(
        this.data.datasets,
        (t, e) => {
          this.getDatasetMeta(e).controller.reset()
        },
        this
      )
    }
    reset() {
      ;(this._resetElements(), this.notifyPlugins('reset'))
    }
    update(t) {
      const e = this.config
      e.update()
      const n = (this._options = e.createResolver(e.chartOptionScopes(), this.getContext())),
        r = (this._animationsDisabled = !n.animation)
      if (
        (this._updateScales(),
        this._checkEventBindings(),
        this._updateHiddenIndices(),
        this._plugins.invalidate(),
        this.notifyPlugins('beforeUpdate', { mode: t, cancelable: !0 }) === !1)
      )
        return
      const i = this.buildOrUpdateControllers()
      this.notifyPlugins('beforeElementsUpdate')
      let s = 0
      for (let f = 0, p = this.data.datasets.length; f < p; f++) {
        const { controller: y } = this.getDatasetMeta(f),
          w = !r && i.indexOf(y) === -1
        ;(y.buildOrUpdateElements(w), (s = Math.max(+y.getMaxOverflow(), s)))
      }
      ;((s = this._minPadding = n.layout.autoPadding ? s : 0),
        this._updateLayout(s),
        r ||
          zt(i, (f) => {
            f.reset()
          }),
        this._updateDatasets(t),
        this.notifyPlugins('afterUpdate', { mode: t }),
        this._layers.sort(ly('z', '_idx')))
      const { _active: c, _lastEvent: h } = this
      ;(h ? this._eventHandler(h, !0) : c.length && this._updateHoverStyles(c, c, !0),
        this.render())
    }
    _updateScales() {
      ;(zt(this.scales, (t) => {
        vi.removeBox(this, t)
      }),
        this.ensureScalesHaveIDs(),
        this.buildOrUpdateScales())
    }
    _checkEventBindings() {
      const t = this.options,
        e = new Set(Object.keys(this._listeners)),
        n = new Set(t.events)
      ;(!xm(e, n) || !!this._responsiveListeners !== t.responsive) &&
        (this.unbindEvents(), this.bindEvents())
    }
    _updateHiddenIndices() {
      const { _hiddenIndices: t } = this,
        e = this._getUniformDataChanges() || []
      for (const { method: n, start: r, count: i } of e) {
        const s = n === '_removeElements' ? -i : i
        U_(t, r, s)
      }
    }
    _getUniformDataChanges() {
      const t = this._dataChanges
      if (!t || !t.length) return
      this._dataChanges = []
      const e = this.data.datasets.length,
        n = (i) =>
          new Set(t.filter((s) => s[0] === i).map((s, c) => c + ',' + s.splice(1).join(','))),
        r = n(0)
      for (let i = 1; i < e; i++) if (!xm(r, n(i))) return
      return Array.from(r)
        .map((i) => i.split(','))
        .map((i) => ({ method: i[1], start: +i[2], count: +i[3] }))
    }
    _updateLayout(t) {
      if (this.notifyPlugins('beforeLayout', { cancelable: !0 }) === !1) return
      vi.update(this, this.width, this.height, t)
      const e = this.chartArea,
        n = e.width <= 0 || e.height <= 0
      ;((this._layers = []),
        zt(
          this.boxes,
          (r) => {
            ;(n && r.position === 'chartArea') ||
              (r.configure && r.configure(), this._layers.push(...r._layers()))
          },
          this
        ),
        this._layers.forEach((r, i) => {
          r._idx = i
        }),
        this.notifyPlugins('afterLayout'))
    }
    _updateDatasets(t) {
      if (this.notifyPlugins('beforeDatasetsUpdate', { mode: t, cancelable: !0 }) !== !1) {
        for (let e = 0, n = this.data.datasets.length; e < n; ++e)
          this.getDatasetMeta(e).controller.configure()
        for (let e = 0, n = this.data.datasets.length; e < n; ++e)
          this._updateDataset(e, Oi(t) ? t({ datasetIndex: e }) : t)
        this.notifyPlugins('afterDatasetsUpdate', { mode: t })
      }
    }
    _updateDataset(t, e) {
      const n = this.getDatasetMeta(t),
        r = { meta: n, index: t, mode: e, cancelable: !0 }
      this.notifyPlugins('beforeDatasetUpdate', r) !== !1 &&
        (n.controller._update(e), (r.cancelable = !1), this.notifyPlugins('afterDatasetUpdate', r))
    }
    render() {
      this.notifyPlugins('beforeRender', { cancelable: !0 }) !== !1 &&
        (Mr.has(this)
          ? this.attached && !Mr.running(this) && Mr.start(this)
          : (this.draw(), cy({ chart: this })))
    }
    draw() {
      let t
      if (this._resizeBeforeDraw) {
        const { width: n, height: r } = this._resizeBeforeDraw
        ;((this._resizeBeforeDraw = null), this._resize(n, r))
      }
      if (
        (this.clear(),
        this.width <= 0 ||
          this.height <= 0 ||
          this.notifyPlugins('beforeDraw', { cancelable: !0 }) === !1)
      )
        return
      const e = this._layers
      for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea)
      for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea)
      this.notifyPlugins('afterDraw')
    }
    _getSortedDatasetMetas(t) {
      const e = this._sortedMetasets,
        n = []
      let r, i
      for (r = 0, i = e.length; r < i; ++r) {
        const s = e[r]
        ;(!t || s.visible) && n.push(s)
      }
      return n
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(!0)
    }
    _drawDatasets() {
      if (this.notifyPlugins('beforeDatasetsDraw', { cancelable: !0 }) === !1) return
      const t = this.getSortedVisibleDatasetMetas()
      for (let e = t.length - 1; e >= 0; --e) this._drawDataset(t[e])
      this.notifyPlugins('afterDatasetsDraw')
    }
    _drawDataset(t) {
      const e = this.ctx,
        n = { meta: t, index: t.index, cancelable: !0 },
        r = I3(this, t)
      this.notifyPlugins('beforeDatasetDraw', n) !== !1 &&
        (r && xh(e, r),
        t.controller.draw(),
        r && Eh(e),
        (n.cancelable = !1),
        this.notifyPlugins('afterDatasetDraw', n))
    }
    isPointInArea(t) {
      return Vr(t, this.chartArea, this._minPadding)
    }
    getElementsAtEventForMode(t, e, n, r) {
      const i = VI.modes[e]
      return typeof i == 'function' ? i(this, t, n, r) : []
    }
    getDatasetMeta(t) {
      const e = this.data.datasets[t],
        n = this._metasets
      let r = n.filter((i) => i && i._dataset === e).pop()
      return (
        r ||
          ((r = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: (e && e.order) || 0,
            index: t,
            _dataset: e,
            _parsed: [],
            _sorted: !1,
          }),
          n.push(r)),
        r
      )
    }
    getContext() {
      return this.$context || (this.$context = Ui(null, { chart: this, type: 'chart' }))
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length
    }
    isDatasetVisible(t) {
      const e = this.data.datasets[t]
      if (!e) return !1
      const n = this.getDatasetMeta(t)
      return typeof n.hidden == 'boolean' ? !n.hidden : !e.hidden
    }
    setDatasetVisibility(t, e) {
      const n = this.getDatasetMeta(t)
      n.hidden = !e
    }
    toggleDataVisibility(t) {
      this._hiddenIndices[t] = !this._hiddenIndices[t]
    }
    getDataVisibility(t) {
      return !this._hiddenIndices[t]
    }
    _updateVisibility(t, e, n) {
      const r = n ? 'show' : 'hide',
        i = this.getDatasetMeta(t),
        s = i.controller._resolveAnimations(void 0, r)
      Il(e)
        ? ((i.data[e].hidden = !n), this.update())
        : (this.setDatasetVisibility(t, n),
          s.update(i, { visible: n }),
          this.update((c) => (c.datasetIndex === t ? r : void 0)))
    }
    hide(t, e) {
      this._updateVisibility(t, e, !1)
    }
    show(t, e) {
      this._updateVisibility(t, e, !0)
    }
    _destroyDatasetMeta(t) {
      const e = this._metasets[t]
      ;(e && e.controller && e.controller._destroy(), delete this._metasets[t])
    }
    _stop() {
      let t, e
      for (this.stop(), Mr.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)
        this._destroyDatasetMeta(t)
    }
    destroy() {
      this.notifyPlugins('beforeDestroy')
      const { canvas: t, ctx: e } = this
      ;(this._stop(),
        this.config.clearCache(),
        t &&
          (this.unbindEvents(),
          Tm(t, e),
          this.platform.releaseContext(e),
          (this.canvas = null),
          (this.ctx = null)),
        delete nu[this.id],
        this.notifyPlugins('afterDestroy'))
    }
    toBase64Image(...t) {
      return this.canvas.toDataURL(...t)
    }
    bindEvents() {
      ;(this.bindUserEvents(),
        this.options.responsive ? this.bindResponsiveEvents() : (this.attached = !0))
    }
    bindUserEvents() {
      const t = this._listeners,
        e = this.platform,
        n = (i, s) => {
          ;(e.addEventListener(this, i, s), (t[i] = s))
        },
        r = (i, s, c) => {
          ;((i.offsetX = s), (i.offsetY = c), this._eventHandler(i))
        }
      zt(this.options.events, (i) => n(i, r))
    }
    bindResponsiveEvents() {
      this._responsiveListeners || (this._responsiveListeners = {})
      const t = this._responsiveListeners,
        e = this.platform,
        n = (h, f) => {
          ;(e.addEventListener(this, h, f), (t[h] = f))
        },
        r = (h, f) => {
          t[h] && (e.removeEventListener(this, h, f), delete t[h])
        },
        i = (h, f) => {
          this.canvas && this.resize(h, f)
        }
      let s
      const c = () => {
        ;(r('attach', c), (this.attached = !0), this.resize(), n('resize', i), n('detach', s))
      }
      ;((s = () => {
        ;((this.attached = !1), r('resize', i), this._stop(), this._resize(0, 0), n('attach', c))
      }),
        e.isAttached(this.canvas) ? c() : s())
    }
    unbindEvents() {
      ;(zt(this._listeners, (t, e) => {
        this.platform.removeEventListener(this, e, t)
      }),
        (this._listeners = {}),
        zt(this._responsiveListeners, (t, e) => {
          this.platform.removeEventListener(this, e, t)
        }),
        (this._responsiveListeners = void 0))
    }
    updateHoverStyle(t, e, n) {
      const r = n ? 'set' : 'remove'
      let i, s, c, h
      for (
        e === 'dataset' &&
          ((i = this.getDatasetMeta(t[0].datasetIndex)),
          i.controller['_' + r + 'DatasetHoverStyle']()),
          c = 0,
          h = t.length;
        c < h;
        ++c
      ) {
        s = t[c]
        const f = s && this.getDatasetMeta(s.datasetIndex).controller
        f && f[r + 'HoverStyle'](s.element, s.datasetIndex, s.index)
      }
    }
    getActiveElements() {
      return this._active || []
    }
    setActiveElements(t) {
      const e = this._active || [],
        n = t.map(({ datasetIndex: r, index: i }) => {
          const s = this.getDatasetMeta(r)
          if (!s) throw new Error('No dataset found at index ' + r)
          return { datasetIndex: r, element: s.data[i], index: i }
        })
      !Bu(n, e) && ((this._active = n), (this._lastEvent = null), this._updateHoverStyles(n, e))
    }
    notifyPlugins(t, e, n) {
      return this._plugins.notify(this, t, e, n)
    }
    isPluginEnabled(t) {
      return this._plugins._cache.filter((e) => e.plugin.id === t).length === 1
    }
    _updateHoverStyles(t, e, n) {
      const r = this.options.hover,
        i = (h, f) =>
          h.filter((p) => !f.some((y) => p.datasetIndex === y.datasetIndex && p.index === y.index)),
        s = i(e, t),
        c = n ? t : i(t, e)
      ;(s.length && this.updateHoverStyle(s, r.mode, !1),
        c.length && r.mode && this.updateHoverStyle(c, r.mode, !0))
    }
    _eventHandler(t, e) {
      const n = { event: t, replay: e, cancelable: !0, inChartArea: this.isPointInArea(t) },
        r = (s) => (s.options.events || this.options.events).includes(t.native.type)
      if (this.notifyPlugins('beforeEvent', n, r) === !1) return
      const i = this._handleEvent(t, e, n.inChartArea)
      return (
        (n.cancelable = !1),
        this.notifyPlugins('afterEvent', n, r),
        (i || n.changed) && this.render(),
        this
      )
    }
    _handleEvent(t, e, n) {
      const { _active: r = [], options: i } = this,
        s = e,
        c = this._getActiveElements(t, r, n, s),
        h = Gk(t),
        f = z_(t, this._lastEvent, n, h)
      n &&
        ((this._lastEvent = null),
        Qt(i.onHover, [t, c, this], this),
        h && Qt(i.onClick, [t, c, this], this))
      const p = !Bu(c, r)
      return (
        (p || e) && ((this._active = c), this._updateHoverStyles(c, r, e)),
        (this._lastEvent = f),
        p
      )
    }
    _getActiveElements(t, e, n, r) {
      if (t.type === 'mouseout') return []
      if (!n) return e
      const i = this.options.hover
      return this.getElementsAtEventForMode(t, i.mode, i, r)
    }
  }),
  yt(ai, 'defaults', be),
  yt(ai, 'instances', nu),
  yt(ai, 'overrides', So),
  yt(ai, 'registry', Cr),
  yt(ai, 'version', j_),
  yt(ai, 'getChart', uy),
  ai)
function hy() {
  return zt(Ul.instances, (t) => t._plugins.invalidate())
}
function V3(t, e, n = e) {
  ;((t.lineCap = It(n.borderCapStyle, e.borderCapStyle)),
    t.setLineDash(It(n.borderDash, e.borderDash)),
    (t.lineDashOffset = It(n.borderDashOffset, e.borderDashOffset)),
    (t.lineJoin = It(n.borderJoinStyle, e.borderJoinStyle)),
    (t.lineWidth = It(n.borderWidth, e.borderWidth)),
    (t.strokeStyle = It(n.borderColor, e.borderColor)))
}
function H_(t, e, n) {
  t.lineTo(n.x, n.y)
}
function X_(t) {
  return t.stepped ? v9 : t.tension || t.cubicInterpolationMode === 'monotone' ? x9 : H_
}
function W3(t, e, n = {}) {
  const r = t.length,
    { start: i = 0, end: s = r - 1 } = n,
    { start: c, end: h } = e,
    f = Math.max(i, c),
    p = Math.min(s, h),
    y = (i < c && s < c) || (i > h && s > h)
  return { count: r, start: f, loop: e.loop, ilen: p < f && !y ? r + p - f : p - f }
}
function G_(t, e, n, r) {
  const { points: i, options: s } = e,
    { count: c, start: h, loop: f, ilen: p } = W3(i, n, r),
    y = X_(s)
  let { move: w = !0, reverse: x } = r || {},
    E,
    S,
    k
  for (E = 0; E <= p; ++E)
    ((S = i[(h + (x ? p - E : E)) % c]),
      !S.skip && (w ? (t.moveTo(S.x, S.y), (w = !1)) : y(t, k, S, x, s.stepped), (k = S)))
  return (f && ((S = i[(h + (x ? p : 0)) % c]), y(t, k, S, x, s.stepped)), !!f)
}
function Y_(t, e, n, r) {
  const i = e.points,
    { count: s, start: c, ilen: h } = W3(i, n, r),
    { move: f = !0, reverse: p } = r || {}
  let y = 0,
    w = 0,
    x,
    E,
    S,
    k,
    D,
    _
  const N = (O) => (c + (p ? h - O : O)) % s,
    M = () => {
      k !== D && (t.lineTo(y, D), t.lineTo(y, k), t.lineTo(y, _))
    }
  for (f && ((E = i[N(0)]), t.moveTo(E.x, E.y)), x = 0; x <= h; ++x) {
    if (((E = i[N(x)]), E.skip)) continue
    const O = E.x,
      F = E.y,
      z = O | 0
    ;(z === S
      ? (F < k ? (k = F) : F > D && (D = F), (y = (w * y + O) / ++w))
      : (M(), t.lineTo(O, F), (S = z), (w = 0), (k = D = F)),
      (_ = F))
  }
  M()
}
function pf(t) {
  const e = t.options,
    n = e.borderDash && e.borderDash.length
  return !t._decimated &&
    !t._loop &&
    !e.tension &&
    e.cubicInterpolationMode !== 'monotone' &&
    !e.stepped &&
    !n
    ? Y_
    : G_
}
function Z_(t) {
  return t.stepped ? tI : t.tension || t.cubicInterpolationMode === 'monotone' ? eI : io
}
function q_(t, e, n, r) {
  let i = e._path
  ;(i || ((i = e._path = new Path2D()), e.path(i, n, r) && i.closePath()),
    V3(t, e.options),
    t.stroke(i))
}
function K_(t, e, n, r) {
  const { segments: i, options: s } = e,
    c = pf(e)
  for (const h of i)
    (V3(t, s, h.style),
      t.beginPath(),
      c(t, e, h, { start: n, end: n + r - 1 }) && t.closePath(),
      t.stroke())
}
const Q_ = typeof Path2D == 'function'
function $_(t, e, n, r) {
  Q_ && !e.options.segment ? q_(t, e, n, r) : K_(t, e, n, r)
}
class Wr extends Ho {
  constructor(e) {
    ;(super(),
      (this.animated = !0),
      (this.options = void 0),
      (this._chart = void 0),
      (this._loop = void 0),
      (this._fullLoop = void 0),
      (this._path = void 0),
      (this._points = void 0),
      (this._segments = void 0),
      (this._decimated = !1),
      (this._pointsUpdated = !1),
      (this._datasetIndex = void 0),
      e && Object.assign(this, e))
  }
  updateControlPoints(e, n) {
    const r = this.options
    if (
      (r.tension || r.cubicInterpolationMode === 'monotone') &&
      !r.stepped &&
      !this._pointsUpdated
    ) {
      const i = r.spanGaps ? this._loop : this._fullLoop
      ;(G9(this._points, r, e, i, n), (this._pointsUpdated = !0))
    }
  }
  set points(e) {
    ;((this._points = e), delete this._segments, delete this._path, (this._pointsUpdated = !1))
  }
  get points() {
    return this._points
  }
  get segments() {
    return this._segments || (this._segments = aI(this, this.options.segment))
  }
  first() {
    const e = this.segments,
      n = this.points
    return e.length && n[e[0].start]
  }
  last() {
    const e = this.segments,
      n = this.points,
      r = e.length
    return r && n[e[r - 1].end]
  }
  interpolate(e, n) {
    const r = this.options,
      i = e[n],
      s = this.points,
      c = k3(this, { property: n, start: i, end: i })
    if (!c.length) return
    const h = [],
      f = Z_(r)
    let p, y
    for (p = 0, y = c.length; p < y; ++p) {
      const { start: w, end: x } = c[p],
        E = s[w],
        S = s[x]
      if (E === S) {
        h.push(E)
        continue
      }
      const k = Math.abs((i - E[n]) / (S[n] - E[n])),
        D = f(E, S, k, r.stepped)
      ;((D[n] = e[n]), h.push(D))
    }
    return h.length === 1 ? h[0] : h
  }
  pathSegment(e, n, r) {
    return pf(this)(e, this, n, r)
  }
  path(e, n, r) {
    const i = this.segments,
      s = pf(this)
    let c = this._loop
    ;((n = n || 0), (r = r || this.points.length - n))
    for (const h of i) c &= s(e, this, h, { start: n, end: n + r - 1 })
    return !!c
  }
  draw(e, n, r, i) {
    const s = this.options || {}
    ;((this.points || []).length && s.borderWidth && (e.save(), $_(e, this, r, i), e.restore()),
      this.animated && ((this._pointsUpdated = !1), (this._path = void 0)))
  }
}
;(yt(Wr, 'id', 'line'),
  yt(Wr, 'defaults', {
    borderCapStyle: 'butt',
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: 'miter',
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: 'default',
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0,
  }),
  yt(Wr, 'defaultRoutes', { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }),
  yt(Wr, 'descriptors', { _scriptable: !0, _indexable: (t) => t !== 'borderDash' && t !== 'fill' }))
function dy(t, e, n, r) {
  const i = t.options,
    { [n]: s } = t.getProps([n], r)
  return Math.abs(e - s) < i.radius + i.hitRadius
}
class Ja extends Ho {
  constructor(e) {
    ;(super(),
      yt(this, 'parsed'),
      yt(this, 'skip'),
      yt(this, 'stop'),
      (this.options = void 0),
      (this.parsed = void 0),
      (this.skip = void 0),
      (this.stop = void 0),
      e && Object.assign(this, e))
  }
  inRange(e, n, r) {
    const i = this.options,
      { x: s, y: c } = this.getProps(['x', 'y'], r)
    return Math.pow(e - s, 2) + Math.pow(n - c, 2) < Math.pow(i.hitRadius + i.radius, 2)
  }
  inXRange(e, n) {
    return dy(this, e, 'x', n)
  }
  inYRange(e, n) {
    return dy(this, e, 'y', n)
  }
  getCenterPoint(e) {
    const { x: n, y: r } = this.getProps(['x', 'y'], e)
    return { x: n, y: r }
  }
  size(e) {
    e = e || this.options || {}
    let n = e.radius || 0
    n = Math.max(n, (n && e.hoverRadius) || 0)
    const r = (n && e.borderWidth) || 0
    return (n + r) * 2
  }
  draw(e, n) {
    const r = this.options
    this.skip ||
      r.radius < 0.1 ||
      !Vr(this, n, this.size(r) / 2) ||
      ((e.strokeStyle = r.borderColor),
      (e.lineWidth = r.borderWidth),
      (e.fillStyle = r.backgroundColor),
      hf(e, r, this.x, this.y))
  }
  getRange() {
    const e = this.options || {}
    return e.radius + e.hitRadius
  }
}
;(yt(Ja, 'id', 'point'),
  yt(Ja, 'defaults', {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: 'circle',
    radius: 3,
    rotation: 0,
  }),
  yt(Ja, 'defaultRoutes', { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }))
function U3(t, e) {
  const {
    x: n,
    y: r,
    base: i,
    width: s,
    height: c,
  } = t.getProps(['x', 'y', 'base', 'width', 'height'], e)
  let h, f, p, y, w
  return (
    t.horizontal
      ? ((w = c / 2), (h = Math.min(n, i)), (f = Math.max(n, i)), (p = r - w), (y = r + w))
      : ((w = s / 2), (h = n - w), (f = n + w), (p = Math.min(r, i)), (y = Math.max(r, i))),
    { left: h, top: p, right: f, bottom: y }
  )
}
function xi(t, e, n, r) {
  return t ? 0 : Mn(e, n, r)
}
function J_(t, e, n) {
  const r = t.options.borderWidth,
    i = t.borderSkipped,
    s = m3(r)
  return {
    t: xi(i.top, s.top, 0, n),
    r: xi(i.right, s.right, 0, e),
    b: xi(i.bottom, s.bottom, 0, n),
    l: xi(i.left, s.left, 0, e),
  }
}
function tR(t, e, n) {
  const { enableBorderRadius: r } = t.getProps(['enableBorderRadius']),
    i = t.options.borderRadius,
    s = po(i),
    c = Math.min(e, n),
    h = t.borderSkipped,
    f = r || Mt(i)
  return {
    topLeft: xi(!f || h.top || h.left, s.topLeft, 0, c),
    topRight: xi(!f || h.top || h.right, s.topRight, 0, c),
    bottomLeft: xi(!f || h.bottom || h.left, s.bottomLeft, 0, c),
    bottomRight: xi(!f || h.bottom || h.right, s.bottomRight, 0, c),
  }
}
function eR(t) {
  const e = U3(t),
    n = e.right - e.left,
    r = e.bottom - e.top,
    i = J_(t, n / 2, r / 2),
    s = tR(t, n / 2, r / 2)
  return {
    outer: { x: e.left, y: e.top, w: n, h: r, radius: s },
    inner: {
      x: e.left + i.l,
      y: e.top + i.t,
      w: n - i.l - i.r,
      h: r - i.t - i.b,
      radius: {
        topLeft: Math.max(0, s.topLeft - Math.max(i.t, i.l)),
        topRight: Math.max(0, s.topRight - Math.max(i.t, i.r)),
        bottomLeft: Math.max(0, s.bottomLeft - Math.max(i.b, i.l)),
        bottomRight: Math.max(0, s.bottomRight - Math.max(i.b, i.r)),
      },
    },
  }
}
function Hd(t, e, n, r) {
  const i = e === null,
    s = n === null,
    c = t && !(i && s) && U3(t, r)
  return c && (i || wi(e, c.left, c.right)) && (s || wi(n, c.top, c.bottom))
}
function nR(t) {
  return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight
}
function rR(t, e) {
  t.rect(e.x, e.y, e.w, e.h)
}
function Xd(t, e, n = {}) {
  const r = t.x !== n.x ? -e : 0,
    i = t.y !== n.y ? -e : 0,
    s = (t.x + t.w !== n.x + n.w ? e : 0) - r,
    c = (t.y + t.h !== n.y + n.h ? e : 0) - i
  return { x: t.x + r, y: t.y + i, w: t.w + s, h: t.h + c, radius: t.radius }
}
class ru extends Ho {
  constructor(e) {
    ;(super(),
      (this.options = void 0),
      (this.horizontal = void 0),
      (this.base = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this.inflateAmount = void 0),
      e && Object.assign(this, e))
  }
  draw(e) {
    const {
        inflateAmount: n,
        options: { borderColor: r, backgroundColor: i },
      } = this,
      { inner: s, outer: c } = eR(this),
      h = nR(c.radius) ? Rl : rR
    ;(e.save(),
      (c.w !== s.w || c.h !== s.h) &&
        (e.beginPath(),
        h(e, Xd(c, n, s)),
        e.clip(),
        h(e, Xd(s, -n, c)),
        (e.fillStyle = r),
        e.fill('evenodd')),
      e.beginPath(),
      h(e, Xd(s, n)),
      (e.fillStyle = i),
      e.fill(),
      e.restore())
  }
  inRange(e, n, r) {
    return Hd(this, e, n, r)
  }
  inXRange(e, n) {
    return Hd(this, e, null, n)
  }
  inYRange(e, n) {
    return Hd(this, null, e, n)
  }
  getCenterPoint(e) {
    const {
      x: n,
      y: r,
      base: i,
      horizontal: s,
    } = this.getProps(['x', 'y', 'base', 'horizontal'], e)
    return { x: s ? (n + i) / 2 : n, y: s ? r : (r + i) / 2 }
  }
  getRange(e) {
    return e === 'x' ? this.width / 2 : this.height / 2
  }
}
;(yt(ru, 'id', 'bar'),
  yt(ru, 'defaults', {
    borderSkipped: 'start',
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: 'auto',
    pointStyle: void 0,
  }),
  yt(ru, 'defaultRoutes', { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }))
function iR(t, e, n) {
  const r = t.segments,
    i = t.points,
    s = e.points,
    c = []
  for (const h of r) {
    let { start: f, end: p } = h
    p = Ah(f, p, i)
    const y = gf(n, i[f], i[p], h.loop)
    if (!e.segments) {
      c.push({ source: h, target: y, start: i[f], end: i[p] })
      continue
    }
    const w = k3(e, y)
    for (const x of w) {
      const E = gf(n, s[x.start], s[x.end], x.loop),
        S = A3(h, i, E)
      for (const k of S)
        c.push({
          source: k,
          target: x,
          start: { [n]: fy(y, E, 'start', Math.max) },
          end: { [n]: fy(y, E, 'end', Math.min) },
        })
    }
  }
  return c
}
function gf(t, e, n, r) {
  if (r) return
  let i = e[t],
    s = n[t]
  return (t === 'angle' && ((i = Rn(i)), (s = Rn(s))), { property: t, start: i, end: s })
}
function oR(t, e) {
  const { x: n = null, y: r = null } = t || {},
    i = e.points,
    s = []
  return (
    e.segments.forEach(({ start: c, end: h }) => {
      h = Ah(c, h, i)
      const f = i[c],
        p = i[h]
      r !== null
        ? (s.push({ x: f.x, y: r }), s.push({ x: p.x, y: r }))
        : n !== null && (s.push({ x: n, y: f.y }), s.push({ x: n, y: p.y }))
    }),
    s
  )
}
function Ah(t, e, n) {
  for (; e > t; e--) {
    const r = n[e]
    if (!isNaN(r.x) && !isNaN(r.y)) break
  }
  return e
}
function fy(t, e, n, r) {
  return t && e ? r(t[n], e[n]) : t ? t[n] : e ? e[n] : 0
}
function z3(t, e) {
  let n = [],
    r = !1
  return (
    ce(t) ? ((r = !0), (n = t)) : (n = oR(t, e)),
    n.length ? new Wr({ points: n, options: { tension: 0 }, _loop: r, _fullLoop: r }) : null
  )
}
function py(t) {
  return t && t.fill !== !1
}
function sR(t, e, n) {
  let r = t[e].fill
  const i = [e]
  let s
  if (!n) return r
  for (; r !== !1 && i.indexOf(r) === -1; ) {
    if (!Be(r)) return r
    if (((s = t[r]), !s)) return !1
    if (s.visible) return r
    ;(i.push(r), (r = s.fill))
  }
  return !1
}
function aR(t, e, n) {
  const r = hR(t)
  if (Mt(r)) return isNaN(r.value) ? !1 : r
  let i = parseFloat(r)
  return Be(i) && Math.floor(i) === i
    ? lR(r[0], e, i, n)
    : ['origin', 'start', 'end', 'stack', 'shape'].indexOf(r) >= 0 && r
}
function lR(t, e, n, r) {
  return ((t === '-' || t === '+') && (n = e + n), n === e || n < 0 || n >= r ? !1 : n)
}
function cR(t, e) {
  let n = null
  return (
    t === 'start'
      ? (n = e.bottom)
      : t === 'end'
        ? (n = e.top)
        : Mt(t)
          ? (n = e.getPixelForValue(t.value))
          : e.getBasePixel && (n = e.getBasePixel()),
    n
  )
}
function uR(t, e, n) {
  let r
  return (
    t === 'start'
      ? (r = n)
      : t === 'end'
        ? (r = e.options.reverse ? e.min : e.max)
        : Mt(t)
          ? (r = t.value)
          : (r = e.getBaseValue()),
    r
  )
}
function hR(t) {
  const e = t.options,
    n = e.fill
  let r = It(n && n.target, n)
  return (
    r === void 0 && (r = !!e.backgroundColor),
    r === !1 || r === null ? !1 : r === !0 ? 'origin' : r
  )
}
function dR(t) {
  const { scale: e, index: n, line: r } = t,
    i = [],
    s = r.segments,
    c = r.points,
    h = fR(e, n)
  h.push(z3({ x: null, y: e.bottom }, r))
  for (let f = 0; f < s.length; f++) {
    const p = s[f]
    for (let y = p.start; y <= p.end; y++) pR(i, c[y], h)
  }
  return new Wr({ points: i, options: {} })
}
function fR(t, e) {
  const n = [],
    r = t.getMatchingVisibleMetas('line')
  for (let i = 0; i < r.length; i++) {
    const s = r[i]
    if (s.index === e) break
    s.hidden || n.unshift(s.dataset)
  }
  return n
}
function pR(t, e, n) {
  const r = []
  for (let i = 0; i < n.length; i++) {
    const s = n[i],
      { first: c, last: h, point: f } = gR(s, e, 'x')
    if (!(!f || (c && h))) {
      if (c) r.unshift(f)
      else if ((t.push(f), !h)) break
    }
  }
  t.push(...r)
}
function gR(t, e, n) {
  const r = t.interpolate(e, n)
  if (!r) return {}
  const i = r[n],
    s = t.segments,
    c = t.points
  let h = !1,
    f = !1
  for (let p = 0; p < s.length; p++) {
    const y = s[p],
      w = c[y.start][n],
      x = c[y.end][n]
    if (wi(i, w, x)) {
      ;((h = i === w), (f = i === x))
      break
    }
  }
  return { first: h, last: f, point: r }
}
class H3 {
  constructor(e) {
    ;((this.x = e.x), (this.y = e.y), (this.radius = e.radius))
  }
  pathSegment(e, n, r) {
    const { x: i, y: s, radius: c } = this
    return ((n = n || { start: 0, end: Ln }), e.arc(i, s, c, n.end, n.start, !0), !r.bounds)
  }
  interpolate(e) {
    const { x: n, y: r, radius: i } = this,
      s = e.angle
    return { x: n + Math.cos(s) * i, y: r + Math.sin(s) * i, angle: s }
  }
}
function mR(t) {
  const { chart: e, fill: n, line: r } = t
  if (Be(n)) return yR(e, n)
  if (n === 'stack') return dR(t)
  if (n === 'shape') return !0
  const i = wR(t)
  return i instanceof H3 ? i : z3(i, r)
}
function yR(t, e) {
  const n = t.getDatasetMeta(e)
  return n && t.isDatasetVisible(e) ? n.dataset : null
}
function wR(t) {
  return (t.scale || {}).getPointPositionForValue ? vR(t) : bR(t)
}
function bR(t) {
  const { scale: e = {}, fill: n } = t,
    r = cR(n, e)
  if (Be(r)) {
    const i = e.isHorizontal()
    return { x: i ? r : null, y: i ? null : r }
  }
  return null
}
function vR(t) {
  const { scale: e, fill: n } = t,
    r = e.options,
    i = e.getLabels().length,
    s = r.reverse ? e.max : e.min,
    c = uR(n, e, s),
    h = []
  if (r.grid.circular) {
    const f = e.getPointPositionForValue(0, s)
    return new H3({ x: f.x, y: f.y, radius: e.getDistanceFromCenterForValue(c) })
  }
  for (let f = 0; f < i; ++f) h.push(e.getPointPositionForValue(f, c))
  return h
}
function Gd(t, e, n) {
  const r = mR(e),
    { chart: i, index: s, line: c, scale: h, axis: f } = e,
    p = c.options,
    y = p.fill,
    w = p.backgroundColor,
    { above: x = w, below: E = w } = y || {},
    S = i.getDatasetMeta(s),
    k = I3(i, S)
  r &&
    c.points.length &&
    (xh(t, n),
    xR(t, { line: c, target: r, above: x, below: E, area: n, scale: h, axis: f, clip: k }),
    Eh(t))
}
function xR(t, e) {
  const { line: n, target: r, above: i, below: s, area: c, scale: h, clip: f } = e,
    p = n._loop ? 'angle' : e.axis
  t.save()
  let y = s
  ;(s !== i &&
    (p === 'x'
      ? (gy(t, r, c.top),
        Yd(t, { line: n, target: r, color: i, scale: h, property: p, clip: f }),
        t.restore(),
        t.save(),
        gy(t, r, c.bottom))
      : p === 'y' &&
        (my(t, r, c.left),
        Yd(t, { line: n, target: r, color: s, scale: h, property: p, clip: f }),
        t.restore(),
        t.save(),
        my(t, r, c.right),
        (y = i))),
    Yd(t, { line: n, target: r, color: y, scale: h, property: p, clip: f }),
    t.restore())
}
function gy(t, e, n) {
  const { segments: r, points: i } = e
  let s = !0,
    c = !1
  t.beginPath()
  for (const h of r) {
    const { start: f, end: p } = h,
      y = i[f],
      w = i[Ah(f, p, i)]
    ;(s ? (t.moveTo(y.x, y.y), (s = !1)) : (t.lineTo(y.x, n), t.lineTo(y.x, y.y)),
      (c = !!e.pathSegment(t, h, { move: c })),
      c ? t.closePath() : t.lineTo(w.x, n))
  }
  ;(t.lineTo(e.first().x, n), t.closePath(), t.clip())
}
function my(t, e, n) {
  const { segments: r, points: i } = e
  let s = !0,
    c = !1
  t.beginPath()
  for (const h of r) {
    const { start: f, end: p } = h,
      y = i[f],
      w = i[Ah(f, p, i)]
    ;(s ? (t.moveTo(y.x, y.y), (s = !1)) : (t.lineTo(n, y.y), t.lineTo(y.x, y.y)),
      (c = !!e.pathSegment(t, h, { move: c })),
      c ? t.closePath() : t.lineTo(n, w.y))
  }
  ;(t.lineTo(n, e.first().y), t.closePath(), t.clip())
}
function Yd(t, e) {
  const { line: n, target: r, property: i, color: s, scale: c, clip: h } = e,
    f = iR(n, r, i)
  for (const { source: p, target: y, start: w, end: x } of f) {
    const { style: { backgroundColor: E = s } = {} } = p,
      S = r !== !0
    ;(t.save(), (t.fillStyle = E), ER(t, c, h, S && gf(i, w, x)), t.beginPath())
    const k = !!n.pathSegment(t, p)
    let D
    if (S) {
      k ? t.closePath() : yy(t, r, x, i)
      const _ = !!r.pathSegment(t, y, { move: k, reverse: !0 })
      ;((D = k && _), D || yy(t, r, w, i))
    }
    ;(t.closePath(), t.fill(D ? 'evenodd' : 'nonzero'), t.restore())
  }
}
function ER(t, e, n, r) {
  const i = e.chart.chartArea,
    { property: s, start: c, end: h } = r || {}
  if (s === 'x' || s === 'y') {
    let f, p, y, w
    ;(s === 'x'
      ? ((f = c), (p = i.top), (y = h), (w = i.bottom))
      : ((f = i.left), (p = c), (y = i.right), (w = h)),
      t.beginPath(),
      n &&
        ((f = Math.max(f, n.left)),
        (y = Math.min(y, n.right)),
        (p = Math.max(p, n.top)),
        (w = Math.min(w, n.bottom))),
      t.rect(f, p, y - f, w - p),
      t.clip())
  }
}
function yy(t, e, n, r) {
  const i = e.interpolate(n, r)
  i && t.lineTo(i.x, i.y)
}
var X3 = {
  id: 'filler',
  afterDatasetsUpdate(t, e, n) {
    const r = (t.data.datasets || []).length,
      i = []
    let s, c, h, f
    for (c = 0; c < r; ++c)
      ((s = t.getDatasetMeta(c)),
        (h = s.dataset),
        (f = null),
        h &&
          h.options &&
          h instanceof Wr &&
          (f = {
            visible: t.isDatasetVisible(c),
            index: c,
            fill: aR(h, c, r),
            chart: t,
            axis: s.controller.options.indexAxis,
            scale: s.vScale,
            line: h,
          }),
        (s.$filler = f),
        i.push(f))
    for (c = 0; c < r; ++c) ((f = i[c]), !(!f || f.fill === !1) && (f.fill = sR(i, c, n.propagate)))
  },
  beforeDraw(t, e, n) {
    const r = n.drawTime === 'beforeDraw',
      i = t.getSortedVisibleDatasetMetas(),
      s = t.chartArea
    for (let c = i.length - 1; c >= 0; --c) {
      const h = i[c].$filler
      h && (h.line.updateControlPoints(s, h.axis), r && h.fill && Gd(t.ctx, h, s))
    }
  },
  beforeDatasetsDraw(t, e, n) {
    if (n.drawTime !== 'beforeDatasetsDraw') return
    const r = t.getSortedVisibleDatasetMetas()
    for (let i = r.length - 1; i >= 0; --i) {
      const s = r[i].$filler
      py(s) && Gd(t.ctx, s, t.chartArea)
    }
  },
  beforeDatasetDraw(t, e, n) {
    const r = e.meta.$filler
    !py(r) || n.drawTime !== 'beforeDatasetDraw' || Gd(t.ctx, r, t.chartArea)
  },
  defaults: { propagate: !0, drawTime: 'beforeDatasetDraw' },
}
const wy = (t, e) => {
    let { boxHeight: n = e, boxWidth: r = e } = t
    return (
      t.usePointStyle && ((n = Math.min(n, e)), (r = t.pointStyleWidth || Math.min(r, e))),
      { boxWidth: r, boxHeight: n, itemHeight: Math.max(e, n) }
    )
  },
  CR = (t, e) =>
    t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index
class by extends Ho {
  constructor(e) {
    ;(super(),
      (this._added = !1),
      (this.legendHitBoxes = []),
      (this._hoveredItem = null),
      (this.doughnutMode = !1),
      (this.chart = e.chart),
      (this.options = e.options),
      (this.ctx = e.ctx),
      (this.legendItems = void 0),
      (this.columnSizes = void 0),
      (this.lineWidths = void 0),
      (this.maxHeight = void 0),
      (this.maxWidth = void 0),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this._margins = void 0),
      (this.position = void 0),
      (this.weight = void 0),
      (this.fullSize = void 0))
  }
  update(e, n, r) {
    ;((this.maxWidth = e),
      (this.maxHeight = n),
      (this._margins = r),
      this.setDimensions(),
      this.buildLabels(),
      this.fit())
  }
  setDimensions() {
    this.isHorizontal()
      ? ((this.width = this.maxWidth), (this.left = this._margins.left), (this.right = this.width))
      : ((this.height = this.maxHeight),
        (this.top = this._margins.top),
        (this.bottom = this.height))
  }
  buildLabels() {
    const e = this.options.labels || {}
    let n = Qt(e.generateLabels, [this.chart], this) || []
    ;(e.filter && (n = n.filter((r) => e.filter(r, this.chart.data))),
      e.sort && (n = n.sort((r, i) => e.sort(r, i, this.chart.data))),
      this.options.reverse && n.reverse(),
      (this.legendItems = n))
  }
  fit() {
    const { options: e, ctx: n } = this
    if (!e.display) {
      this.width = this.height = 0
      return
    }
    const r = e.labels,
      i = He(r.font),
      s = i.size,
      c = this._computeTitleHeight(),
      { boxWidth: h, itemHeight: f } = wy(r, s)
    let p, y
    ;((n.font = i.string),
      this.isHorizontal()
        ? ((p = this.maxWidth), (y = this._fitRows(c, s, h, f) + 10))
        : ((y = this.maxHeight), (p = this._fitCols(c, i, h, f) + 10)),
      (this.width = Math.min(p, e.maxWidth || this.maxWidth)),
      (this.height = Math.min(y, e.maxHeight || this.maxHeight)))
  }
  _fitRows(e, n, r, i) {
    const {
        ctx: s,
        maxWidth: c,
        options: {
          labels: { padding: h },
        },
      } = this,
      f = (this.legendHitBoxes = []),
      p = (this.lineWidths = [0]),
      y = i + h
    let w = e
    ;((s.textAlign = 'left'), (s.textBaseline = 'middle'))
    let x = -1,
      E = -y
    return (
      this.legendItems.forEach((S, k) => {
        const D = r + n / 2 + s.measureText(S.text).width
        ;((k === 0 || p[p.length - 1] + D + 2 * h > c) &&
          ((w += y), (p[p.length - (k > 0 ? 0 : 1)] = 0), (E += y), x++),
          (f[k] = { left: 0, top: E, row: x, width: D, height: i }),
          (p[p.length - 1] += D + h))
      }),
      w
    )
  }
  _fitCols(e, n, r, i) {
    const {
        ctx: s,
        maxHeight: c,
        options: {
          labels: { padding: h },
        },
      } = this,
      f = (this.legendHitBoxes = []),
      p = (this.columnSizes = []),
      y = c - e
    let w = h,
      x = 0,
      E = 0,
      S = 0,
      k = 0
    return (
      this.legendItems.forEach((D, _) => {
        const { itemWidth: N, itemHeight: M } = SR(r, n, s, D, i)
        ;(_ > 0 &&
          E + M + 2 * h > y &&
          ((w += x + h), p.push({ width: x, height: E }), (S += x + h), k++, (x = E = 0)),
          (f[_] = { left: S, top: E, col: k, width: N, height: M }),
          (x = Math.max(x, N)),
          (E += M + h))
      }),
      (w += x),
      p.push({ width: x, height: E }),
      w
    )
  }
  adjustHitBoxes() {
    if (!this.options.display) return
    const e = this._computeTitleHeight(),
      {
        legendHitBoxes: n,
        options: {
          align: r,
          labels: { padding: i },
          rtl: s,
        },
      } = this,
      c = Rs(s, this.left, this.width)
    if (this.isHorizontal()) {
      let h = 0,
        f = kn(r, this.left + i, this.right - this.lineWidths[h])
      for (const p of n)
        (h !== p.row && ((h = p.row), (f = kn(r, this.left + i, this.right - this.lineWidths[h]))),
          (p.top += this.top + e + i),
          (p.left = c.leftForLtr(c.x(f), p.width)),
          (f += p.width + i))
    } else {
      let h = 0,
        f = kn(r, this.top + e + i, this.bottom - this.columnSizes[h].height)
      for (const p of n)
        (p.col !== h &&
          ((h = p.col), (f = kn(r, this.top + e + i, this.bottom - this.columnSizes[h].height))),
          (p.top = f),
          (p.left += this.left + i),
          (p.left = c.leftForLtr(c.x(p.left), p.width)),
          (f += p.height + i))
    }
  }
  isHorizontal() {
    return this.options.position === 'top' || this.options.position === 'bottom'
  }
  draw() {
    if (this.options.display) {
      const e = this.ctx
      ;(xh(e, this), this._draw(), Eh(e))
    }
  }
  _draw() {
    const { options: e, columnSizes: n, lineWidths: r, ctx: i } = this,
      { align: s, labels: c } = e,
      h = be.color,
      f = Rs(e.rtl, this.left, this.width),
      p = He(c.font),
      { padding: y } = c,
      w = p.size,
      x = w / 2
    let E
    ;(this.drawTitle(),
      (i.textAlign = f.textAlign('left')),
      (i.textBaseline = 'middle'),
      (i.lineWidth = 0.5),
      (i.font = p.string))
    const { boxWidth: S, boxHeight: k, itemHeight: D } = wy(c, w),
      _ = function (z, V, W) {
        if (isNaN(S) || S <= 0 || isNaN(k) || k < 0) return
        i.save()
        const Z = It(W.lineWidth, 1)
        if (
          ((i.fillStyle = It(W.fillStyle, h)),
          (i.lineCap = It(W.lineCap, 'butt')),
          (i.lineDashOffset = It(W.lineDashOffset, 0)),
          (i.lineJoin = It(W.lineJoin, 'miter')),
          (i.lineWidth = Z),
          (i.strokeStyle = It(W.strokeStyle, h)),
          i.setLineDash(It(W.lineDash, [])),
          c.usePointStyle)
        ) {
          const J = {
              radius: (k * Math.SQRT2) / 2,
              pointStyle: W.pointStyle,
              rotation: W.rotation,
              borderWidth: Z,
            },
            st = f.xPlus(z, S / 2),
            rt = V + x
          p3(i, J, st, rt, c.pointStyleWidth && S)
        } else {
          const J = V + Math.max((w - k) / 2, 0),
            st = f.leftForLtr(z, S),
            rt = po(W.borderRadius)
          ;(i.beginPath(),
            Object.values(rt).some((vt) => vt !== 0)
              ? Rl(i, { x: st, y: J, w: S, h: k, radius: rt })
              : i.rect(st, J, S, k),
            i.fill(),
            Z !== 0 && i.stroke())
        }
        i.restore()
      },
      N = function (z, V, W) {
        Ws(i, W.text, z, V + D / 2, p, {
          strikethrough: W.hidden,
          textAlign: f.textAlign(W.textAlign),
        })
      },
      M = this.isHorizontal(),
      O = this._computeTitleHeight()
    ;(M
      ? (E = { x: kn(s, this.left + y, this.right - r[0]), y: this.top + y + O, line: 0 })
      : (E = { x: this.left + y, y: kn(s, this.top + O + y, this.bottom - n[0].height), line: 0 }),
      E3(this.ctx, e.textDirection))
    const F = D + y
    ;(this.legendItems.forEach((z, V) => {
      ;((i.strokeStyle = z.fontColor), (i.fillStyle = z.fontColor))
      const W = i.measureText(z.text).width,
        Z = f.textAlign(z.textAlign || (z.textAlign = c.textAlign)),
        J = S + x + W
      let st = E.x,
        rt = E.y
      ;(f.setWidth(this.width),
        M
          ? V > 0 &&
            st + J + y > this.right &&
            ((rt = E.y += F), E.line++, (st = E.x = kn(s, this.left + y, this.right - r[E.line])))
          : V > 0 &&
            rt + F > this.bottom &&
            ((st = E.x = st + n[E.line].width + y),
            E.line++,
            (rt = E.y = kn(s, this.top + O + y, this.bottom - n[E.line].height))))
      const vt = f.x(st)
      if (
        (_(vt, rt, z),
        (st = s9(Z, st + S + x, M ? st + J : this.right, e.rtl)),
        N(f.x(st), rt, z),
        M)
      )
        E.x += J + y
      else if (typeof z.text != 'string') {
        const _t = p.lineHeight
        E.y += G3(z, _t) + y
      } else E.y += F
    }),
      C3(this.ctx, e.textDirection))
  }
  drawTitle() {
    const e = this.options,
      n = e.title,
      r = He(n.font),
      i = sn(n.padding)
    if (!n.display) return
    const s = Rs(e.rtl, this.left, this.width),
      c = this.ctx,
      h = n.position,
      f = r.size / 2,
      p = i.top + f
    let y,
      w = this.left,
      x = this.width
    if (this.isHorizontal())
      ((x = Math.max(...this.lineWidths)), (y = this.top + p), (w = kn(e.align, w, this.right - x)))
    else {
      const S = this.columnSizes.reduce((k, D) => Math.max(k, D.height), 0)
      y = p + kn(e.align, this.top, this.bottom - S - e.labels.padding - this._computeTitleHeight())
    }
    const E = kn(h, w, w + x)
    ;((c.textAlign = s.textAlign(d3(h))),
      (c.textBaseline = 'middle'),
      (c.strokeStyle = n.color),
      (c.fillStyle = n.color),
      (c.font = r.string),
      Ws(c, n.text, E, y, r))
  }
  _computeTitleHeight() {
    const e = this.options.title,
      n = He(e.font),
      r = sn(e.padding)
    return e.display ? n.lineHeight + r.height : 0
  }
  _getLegendItemAt(e, n) {
    let r, i, s
    if (wi(e, this.left, this.right) && wi(n, this.top, this.bottom)) {
      for (s = this.legendHitBoxes, r = 0; r < s.length; ++r)
        if (((i = s[r]), wi(e, i.left, i.left + i.width) && wi(n, i.top, i.top + i.height)))
          return this.legendItems[r]
    }
    return null
  }
  handleEvent(e) {
    const n = this.options
    if (!IR(e.type, n)) return
    const r = this._getLegendItemAt(e.x, e.y)
    if (e.type === 'mousemove' || e.type === 'mouseout') {
      const i = this._hoveredItem,
        s = CR(i, r)
      ;(i && !s && Qt(n.onLeave, [e, i, this], this),
        (this._hoveredItem = r),
        r && !s && Qt(n.onHover, [e, r, this], this))
    } else r && Qt(n.onClick, [e, r, this], this)
  }
}
function SR(t, e, n, r, i) {
  const s = AR(r, t, e, n),
    c = kR(i, r, e.lineHeight)
  return { itemWidth: s, itemHeight: c }
}
function AR(t, e, n, r) {
  let i = t.text
  return (
    i && typeof i != 'string' && (i = i.reduce((s, c) => (s.length > c.length ? s : c))),
    e + n.size / 2 + r.measureText(i).width
  )
}
function kR(t, e, n) {
  let r = t
  return (typeof e.text != 'string' && (r = G3(e, n)), r)
}
function G3(t, e) {
  const n = t.text ? t.text.length : 0
  return e * n
}
function IR(t, e) {
  return !!(
    ((t === 'mousemove' || t === 'mouseout') && (e.onHover || e.onLeave)) ||
    (e.onClick && (t === 'click' || t === 'mouseup'))
  )
}
var _R = {
  id: 'legend',
  _element: by,
  start(t, e, n) {
    const r = (t.legend = new by({ ctx: t.ctx, options: n, chart: t }))
    ;(vi.configure(t, r, n), vi.addBox(t, r))
  },
  stop(t) {
    ;(vi.removeBox(t, t.legend), delete t.legend)
  },
  beforeUpdate(t, e, n) {
    const r = t.legend
    ;(vi.configure(t, r, n), (r.options = n))
  },
  afterUpdate(t) {
    const e = t.legend
    ;(e.buildLabels(), e.adjustHitBoxes())
  },
  afterEvent(t, e) {
    e.replay || t.legend.handleEvent(e.event)
  },
  defaults: {
    display: !0,
    position: 'top',
    align: 'center',
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(t, e, n) {
      const r = e.datasetIndex,
        i = n.chart
      i.isDatasetVisible(r) ? (i.hide(r), (e.hidden = !0)) : (i.show(r), (e.hidden = !1))
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (t) => t.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(t) {
        const e = t.data.datasets,
          {
            labels: {
              usePointStyle: n,
              pointStyle: r,
              textAlign: i,
              color: s,
              useBorderRadius: c,
              borderRadius: h,
            },
          } = t.legend.options
        return t._getSortedDatasetMetas().map((f) => {
          const p = f.controller.getStyle(n ? 0 : void 0),
            y = sn(p.borderWidth)
          return {
            text: e[f.index].label,
            fillStyle: p.backgroundColor,
            fontColor: s,
            hidden: !f.visible,
            lineCap: p.borderCapStyle,
            lineDash: p.borderDash,
            lineDashOffset: p.borderDashOffset,
            lineJoin: p.borderJoinStyle,
            lineWidth: (y.width + y.height) / 4,
            strokeStyle: p.borderColor,
            pointStyle: r || p.pointStyle,
            rotation: p.rotation,
            textAlign: i || p.textAlign,
            borderRadius: c && (h || p.borderRadius),
            datasetIndex: f.index,
          }
        }, this)
      },
    },
    title: { color: (t) => t.chart.options.color, display: !1, position: 'center', text: '' },
  },
  descriptors: {
    _scriptable: (t) => !t.startsWith('on'),
    labels: { _scriptable: (t) => !['generateLabels', 'filter', 'sort'].includes(t) },
  },
}
const tl = {
  average(t) {
    if (!t.length) return !1
    let e,
      n,
      r = new Set(),
      i = 0,
      s = 0
    for (e = 0, n = t.length; e < n; ++e) {
      const c = t[e].element
      if (c && c.hasValue()) {
        const h = c.tooltipPosition()
        ;(r.add(h.x), (i += h.y), ++s)
      }
    }
    return s === 0 || r.size === 0 ? !1 : { x: [...r].reduce((c, h) => c + h) / r.size, y: i / s }
  },
  nearest(t, e) {
    if (!t.length) return !1
    let n = e.x,
      r = e.y,
      i = Number.POSITIVE_INFINITY,
      s,
      c,
      h
    for (s = 0, c = t.length; s < c; ++s) {
      const f = t[s].element
      if (f && f.hasValue()) {
        const p = f.getCenterPoint(),
          y = cf(e, p)
        y < i && ((i = y), (h = f))
      }
    }
    if (h) {
      const f = h.tooltipPosition()
      ;((n = f.x), (r = f.y))
    }
    return { x: n, y: r }
  },
}
function xr(t, e) {
  return (e && (ce(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t)
}
function Dr(t) {
  return (typeof t == 'string' || t instanceof String) &&
    t.indexOf(`
`) > -1
    ? t.split(`
`)
    : t
}
function RR(t, e) {
  const { element: n, datasetIndex: r, index: i } = e,
    s = t.getDatasetMeta(r).controller,
    { label: c, value: h } = s.getLabelAndValue(i)
  return {
    chart: t,
    label: c,
    parsed: s.getParsed(i),
    raw: t.data.datasets[r].data[i],
    formattedValue: h,
    dataset: s.getDataset(),
    dataIndex: i,
    datasetIndex: r,
    element: n,
  }
}
function vy(t, e) {
  const n = t.chart.ctx,
    { body: r, footer: i, title: s } = t,
    { boxWidth: c, boxHeight: h } = e,
    f = He(e.bodyFont),
    p = He(e.titleFont),
    y = He(e.footerFont),
    w = s.length,
    x = i.length,
    E = r.length,
    S = sn(e.padding)
  let k = S.height,
    D = 0,
    _ = r.reduce((O, F) => O + F.before.length + F.lines.length + F.after.length, 0)
  if (
    ((_ += t.beforeBody.length + t.afterBody.length),
    w && (k += w * p.lineHeight + (w - 1) * e.titleSpacing + e.titleMarginBottom),
    _)
  ) {
    const O = e.displayColors ? Math.max(h, f.lineHeight) : f.lineHeight
    k += E * O + (_ - E) * f.lineHeight + (_ - 1) * e.bodySpacing
  }
  x && (k += e.footerMarginTop + x * y.lineHeight + (x - 1) * e.footerSpacing)
  let N = 0
  const M = function (O) {
    D = Math.max(D, n.measureText(O).width + N)
  }
  return (
    n.save(),
    (n.font = p.string),
    zt(t.title, M),
    (n.font = f.string),
    zt(t.beforeBody.concat(t.afterBody), M),
    (N = e.displayColors ? c + 2 + e.boxPadding : 0),
    zt(r, (O) => {
      ;(zt(O.before, M), zt(O.lines, M), zt(O.after, M))
    }),
    (N = 0),
    (n.font = y.string),
    zt(t.footer, M),
    n.restore(),
    (D += S.width),
    { width: D, height: k }
  )
}
function TR(t, e) {
  const { y: n, height: r } = e
  return n < r / 2 ? 'top' : n > t.height - r / 2 ? 'bottom' : 'center'
}
function NR(t, e, n, r) {
  const { x: i, width: s } = r,
    c = n.caretSize + n.caretPadding
  if ((t === 'left' && i + s + c > e.width) || (t === 'right' && i - s - c < 0)) return !0
}
function MR(t, e, n, r) {
  const { x: i, width: s } = n,
    {
      width: c,
      chartArea: { left: h, right: f },
    } = t
  let p = 'center'
  return (
    r === 'center'
      ? (p = i <= (h + f) / 2 ? 'left' : 'right')
      : i <= s / 2
        ? (p = 'left')
        : i >= c - s / 2 && (p = 'right'),
    NR(p, t, e, n) && (p = 'center'),
    p
  )
}
function xy(t, e, n) {
  const r = n.yAlign || e.yAlign || TR(t, n)
  return { xAlign: n.xAlign || e.xAlign || MR(t, e, n, r), yAlign: r }
}
function DR(t, e) {
  let { x: n, width: r } = t
  return (e === 'right' ? (n -= r) : e === 'center' && (n -= r / 2), n)
}
function PR(t, e, n) {
  let { y: r, height: i } = t
  return (e === 'top' ? (r += n) : e === 'bottom' ? (r -= i + n) : (r -= i / 2), r)
}
function Ey(t, e, n, r) {
  const { caretSize: i, caretPadding: s, cornerRadius: c } = t,
    { xAlign: h, yAlign: f } = n,
    p = i + s,
    { topLeft: y, topRight: w, bottomLeft: x, bottomRight: E } = po(c)
  let S = DR(e, h)
  const k = PR(e, f, p)
  return (
    f === 'center'
      ? h === 'left'
        ? (S += p)
        : h === 'right' && (S -= p)
      : h === 'left'
        ? (S -= Math.max(y, x) + i)
        : h === 'right' && (S += Math.max(w, E) + i),
    { x: Mn(S, 0, r.width - e.width), y: Mn(k, 0, r.height - e.height) }
  )
}
function Pc(t, e, n) {
  const r = sn(n.padding)
  return e === 'center' ? t.x + t.width / 2 : e === 'right' ? t.x + t.width - r.right : t.x + r.left
}
function Cy(t) {
  return xr([], Dr(t))
}
function LR(t, e, n) {
  return Ui(t, { tooltip: e, tooltipItems: n, type: 'tooltip' })
}
function Sy(t, e) {
  const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks
  return n ? t.override(n) : t
}
const Y3 = {
  beforeTitle: Nr,
  title(t) {
    if (t.length > 0) {
      const e = t[0],
        n = e.chart.data.labels,
        r = n ? n.length : 0
      if (this && this.options && this.options.mode === 'dataset') return e.dataset.label || ''
      if (e.label) return e.label
      if (r > 0 && e.dataIndex < r) return n[e.dataIndex]
    }
    return ''
  },
  afterTitle: Nr,
  beforeBody: Nr,
  beforeLabel: Nr,
  label(t) {
    if (this && this.options && this.options.mode === 'dataset')
      return t.label + ': ' + t.formattedValue || t.formattedValue
    let e = t.dataset.label || ''
    e && (e += ': ')
    const n = t.formattedValue
    return (Ot(n) || (e += n), e)
  },
  labelColor(t) {
    const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex)
    return {
      borderColor: e.borderColor,
      backgroundColor: e.backgroundColor,
      borderWidth: e.borderWidth,
      borderDash: e.borderDash,
      borderDashOffset: e.borderDashOffset,
      borderRadius: 0,
    }
  },
  labelTextColor() {
    return this.options.bodyColor
  },
  labelPointStyle(t) {
    const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex)
    return { pointStyle: e.pointStyle, rotation: e.rotation }
  },
  afterLabel: Nr,
  afterBody: Nr,
  beforeFooter: Nr,
  footer: Nr,
  afterFooter: Nr,
}
function mn(t, e, n, r) {
  const i = t[e].call(n, r)
  return typeof i > 'u' ? Y3[e].call(n, r) : i
}
class mf extends Ho {
  constructor(e) {
    ;(super(),
      (this.opacity = 0),
      (this._active = []),
      (this._eventPosition = void 0),
      (this._size = void 0),
      (this._cachedAnimations = void 0),
      (this._tooltipItems = []),
      (this.$animations = void 0),
      (this.$context = void 0),
      (this.chart = e.chart),
      (this.options = e.options),
      (this.dataPoints = void 0),
      (this.title = void 0),
      (this.beforeBody = void 0),
      (this.body = void 0),
      (this.afterBody = void 0),
      (this.footer = void 0),
      (this.xAlign = void 0),
      (this.yAlign = void 0),
      (this.x = void 0),
      (this.y = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this.caretX = void 0),
      (this.caretY = void 0),
      (this.labelColors = void 0),
      (this.labelPointStyles = void 0),
      (this.labelTextColors = void 0))
  }
  initialize(e) {
    ;((this.options = e), (this._cachedAnimations = void 0), (this.$context = void 0))
  }
  _resolveAnimations() {
    const e = this._cachedAnimations
    if (e) return e
    const n = this.chart,
      r = this.options.setContext(this.getContext()),
      i = r.enabled && n.options.animation && r.animations,
      s = new _3(this.chart, i)
    return (i._cacheable && (this._cachedAnimations = Object.freeze(s)), s)
  }
  getContext() {
    return this.$context || (this.$context = LR(this.chart.getContext(), this, this._tooltipItems))
  }
  getTitle(e, n) {
    const { callbacks: r } = n,
      i = mn(r, 'beforeTitle', this, e),
      s = mn(r, 'title', this, e),
      c = mn(r, 'afterTitle', this, e)
    let h = []
    return ((h = xr(h, Dr(i))), (h = xr(h, Dr(s))), (h = xr(h, Dr(c))), h)
  }
  getBeforeBody(e, n) {
    return Cy(mn(n.callbacks, 'beforeBody', this, e))
  }
  getBody(e, n) {
    const { callbacks: r } = n,
      i = []
    return (
      zt(e, (s) => {
        const c = { before: [], lines: [], after: [] },
          h = Sy(r, s)
        ;(xr(c.before, Dr(mn(h, 'beforeLabel', this, s))),
          xr(c.lines, mn(h, 'label', this, s)),
          xr(c.after, Dr(mn(h, 'afterLabel', this, s))),
          i.push(c))
      }),
      i
    )
  }
  getAfterBody(e, n) {
    return Cy(mn(n.callbacks, 'afterBody', this, e))
  }
  getFooter(e, n) {
    const { callbacks: r } = n,
      i = mn(r, 'beforeFooter', this, e),
      s = mn(r, 'footer', this, e),
      c = mn(r, 'afterFooter', this, e)
    let h = []
    return ((h = xr(h, Dr(i))), (h = xr(h, Dr(s))), (h = xr(h, Dr(c))), h)
  }
  _createItems(e) {
    const n = this._active,
      r = this.chart.data,
      i = [],
      s = [],
      c = []
    let h = [],
      f,
      p
    for (f = 0, p = n.length; f < p; ++f) h.push(RR(this.chart, n[f]))
    return (
      e.filter && (h = h.filter((y, w, x) => e.filter(y, w, x, r))),
      e.itemSort && (h = h.sort((y, w) => e.itemSort(y, w, r))),
      zt(h, (y) => {
        const w = Sy(e.callbacks, y)
        ;(i.push(mn(w, 'labelColor', this, y)),
          s.push(mn(w, 'labelPointStyle', this, y)),
          c.push(mn(w, 'labelTextColor', this, y)))
      }),
      (this.labelColors = i),
      (this.labelPointStyles = s),
      (this.labelTextColors = c),
      (this.dataPoints = h),
      h
    )
  }
  update(e, n) {
    const r = this.options.setContext(this.getContext()),
      i = this._active
    let s,
      c = []
    if (!i.length) this.opacity !== 0 && (s = { opacity: 0 })
    else {
      const h = tl[r.position].call(this, i, this._eventPosition)
      ;((c = this._createItems(r)),
        (this.title = this.getTitle(c, r)),
        (this.beforeBody = this.getBeforeBody(c, r)),
        (this.body = this.getBody(c, r)),
        (this.afterBody = this.getAfterBody(c, r)),
        (this.footer = this.getFooter(c, r)))
      const f = (this._size = vy(this, r)),
        p = Object.assign({}, h, f),
        y = xy(this.chart, r, p),
        w = Ey(r, p, y, this.chart)
      ;((this.xAlign = y.xAlign),
        (this.yAlign = y.yAlign),
        (s = {
          opacity: 1,
          x: w.x,
          y: w.y,
          width: f.width,
          height: f.height,
          caretX: h.x,
          caretY: h.y,
        }))
    }
    ;((this._tooltipItems = c),
      (this.$context = void 0),
      s && this._resolveAnimations().update(this, s),
      e && r.external && r.external.call(this, { chart: this.chart, tooltip: this, replay: n }))
  }
  drawCaret(e, n, r, i) {
    const s = this.getCaretPosition(e, r, i)
    ;(n.lineTo(s.x1, s.y1), n.lineTo(s.x2, s.y2), n.lineTo(s.x3, s.y3))
  }
  getCaretPosition(e, n, r) {
    const { xAlign: i, yAlign: s } = this,
      { caretSize: c, cornerRadius: h } = r,
      { topLeft: f, topRight: p, bottomLeft: y, bottomRight: w } = po(h),
      { x, y: E } = e,
      { width: S, height: k } = n
    let D, _, N, M, O, F
    return (
      s === 'center'
        ? ((O = E + k / 2),
          i === 'left'
            ? ((D = x), (_ = D - c), (M = O + c), (F = O - c))
            : ((D = x + S), (_ = D + c), (M = O - c), (F = O + c)),
          (N = D))
        : (i === 'left'
            ? (_ = x + Math.max(f, y) + c)
            : i === 'right'
              ? (_ = x + S - Math.max(p, w) - c)
              : (_ = this.caretX),
          s === 'top'
            ? ((M = E), (O = M - c), (D = _ - c), (N = _ + c))
            : ((M = E + k), (O = M + c), (D = _ + c), (N = _ - c)),
          (F = M)),
      { x1: D, x2: _, x3: N, y1: M, y2: O, y3: F }
    )
  }
  drawTitle(e, n, r) {
    const i = this.title,
      s = i.length
    let c, h, f
    if (s) {
      const p = Rs(r.rtl, this.x, this.width)
      for (
        e.x = Pc(this, r.titleAlign, r),
          n.textAlign = p.textAlign(r.titleAlign),
          n.textBaseline = 'middle',
          c = He(r.titleFont),
          h = r.titleSpacing,
          n.fillStyle = r.titleColor,
          n.font = c.string,
          f = 0;
        f < s;
        ++f
      )
        (n.fillText(i[f], p.x(e.x), e.y + c.lineHeight / 2),
          (e.y += c.lineHeight + h),
          f + 1 === s && (e.y += r.titleMarginBottom - h))
    }
  }
  _drawColorBox(e, n, r, i, s) {
    const c = this.labelColors[r],
      h = this.labelPointStyles[r],
      { boxHeight: f, boxWidth: p } = s,
      y = He(s.bodyFont),
      w = Pc(this, 'left', s),
      x = i.x(w),
      E = f < y.lineHeight ? (y.lineHeight - f) / 2 : 0,
      S = n.y + E
    if (s.usePointStyle) {
      const k = {
          radius: Math.min(p, f) / 2,
          pointStyle: h.pointStyle,
          rotation: h.rotation,
          borderWidth: 1,
        },
        D = i.leftForLtr(x, p) + p / 2,
        _ = S + f / 2
      ;((e.strokeStyle = s.multiKeyBackground),
        (e.fillStyle = s.multiKeyBackground),
        hf(e, k, D, _),
        (e.strokeStyle = c.borderColor),
        (e.fillStyle = c.backgroundColor),
        hf(e, k, D, _))
    } else {
      ;((e.lineWidth = Mt(c.borderWidth)
        ? Math.max(...Object.values(c.borderWidth))
        : c.borderWidth || 1),
        (e.strokeStyle = c.borderColor),
        e.setLineDash(c.borderDash || []),
        (e.lineDashOffset = c.borderDashOffset || 0))
      const k = i.leftForLtr(x, p),
        D = i.leftForLtr(i.xPlus(x, 1), p - 2),
        _ = po(c.borderRadius)
      Object.values(_).some((N) => N !== 0)
        ? (e.beginPath(),
          (e.fillStyle = s.multiKeyBackground),
          Rl(e, { x: k, y: S, w: p, h: f, radius: _ }),
          e.fill(),
          e.stroke(),
          (e.fillStyle = c.backgroundColor),
          e.beginPath(),
          Rl(e, { x: D, y: S + 1, w: p - 2, h: f - 2, radius: _ }),
          e.fill())
        : ((e.fillStyle = s.multiKeyBackground),
          e.fillRect(k, S, p, f),
          e.strokeRect(k, S, p, f),
          (e.fillStyle = c.backgroundColor),
          e.fillRect(D, S + 1, p - 2, f - 2))
    }
    e.fillStyle = this.labelTextColors[r]
  }
  drawBody(e, n, r) {
    const { body: i } = this,
      {
        bodySpacing: s,
        bodyAlign: c,
        displayColors: h,
        boxHeight: f,
        boxWidth: p,
        boxPadding: y,
      } = r,
      w = He(r.bodyFont)
    let x = w.lineHeight,
      E = 0
    const S = Rs(r.rtl, this.x, this.width),
      k = function (W) {
        ;(n.fillText(W, S.x(e.x + E), e.y + x / 2), (e.y += x + s))
      },
      D = S.textAlign(c)
    let _, N, M, O, F, z, V
    for (
      n.textAlign = c,
        n.textBaseline = 'middle',
        n.font = w.string,
        e.x = Pc(this, D, r),
        n.fillStyle = r.bodyColor,
        zt(this.beforeBody, k),
        E = h && D !== 'right' ? (c === 'center' ? p / 2 + y : p + 2 + y) : 0,
        O = 0,
        z = i.length;
      O < z;
      ++O
    ) {
      for (
        _ = i[O],
          N = this.labelTextColors[O],
          n.fillStyle = N,
          zt(_.before, k),
          M = _.lines,
          h && M.length && (this._drawColorBox(n, e, O, S, r), (x = Math.max(w.lineHeight, f))),
          F = 0,
          V = M.length;
        F < V;
        ++F
      )
        (k(M[F]), (x = w.lineHeight))
      zt(_.after, k)
    }
    ;((E = 0), (x = w.lineHeight), zt(this.afterBody, k), (e.y -= s))
  }
  drawFooter(e, n, r) {
    const i = this.footer,
      s = i.length
    let c, h
    if (s) {
      const f = Rs(r.rtl, this.x, this.width)
      for (
        e.x = Pc(this, r.footerAlign, r),
          e.y += r.footerMarginTop,
          n.textAlign = f.textAlign(r.footerAlign),
          n.textBaseline = 'middle',
          c = He(r.footerFont),
          n.fillStyle = r.footerColor,
          n.font = c.string,
          h = 0;
        h < s;
        ++h
      )
        (n.fillText(i[h], f.x(e.x), e.y + c.lineHeight / 2),
          (e.y += c.lineHeight + r.footerSpacing))
    }
  }
  drawBackground(e, n, r, i) {
    const { xAlign: s, yAlign: c } = this,
      { x: h, y: f } = e,
      { width: p, height: y } = r,
      { topLeft: w, topRight: x, bottomLeft: E, bottomRight: S } = po(i.cornerRadius)
    ;((n.fillStyle = i.backgroundColor),
      (n.strokeStyle = i.borderColor),
      (n.lineWidth = i.borderWidth),
      n.beginPath(),
      n.moveTo(h + w, f),
      c === 'top' && this.drawCaret(e, n, r, i),
      n.lineTo(h + p - x, f),
      n.quadraticCurveTo(h + p, f, h + p, f + x),
      c === 'center' && s === 'right' && this.drawCaret(e, n, r, i),
      n.lineTo(h + p, f + y - S),
      n.quadraticCurveTo(h + p, f + y, h + p - S, f + y),
      c === 'bottom' && this.drawCaret(e, n, r, i),
      n.lineTo(h + E, f + y),
      n.quadraticCurveTo(h, f + y, h, f + y - E),
      c === 'center' && s === 'left' && this.drawCaret(e, n, r, i),
      n.lineTo(h, f + w),
      n.quadraticCurveTo(h, f, h + w, f),
      n.closePath(),
      n.fill(),
      i.borderWidth > 0 && n.stroke())
  }
  _updateAnimationTarget(e) {
    const n = this.chart,
      r = this.$animations,
      i = r && r.x,
      s = r && r.y
    if (i || s) {
      const c = tl[e.position].call(this, this._active, this._eventPosition)
      if (!c) return
      const h = (this._size = vy(this, e)),
        f = Object.assign({}, c, this._size),
        p = xy(n, e, f),
        y = Ey(e, f, p, n)
      ;(i._to !== y.x || s._to !== y.y) &&
        ((this.xAlign = p.xAlign),
        (this.yAlign = p.yAlign),
        (this.width = h.width),
        (this.height = h.height),
        (this.caretX = c.x),
        (this.caretY = c.y),
        this._resolveAnimations().update(this, y))
    }
  }
  _willRender() {
    return !!this.opacity
  }
  draw(e) {
    const n = this.options.setContext(this.getContext())
    let r = this.opacity
    if (!r) return
    this._updateAnimationTarget(n)
    const i = { width: this.width, height: this.height },
      s = { x: this.x, y: this.y }
    r = Math.abs(r) < 0.001 ? 0 : r
    const c = sn(n.padding),
      h =
        this.title.length ||
        this.beforeBody.length ||
        this.body.length ||
        this.afterBody.length ||
        this.footer.length
    n.enabled &&
      h &&
      (e.save(),
      (e.globalAlpha = r),
      this.drawBackground(s, e, i, n),
      E3(e, n.textDirection),
      (s.y += c.top),
      this.drawTitle(s, e, n),
      this.drawBody(s, e, n),
      this.drawFooter(s, e, n),
      C3(e, n.textDirection),
      e.restore())
  }
  getActiveElements() {
    return this._active || []
  }
  setActiveElements(e, n) {
    const r = this._active,
      i = e.map(({ datasetIndex: h, index: f }) => {
        const p = this.chart.getDatasetMeta(h)
        if (!p) throw new Error('Cannot find a dataset at index ' + h)
        return { datasetIndex: h, element: p.data[f], index: f }
      }),
      s = !Bu(r, i),
      c = this._positionChanged(i, n)
    ;(s || c) &&
      ((this._active = i),
      (this._eventPosition = n),
      (this._ignoreReplayEvents = !0),
      this.update(!0))
  }
  handleEvent(e, n, r = !0) {
    if (n && this._ignoreReplayEvents) return !1
    this._ignoreReplayEvents = !1
    const i = this.options,
      s = this._active || [],
      c = this._getActiveElements(e, s, n, r),
      h = this._positionChanged(c, e),
      f = n || !Bu(c, s) || h
    return (
      f &&
        ((this._active = c),
        (i.enabled || i.external) &&
          ((this._eventPosition = { x: e.x, y: e.y }), this.update(!0, n))),
      f
    )
  }
  _getActiveElements(e, n, r, i) {
    const s = this.options
    if (e.type === 'mouseout') return []
    if (!i)
      return n.filter(
        (h) =>
          this.chart.data.datasets[h.datasetIndex] &&
          this.chart.getDatasetMeta(h.datasetIndex).controller.getParsed(h.index) !== void 0
      )
    const c = this.chart.getElementsAtEventForMode(e, s.mode, s, r)
    return (s.reverse && c.reverse(), c)
  }
  _positionChanged(e, n) {
    const { caretX: r, caretY: i, options: s } = this,
      c = tl[s.position].call(this, e, n)
    return c !== !1 && (r !== c.x || i !== c.y)
  }
}
yt(mf, 'positioners', tl)
var Z3 = {
  id: 'tooltip',
  _element: mf,
  positioners: tl,
  afterInit(t, e, n) {
    n && (t.tooltip = new mf({ chart: t, options: n }))
  },
  beforeUpdate(t, e, n) {
    t.tooltip && t.tooltip.initialize(n)
  },
  reset(t, e, n) {
    t.tooltip && t.tooltip.initialize(n)
  },
  afterDraw(t) {
    const e = t.tooltip
    if (e && e._willRender()) {
      const n = { tooltip: e }
      if (t.notifyPlugins('beforeTooltipDraw', { ...n, cancelable: !0 }) === !1) return
      ;(e.draw(t.ctx), t.notifyPlugins('afterTooltipDraw', n))
    }
  },
  afterEvent(t, e) {
    if (t.tooltip) {
      const n = e.replay
      t.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = !0)
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: 'average',
    backgroundColor: 'rgba(0,0,0,0.8)',
    titleColor: '#fff',
    titleFont: { weight: 'bold' },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: 'left',
    bodyColor: '#fff',
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: 'left',
    footerColor: '#fff',
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: { weight: 'bold' },
    footerAlign: 'left',
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (t, e) => e.bodyFont.size,
    boxWidth: (t, e) => e.bodyFont.size,
    multiKeyBackground: '#fff',
    displayColors: !0,
    boxPadding: 0,
    borderColor: 'rgba(0,0,0,0)',
    borderWidth: 0,
    animation: { duration: 400, easing: 'easeOutQuart' },
    animations: {
      numbers: { type: 'number', properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'] },
      opacity: { easing: 'linear', duration: 200 },
    },
    callbacks: Y3,
  },
  defaultRoutes: { bodyFont: 'font', footerFont: 'font', titleFont: 'font' },
  descriptors: {
    _scriptable: (t) => t !== 'filter' && t !== 'itemSort' && t !== 'external',
    _indexable: !1,
    callbacks: { _scriptable: !1, _indexable: !1 },
    animation: { _fallback: !1 },
    animations: { _fallback: 'animation' },
  },
  additionalOptionScopes: ['interaction'],
}
const OR = (t, e, n, r) => (
  typeof e == 'string'
    ? ((n = t.push(e) - 1), r.unshift({ index: n, label: e }))
    : isNaN(e) && (n = null),
  n
)
function BR(t, e, n, r) {
  const i = t.indexOf(e)
  if (i === -1) return OR(t, e, n, r)
  const s = t.lastIndexOf(e)
  return i !== s ? n : i
}
const FR = (t, e) => (t === null ? null : Mn(Math.round(t), 0, e))
function q3(t) {
  const e = this.getLabels()
  return t >= 0 && t < e.length ? e[t] : t
}
class yf extends $s {
  constructor(e) {
    ;(super(e), (this._startValue = void 0), (this._valueRange = 0), (this._addedLabels = []))
  }
  init(e) {
    const n = this._addedLabels
    if (n.length) {
      const r = this.getLabels()
      for (const { index: i, label: s } of n) r[i] === s && r.splice(i, 1)
      this._addedLabels = []
    }
    super.init(e)
  }
  parse(e, n) {
    if (Ot(e)) return null
    const r = this.getLabels()
    return (
      (n = isFinite(n) && r[n] === e ? n : BR(r, e, It(n, e), this._addedLabels)),
      FR(n, r.length - 1)
    )
  }
  determineDataLimits() {
    const { minDefined: e, maxDefined: n } = this.getUserBounds()
    let { min: r, max: i } = this.getMinMax(!0)
    ;(this.options.bounds === 'ticks' && (e || (r = 0), n || (i = this.getLabels().length - 1)),
      (this.min = r),
      (this.max = i))
  }
  buildTicks() {
    const e = this.min,
      n = this.max,
      r = this.options.offset,
      i = []
    let s = this.getLabels()
    ;((s = e === 0 && n === s.length - 1 ? s : s.slice(e, n + 1)),
      (this._valueRange = Math.max(s.length - (r ? 0 : 1), 1)),
      (this._startValue = this.min - (r ? 0.5 : 0)))
    for (let c = e; c <= n; c++) i.push({ value: c })
    return i
  }
  getLabelForValue(e) {
    return q3.call(this, e)
  }
  configure() {
    ;(super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels))
  }
  getPixelForValue(e) {
    return (
      typeof e != 'number' && (e = this.parse(e)),
      e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange)
    )
  }
  getPixelForTick(e) {
    const n = this.ticks
    return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value)
  }
  getValueForPixel(e) {
    return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange)
  }
  getBasePixel() {
    return this.bottom
  }
}
;(yt(yf, 'id', 'category'), yt(yf, 'defaults', { ticks: { callback: q3 } }))
function jR(t, e) {
  const n = [],
    {
      bounds: r,
      step: i,
      min: s,
      max: c,
      precision: h,
      count: f,
      maxTicks: p,
      maxDigits: y,
      includeBounds: w,
    } = t,
    x = i || 1,
    E = p - 1,
    { min: S, max: k } = e,
    D = !Ot(s),
    _ = !Ot(c),
    N = !Ot(f),
    M = (k - S) / (y + 1)
  let O = Cm((k - S) / E / x) * x,
    F,
    z,
    V,
    W
  if (O < 1e-14 && !D && !_) return [{ value: S }, { value: k }]
  ;((W = Math.ceil(k / O) - Math.floor(S / O)),
    W > E && (O = Cm((W * O) / E / x) * x),
    Ot(h) || ((F = Math.pow(10, h)), (O = Math.ceil(O * F) / F)),
    r === 'ticks' ? ((z = Math.floor(S / O) * O), (V = Math.ceil(k / O) * O)) : ((z = S), (V = k)),
    D && _ && i && Qk((c - s) / i, O / 1e3)
      ? ((W = Math.round(Math.min((c - s) / O, p))), (O = (c - s) / W), (z = s), (V = c))
      : N
        ? ((z = D ? s : z), (V = _ ? c : V), (W = f - 1), (O = (V - z) / W))
        : ((W = (V - z) / O),
          Ka(W, Math.round(W), O / 1e3) ? (W = Math.round(W)) : (W = Math.ceil(W))))
  const Z = Math.max(Sm(O), Sm(z))
  ;((F = Math.pow(10, Ot(h) ? Z : h)), (z = Math.round(z * F) / F), (V = Math.round(V * F) / F))
  let J = 0
  for (
    D &&
    (w && z !== s
      ? (n.push({ value: s }),
        z < s && J++,
        Ka(Math.round((z + J * O) * F) / F, s, Ay(s, M, t)) && J++)
      : z < s && J++);
    J < W;
    ++J
  ) {
    const st = Math.round((z + J * O) * F) / F
    if (_ && st > c) break
    n.push({ value: st })
  }
  return (
    _ && w && V !== c
      ? n.length && Ka(n[n.length - 1].value, c, Ay(c, M, t))
        ? (n[n.length - 1].value = c)
        : n.push({ value: c })
      : (!_ || V === c) && n.push({ value: V }),
    n
  )
}
function Ay(t, e, { horizontal: n, minRotation: r }) {
  const i = yi(r),
    s = (n ? Math.sin(i) : Math.cos(i)) || 0.001,
    c = 0.75 * e * ('' + t).length
  return Math.min(e / s, c)
}
class wf extends $s {
  constructor(e) {
    ;(super(e),
      (this.start = void 0),
      (this.end = void 0),
      (this._startValue = void 0),
      (this._endValue = void 0),
      (this._valueRange = 0))
  }
  parse(e, n) {
    return Ot(e) || ((typeof e == 'number' || e instanceof Number) && !isFinite(+e)) ? null : +e
  }
  handleTickRangeOptions() {
    const { beginAtZero: e } = this.options,
      { minDefined: n, maxDefined: r } = this.getUserBounds()
    let { min: i, max: s } = this
    const c = (f) => (i = n ? i : f),
      h = (f) => (s = r ? s : f)
    if (e) {
      const f = Rr(i),
        p = Rr(s)
      f < 0 && p < 0 ? h(0) : f > 0 && p > 0 && c(0)
    }
    if (i === s) {
      let f = s === 0 ? 1 : Math.abs(s * 0.05)
      ;(h(s + f), e || c(i - f))
    }
    ;((this.min = i), (this.max = s))
  }
  getTickLimit() {
    const e = this.options.ticks
    let { maxTicksLimit: n, stepSize: r } = e,
      i
    return (
      r
        ? ((i = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1),
          i > 1e3 &&
            (console.warn(
              `scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${i} ticks. Limiting to 1000.`
            ),
            (i = 1e3)))
        : ((i = this.computeTickLimit()), (n = n || 11)),
      n && (i = Math.min(n, i)),
      i
    )
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY
  }
  buildTicks() {
    const e = this.options,
      n = e.ticks
    let r = this.getTickLimit()
    r = Math.max(2, r)
    const i = {
        maxTicks: r,
        bounds: e.bounds,
        min: e.min,
        max: e.max,
        precision: n.precision,
        step: n.stepSize,
        count: n.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: n.minRotation || 0,
        includeBounds: n.includeBounds !== !1,
      },
      s = this._range || this,
      c = jR(i, s)
    return (
      e.bounds === 'ticks' && $k(c, this, 'value'),
      e.reverse
        ? (c.reverse(), (this.start = this.max), (this.end = this.min))
        : ((this.start = this.min), (this.end = this.max)),
      c
    )
  }
  configure() {
    const e = this.ticks
    let n = this.min,
      r = this.max
    if ((super.configure(), this.options.offset && e.length)) {
      const i = (r - n) / Math.max(e.length - 1, 1) / 2
      ;((n -= i), (r += i))
    }
    ;((this._startValue = n), (this._endValue = r), (this._valueRange = r - n))
  }
  getLabelForValue(e) {
    return f3(e, this.chart.options.locale, this.options.ticks.format)
  }
}
class bf extends wf {
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(!0)
    ;((this.min = Be(e) ? e : 0), (this.max = Be(n) ? n : 1), this.handleTickRangeOptions())
  }
  computeTickLimit() {
    const e = this.isHorizontal(),
      n = e ? this.width : this.height,
      r = yi(this.options.ticks.minRotation),
      i = (e ? Math.sin(r) : Math.cos(r)) || 0.001,
      s = this._resolveTickFontOptions(0)
    return Math.ceil(n / Math.min(40, s.lineHeight / i))
  }
  getPixelForValue(e) {
    return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange)
  }
  getValueForPixel(e) {
    return this._startValue + this.getDecimalForPixel(e) * this._valueRange
  }
}
;(yt(bf, 'id', 'linear'), yt(bf, 'defaults', { ticks: { callback: cp.formatters.numeric } }))
function vf(t) {
  const e = t.ticks
  if (e.display && t.display) {
    const n = sn(e.backdropPadding)
    return It(e.font && e.font.size, be.font.size) + n.height
  }
  return 0
}
function VR(t, e, n) {
  return ((n = ce(n) ? n : [n]), { w: b9(t, e.string, n), h: n.length * e.lineHeight })
}
function ky(t, e, n, r, i) {
  return t === r || t === i
    ? { start: e - n / 2, end: e + n / 2 }
    : t < r || t > i
      ? { start: e - n, end: e }
      : { start: e, end: e + n }
}
function WR(t) {
  const e = {
      l: t.left + t._padding.left,
      r: t.right - t._padding.right,
      t: t.top + t._padding.top,
      b: t.bottom - t._padding.bottom,
    },
    n = Object.assign({}, e),
    r = [],
    i = [],
    s = t._pointLabels.length,
    c = t.options.pointLabels,
    h = c.centerPointLabels ? Oe / s : 0
  for (let f = 0; f < s; f++) {
    const p = c.setContext(t.getPointLabelContext(f))
    i[f] = p.padding
    const y = t.getPointPosition(f, t.drawingArea + i[f], h),
      w = He(p.font),
      x = VR(t.ctx, w, t._pointLabels[f])
    r[f] = x
    const E = Rn(t.getIndexAngle(f) + h),
      S = Math.round(sp(E)),
      k = ky(S, y.x, x.w, 0, 180),
      D = ky(S, y.y, x.h, 90, 270)
    UR(n, e, E, k, D)
  }
  ;(t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b),
    (t._pointLabelItems = XR(t, r, i)))
}
function UR(t, e, n, r, i) {
  const s = Math.abs(Math.sin(n)),
    c = Math.abs(Math.cos(n))
  let h = 0,
    f = 0
  ;(r.start < e.l
    ? ((h = (e.l - r.start) / s), (t.l = Math.min(t.l, e.l - h)))
    : r.end > e.r && ((h = (r.end - e.r) / s), (t.r = Math.max(t.r, e.r + h))),
    i.start < e.t
      ? ((f = (e.t - i.start) / c), (t.t = Math.min(t.t, e.t - f)))
      : i.end > e.b && ((f = (i.end - e.b) / c), (t.b = Math.max(t.b, e.b + f))))
}
function zR(t, e, n) {
  const r = t.drawingArea,
    { extra: i, additionalAngle: s, padding: c, size: h } = n,
    f = t.getPointPosition(e, r + i + c, s),
    p = Math.round(sp(Rn(f.angle + Nn))),
    y = ZR(f.y, h.h, p),
    w = GR(p),
    x = YR(f.x, h.w, w)
  return { visible: !0, x: f.x, y, textAlign: w, left: x, top: y, right: x + h.w, bottom: y + h.h }
}
function HR(t, e) {
  if (!e) return !0
  const { left: n, top: r, right: i, bottom: s } = t
  return !(
    Vr({ x: n, y: r }, e) ||
    Vr({ x: n, y: s }, e) ||
    Vr({ x: i, y: r }, e) ||
    Vr({ x: i, y: s }, e)
  )
}
function XR(t, e, n) {
  const r = [],
    i = t._pointLabels.length,
    s = t.options,
    { centerPointLabels: c, display: h } = s.pointLabels,
    f = { extra: vf(s) / 2, additionalAngle: c ? Oe / i : 0 }
  let p
  for (let y = 0; y < i; y++) {
    ;((f.padding = n[y]), (f.size = e[y]))
    const w = zR(t, y, f)
    ;(r.push(w), h === 'auto' && ((w.visible = HR(w, p)), w.visible && (p = w)))
  }
  return r
}
function GR(t) {
  return t === 0 || t === 180 ? 'center' : t < 180 ? 'left' : 'right'
}
function YR(t, e, n) {
  return (n === 'right' ? (t -= e) : n === 'center' && (t -= e / 2), t)
}
function ZR(t, e, n) {
  return (n === 90 || n === 270 ? (t -= e / 2) : (n > 270 || n < 90) && (t -= e), t)
}
function qR(t, e, n) {
  const { left: r, top: i, right: s, bottom: c } = n,
    { backdropColor: h } = e
  if (!Ot(h)) {
    const f = po(e.borderRadius),
      p = sn(e.backdropPadding)
    t.fillStyle = h
    const y = r - p.left,
      w = i - p.top,
      x = s - r + p.width,
      E = c - i + p.height
    Object.values(f).some((S) => S !== 0)
      ? (t.beginPath(), Rl(t, { x: y, y: w, w: x, h: E, radius: f }), t.fill())
      : t.fillRect(y, w, x, E)
  }
}
function KR(t, e) {
  const {
    ctx: n,
    options: { pointLabels: r },
  } = t
  for (let i = e - 1; i >= 0; i--) {
    const s = t._pointLabelItems[i]
    if (!s.visible) continue
    const c = r.setContext(t.getPointLabelContext(i))
    qR(n, c, s)
    const h = He(c.font),
      { x: f, y: p, textAlign: y } = s
    Ws(n, t._pointLabels[i], f, p + h.lineHeight / 2, h, {
      color: c.color,
      textAlign: y,
      textBaseline: 'middle',
    })
  }
}
function K3(t, e, n, r) {
  const { ctx: i } = t
  if (n) i.arc(t.xCenter, t.yCenter, e, 0, Ln)
  else {
    let s = t.getPointPosition(0, e)
    i.moveTo(s.x, s.y)
    for (let c = 1; c < r; c++) ((s = t.getPointPosition(c, e)), i.lineTo(s.x, s.y))
  }
}
function QR(t, e, n, r, i) {
  const s = t.ctx,
    c = e.circular,
    { color: h, lineWidth: f } = e
  ;(!c && !r) ||
    !h ||
    !f ||
    n < 0 ||
    (s.save(),
    (s.strokeStyle = h),
    (s.lineWidth = f),
    s.setLineDash(i.dash || []),
    (s.lineDashOffset = i.dashOffset),
    s.beginPath(),
    K3(t, n, c, r),
    s.closePath(),
    s.stroke(),
    s.restore())
}
function $R(t, e, n) {
  return Ui(t, { label: n, index: e, type: 'pointLabel' })
}
class xs extends wf {
  constructor(e) {
    ;(super(e),
      (this.xCenter = void 0),
      (this.yCenter = void 0),
      (this.drawingArea = void 0),
      (this._pointLabels = []),
      (this._pointLabelItems = []))
  }
  setDimensions() {
    const e = (this._padding = sn(vf(this.options) / 2)),
      n = (this.width = this.maxWidth - e.width),
      r = (this.height = this.maxHeight - e.height)
    ;((this.xCenter = Math.floor(this.left + n / 2 + e.left)),
      (this.yCenter = Math.floor(this.top + r / 2 + e.top)),
      (this.drawingArea = Math.floor(Math.min(n, r) / 2)))
  }
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(!1)
    ;((this.min = Be(e) && !isNaN(e) ? e : 0),
      (this.max = Be(n) && !isNaN(n) ? n : 0),
      this.handleTickRangeOptions())
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / vf(this.options))
  }
  generateTickLabels(e) {
    ;(wf.prototype.generateTickLabels.call(this, e),
      (this._pointLabels = this.getLabels()
        .map((n, r) => {
          const i = Qt(this.options.pointLabels.callback, [n, r], this)
          return i || i === 0 ? i : ''
        })
        .filter((n, r) => this.chart.getDataVisibility(r))))
  }
  fit() {
    const e = this.options
    e.display && e.pointLabels.display ? WR(this) : this.setCenterPoint(0, 0, 0, 0)
  }
  setCenterPoint(e, n, r, i) {
    ;((this.xCenter += Math.floor((e - n) / 2)),
      (this.yCenter += Math.floor((r - i) / 2)),
      (this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, r, i))))
  }
  getIndexAngle(e) {
    const n = Ln / (this._pointLabels.length || 1),
      r = this.options.startAngle || 0
    return Rn(e * n + yi(r))
  }
  getDistanceFromCenterForValue(e) {
    if (Ot(e)) return NaN
    const n = this.drawingArea / (this.max - this.min)
    return this.options.reverse ? (this.max - e) * n : (e - this.min) * n
  }
  getValueForDistanceFromCenter(e) {
    if (Ot(e)) return NaN
    const n = e / (this.drawingArea / (this.max - this.min))
    return this.options.reverse ? this.max - n : this.min + n
  }
  getPointLabelContext(e) {
    const n = this._pointLabels || []
    if (e >= 0 && e < n.length) {
      const r = n[e]
      return $R(this.getContext(), e, r)
    }
  }
  getPointPosition(e, n, r = 0) {
    const i = this.getIndexAngle(e) - Nn + r
    return { x: Math.cos(i) * n + this.xCenter, y: Math.sin(i) * n + this.yCenter, angle: i }
  }
  getPointPositionForValue(e, n) {
    return this.getPointPosition(e, this.getDistanceFromCenterForValue(n))
  }
  getBasePosition(e) {
    return this.getPointPositionForValue(e || 0, this.getBaseValue())
  }
  getPointLabelPosition(e) {
    const { left: n, top: r, right: i, bottom: s } = this._pointLabelItems[e]
    return { left: n, top: r, right: i, bottom: s }
  }
  drawBackground() {
    const {
      backgroundColor: e,
      grid: { circular: n },
    } = this.options
    if (e) {
      const r = this.ctx
      ;(r.save(),
        r.beginPath(),
        K3(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length),
        r.closePath(),
        (r.fillStyle = e),
        r.fill(),
        r.restore())
    }
  }
  drawGrid() {
    const e = this.ctx,
      n = this.options,
      { angleLines: r, grid: i, border: s } = n,
      c = this._pointLabels.length
    let h, f, p
    if (
      (n.pointLabels.display && KR(this, c),
      i.display &&
        this.ticks.forEach((y, w) => {
          if (w !== 0 || (w === 0 && this.min < 0)) {
            f = this.getDistanceFromCenterForValue(y.value)
            const x = this.getContext(w),
              E = i.setContext(x),
              S = s.setContext(x)
            QR(this, E, f, c, S)
          }
        }),
      r.display)
    ) {
      for (e.save(), h = c - 1; h >= 0; h--) {
        const y = r.setContext(this.getPointLabelContext(h)),
          { color: w, lineWidth: x } = y
        !x ||
          !w ||
          ((e.lineWidth = x),
          (e.strokeStyle = w),
          e.setLineDash(y.borderDash),
          (e.lineDashOffset = y.borderDashOffset),
          (f = this.getDistanceFromCenterForValue(n.reverse ? this.min : this.max)),
          (p = this.getPointPosition(h, f)),
          e.beginPath(),
          e.moveTo(this.xCenter, this.yCenter),
          e.lineTo(p.x, p.y),
          e.stroke())
      }
      e.restore()
    }
  }
  drawBorder() {}
  drawLabels() {
    const e = this.ctx,
      n = this.options,
      r = n.ticks
    if (!r.display) return
    const i = this.getIndexAngle(0)
    let s, c
    ;(e.save(),
      e.translate(this.xCenter, this.yCenter),
      e.rotate(i),
      (e.textAlign = 'center'),
      (e.textBaseline = 'middle'),
      this.ticks.forEach((h, f) => {
        if (f === 0 && this.min >= 0 && !n.reverse) return
        const p = r.setContext(this.getContext(f)),
          y = He(p.font)
        if (((s = this.getDistanceFromCenterForValue(this.ticks[f].value)), p.showLabelBackdrop)) {
          ;((e.font = y.string),
            (c = e.measureText(h.label).width),
            (e.fillStyle = p.backdropColor))
          const w = sn(p.backdropPadding)
          e.fillRect(-c / 2 - w.left, -s - y.size / 2 - w.top, c + w.width, y.size + w.height)
        }
        Ws(e, h.label, 0, -s, y, {
          color: p.color,
          strokeColor: p.textStrokeColor,
          strokeWidth: p.textStrokeWidth,
        })
      }),
      e.restore())
  }
  drawTitle() {}
}
;(yt(xs, 'id', 'radialLinear'),
  yt(xs, 'defaults', {
    display: !0,
    animate: !0,
    position: 'chartArea',
    angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 },
    grid: { circular: !1 },
    startAngle: 0,
    ticks: { showLabelBackdrop: !0, callback: cp.formatters.numeric },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: !0,
      font: { size: 10 },
      callback(t) {
        return t
      },
      padding: 5,
      centerPointLabels: !1,
    },
  }),
  yt(xs, 'defaultRoutes', {
    'angleLines.color': 'borderColor',
    'pointLabels.color': 'color',
    'ticks.color': 'color',
  }),
  yt(xs, 'descriptors', { angleLines: { _fallback: 'grid' } }))
const kh = {
    millisecond: { common: !0, size: 1, steps: 1e3 },
    second: { common: !0, size: 1e3, steps: 60 },
    minute: { common: !0, size: 6e4, steps: 60 },
    hour: { common: !0, size: 36e5, steps: 24 },
    day: { common: !0, size: 864e5, steps: 30 },
    week: { common: !1, size: 6048e5, steps: 4 },
    month: { common: !0, size: 2628e6, steps: 12 },
    quarter: { common: !1, size: 7884e6, steps: 4 },
    year: { common: !0, size: 3154e7 },
  },
  wn = Object.keys(kh)
function Iy(t, e) {
  return t - e
}
function _y(t, e) {
  if (Ot(e)) return null
  const n = t._adapter,
    { parser: r, round: i, isoWeekday: s } = t._parseOpts
  let c = e
  return (
    typeof r == 'function' && (c = r(c)),
    Be(c) || (c = typeof r == 'string' ? n.parse(c, r) : n.parse(c)),
    c === null
      ? null
      : (i &&
          (c = i === 'week' && (_l(s) || s === !0) ? n.startOf(c, 'isoWeek', s) : n.startOf(c, i)),
        +c)
  )
}
function Ry(t, e, n, r) {
  const i = wn.length
  for (let s = wn.indexOf(t); s < i - 1; ++s) {
    const c = kh[wn[s]],
      h = c.steps ? c.steps : Number.MAX_SAFE_INTEGER
    if (c.common && Math.ceil((n - e) / (h * c.size)) <= r) return wn[s]
  }
  return wn[i - 1]
}
function JR(t, e, n, r, i) {
  for (let s = wn.length - 1; s >= wn.indexOf(n); s--) {
    const c = wn[s]
    if (kh[c].common && t._adapter.diff(i, r, c) >= e - 1) return c
  }
  return wn[n ? wn.indexOf(n) : 0]
}
function tT(t) {
  for (let e = wn.indexOf(t) + 1, n = wn.length; e < n; ++e) if (kh[wn[e]].common) return wn[e]
}
function Ty(t, e, n) {
  if (!n) t[e] = !0
  else if (n.length) {
    const { lo: r, hi: i } = ap(n, e),
      s = n[r] >= e ? n[r] : n[i]
    t[s] = !0
  }
}
function eT(t, e, n, r) {
  const i = t._adapter,
    s = +i.startOf(e[0].value, r),
    c = e[e.length - 1].value
  let h, f
  for (h = s; h <= c; h = +i.add(h, 1, r)) ((f = n[h]), f >= 0 && (e[f].major = !0))
  return e
}
function Ny(t, e, n) {
  const r = [],
    i = {},
    s = e.length
  let c, h
  for (c = 0; c < s; ++c) ((h = e[c]), (i[h] = c), r.push({ value: h, major: !1 }))
  return s === 0 || !n ? r : eT(t, r, i, n)
}
class zu extends $s {
  constructor(e) {
    ;(super(e),
      (this._cache = { data: [], labels: [], all: [] }),
      (this._unit = 'day'),
      (this._majorUnit = void 0),
      (this._offsets = {}),
      (this._normalized = !1),
      (this._parseOpts = void 0))
  }
  init(e, n = {}) {
    const r = e.time || (e.time = {}),
      i = (this._adapter = new LI._date(e.adapters.date))
    ;(i.init(n),
      qa(r.displayFormats, i.formats()),
      (this._parseOpts = { parser: r.parser, round: r.round, isoWeekday: r.isoWeekday }),
      super.init(e),
      (this._normalized = n.normalized))
  }
  parse(e, n) {
    return e === void 0 ? null : _y(this, e)
  }
  beforeLayout() {
    ;(super.beforeLayout(), (this._cache = { data: [], labels: [], all: [] }))
  }
  determineDataLimits() {
    const e = this.options,
      n = this._adapter,
      r = e.time.unit || 'day'
    let { min: i, max: s, minDefined: c, maxDefined: h } = this.getUserBounds()
    function f(p) {
      ;(!c && !isNaN(p.min) && (i = Math.min(i, p.min)),
        !h && !isNaN(p.max) && (s = Math.max(s, p.max)))
    }
    ;((!c || !h) &&
      (f(this._getLabelBounds()),
      (e.bounds !== 'ticks' || e.ticks.source !== 'labels') && f(this.getMinMax(!1))),
      (i = Be(i) && !isNaN(i) ? i : +n.startOf(Date.now(), r)),
      (s = Be(s) && !isNaN(s) ? s : +n.endOf(Date.now(), r) + 1),
      (this.min = Math.min(i, s - 1)),
      (this.max = Math.max(i + 1, s)))
  }
  _getLabelBounds() {
    const e = this.getLabelTimestamps()
    let n = Number.POSITIVE_INFINITY,
      r = Number.NEGATIVE_INFINITY
    return (e.length && ((n = e[0]), (r = e[e.length - 1])), { min: n, max: r })
  }
  buildTicks() {
    const e = this.options,
      n = e.time,
      r = e.ticks,
      i = r.source === 'labels' ? this.getLabelTimestamps() : this._generate()
    e.bounds === 'ticks' &&
      i.length &&
      ((this.min = this._userMin || i[0]), (this.max = this._userMax || i[i.length - 1]))
    const s = this.min,
      c = this.max,
      h = r9(i, s, c)
    return (
      (this._unit =
        n.unit ||
        (r.autoSkip
          ? Ry(n.minUnit, this.min, this.max, this._getLabelCapacity(s))
          : JR(this, h.length, n.minUnit, this.min, this.max))),
      (this._majorUnit = !r.major.enabled || this._unit === 'year' ? void 0 : tT(this._unit)),
      this.initOffsets(i),
      e.reverse && h.reverse(),
      Ny(this, h, this._majorUnit)
    )
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value))
  }
  initOffsets(e = []) {
    let n = 0,
      r = 0,
      i,
      s
    this.options.offset &&
      e.length &&
      ((i = this.getDecimalForValue(e[0])),
      e.length === 1 ? (n = 1 - i) : (n = (this.getDecimalForValue(e[1]) - i) / 2),
      (s = this.getDecimalForValue(e[e.length - 1])),
      e.length === 1 ? (r = s) : (r = (s - this.getDecimalForValue(e[e.length - 2])) / 2))
    const c = e.length < 3 ? 0.5 : 0.25
    ;((n = Mn(n, 0, c)),
      (r = Mn(r, 0, c)),
      (this._offsets = { start: n, end: r, factor: 1 / (n + 1 + r) }))
  }
  _generate() {
    const e = this._adapter,
      n = this.min,
      r = this.max,
      i = this.options,
      s = i.time,
      c = s.unit || Ry(s.minUnit, n, r, this._getLabelCapacity(n)),
      h = It(i.ticks.stepSize, 1),
      f = c === 'week' ? s.isoWeekday : !1,
      p = _l(f) || f === !0,
      y = {}
    let w = n,
      x,
      E
    if (
      (p && (w = +e.startOf(w, 'isoWeek', f)),
      (w = +e.startOf(w, p ? 'day' : c)),
      e.diff(r, n, c) > 1e5 * h)
    )
      throw new Error(n + ' and ' + r + ' are too far apart with stepSize of ' + h + ' ' + c)
    const S = i.ticks.source === 'data' && this.getDataTimestamps()
    for (x = w, E = 0; x < r; x = +e.add(x, h, c), E++) Ty(y, x, S)
    return (
      (x === r || i.bounds === 'ticks' || E === 1) && Ty(y, x, S),
      Object.keys(y)
        .sort(Iy)
        .map((k) => +k)
    )
  }
  getLabelForValue(e) {
    const n = this._adapter,
      r = this.options.time
    return r.tooltipFormat ? n.format(e, r.tooltipFormat) : n.format(e, r.displayFormats.datetime)
  }
  format(e, n) {
    const r = this.options.time.displayFormats,
      i = this._unit,
      s = n || r[i]
    return this._adapter.format(e, s)
  }
  _tickFormatFunction(e, n, r, i) {
    const s = this.options,
      c = s.ticks.callback
    if (c) return Qt(c, [e, n, r], this)
    const h = s.time.displayFormats,
      f = this._unit,
      p = this._majorUnit,
      y = f && h[f],
      w = p && h[p],
      x = r[n],
      E = p && w && x && x.major
    return this._adapter.format(e, i || (E ? w : y))
  }
  generateTickLabels(e) {
    let n, r, i
    for (n = 0, r = e.length; n < r; ++n)
      ((i = e[n]), (i.label = this._tickFormatFunction(i.value, n, e)))
  }
  getDecimalForValue(e) {
    return e === null ? NaN : (e - this.min) / (this.max - this.min)
  }
  getPixelForValue(e) {
    const n = this._offsets,
      r = this.getDecimalForValue(e)
    return this.getPixelForDecimal((n.start + r) * n.factor)
  }
  getValueForPixel(e) {
    const n = this._offsets,
      r = this.getDecimalForPixel(e) / n.factor - n.end
    return this.min + r * (this.max - this.min)
  }
  _getLabelSize(e) {
    const n = this.options.ticks,
      r = this.ctx.measureText(e).width,
      i = yi(this.isHorizontal() ? n.maxRotation : n.minRotation),
      s = Math.cos(i),
      c = Math.sin(i),
      h = this._resolveTickFontOptions(0).size
    return { w: r * s + h * c, h: r * c + h * s }
  }
  _getLabelCapacity(e) {
    const n = this.options.time,
      r = n.displayFormats,
      i = r[n.unit] || r.millisecond,
      s = this._tickFormatFunction(e, 0, Ny(this, [e], this._majorUnit), i),
      c = this._getLabelSize(s),
      h = Math.floor(this.isHorizontal() ? this.width / c.w : this.height / c.h) - 1
    return h > 0 ? h : 1
  }
  getDataTimestamps() {
    let e = this._cache.data || [],
      n,
      r
    if (e.length) return e
    const i = this.getMatchingVisibleMetas()
    if (this._normalized && i.length)
      return (this._cache.data = i[0].controller.getAllParsedValues(this))
    for (n = 0, r = i.length; n < r; ++n) e = e.concat(i[n].controller.getAllParsedValues(this))
    return (this._cache.data = this.normalize(e))
  }
  getLabelTimestamps() {
    const e = this._cache.labels || []
    let n, r
    if (e.length) return e
    const i = this.getLabels()
    for (n = 0, r = i.length; n < r; ++n) e.push(_y(this, i[n]))
    return (this._cache.labels = this._normalized ? e : this.normalize(e))
  }
  normalize(e) {
    return c3(e.sort(Iy))
  }
}
;(yt(zu, 'id', 'time'),
  yt(zu, 'defaults', {
    bounds: 'data',
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: 'millisecond',
      displayFormats: {},
    },
    ticks: { source: 'auto', callback: !1, major: { enabled: !1 } },
  }))
function Lc(t, e, n) {
  let r = 0,
    i = t.length - 1,
    s,
    c,
    h,
    f
  n
    ? (e >= t[r].pos && e <= t[i].pos && ({ lo: r, hi: i } = co(t, 'pos', e)),
      ({ pos: s, time: h } = t[r]),
      ({ pos: c, time: f } = t[i]))
    : (e >= t[r].time && e <= t[i].time && ({ lo: r, hi: i } = co(t, 'time', e)),
      ({ time: s, pos: h } = t[r]),
      ({ time: c, pos: f } = t[i]))
  const p = c - s
  return p ? h + ((f - h) * (e - s)) / p : h
}
class My extends zu {
  constructor(e) {
    ;(super(e), (this._table = []), (this._minPos = void 0), (this._tableRange = void 0))
  }
  initOffsets() {
    const e = this._getTimestampsForTable(),
      n = (this._table = this.buildLookupTable(e))
    ;((this._minPos = Lc(n, this.min)),
      (this._tableRange = Lc(n, this.max) - this._minPos),
      super.initOffsets(e))
  }
  buildLookupTable(e) {
    const { min: n, max: r } = this,
      i = [],
      s = []
    let c, h, f, p, y
    for (c = 0, h = e.length; c < h; ++c) ((p = e[c]), p >= n && p <= r && i.push(p))
    if (i.length < 2)
      return [
        { time: n, pos: 0 },
        { time: r, pos: 1 },
      ]
    for (c = 0, h = i.length; c < h; ++c)
      ((y = i[c + 1]),
        (f = i[c - 1]),
        (p = i[c]),
        Math.round((y + f) / 2) !== p && s.push({ time: p, pos: c / (h - 1) }))
    return s
  }
  _generate() {
    const e = this.min,
      n = this.max
    let r = super.getDataTimestamps()
    return (
      (!r.includes(e) || !r.length) && r.splice(0, 0, e),
      (!r.includes(n) || r.length === 1) && r.push(n),
      r.sort((i, s) => i - s)
    )
  }
  _getTimestampsForTable() {
    let e = this._cache.all || []
    if (e.length) return e
    const n = this.getDataTimestamps(),
      r = this.getLabelTimestamps()
    return (
      n.length && r.length ? (e = this.normalize(n.concat(r))) : (e = n.length ? n : r),
      (e = this._cache.all = e),
      e
    )
  }
  getDecimalForValue(e) {
    return (Lc(this._table, e) - this._minPos) / this._tableRange
  }
  getValueForPixel(e) {
    const n = this._offsets,
      r = this.getDecimalForPixel(e) / n.factor - n.end
    return Lc(this._table, r * this._tableRange + this._minPos, !0)
  }
}
;(yt(My, 'id', 'timeseries'), yt(My, 'defaults', zu.defaults))
const Q3 = 'label'
function Dy(t, e) {
  typeof t == 'function' ? t(e) : t && (t.current = e)
}
function nT(t, e) {
  const n = t.options
  n && e && Object.assign(n, e)
}
function $3(t, e) {
  t.labels = e
}
function J3(t, e, n = Q3) {
  const r = []
  t.datasets = e.map((i) => {
    const s = t.datasets.find((c) => c[n] === i[n])
    return !s || !i.data || r.includes(s) ? { ...i } : (r.push(s), Object.assign(s, i), s)
  })
}
function rT(t, e = Q3) {
  const n = { labels: [], datasets: [] }
  return ($3(n, t.labels), J3(n, t.datasets, e), n)
}
function iT(t, e) {
  const {
      height: n = 150,
      width: r = 300,
      redraw: i = !1,
      datasetIdKey: s,
      type: c,
      data: h,
      options: f,
      plugins: p = [],
      fallbackContent: y,
      updateMode: w,
      ...x
    } = t,
    E = X.useRef(null),
    S = X.useRef(null),
    k = () => {
      E.current &&
        ((S.current = new Ul(E.current, {
          type: c,
          data: rT(h, s),
          options: f && { ...f },
          plugins: p,
        })),
        Dy(e, S.current))
    },
    D = () => {
      ;(Dy(e, null), S.current && (S.current.destroy(), (S.current = null)))
    }
  return (
    X.useEffect(() => {
      !i && S.current && f && nT(S.current, f)
    }, [i, f]),
    X.useEffect(() => {
      !i && S.current && $3(S.current.config.data, h.labels)
    }, [i, h.labels]),
    X.useEffect(() => {
      !i && S.current && h.datasets && J3(S.current.config.data, h.datasets, s)
    }, [i, h.datasets]),
    X.useEffect(() => {
      S.current && (i ? (D(), setTimeout(k)) : S.current.update(w))
    }, [i, f, h.labels, h.datasets, w]),
    X.useEffect(() => {
      S.current && (D(), setTimeout(k))
    }, [c]),
    X.useEffect(() => (k(), () => D()), []),
    R.jsx('canvas', { ref: E, role: 'img', height: n, width: r, ...x, children: y })
  )
}
const oT = X.forwardRef(iT)
function mp(t, e) {
  return (Ul.register(e), X.forwardRef((n, r) => R.jsx(oT, { ...n, ref: r, type: t })))
}
const sT = mp('line', Jc),
  aT = mp('bar', $c),
  tb = mp('radar', tu)
var lT = Object.defineProperty,
  Hu = Object.getOwnPropertySymbols,
  eb = Object.prototype.hasOwnProperty,
  nb = Object.prototype.propertyIsEnumerable,
  Py = (t, e, n) =>
    e in t ? lT(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Ly = (t, e) => {
    for (var n in e || (e = {})) eb.call(e, n) && Py(t, n, e[n])
    if (Hu) for (var n of Hu(e)) nb.call(e, n) && Py(t, n, e[n])
    return t
  },
  cT = (t, e) => {
    var n = {}
    for (var r in t) eb.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && Hu) for (var r of Hu(t)) e.indexOf(r) < 0 && nb.call(t, r) && (n[r] = t[r])
    return n
  }
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */ var Ao
;((t) => {
  const e = class {
    constructor(f, p, y, w) {
      if (
        ((this.version = f),
        (this.errorCorrectionLevel = p),
        (this.modules = []),
        (this.isFunction = []),
        f < e.MIN_VERSION || f > e.MAX_VERSION)
      )
        throw new RangeError('Version value out of range')
      if (w < -1 || w > 7) throw new RangeError('Mask value out of range')
      this.size = f * 4 + 17
      let x = []
      for (let S = 0; S < this.size; S++) x.push(!1)
      for (let S = 0; S < this.size; S++)
        (this.modules.push(x.slice()), this.isFunction.push(x.slice()))
      this.drawFunctionPatterns()
      const E = this.addEccAndInterleave(y)
      if ((this.drawCodewords(E), w == -1)) {
        let S = 1e9
        for (let k = 0; k < 8; k++) {
          ;(this.applyMask(k), this.drawFormatBits(k))
          const D = this.getPenaltyScore()
          ;(D < S && ((w = k), (S = D)), this.applyMask(k))
        }
      }
      ;(s(0 <= w && w <= 7),
        (this.mask = w),
        this.applyMask(w),
        this.drawFormatBits(w),
        (this.isFunction = []))
    }
    static encodeText(f, p) {
      const y = t.QrSegment.makeSegments(f)
      return e.encodeSegments(y, p)
    }
    static encodeBinary(f, p) {
      const y = t.QrSegment.makeBytes(f)
      return e.encodeSegments([y], p)
    }
    static encodeSegments(f, p, y = 1, w = 40, x = -1, E = !0) {
      if (!(e.MIN_VERSION <= y && y <= w && w <= e.MAX_VERSION) || x < -1 || x > 7)
        throw new RangeError('Invalid value')
      let S, k
      for (S = y; ; S++) {
        const M = e.getNumDataCodewords(S, p) * 8,
          O = h.getTotalBits(f, S)
        if (O <= M) {
          k = O
          break
        }
        if (S >= w) throw new RangeError('Data too long')
      }
      for (const M of [e.Ecc.MEDIUM, e.Ecc.QUARTILE, e.Ecc.HIGH])
        E && k <= e.getNumDataCodewords(S, M) * 8 && (p = M)
      let D = []
      for (const M of f) {
        ;(r(M.mode.modeBits, 4, D), r(M.numChars, M.mode.numCharCountBits(S), D))
        for (const O of M.getData()) D.push(O)
      }
      s(D.length == k)
      const _ = e.getNumDataCodewords(S, p) * 8
      ;(s(D.length <= _),
        r(0, Math.min(4, _ - D.length), D),
        r(0, (8 - (D.length % 8)) % 8, D),
        s(D.length % 8 == 0))
      for (let M = 236; D.length < _; M ^= 253) r(M, 8, D)
      let N = []
      for (; N.length * 8 < D.length; ) N.push(0)
      return (D.forEach((M, O) => (N[O >>> 3] |= M << (7 - (O & 7)))), new e(S, p, N, x))
    }
    getModule(f, p) {
      return 0 <= f && f < this.size && 0 <= p && p < this.size && this.modules[p][f]
    }
    getModules() {
      return this.modules
    }
    drawFunctionPatterns() {
      for (let y = 0; y < this.size; y++)
        (this.setFunctionModule(6, y, y % 2 == 0), this.setFunctionModule(y, 6, y % 2 == 0))
      ;(this.drawFinderPattern(3, 3),
        this.drawFinderPattern(this.size - 4, 3),
        this.drawFinderPattern(3, this.size - 4))
      const f = this.getAlignmentPatternPositions(),
        p = f.length
      for (let y = 0; y < p; y++)
        for (let w = 0; w < p; w++)
          (y == 0 && w == 0) ||
            (y == 0 && w == p - 1) ||
            (y == p - 1 && w == 0) ||
            this.drawAlignmentPattern(f[y], f[w])
      ;(this.drawFormatBits(0), this.drawVersion())
    }
    drawFormatBits(f) {
      const p = (this.errorCorrectionLevel.formatBits << 3) | f
      let y = p
      for (let x = 0; x < 10; x++) y = (y << 1) ^ ((y >>> 9) * 1335)
      const w = ((p << 10) | y) ^ 21522
      s(w >>> 15 == 0)
      for (let x = 0; x <= 5; x++) this.setFunctionModule(8, x, i(w, x))
      ;(this.setFunctionModule(8, 7, i(w, 6)),
        this.setFunctionModule(8, 8, i(w, 7)),
        this.setFunctionModule(7, 8, i(w, 8)))
      for (let x = 9; x < 15; x++) this.setFunctionModule(14 - x, 8, i(w, x))
      for (let x = 0; x < 8; x++) this.setFunctionModule(this.size - 1 - x, 8, i(w, x))
      for (let x = 8; x < 15; x++) this.setFunctionModule(8, this.size - 15 + x, i(w, x))
      this.setFunctionModule(8, this.size - 8, !0)
    }
    drawVersion() {
      if (this.version < 7) return
      let f = this.version
      for (let y = 0; y < 12; y++) f = (f << 1) ^ ((f >>> 11) * 7973)
      const p = (this.version << 12) | f
      s(p >>> 18 == 0)
      for (let y = 0; y < 18; y++) {
        const w = i(p, y),
          x = this.size - 11 + (y % 3),
          E = Math.floor(y / 3)
        ;(this.setFunctionModule(x, E, w), this.setFunctionModule(E, x, w))
      }
    }
    drawFinderPattern(f, p) {
      for (let y = -4; y <= 4; y++)
        for (let w = -4; w <= 4; w++) {
          const x = Math.max(Math.abs(w), Math.abs(y)),
            E = f + w,
            S = p + y
          0 <= E &&
            E < this.size &&
            0 <= S &&
            S < this.size &&
            this.setFunctionModule(E, S, x != 2 && x != 4)
        }
    }
    drawAlignmentPattern(f, p) {
      for (let y = -2; y <= 2; y++)
        for (let w = -2; w <= 2; w++)
          this.setFunctionModule(f + w, p + y, Math.max(Math.abs(w), Math.abs(y)) != 1)
    }
    setFunctionModule(f, p, y) {
      ;((this.modules[p][f] = y), (this.isFunction[p][f] = !0))
    }
    addEccAndInterleave(f) {
      const p = this.version,
        y = this.errorCorrectionLevel
      if (f.length != e.getNumDataCodewords(p, y)) throw new RangeError('Invalid argument')
      const w = e.NUM_ERROR_CORRECTION_BLOCKS[y.ordinal][p],
        x = e.ECC_CODEWORDS_PER_BLOCK[y.ordinal][p],
        E = Math.floor(e.getNumRawDataModules(p) / 8),
        S = w - (E % w),
        k = Math.floor(E / w)
      let D = []
      const _ = e.reedSolomonComputeDivisor(x)
      for (let M = 0, O = 0; M < w; M++) {
        let F = f.slice(O, O + k - x + (M < S ? 0 : 1))
        O += F.length
        const z = e.reedSolomonComputeRemainder(F, _)
        ;(M < S && F.push(0), D.push(F.concat(z)))
      }
      let N = []
      for (let M = 0; M < D[0].length; M++)
        D.forEach((O, F) => {
          ;(M != k - x || F >= S) && N.push(O[M])
        })
      return (s(N.length == E), N)
    }
    drawCodewords(f) {
      if (f.length != Math.floor(e.getNumRawDataModules(this.version) / 8))
        throw new RangeError('Invalid argument')
      let p = 0
      for (let y = this.size - 1; y >= 1; y -= 2) {
        y == 6 && (y = 5)
        for (let w = 0; w < this.size; w++)
          for (let x = 0; x < 2; x++) {
            const E = y - x,
              S = (y + 1) & 2 ? w : this.size - 1 - w
            !this.isFunction[S][E] &&
              p < f.length * 8 &&
              ((this.modules[S][E] = i(f[p >>> 3], 7 - (p & 7))), p++)
          }
      }
      s(p == f.length * 8)
    }
    applyMask(f) {
      if (f < 0 || f > 7) throw new RangeError('Mask value out of range')
      for (let p = 0; p < this.size; p++)
        for (let y = 0; y < this.size; y++) {
          let w
          switch (f) {
            case 0:
              w = (y + p) % 2 == 0
              break
            case 1:
              w = p % 2 == 0
              break
            case 2:
              w = y % 3 == 0
              break
            case 3:
              w = (y + p) % 3 == 0
              break
            case 4:
              w = (Math.floor(y / 3) + Math.floor(p / 2)) % 2 == 0
              break
            case 5:
              w = ((y * p) % 2) + ((y * p) % 3) == 0
              break
            case 6:
              w = (((y * p) % 2) + ((y * p) % 3)) % 2 == 0
              break
            case 7:
              w = (((y + p) % 2) + ((y * p) % 3)) % 2 == 0
              break
            default:
              throw new Error('Unreachable')
          }
          !this.isFunction[p][y] && w && (this.modules[p][y] = !this.modules[p][y])
        }
    }
    getPenaltyScore() {
      let f = 0
      for (let x = 0; x < this.size; x++) {
        let E = !1,
          S = 0,
          k = [0, 0, 0, 0, 0, 0, 0]
        for (let D = 0; D < this.size; D++)
          this.modules[x][D] == E
            ? (S++, S == 5 ? (f += e.PENALTY_N1) : S > 5 && f++)
            : (this.finderPenaltyAddHistory(S, k),
              E || (f += this.finderPenaltyCountPatterns(k) * e.PENALTY_N3),
              (E = this.modules[x][D]),
              (S = 1))
        f += this.finderPenaltyTerminateAndCount(E, S, k) * e.PENALTY_N3
      }
      for (let x = 0; x < this.size; x++) {
        let E = !1,
          S = 0,
          k = [0, 0, 0, 0, 0, 0, 0]
        for (let D = 0; D < this.size; D++)
          this.modules[D][x] == E
            ? (S++, S == 5 ? (f += e.PENALTY_N1) : S > 5 && f++)
            : (this.finderPenaltyAddHistory(S, k),
              E || (f += this.finderPenaltyCountPatterns(k) * e.PENALTY_N3),
              (E = this.modules[D][x]),
              (S = 1))
        f += this.finderPenaltyTerminateAndCount(E, S, k) * e.PENALTY_N3
      }
      for (let x = 0; x < this.size - 1; x++)
        for (let E = 0; E < this.size - 1; E++) {
          const S = this.modules[x][E]
          S == this.modules[x][E + 1] &&
            S == this.modules[x + 1][E] &&
            S == this.modules[x + 1][E + 1] &&
            (f += e.PENALTY_N2)
        }
      let p = 0
      for (const x of this.modules) p = x.reduce((E, S) => E + (S ? 1 : 0), p)
      const y = this.size * this.size,
        w = Math.ceil(Math.abs(p * 20 - y * 10) / y) - 1
      return (s(0 <= w && w <= 9), (f += w * e.PENALTY_N4), s(0 <= f && f <= 2568888), f)
    }
    getAlignmentPatternPositions() {
      if (this.version == 1) return []
      {
        const f = Math.floor(this.version / 7) + 2,
          p = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (f * 2 - 2)) * 2
        let y = [6]
        for (let w = this.size - 7; y.length < f; w -= p) y.splice(1, 0, w)
        return y
      }
    }
    static getNumRawDataModules(f) {
      if (f < e.MIN_VERSION || f > e.MAX_VERSION)
        throw new RangeError('Version number out of range')
      let p = (16 * f + 128) * f + 64
      if (f >= 2) {
        const y = Math.floor(f / 7) + 2
        ;((p -= (25 * y - 10) * y - 55), f >= 7 && (p -= 36))
      }
      return (s(208 <= p && p <= 29648), p)
    }
    static getNumDataCodewords(f, p) {
      return (
        Math.floor(e.getNumRawDataModules(f) / 8) -
        e.ECC_CODEWORDS_PER_BLOCK[p.ordinal][f] * e.NUM_ERROR_CORRECTION_BLOCKS[p.ordinal][f]
      )
    }
    static reedSolomonComputeDivisor(f) {
      if (f < 1 || f > 255) throw new RangeError('Degree out of range')
      let p = []
      for (let w = 0; w < f - 1; w++) p.push(0)
      p.push(1)
      let y = 1
      for (let w = 0; w < f; w++) {
        for (let x = 0; x < p.length; x++)
          ((p[x] = e.reedSolomonMultiply(p[x], y)), x + 1 < p.length && (p[x] ^= p[x + 1]))
        y = e.reedSolomonMultiply(y, 2)
      }
      return p
    }
    static reedSolomonComputeRemainder(f, p) {
      let y = p.map((w) => 0)
      for (const w of f) {
        const x = w ^ y.shift()
        ;(y.push(0), p.forEach((E, S) => (y[S] ^= e.reedSolomonMultiply(E, x))))
      }
      return y
    }
    static reedSolomonMultiply(f, p) {
      if (f >>> 8 || p >>> 8) throw new RangeError('Byte out of range')
      let y = 0
      for (let w = 7; w >= 0; w--) ((y = (y << 1) ^ ((y >>> 7) * 285)), (y ^= ((p >>> w) & 1) * f))
      return (s(y >>> 8 == 0), y)
    }
    finderPenaltyCountPatterns(f) {
      const p = f[1]
      s(p <= this.size * 3)
      const y = p > 0 && f[2] == p && f[3] == p * 3 && f[4] == p && f[5] == p
      return (y && f[0] >= p * 4 && f[6] >= p ? 1 : 0) + (y && f[6] >= p * 4 && f[0] >= p ? 1 : 0)
    }
    finderPenaltyTerminateAndCount(f, p, y) {
      return (
        f && (this.finderPenaltyAddHistory(p, y), (p = 0)),
        (p += this.size),
        this.finderPenaltyAddHistory(p, y),
        this.finderPenaltyCountPatterns(y)
      )
    }
    finderPenaltyAddHistory(f, p) {
      ;(p[0] == 0 && (f += this.size), p.pop(), p.unshift(f))
    }
  }
  let n = e
  ;((n.MIN_VERSION = 1),
    (n.MAX_VERSION = 40),
    (n.PENALTY_N1 = 3),
    (n.PENALTY_N2 = 3),
    (n.PENALTY_N3 = 40),
    (n.PENALTY_N4 = 10),
    (n.ECC_CODEWORDS_PER_BLOCK = [
      [
        -1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28,
        30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
      ],
      [
        -1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28,
        28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
      ],
      [
        -1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30,
        30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
      ],
      [
        -1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24,
        30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
      ],
    ]),
    (n.NUM_ERROR_CORRECTION_BLOCKS = [
      [
        -1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13,
        14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25,
      ],
      [
        -1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21,
        23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49,
      ],
      [
        -1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29,
        34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68,
      ],
      [
        -1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32,
        35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81,
      ],
    ]),
    (t.QrCode = n))
  function r(f, p, y) {
    if (p < 0 || p > 31 || f >>> p) throw new RangeError('Value out of range')
    for (let w = p - 1; w >= 0; w--) y.push((f >>> w) & 1)
  }
  function i(f, p) {
    return ((f >>> p) & 1) != 0
  }
  function s(f) {
    if (!f) throw new Error('Assertion error')
  }
  const c = class {
    constructor(f, p, y) {
      if (((this.mode = f), (this.numChars = p), (this.bitData = y), p < 0))
        throw new RangeError('Invalid argument')
      this.bitData = y.slice()
    }
    static makeBytes(f) {
      let p = []
      for (const y of f) r(y, 8, p)
      return new c(c.Mode.BYTE, f.length, p)
    }
    static makeNumeric(f) {
      if (!c.isNumeric(f)) throw new RangeError('String contains non-numeric characters')
      let p = []
      for (let y = 0; y < f.length; ) {
        const w = Math.min(f.length - y, 3)
        ;(r(parseInt(f.substr(y, w), 10), w * 3 + 1, p), (y += w))
      }
      return new c(c.Mode.NUMERIC, f.length, p)
    }
    static makeAlphanumeric(f) {
      if (!c.isAlphanumeric(f))
        throw new RangeError('String contains unencodable characters in alphanumeric mode')
      let p = [],
        y
      for (y = 0; y + 2 <= f.length; y += 2) {
        let w = c.ALPHANUMERIC_CHARSET.indexOf(f.charAt(y)) * 45
        ;((w += c.ALPHANUMERIC_CHARSET.indexOf(f.charAt(y + 1))), r(w, 11, p))
      }
      return (
        y < f.length && r(c.ALPHANUMERIC_CHARSET.indexOf(f.charAt(y)), 6, p),
        new c(c.Mode.ALPHANUMERIC, f.length, p)
      )
    }
    static makeSegments(f) {
      return f == ''
        ? []
        : c.isNumeric(f)
          ? [c.makeNumeric(f)]
          : c.isAlphanumeric(f)
            ? [c.makeAlphanumeric(f)]
            : [c.makeBytes(c.toUtf8ByteArray(f))]
    }
    static makeEci(f) {
      let p = []
      if (f < 0) throw new RangeError('ECI assignment value out of range')
      if (f < 128) r(f, 8, p)
      else if (f < 16384) (r(2, 2, p), r(f, 14, p))
      else if (f < 1e6) (r(6, 3, p), r(f, 21, p))
      else throw new RangeError('ECI assignment value out of range')
      return new c(c.Mode.ECI, 0, p)
    }
    static isNumeric(f) {
      return c.NUMERIC_REGEX.test(f)
    }
    static isAlphanumeric(f) {
      return c.ALPHANUMERIC_REGEX.test(f)
    }
    getData() {
      return this.bitData.slice()
    }
    static getTotalBits(f, p) {
      let y = 0
      for (const w of f) {
        const x = w.mode.numCharCountBits(p)
        if (w.numChars >= 1 << x) return 1 / 0
        y += 4 + x + w.bitData.length
      }
      return y
    }
    static toUtf8ByteArray(f) {
      f = encodeURI(f)
      let p = []
      for (let y = 0; y < f.length; y++)
        f.charAt(y) != '%'
          ? p.push(f.charCodeAt(y))
          : (p.push(parseInt(f.substr(y + 1, 2), 16)), (y += 2))
      return p
    }
  }
  let h = c
  ;((h.NUMERIC_REGEX = /^[0-9]*$/),
    (h.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/),
    (h.ALPHANUMERIC_CHARSET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'),
    (t.QrSegment = h))
})(Ao || (Ao = {}))
;((t) => {
  ;((e) => {
    const n = class {
      constructor(i, s) {
        ;((this.ordinal = i), (this.formatBits = s))
      }
    }
    let r = n
    ;((r.LOW = new n(0, 1)),
      (r.MEDIUM = new n(1, 0)),
      (r.QUARTILE = new n(2, 3)),
      (r.HIGH = new n(3, 2)),
      (e.Ecc = r))
  })(t.QrCode || (t.QrCode = {}))
})(Ao || (Ao = {}))
;((t) => {
  ;((e) => {
    const n = class {
      constructor(i, s) {
        ;((this.modeBits = i), (this.numBitsCharCount = s))
      }
      numCharCountBits(i) {
        return this.numBitsCharCount[Math.floor((i + 7) / 17)]
      }
    }
    let r = n
    ;((r.NUMERIC = new n(1, [10, 12, 14])),
      (r.ALPHANUMERIC = new n(2, [9, 11, 13])),
      (r.BYTE = new n(4, [8, 16, 16])),
      (r.KANJI = new n(8, [8, 10, 12])),
      (r.ECI = new n(7, [0, 0, 0])),
      (e.Mode = r))
  })(t.QrSegment || (t.QrSegment = {}))
})(Ao || (Ao = {}))
var La = Ao
/**
 * @license qrcode.react
 * Copyright (c) Paul O'Shannessy
 * SPDX-License-Identifier: ISC
 */ var uT = {
    L: La.QrCode.Ecc.LOW,
    M: La.QrCode.Ecc.MEDIUM,
    Q: La.QrCode.Ecc.QUARTILE,
    H: La.QrCode.Ecc.HIGH,
  },
  hT = 128,
  dT = 'L',
  fT = '#FFFFFF',
  pT = '#000000',
  gT = !1,
  rb = 4,
  mT = 0.1
function yT(t, e = 0) {
  const n = []
  return (
    t.forEach(function (r, i) {
      let s = null
      r.forEach(function (c, h) {
        if (!c && s !== null) {
          ;(n.push(`M${s + e} ${i + e}h${h - s}v1H${s + e}z`), (s = null))
          return
        }
        if (h === r.length - 1) {
          if (!c) return
          s === null
            ? n.push(`M${h + e},${i + e} h1v1H${h + e}z`)
            : n.push(`M${s + e},${i + e} h${h + 1 - s}v1H${s + e}z`)
          return
        }
        c && s === null && (s = h)
      })
    }),
    n.join('')
  )
}
function wT(t, e) {
  return t
    .slice()
    .map((n, r) =>
      r < e.y || r >= e.y + e.h ? n : n.map((i, s) => (s < e.x || s >= e.x + e.w ? i : !1))
    )
}
function bT(t, e, n, r) {
  if (r == null) return null
  const i = n ? rb : 0,
    s = t.length + i * 2,
    c = Math.floor(e * mT),
    h = s / e,
    f = (r.width || c) * h,
    p = (r.height || c) * h,
    y = r.x == null ? t.length / 2 - f / 2 : r.x * h,
    w = r.y == null ? t.length / 2 - p / 2 : r.y * h
  let x = null
  if (r.excavate) {
    let E = Math.floor(y),
      S = Math.floor(w),
      k = Math.ceil(f + y - E),
      D = Math.ceil(p + w - S)
    x = { x: E, y: S, w: k, h: D }
  }
  return { x: y, y: w, h: p, w: f, excavation: x }
}
var vT = (function () {
  try {
    new Path2D().addPath(new Path2D())
  } catch {
    return !1
  }
  return !0
})()
function xT(t) {
  const e = t,
    {
      value: n,
      size: r = hT,
      level: i = dT,
      bgColor: s = fT,
      fgColor: c = pT,
      includeMargin: h = gT,
      style: f,
      imageSettings: p,
    } = e,
    y = cT(e, [
      'value',
      'size',
      'level',
      'bgColor',
      'fgColor',
      'includeMargin',
      'style',
      'imageSettings',
    ]),
    w = p == null ? void 0 : p.src,
    x = A.useRef(null),
    E = A.useRef(null),
    [S, k] = A.useState(!1)
  ;(A.useEffect(() => {
    if (x.current != null) {
      const N = x.current,
        M = N.getContext('2d')
      if (!M) return
      let O = La.QrCode.encodeText(n, uT[i]).getModules()
      const F = h ? rb : 0,
        z = O.length + F * 2,
        V = bT(O, r, h, p),
        W = E.current,
        Z = V != null && W !== null && W.complete && W.naturalHeight !== 0 && W.naturalWidth !== 0
      Z && V.excavation != null && (O = wT(O, V.excavation))
      const J = window.devicePixelRatio || 1
      N.height = N.width = r * J
      const st = (r / z) * J
      ;(M.scale(st, st),
        (M.fillStyle = s),
        M.fillRect(0, 0, z, z),
        (M.fillStyle = c),
        vT
          ? M.fill(new Path2D(yT(O, F)))
          : O.forEach(function (rt, vt) {
              rt.forEach(function (_t, H) {
                _t && M.fillRect(H + F, vt + F, 1, 1)
              })
            }),
        Z && M.drawImage(W, V.x + F, V.y + F, V.w, V.h))
    }
  }),
    A.useEffect(() => {
      k(!1)
    }, [w]))
  const D = Ly({ height: r, width: r }, f)
  let _ = null
  return (
    w != null &&
      (_ = A.createElement('img', {
        src: w,
        key: w,
        style: { display: 'none' },
        onLoad: () => {
          k(!0)
        },
        ref: E,
      })),
    A.createElement(
      A.Fragment,
      null,
      A.createElement('canvas', Ly({ style: D, height: r, width: r, ref: x }, y)),
      _
    )
  )
}
Ul.register(xs, Ja, Wr, X3, Z3)
const ET = ['Presence', 'Strategy', 'Composure', 'Guidance'],
  Oy = {
    GREEN: {
      name: 'Calm Navigator',
      description: 'You move with steady composure and keep the room grounded in clarity.',
    },
    YELLOW: {
      name: 'Signal Catalyst',
      description: 'Your energy shapes momentum and keeps people focused on what matters.',
    },
    RED: {
      name: 'Edge Architect',
      description: 'You bring sharp intensity and strong direction when stakes rise.',
    },
  },
  CT = () => {
    const t = e3(),
      [e, n] = X.useState(null),
      [r, i] = X.useState(!1)
    return (
      X.useEffect(() => {
        t &&
          (async () => {
            try {
              const s = t3(t).split('|'),
                c = s.pop(),
                h = s.join('|')
              if (!c) {
                i(!0)
                return
              }
              if ((await ep(h)).slice(0, 8) !== c) {
                i(!0)
                return
              }
              n({
                band: s[3],
                dtiBase: Number(s[4]),
                dtiFinal: Number(s[5]),
                scores: { N: Number(s[6]), M: Number(s[7]), P: Number(s[8]), MD: Number(s[9]) },
                integrity: Number(s[10]),
                archetype: s[11],
              })
            } catch {
              i(!0)
            }
          })()
      }, [t]),
      R.jsxs('div', {
        className: 'mx-auto flex w-full max-w-5xl flex-col gap-8 px-6 py-16',
        children: [
          R.jsxs('div', {
            className:
              'flex items-center gap-3 text-sm uppercase tracking-[0.3em] text-emerald-200',
            children: [R.jsx(Qs, { size: 18 }), 'Vibe Prism Results'],
          }),
          !t &&
            R.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                R.jsx('h2', {
                  className: 'text-xl font-semibold',
                  children: 'No profile found yet',
                }),
                R.jsx('p', {
                  className: 'mt-2 text-sm text-slate-400',
                  children: 'Take the quiz to generate your vibe profile.',
                }),
                R.jsx(tr, {
                  to: '/quiz',
                  className: 'button-primary mt-6',
                  children: 'Start the quiz',
                }),
              ],
            }),
          t &&
            !e &&
            !r &&
            R.jsx('div', { className: 'glass-panel p-6', children: 'Loading profile...' }),
          t && (e || r) && R.jsx(ST, { data: e, token: t, error: r }),
        ],
      })
    )
  },
  ST = ({ data: t, token: e, error: n }) => {
    if (n || !t)
      return R.jsxs('div', {
        className: 'glass-panel p-6',
        children: [
          R.jsx('p', {
            className: 'text-sm text-slate-400',
            children: 'Token validation failed. Please restore a valid profile.',
          }),
          R.jsx(tr, { to: '/quiz', className: 'button-primary mt-4', children: 'Retake quiz' }),
        ],
      })
    const r = Oy[t.band] ?? Oy.GREEN,
      i = {
        labels: ET,
        datasets: [
          {
            label: 'Vibe',
            data: [t.scores.N, t.scores.M, t.scores.P, t.scores.MD],
            backgroundColor: 'rgba(16, 185, 129, 0.2)',
            borderColor: 'rgba(16, 185, 129, 0.7)',
            borderWidth: 2,
            pointBackgroundColor: 'rgba(16, 185, 129, 0.9)',
          },
        ],
      }
    return R.jsxs('div', {
      className: 'grid gap-8 lg:grid-cols-[1.1fr_0.9fr]',
      children: [
        R.jsxs(Kn.div, {
          initial: { opacity: 0, scale: 0.98 },
          animate: { opacity: 1, scale: 1 },
          transition: { duration: 0.4 },
          className: 'glass-panel p-6',
          children: [
            R.jsxs('div', {
              className: 'flex items-center gap-3',
              children: [
                R.jsx(bh, { size: 24, className: 'text-emerald-300' }),
                R.jsxs('div', {
                  children: [
                    R.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                      children: 'Persona',
                    }),
                    R.jsx('h2', {
                      className: 'text-2xl font-semibold text-slate-50',
                      children: r.name,
                    }),
                  ],
                }),
              ],
            }),
            R.jsx('p', { className: 'mt-4 text-sm text-slate-300', children: r.description }),
            R.jsxs('div', {
              className: 'mt-6 grid gap-3 sm:grid-cols-3',
              children: [
                R.jsxs('div', {
                  className: 'rounded-xl border border-white/10 bg-slate-900/60 p-3',
                  children: [
                    R.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                      children: 'Momentum',
                    }),
                    R.jsx('p', {
                      className: 'mt-2 text-lg font-semibold text-slate-50',
                      children: t.dtiFinal,
                    }),
                  ],
                }),
                R.jsxs('div', {
                  className: 'rounded-xl border border-white/10 bg-slate-900/60 p-3',
                  children: [
                    R.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                      children: 'Integrity',
                    }),
                    R.jsx('p', {
                      className: 'mt-2 text-lg font-semibold text-slate-50',
                      children: t.integrity,
                    }),
                  ],
                }),
                R.jsxs('div', {
                  className: 'rounded-xl border border-white/10 bg-slate-900/60 p-3',
                  children: [
                    R.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                      children: 'Archetype',
                    }),
                    R.jsx('p', {
                      className: 'mt-2 text-sm font-semibold text-slate-50',
                      children: t.archetype,
                    }),
                  ],
                }),
              ],
            }),
            R.jsx('div', {
              className: 'mt-6 h-64',
              children: R.jsx(tb, {
                data: i,
                options: {
                  scales: {
                    r: {
                      ticks: { display: !1 },
                      grid: { color: 'rgba(148, 163, 184, 0.2)' },
                      pointLabels: { color: 'rgba(226, 232, 240, 0.8)' },
                      suggestedMin: 0,
                      suggestedMax: 100,
                    },
                  },
                  plugins: { legend: { display: !1 } },
                  animation: { duration: 800 },
                },
              }),
            }),
          ],
        }),
        R.jsxs('div', {
          className: 'flex flex-col gap-6',
          children: [
            R.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                R.jsx('h3', { className: 'text-lg font-semibold', children: 'Profile Readout' }),
                R.jsxs('p', {
                  className: 'mt-2 text-sm text-slate-400',
                  children: ['Base DTI: ', t.dtiBase, '  Final DTI: ', t.dtiFinal],
                }),
                R.jsxs('div', {
                  className: 'mt-4 grid gap-2 text-sm text-slate-300',
                  children: [
                    R.jsxs('div', {
                      className:
                        'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                      children: [
                        R.jsx('span', { children: 'Presence' }),
                        R.jsx('span', { children: t.scores.N }),
                      ],
                    }),
                    R.jsxs('div', {
                      className:
                        'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                      children: [
                        R.jsx('span', { children: 'Strategy' }),
                        R.jsx('span', { children: t.scores.M }),
                      ],
                    }),
                    R.jsxs('div', {
                      className:
                        'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                      children: [
                        R.jsx('span', { children: 'Composure' }),
                        R.jsx('span', { children: t.scores.P }),
                      ],
                    }),
                    R.jsxs('div', {
                      className:
                        'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                      children: [
                        R.jsx('span', { children: 'Guidance' }),
                        R.jsx('span', { children: t.scores.MD }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
            R.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                R.jsxs('div', {
                  className: 'flex items-center gap-3',
                  children: [
                    R.jsx(Vl, { size: 22, className: 'text-emerald-300' }),
                    R.jsxs('div', {
                      children: [
                        R.jsx('h3', {
                          className: 'text-lg font-semibold',
                          children: 'Private QR token',
                        }),
                        R.jsx('p', {
                          className: 'text-sm text-slate-400',
                          children: 'Store this token to restore your profile later.',
                        }),
                      ],
                    }),
                  ],
                }),
                R.jsx('div', {
                  className:
                    'mt-4 flex items-center justify-center rounded-xl border border-white/10 bg-slate-900/60 p-4',
                  children: R.jsx(xT, {
                    value: e,
                    size: 160,
                    bgColor: '#0f172a',
                    fgColor: '#e2e8f0',
                  }),
                }),
                R.jsxs('p', {
                  className: 'mt-4 text-xs text-slate-500',
                  children: ['Token preview: ', e.slice(0, 32), '...'],
                }),
              ],
            }),
            R.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                R.jsx('h3', {
                  className: 'text-lg font-semibold',
                  children: 'Need the full profile?',
                }),
                R.jsx('p', {
                  className: 'mt-2 text-sm text-slate-400',
                  children: 'Restore your profile with the secure decoder.',
                }),
                R.jsx(tr, {
                  to: '/restore',
                  className: 'button-secondary mt-4',
                  children: 'Restore Profile',
                }),
              ],
            }),
            R.jsxs('div', {
              className: 'glass-panel p-6',
              children: [
                R.jsx('h3', { className: 'text-lg font-semibold', children: 'Next actions' }),
                R.jsx('ul', {
                  className: 'mt-3 space-y-2 text-sm text-slate-300',
                  children: [
                    'Save your QR token to a secure note.',
                    'Share the persona name with your team.',
                    'Use the decoder to review trait-level insights.',
                  ].map((s) => R.jsx('li', { className: 'list-item', children: s }, s)),
                }),
              ],
            }),
          ],
        }),
      ],
    })
  },
  AT = '55486423',
  kT = (t) => (t <= 0 ? 0 : Math.min(6e4, 3e3 * t * t)),
  IT = ({ onUnlock: t }) => {
    const [e, n] = X.useState(''),
      [r, i] = X.useState(0),
      [s, c] = X.useState(null),
      h = s !== null && s > Date.now(),
      f = X.useMemo(() => ''.repeat(e.length).padEnd(8, ''), [e]),
      p = (E) => {
        h || e.length >= 8 || n((S) => S + E)
      },
      y = () => {
        h || n((E) => E.slice(0, -1))
      },
      w = () => {
        h || n('')
      },
      x = () => {
        if (h || e.length < 8) return
        if (e === AT) {
          ;(sessionStorage.setItem('VP_DECODE_UNLOCK', '1'), t())
          return
        }
        const E = r + 1
        if ((i(E), n(''), E >= 3)) {
          const S = kT(E)
          ;(c(Date.now() + S), setTimeout(() => c(null), S + 200))
        }
      }
    return R.jsxs('div', {
      className: 'glass-panel p-6',
      children: [
        R.jsxs('div', {
          className: 'flex items-center gap-3',
          children: [
            R.jsx(Eo, { size: 28, className: 'text-emerald-300' }),
            R.jsxs('div', {
              children: [
                R.jsx('p', {
                  className: 'text-sm uppercase tracking-[0.2em] text-slate-400',
                  children: 'Nexus Who Access',
                }),
                R.jsx('h2', { className: 'text-xl font-semibold', children: 'Enter 8-digit PIN' }),
              ],
            }),
          ],
        }),
        R.jsxs('div', {
          className:
            'mt-6 flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-4 py-3 text-lg tracking-[0.3em]',
          children: [
            R.jsx('span', { children: f }),
            h &&
              R.jsx('span', {
                className: 'text-xs uppercase tracking-[0.3em] text-rose-300',
                children: 'Locked',
              }),
          ],
        }),
        R.jsxs('div', {
          className: 'mt-6 grid grid-cols-3 gap-3',
          children: [
            ['1', '2', '3', '4', '5', '6', '7', '8', '9'].map((E) =>
              R.jsx(
                'button',
                {
                  type: 'button',
                  onClick: () => p(E),
                  className:
                    'rounded-xl border border-white/10 bg-white/5 py-3 text-lg font-semibold text-slate-100 transition hover:border-emerald-400/40',
                  children: E,
                },
                E
              )
            ),
            R.jsx('button', {
              type: 'button',
              onClick: w,
              className:
                'rounded-xl border border-white/10 bg-white/5 py-3 text-xs uppercase tracking-[0.3em] text-slate-400',
              children: 'Clear',
            }),
            R.jsx('button', {
              type: 'button',
              onClick: () => p('0'),
              className:
                'rounded-xl border border-white/10 bg-white/5 py-3 text-lg font-semibold text-slate-100 transition hover:border-emerald-400/40',
              children: '0',
            }),
            R.jsx('button', {
              type: 'button',
              onClick: y,
              className:
                'rounded-xl border border-white/10 bg-white/5 py-3 text-xs uppercase tracking-[0.3em] text-slate-400',
              children: 'Delete',
            }),
          ],
        }),
        R.jsxs('div', {
          className: 'mt-6 flex flex-wrap gap-3',
          children: [
            R.jsx('button', {
              type: 'button',
              onClick: x,
              className: 'button-primary',
              children: 'Unlock',
            }),
            r > 0 &&
              R.jsxs('span', {
                className: 'text-xs text-slate-400',
                children: ['Attempts: ', r, ' / 3'],
              }),
          ],
        }),
      ],
    })
  }
var lt
;(function (t) {
  ;((t[(t.QR_CODE = 0)] = 'QR_CODE'),
    (t[(t.AZTEC = 1)] = 'AZTEC'),
    (t[(t.CODABAR = 2)] = 'CODABAR'),
    (t[(t.CODE_39 = 3)] = 'CODE_39'),
    (t[(t.CODE_93 = 4)] = 'CODE_93'),
    (t[(t.CODE_128 = 5)] = 'CODE_128'),
    (t[(t.DATA_MATRIX = 6)] = 'DATA_MATRIX'),
    (t[(t.MAXICODE = 7)] = 'MAXICODE'),
    (t[(t.ITF = 8)] = 'ITF'),
    (t[(t.EAN_13 = 9)] = 'EAN_13'),
    (t[(t.EAN_8 = 10)] = 'EAN_8'),
    (t[(t.PDF_417 = 11)] = 'PDF_417'),
    (t[(t.RSS_14 = 12)] = 'RSS_14'),
    (t[(t.RSS_EXPANDED = 13)] = 'RSS_EXPANDED'),
    (t[(t.UPC_A = 14)] = 'UPC_A'),
    (t[(t.UPC_E = 15)] = 'UPC_E'),
    (t[(t.UPC_EAN_EXTENSION = 16)] = 'UPC_EAN_EXTENSION'))
})(lt || (lt = {}))
var By = new Map([
    [lt.QR_CODE, 'QR_CODE'],
    [lt.AZTEC, 'AZTEC'],
    [lt.CODABAR, 'CODABAR'],
    [lt.CODE_39, 'CODE_39'],
    [lt.CODE_93, 'CODE_93'],
    [lt.CODE_128, 'CODE_128'],
    [lt.DATA_MATRIX, 'DATA_MATRIX'],
    [lt.MAXICODE, 'MAXICODE'],
    [lt.ITF, 'ITF'],
    [lt.EAN_13, 'EAN_13'],
    [lt.EAN_8, 'EAN_8'],
    [lt.PDF_417, 'PDF_417'],
    [lt.RSS_14, 'RSS_14'],
    [lt.RSS_EXPANDED, 'RSS_EXPANDED'],
    [lt.UPC_A, 'UPC_A'],
    [lt.UPC_E, 'UPC_E'],
    [lt.UPC_EAN_EXTENSION, 'UPC_EAN_EXTENSION'],
  ]),
  Fy
;(function (t) {
  ;((t[(t.UNKNOWN = 0)] = 'UNKNOWN'), (t[(t.URL = 1)] = 'URL'))
})(Fy || (Fy = {}))
function _T(t) {
  return Object.values(lt).includes(t)
}
var Xu
;(function (t) {
  ;((t[(t.SCAN_TYPE_CAMERA = 0)] = 'SCAN_TYPE_CAMERA'),
    (t[(t.SCAN_TYPE_FILE = 1)] = 'SCAN_TYPE_FILE'))
})(Xu || (Xu = {}))
var RT = (function () {
    function t() {}
    return (
      (t.GITHUB_PROJECT_URL = 'https://github.com/mebjas/html5-qrcode'),
      (t.SCAN_DEFAULT_FPS = 2),
      (t.DEFAULT_DISABLE_FLIP = !1),
      (t.DEFAULT_REMEMBER_LAST_CAMERA_USED = !0),
      (t.DEFAULT_SUPPORTED_SCAN_TYPE = [Xu.SCAN_TYPE_CAMERA, Xu.SCAN_TYPE_FILE]),
      t
    )
  })(),
  ib = (function () {
    function t(e, n) {
      ;((this.format = e), (this.formatName = n))
    }
    return (
      (t.prototype.toString = function () {
        return this.formatName
      }),
      (t.create = function (e) {
        if (!By.has(e)) throw ''.concat(e, ' not in html5QrcodeSupportedFormatsTextMap')
        return new t(e, By.get(e))
      }),
      t
    )
  })(),
  jy = (function () {
    function t() {}
    return (
      (t.createFromText = function (e) {
        var n = { text: e }
        return { decodedText: e, result: n }
      }),
      (t.createFromQrcodeResult = function (e) {
        return { decodedText: e.text, result: e }
      }),
      t
    )
  })(),
  xf
;(function (t) {
  ;((t[(t.UNKWOWN_ERROR = 0)] = 'UNKWOWN_ERROR'),
    (t[(t.IMPLEMENTATION_ERROR = 1)] = 'IMPLEMENTATION_ERROR'),
    (t[(t.NO_CODE_FOUND_ERROR = 2)] = 'NO_CODE_FOUND_ERROR'))
})(xf || (xf = {}))
var TT = (function () {
    function t() {}
    return (
      (t.createFrom = function (e) {
        return { errorMessage: e, type: xf.UNKWOWN_ERROR }
      }),
      t
    )
  })(),
  NT = (function () {
    function t(e) {
      this.verbose = e
    }
    return (
      (t.prototype.log = function (e) {
        this.verbose && console.log(e)
      }),
      (t.prototype.warn = function (e) {
        this.verbose && console.warn(e)
      }),
      (t.prototype.logError = function (e, n) {
        ;(this.verbose || n === !0) && console.error(e)
      }),
      (t.prototype.logErrors = function (e) {
        if (e.length === 0) throw 'Logger#logError called without arguments'
        this.verbose && console.error(e)
      }),
      t
    )
  })()
function Pr(t) {
  return typeof t > 'u' || t === null
}
var Es = (function () {
    function t() {}
    return (
      (t.codeParseError = function (e) {
        return 'QR code parse error, error = '.concat(e)
      }),
      (t.errorGettingUserMedia = function (e) {
        return 'Error getting userMedia, error = '.concat(e)
      }),
      (t.onlyDeviceSupportedError = function () {
        return "The device doesn't support navigator.mediaDevices , only supported cameraIdOrConfig in this case is deviceId parameter (string)."
      }),
      (t.cameraStreamingNotSupported = function () {
        return 'Camera streaming not supported by the browser.'
      }),
      (t.unableToQuerySupportedDevices = function () {
        return 'Unable to query supported devices, unknown error.'
      }),
      (t.insecureContextCameraQueryError = function () {
        return 'Camera access is only supported in secure context like https or localhost.'
      }),
      (t.scannerPaused = function () {
        return 'Scanner paused'
      }),
      t
    )
  })(),
  ob = (function () {
    function t() {}
    return (
      (t.isMediaStreamConstraintsValid = function (e, n) {
        if (typeof e != 'object') {
          var r = typeof e
          return (
            n.logError(
              'videoConstraints should be of type object, the ' +
                'object passed is of type '.concat(r, '.'),
              !0
            ),
            !1
          )
        }
        for (
          var i = [
              'autoGainControl',
              'channelCount',
              'echoCancellation',
              'latency',
              'noiseSuppression',
              'sampleRate',
              'sampleSize',
              'volume',
            ],
            s = new Set(i),
            c = Object.keys(e),
            h = 0,
            f = c;
          h < f.length;
          h++
        ) {
          var p = f[h]
          if (s.has(p))
            return (n.logError(''.concat(p, ' is not supported videoConstaints.'), !0), !1)
        }
        return !0
      }),
      t
    )
  })(),
  Ef = { exports: {} }
;(function (t, e) {
  ;(function (n, r) {
    r(e)
  })(ha, function (n) {
    function r(I) {
      return I == null
    }
    var i =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (I, o) {
          I.__proto__ = o
        }) ||
      function (I, o) {
        for (var a in o) o.hasOwnProperty(a) && (I[a] = o[a])
      }
    function s(I, o) {
      i(I, o)
      function a() {
        this.constructor = I
      }
      I.prototype = o === null ? Object.create(o) : ((a.prototype = o.prototype), new a())
    }
    function c(I, o) {
      var a = Object.setPrototypeOf
      a ? a(I, o) : (I.__proto__ = o)
    }
    function h(I, o) {
      o === void 0 && (o = I.constructor)
      var a = Error.captureStackTrace
      a && a(I, o)
    }
    var f = (function (I) {
      s(o, I)
      function o(a) {
        var l = this.constructor,
          u = I.call(this, a) || this
        return (
          Object.defineProperty(u, 'name', { value: l.name, enumerable: !1 }),
          c(u, l.prototype),
          h(u),
          u
        )
      }
      return o
    })(Error)
    class p extends f {
      constructor(o = void 0) {
        ;(super(o), (this.message = o))
      }
      getKind() {
        return this.constructor.kind
      }
    }
    p.kind = 'Exception'
    class y extends p {}
    y.kind = 'ArgumentException'
    class w extends p {}
    w.kind = 'IllegalArgumentException'
    class x {
      constructor(o) {
        if (((this.binarizer = o), o === null)) throw new w('Binarizer must be non-null.')
      }
      getWidth() {
        return this.binarizer.getWidth()
      }
      getHeight() {
        return this.binarizer.getHeight()
      }
      getBlackRow(o, a) {
        return this.binarizer.getBlackRow(o, a)
      }
      getBlackMatrix() {
        return (
          (this.matrix === null || this.matrix === void 0) &&
            (this.matrix = this.binarizer.getBlackMatrix()),
          this.matrix
        )
      }
      isCropSupported() {
        return this.binarizer.getLuminanceSource().isCropSupported()
      }
      crop(o, a, l, u) {
        const d = this.binarizer.getLuminanceSource().crop(o, a, l, u)
        return new x(this.binarizer.createBinarizer(d))
      }
      isRotateSupported() {
        return this.binarizer.getLuminanceSource().isRotateSupported()
      }
      rotateCounterClockwise() {
        const o = this.binarizer.getLuminanceSource().rotateCounterClockwise()
        return new x(this.binarizer.createBinarizer(o))
      }
      rotateCounterClockwise45() {
        const o = this.binarizer.getLuminanceSource().rotateCounterClockwise45()
        return new x(this.binarizer.createBinarizer(o))
      }
      toString() {
        try {
          return this.getBlackMatrix().toString()
        } catch {
          return ''
        }
      }
    }
    class E extends p {
      static getChecksumInstance() {
        return new E()
      }
    }
    E.kind = 'ChecksumException'
    class S {
      constructor(o) {
        this.source = o
      }
      getLuminanceSource() {
        return this.source
      }
      getWidth() {
        return this.source.getWidth()
      }
      getHeight() {
        return this.source.getHeight()
      }
    }
    class k {
      static arraycopy(o, a, l, u, d) {
        for (; d--; ) l[u++] = o[a++]
      }
      static currentTimeMillis() {
        return Date.now()
      }
    }
    class D extends p {}
    D.kind = 'IndexOutOfBoundsException'
    class _ extends D {
      constructor(o = void 0, a = void 0) {
        ;(super(a), (this.index = o), (this.message = a))
      }
    }
    _.kind = 'ArrayIndexOutOfBoundsException'
    class N {
      static fill(o, a) {
        for (let l = 0, u = o.length; l < u; l++) o[l] = a
      }
      static fillWithin(o, a, l, u) {
        N.rangeCheck(o.length, a, l)
        for (let d = a; d < l; d++) o[d] = u
      }
      static rangeCheck(o, a, l) {
        if (a > l) throw new w('fromIndex(' + a + ') > toIndex(' + l + ')')
        if (a < 0) throw new _(a)
        if (l > o) throw new _(l)
      }
      static asList(...o) {
        return o
      }
      static create(o, a, l) {
        return Array.from({ length: o }).map((u) => Array.from({ length: a }).fill(l))
      }
      static createInt32Array(o, a, l) {
        return Array.from({ length: o }).map((u) => Int32Array.from({ length: a }).fill(l))
      }
      static equals(o, a) {
        if (!o || !a || !o.length || !a.length || o.length !== a.length) return !1
        for (let l = 0, u = o.length; l < u; l++) if (o[l] !== a[l]) return !1
        return !0
      }
      static hashCode(o) {
        if (o === null) return 0
        let a = 1
        for (const l of o) a = 31 * a + l
        return a
      }
      static fillUint8Array(o, a) {
        for (let l = 0; l !== o.length; l++) o[l] = a
      }
      static copyOf(o, a) {
        return o.slice(0, a)
      }
      static copyOfUint8Array(o, a) {
        if (o.length <= a) {
          const l = new Uint8Array(a)
          return (l.set(o), l)
        }
        return o.slice(0, a)
      }
      static copyOfRange(o, a, l) {
        const u = l - a,
          d = new Int32Array(u)
        return (k.arraycopy(o, a, d, 0, u), d)
      }
      static binarySearch(o, a, l) {
        l === void 0 && (l = N.numberComparator)
        let u = 0,
          d = o.length - 1
        for (; u <= d; ) {
          const g = (d + u) >> 1,
            m = l(a, o[g])
          if (m > 0) u = g + 1
          else if (m < 0) d = g - 1
          else return g
        }
        return -u - 1
      }
      static numberComparator(o, a) {
        return o - a
      }
    }
    class M {
      static numberOfTrailingZeros(o) {
        let a
        if (o === 0) return 32
        let l = 31
        return (
          (a = o << 16),
          a !== 0 && ((l -= 16), (o = a)),
          (a = o << 8),
          a !== 0 && ((l -= 8), (o = a)),
          (a = o << 4),
          a !== 0 && ((l -= 4), (o = a)),
          (a = o << 2),
          a !== 0 && ((l -= 2), (o = a)),
          l - ((o << 1) >>> 31)
        )
      }
      static numberOfLeadingZeros(o) {
        if (o === 0) return 32
        let a = 1
        return (
          o >>> 16 || ((a += 16), (o <<= 16)),
          o >>> 24 || ((a += 8), (o <<= 8)),
          o >>> 28 || ((a += 4), (o <<= 4)),
          o >>> 30 || ((a += 2), (o <<= 2)),
          (a -= o >>> 31),
          a
        )
      }
      static toHexString(o) {
        return o.toString(16)
      }
      static toBinaryString(o) {
        return String(parseInt(String(o), 2))
      }
      static bitCount(o) {
        return (
          (o = o - ((o >>> 1) & 1431655765)),
          (o = (o & 858993459) + ((o >>> 2) & 858993459)),
          (o = (o + (o >>> 4)) & 252645135),
          (o = o + (o >>> 8)),
          (o = o + (o >>> 16)),
          o & 63
        )
      }
      static truncDivision(o, a) {
        return Math.trunc(o / a)
      }
      static parseInt(o, a = void 0) {
        return parseInt(o, a)
      }
    }
    ;((M.MIN_VALUE_32_BITS = -2147483648), (M.MAX_VALUE = Number.MAX_SAFE_INTEGER))
    class O {
      constructor(o, a) {
        o === void 0
          ? ((this.size = 0), (this.bits = new Int32Array(1)))
          : ((this.size = o), a == null ? (this.bits = O.makeArray(o)) : (this.bits = a))
      }
      getSize() {
        return this.size
      }
      getSizeInBytes() {
        return Math.floor((this.size + 7) / 8)
      }
      ensureCapacity(o) {
        if (o > this.bits.length * 32) {
          const a = O.makeArray(o)
          ;(k.arraycopy(this.bits, 0, a, 0, this.bits.length), (this.bits = a))
        }
      }
      get(o) {
        return (this.bits[Math.floor(o / 32)] & (1 << (o & 31))) !== 0
      }
      set(o) {
        this.bits[Math.floor(o / 32)] |= 1 << (o & 31)
      }
      flip(o) {
        this.bits[Math.floor(o / 32)] ^= 1 << (o & 31)
      }
      getNextSet(o) {
        const a = this.size
        if (o >= a) return a
        const l = this.bits
        let u = Math.floor(o / 32),
          d = l[u]
        d &= ~((1 << (o & 31)) - 1)
        const g = l.length
        for (; d === 0; ) {
          if (++u === g) return a
          d = l[u]
        }
        const m = u * 32 + M.numberOfTrailingZeros(d)
        return m > a ? a : m
      }
      getNextUnset(o) {
        const a = this.size
        if (o >= a) return a
        const l = this.bits
        let u = Math.floor(o / 32),
          d = ~l[u]
        d &= ~((1 << (o & 31)) - 1)
        const g = l.length
        for (; d === 0; ) {
          if (++u === g) return a
          d = ~l[u]
        }
        const m = u * 32 + M.numberOfTrailingZeros(d)
        return m > a ? a : m
      }
      setBulk(o, a) {
        this.bits[Math.floor(o / 32)] = a
      }
      setRange(o, a) {
        if (a < o || o < 0 || a > this.size) throw new w()
        if (a === o) return
        a--
        const l = Math.floor(o / 32),
          u = Math.floor(a / 32),
          d = this.bits
        for (let g = l; g <= u; g++) {
          const m = g > l ? 0 : o & 31,
            b = (2 << (g < u ? 31 : a & 31)) - (1 << m)
          d[g] |= b
        }
      }
      clear() {
        const o = this.bits.length,
          a = this.bits
        for (let l = 0; l < o; l++) a[l] = 0
      }
      isRange(o, a, l) {
        if (a < o || o < 0 || a > this.size) throw new w()
        if (a === o) return !0
        a--
        const u = Math.floor(o / 32),
          d = Math.floor(a / 32),
          g = this.bits
        for (let m = u; m <= d; m++) {
          const b = m > u ? 0 : o & 31,
            v = ((2 << (m < d ? 31 : a & 31)) - (1 << b)) & 4294967295
          if ((g[m] & v) !== (l ? v : 0)) return !1
        }
        return !0
      }
      appendBit(o) {
        ;(this.ensureCapacity(this.size + 1),
          o && (this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 31)),
          this.size++)
      }
      appendBits(o, a) {
        if (a < 0 || a > 32) throw new w('Num bits must be between 0 and 32')
        this.ensureCapacity(this.size + a)
        for (let l = a; l > 0; l--) this.appendBit(((o >> (l - 1)) & 1) === 1)
      }
      appendBitArray(o) {
        const a = o.size
        this.ensureCapacity(this.size + a)
        for (let l = 0; l < a; l++) this.appendBit(o.get(l))
      }
      xor(o) {
        if (this.size !== o.size) throw new w("Sizes don't match")
        const a = this.bits
        for (let l = 0, u = a.length; l < u; l++) a[l] ^= o.bits[l]
      }
      toBytes(o, a, l, u) {
        for (let d = 0; d < u; d++) {
          let g = 0
          for (let m = 0; m < 8; m++) (this.get(o) && (g |= 1 << (7 - m)), o++)
          a[l + d] = g
        }
      }
      getBitArray() {
        return this.bits
      }
      reverse() {
        const o = new Int32Array(this.bits.length),
          a = Math.floor((this.size - 1) / 32),
          l = a + 1,
          u = this.bits
        for (let d = 0; d < l; d++) {
          let g = u[d]
          ;((g = ((g >> 1) & 1431655765) | ((g & 1431655765) << 1)),
            (g = ((g >> 2) & 858993459) | ((g & 858993459) << 2)),
            (g = ((g >> 4) & 252645135) | ((g & 252645135) << 4)),
            (g = ((g >> 8) & 16711935) | ((g & 16711935) << 8)),
            (g = ((g >> 16) & 65535) | ((g & 65535) << 16)),
            (o[a - d] = g))
        }
        if (this.size !== l * 32) {
          const d = l * 32 - this.size
          let g = o[0] >>> d
          for (let m = 1; m < l; m++) {
            const b = o[m]
            ;((g |= b << (32 - d)), (o[m - 1] = g), (g = b >>> d))
          }
          o[l - 1] = g
        }
        this.bits = o
      }
      static makeArray(o) {
        return new Int32Array(Math.floor((o + 31) / 32))
      }
      equals(o) {
        if (!(o instanceof O)) return !1
        const a = o
        return this.size === a.size && N.equals(this.bits, a.bits)
      }
      hashCode() {
        return 31 * this.size + N.hashCode(this.bits)
      }
      toString() {
        let o = ''
        for (let a = 0, l = this.size; a < l; a++)
          (a & 7 || (o += ' '), (o += this.get(a) ? 'X' : '.'))
        return o
      }
      clone() {
        return new O(this.size, this.bits.slice())
      }
    }
    var F
    ;(function (I) {
      ;((I[(I.OTHER = 0)] = 'OTHER'),
        (I[(I.PURE_BARCODE = 1)] = 'PURE_BARCODE'),
        (I[(I.POSSIBLE_FORMATS = 2)] = 'POSSIBLE_FORMATS'),
        (I[(I.TRY_HARDER = 3)] = 'TRY_HARDER'),
        (I[(I.CHARACTER_SET = 4)] = 'CHARACTER_SET'),
        (I[(I.ALLOWED_LENGTHS = 5)] = 'ALLOWED_LENGTHS'),
        (I[(I.ASSUME_CODE_39_CHECK_DIGIT = 6)] = 'ASSUME_CODE_39_CHECK_DIGIT'),
        (I[(I.ASSUME_GS1 = 7)] = 'ASSUME_GS1'),
        (I[(I.RETURN_CODABAR_START_END = 8)] = 'RETURN_CODABAR_START_END'),
        (I[(I.NEED_RESULT_POINT_CALLBACK = 9)] = 'NEED_RESULT_POINT_CALLBACK'),
        (I[(I.ALLOWED_EAN_EXTENSIONS = 10)] = 'ALLOWED_EAN_EXTENSIONS'))
    })(F || (F = {}))
    var z = F
    class V extends p {
      static getFormatInstance() {
        return new V()
      }
    }
    V.kind = 'FormatException'
    var W
    ;(function (I) {
      ;((I[(I.Cp437 = 0)] = 'Cp437'),
        (I[(I.ISO8859_1 = 1)] = 'ISO8859_1'),
        (I[(I.ISO8859_2 = 2)] = 'ISO8859_2'),
        (I[(I.ISO8859_3 = 3)] = 'ISO8859_3'),
        (I[(I.ISO8859_4 = 4)] = 'ISO8859_4'),
        (I[(I.ISO8859_5 = 5)] = 'ISO8859_5'),
        (I[(I.ISO8859_6 = 6)] = 'ISO8859_6'),
        (I[(I.ISO8859_7 = 7)] = 'ISO8859_7'),
        (I[(I.ISO8859_8 = 8)] = 'ISO8859_8'),
        (I[(I.ISO8859_9 = 9)] = 'ISO8859_9'),
        (I[(I.ISO8859_10 = 10)] = 'ISO8859_10'),
        (I[(I.ISO8859_11 = 11)] = 'ISO8859_11'),
        (I[(I.ISO8859_13 = 12)] = 'ISO8859_13'),
        (I[(I.ISO8859_14 = 13)] = 'ISO8859_14'),
        (I[(I.ISO8859_15 = 14)] = 'ISO8859_15'),
        (I[(I.ISO8859_16 = 15)] = 'ISO8859_16'),
        (I[(I.SJIS = 16)] = 'SJIS'),
        (I[(I.Cp1250 = 17)] = 'Cp1250'),
        (I[(I.Cp1251 = 18)] = 'Cp1251'),
        (I[(I.Cp1252 = 19)] = 'Cp1252'),
        (I[(I.Cp1256 = 20)] = 'Cp1256'),
        (I[(I.UnicodeBigUnmarked = 21)] = 'UnicodeBigUnmarked'),
        (I[(I.UTF8 = 22)] = 'UTF8'),
        (I[(I.ASCII = 23)] = 'ASCII'),
        (I[(I.Big5 = 24)] = 'Big5'),
        (I[(I.GB18030 = 25)] = 'GB18030'),
        (I[(I.EUC_KR = 26)] = 'EUC_KR'))
    })(W || (W = {}))
    class Z {
      constructor(o, a, l, ...u) {
        ;((this.valueIdentifier = o),
          (this.name = l),
          typeof a == 'number' ? (this.values = Int32Array.from([a])) : (this.values = a),
          (this.otherEncodingNames = u),
          Z.VALUE_IDENTIFIER_TO_ECI.set(o, this),
          Z.NAME_TO_ECI.set(l, this))
        const d = this.values
        for (let g = 0, m = d.length; g !== m; g++) {
          const b = d[g]
          Z.VALUES_TO_ECI.set(b, this)
        }
        for (const g of u) Z.NAME_TO_ECI.set(g, this)
      }
      getValueIdentifier() {
        return this.valueIdentifier
      }
      getName() {
        return this.name
      }
      getValue() {
        return this.values[0]
      }
      static getCharacterSetECIByValue(o) {
        if (o < 0 || o >= 900) throw new V('incorect value')
        const a = Z.VALUES_TO_ECI.get(o)
        if (a === void 0) throw new V('incorect value')
        return a
      }
      static getCharacterSetECIByName(o) {
        const a = Z.NAME_TO_ECI.get(o)
        if (a === void 0) throw new V('incorect value')
        return a
      }
      equals(o) {
        if (!(o instanceof Z)) return !1
        const a = o
        return this.getName() === a.getName()
      }
    }
    ;((Z.VALUE_IDENTIFIER_TO_ECI = new Map()),
      (Z.VALUES_TO_ECI = new Map()),
      (Z.NAME_TO_ECI = new Map()),
      (Z.Cp437 = new Z(W.Cp437, Int32Array.from([0, 2]), 'Cp437')),
      (Z.ISO8859_1 = new Z(
        W.ISO8859_1,
        Int32Array.from([1, 3]),
        'ISO-8859-1',
        'ISO88591',
        'ISO8859_1'
      )),
      (Z.ISO8859_2 = new Z(W.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2')),
      (Z.ISO8859_3 = new Z(W.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3')),
      (Z.ISO8859_4 = new Z(W.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4')),
      (Z.ISO8859_5 = new Z(W.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5')),
      (Z.ISO8859_6 = new Z(W.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6')),
      (Z.ISO8859_7 = new Z(W.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7')),
      (Z.ISO8859_8 = new Z(W.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8')),
      (Z.ISO8859_9 = new Z(W.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9')),
      (Z.ISO8859_10 = new Z(W.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10')),
      (Z.ISO8859_11 = new Z(W.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11')),
      (Z.ISO8859_13 = new Z(W.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13')),
      (Z.ISO8859_14 = new Z(W.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14')),
      (Z.ISO8859_15 = new Z(W.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15')),
      (Z.ISO8859_16 = new Z(W.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16')),
      (Z.SJIS = new Z(W.SJIS, 20, 'SJIS', 'Shift_JIS')),
      (Z.Cp1250 = new Z(W.Cp1250, 21, 'Cp1250', 'windows-1250')),
      (Z.Cp1251 = new Z(W.Cp1251, 22, 'Cp1251', 'windows-1251')),
      (Z.Cp1252 = new Z(W.Cp1252, 23, 'Cp1252', 'windows-1252')),
      (Z.Cp1256 = new Z(W.Cp1256, 24, 'Cp1256', 'windows-1256')),
      (Z.UnicodeBigUnmarked = new Z(
        W.UnicodeBigUnmarked,
        25,
        'UnicodeBigUnmarked',
        'UTF-16BE',
        'UnicodeBig'
      )),
      (Z.UTF8 = new Z(W.UTF8, 26, 'UTF8', 'UTF-8')),
      (Z.ASCII = new Z(W.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII')),
      (Z.Big5 = new Z(W.Big5, 28, 'Big5')),
      (Z.GB18030 = new Z(W.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK')),
      (Z.EUC_KR = new Z(W.EUC_KR, 30, 'EUC_KR', 'EUC-KR')))
    class J extends p {}
    J.kind = 'UnsupportedOperationException'
    class st {
      static decode(o, a) {
        const l = this.encodingName(a)
        return this.customDecoder
          ? this.customDecoder(o, l)
          : typeof TextDecoder > 'u' || this.shouldDecodeOnFallback(l)
            ? this.decodeFallback(o, l)
            : new TextDecoder(l).decode(o)
      }
      static shouldDecodeOnFallback(o) {
        return !st.isBrowser() && o === 'ISO-8859-1'
      }
      static encode(o, a) {
        const l = this.encodingName(a)
        return this.customEncoder
          ? this.customEncoder(o, l)
          : typeof TextEncoder > 'u'
            ? this.encodeFallback(o)
            : new TextEncoder().encode(o)
      }
      static isBrowser() {
        return typeof window < 'u' && {}.toString.call(window) === '[object Window]'
      }
      static encodingName(o) {
        return typeof o == 'string' ? o : o.getName()
      }
      static encodingCharacterSet(o) {
        return o instanceof Z ? o : Z.getCharacterSetECIByName(o)
      }
      static decodeFallback(o, a) {
        const l = this.encodingCharacterSet(a)
        if (st.isDecodeFallbackSupported(l)) {
          let u = ''
          for (let d = 0, g = o.length; d < g; d++) {
            let m = o[d].toString(16)
            ;(m.length < 2 && (m = '0' + m), (u += '%' + m))
          }
          return decodeURIComponent(u)
        }
        if (l.equals(Z.UnicodeBigUnmarked))
          return String.fromCharCode.apply(null, new Uint16Array(o.buffer))
        throw new J(`Encoding ${this.encodingName(a)} not supported by fallback.`)
      }
      static isDecodeFallbackSupported(o) {
        return o.equals(Z.UTF8) || o.equals(Z.ISO8859_1) || o.equals(Z.ASCII)
      }
      static encodeFallback(o) {
        const a = btoa(unescape(encodeURIComponent(o))).split(''),
          l = []
        for (let u = 0; u < a.length; u++) l.push(a[u].charCodeAt(0))
        return new Uint8Array(l)
      }
    }
    class rt {
      static castAsNonUtf8Char(o, a = null) {
        const l = a ? a.getName() : this.ISO88591
        return st.decode(new Uint8Array([o]), l)
      }
      static guessEncoding(o, a) {
        if (a != null && a.get(z.CHARACTER_SET) !== void 0) return a.get(z.CHARACTER_SET).toString()
        const l = o.length
        let u = !0,
          d = !0,
          g = !0,
          m = 0,
          b = 0,
          v = 0,
          C = 0,
          T = 0,
          P = 0,
          B = 0,
          j = 0,
          U = 0,
          Y = 0,
          K = 0
        const nt = o.length > 3 && o[0] === 239 && o[1] === 187 && o[2] === 191
        for (let et = 0; et < l && (u || d || g); et++) {
          const $ = o[et] & 255
          ;(g &&
            (m > 0
              ? $ & 128
                ? m--
                : (g = !1)
              : $ & 128 &&
                ($ & 64
                  ? (m++, $ & 32 ? (m++, $ & 16 ? (m++, $ & 8 ? (g = !1) : C++) : v++) : b++)
                  : (g = !1))),
            u &&
              ($ > 127 && $ < 160
                ? (u = !1)
                : $ > 159 && ($ < 192 || $ === 215 || $ === 247) && K++),
            d &&
              (T > 0
                ? $ < 64 || $ === 127 || $ > 252
                  ? (d = !1)
                  : T--
                : $ === 128 || $ === 160 || $ > 239
                  ? (d = !1)
                  : $ > 160 && $ < 224
                    ? (P++, (j = 0), B++, B > U && (U = B))
                    : $ > 127
                      ? (T++, (B = 0), j++, j > Y && (Y = j))
                      : ((B = 0), (j = 0))))
        }
        return (
          g && m > 0 && (g = !1),
          d && T > 0 && (d = !1),
          g && (nt || b + v + C > 0)
            ? rt.UTF8
            : d && (rt.ASSUME_SHIFT_JIS || U >= 3 || Y >= 3)
              ? rt.SHIFT_JIS
              : u && d
                ? (U === 2 && P === 2) || K * 10 >= l
                  ? rt.SHIFT_JIS
                  : rt.ISO88591
                : u
                  ? rt.ISO88591
                  : d
                    ? rt.SHIFT_JIS
                    : g
                      ? rt.UTF8
                      : rt.PLATFORM_DEFAULT_ENCODING
        )
      }
      static format(o, ...a) {
        let l = -1
        function u(g, m, b, v, C, T) {
          if (g === '%%') return '%'
          if (a[++l] === void 0) return
          g = v ? parseInt(v.substr(1)) : void 0
          let P = C ? parseInt(C.substr(1)) : void 0,
            B
          switch (T) {
            case 's':
              B = a[l]
              break
            case 'c':
              B = a[l][0]
              break
            case 'f':
              B = parseFloat(a[l]).toFixed(g)
              break
            case 'p':
              B = parseFloat(a[l]).toPrecision(g)
              break
            case 'e':
              B = parseFloat(a[l]).toExponential(g)
              break
            case 'x':
              B = parseInt(a[l]).toString(P || 16)
              break
            case 'd':
              B = parseFloat(parseInt(a[l], P || 10).toPrecision(g)).toFixed(0)
              break
          }
          B = typeof B == 'object' ? JSON.stringify(B) : (+B).toString(P)
          let j = parseInt(b),
            U = b && b[0] + '' == '0' ? '0' : ' '
          for (; B.length < j; ) B = m !== void 0 ? B + U : U + B
          return B
        }
        let d = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g
        return o.replace(d, u)
      }
      static getBytes(o, a) {
        return st.encode(o, a)
      }
      static getCharCode(o, a = 0) {
        return o.charCodeAt(a)
      }
      static getCharAt(o) {
        return String.fromCharCode(o)
      }
    }
    ;((rt.SHIFT_JIS = Z.SJIS.getName()),
      (rt.GB2312 = 'GB2312'),
      (rt.ISO88591 = Z.ISO8859_1.getName()),
      (rt.EUC_JP = 'EUC_JP'),
      (rt.UTF8 = Z.UTF8.getName()),
      (rt.PLATFORM_DEFAULT_ENCODING = rt.UTF8),
      (rt.ASSUME_SHIFT_JIS = !1))
    class vt {
      constructor(o = '') {
        this.value = o
      }
      enableDecoding(o) {
        return ((this.encoding = o), this)
      }
      append(o) {
        return (
          typeof o == 'string'
            ? (this.value += o.toString())
            : this.encoding
              ? (this.value += rt.castAsNonUtf8Char(o, this.encoding))
              : (this.value += String.fromCharCode(o)),
          this
        )
      }
      appendChars(o, a, l) {
        for (let u = a; a < a + l; u++) this.append(o[u])
        return this
      }
      length() {
        return this.value.length
      }
      charAt(o) {
        return this.value.charAt(o)
      }
      deleteCharAt(o) {
        this.value = this.value.substr(0, o) + this.value.substring(o + 1)
      }
      setCharAt(o, a) {
        this.value = this.value.substr(0, o) + a + this.value.substr(o + 1)
      }
      substring(o, a) {
        return this.value.substring(o, a)
      }
      setLengthToZero() {
        this.value = ''
      }
      toString() {
        return this.value
      }
      insert(o, a) {
        this.value = this.value.substr(0, o) + a + this.value.substr(o + a.length)
      }
    }
    class _t {
      constructor(o, a, l, u) {
        if (
          ((this.width = o),
          (this.height = a),
          (this.rowSize = l),
          (this.bits = u),
          a == null && (a = o),
          (this.height = a),
          o < 1 || a < 1)
        )
          throw new w('Both dimensions must be greater than 0')
        ;(l == null && (l = Math.floor((o + 31) / 32)),
          (this.rowSize = l),
          u == null && (this.bits = new Int32Array(this.rowSize * this.height)))
      }
      static parseFromBooleanArray(o) {
        const a = o.length,
          l = o[0].length,
          u = new _t(l, a)
        for (let d = 0; d < a; d++) {
          const g = o[d]
          for (let m = 0; m < l; m++) g[m] && u.set(m, d)
        }
        return u
      }
      static parseFromString(o, a, l) {
        if (o === null) throw new w('stringRepresentation cannot be null')
        const u = new Array(o.length)
        let d = 0,
          g = 0,
          m = -1,
          b = 0,
          v = 0
        for (; v < o.length; )
          if (
            o.charAt(v) ===
              `
` ||
            o.charAt(v) === '\r'
          ) {
            if (d > g) {
              if (m === -1) m = d - g
              else if (d - g !== m) throw new w('row lengths do not match')
              ;((g = d), b++)
            }
            v++
          } else if (o.substring(v, v + a.length) === a) ((v += a.length), (u[d] = !0), d++)
          else if (o.substring(v, v + l.length) === l) ((v += l.length), (u[d] = !1), d++)
          else throw new w('illegal character encountered: ' + o.substring(v))
        if (d > g) {
          if (m === -1) m = d - g
          else if (d - g !== m) throw new w('row lengths do not match')
          b++
        }
        const C = new _t(m, b)
        for (let T = 0; T < d; T++) u[T] && C.set(Math.floor(T % m), Math.floor(T / m))
        return C
      }
      get(o, a) {
        const l = a * this.rowSize + Math.floor(o / 32)
        return ((this.bits[l] >>> (o & 31)) & 1) !== 0
      }
      set(o, a) {
        const l = a * this.rowSize + Math.floor(o / 32)
        this.bits[l] |= (1 << (o & 31)) & 4294967295
      }
      unset(o, a) {
        const l = a * this.rowSize + Math.floor(o / 32)
        this.bits[l] &= ~((1 << (o & 31)) & 4294967295)
      }
      flip(o, a) {
        const l = a * this.rowSize + Math.floor(o / 32)
        this.bits[l] ^= (1 << (o & 31)) & 4294967295
      }
      xor(o) {
        if (
          this.width !== o.getWidth() ||
          this.height !== o.getHeight() ||
          this.rowSize !== o.getRowSize()
        )
          throw new w('input matrix dimensions do not match')
        const a = new O(Math.floor(this.width / 32) + 1),
          l = this.rowSize,
          u = this.bits
        for (let d = 0, g = this.height; d < g; d++) {
          const m = d * l,
            b = o.getRow(d, a).getBitArray()
          for (let v = 0; v < l; v++) u[m + v] ^= b[v]
        }
      }
      clear() {
        const o = this.bits,
          a = o.length
        for (let l = 0; l < a; l++) o[l] = 0
      }
      setRegion(o, a, l, u) {
        if (a < 0 || o < 0) throw new w('Left and top must be nonnegative')
        if (u < 1 || l < 1) throw new w('Height and width must be at least 1')
        const d = o + l,
          g = a + u
        if (g > this.height || d > this.width) throw new w('The region must fit inside the matrix')
        const m = this.rowSize,
          b = this.bits
        for (let v = a; v < g; v++) {
          const C = v * m
          for (let T = o; T < d; T++) b[C + Math.floor(T / 32)] |= (1 << (T & 31)) & 4294967295
        }
      }
      getRow(o, a) {
        a == null || a.getSize() < this.width ? (a = new O(this.width)) : a.clear()
        const l = this.rowSize,
          u = this.bits,
          d = o * l
        for (let g = 0; g < l; g++) a.setBulk(g * 32, u[d + g])
        return a
      }
      setRow(o, a) {
        k.arraycopy(a.getBitArray(), 0, this.bits, o * this.rowSize, this.rowSize)
      }
      rotate180() {
        const o = this.getWidth(),
          a = this.getHeight()
        let l = new O(o),
          u = new O(o)
        for (let d = 0, g = Math.floor((a + 1) / 2); d < g; d++)
          ((l = this.getRow(d, l)),
            (u = this.getRow(a - 1 - d, u)),
            l.reverse(),
            u.reverse(),
            this.setRow(d, u),
            this.setRow(a - 1 - d, l))
      }
      getEnclosingRectangle() {
        const o = this.width,
          a = this.height,
          l = this.rowSize,
          u = this.bits
        let d = o,
          g = a,
          m = -1,
          b = -1
        for (let v = 0; v < a; v++)
          for (let C = 0; C < l; C++) {
            const T = u[v * l + C]
            if (T !== 0) {
              if ((v < g && (g = v), v > b && (b = v), C * 32 < d)) {
                let P = 0
                for (; !((T << (31 - P)) & 4294967295); ) P++
                C * 32 + P < d && (d = C * 32 + P)
              }
              if (C * 32 + 31 > m) {
                let P = 31
                for (; !(T >>> P); ) P--
                C * 32 + P > m && (m = C * 32 + P)
              }
            }
          }
        return m < d || b < g ? null : Int32Array.from([d, g, m - d + 1, b - g + 1])
      }
      getTopLeftOnBit() {
        const o = this.rowSize,
          a = this.bits
        let l = 0
        for (; l < a.length && a[l] === 0; ) l++
        if (l === a.length) return null
        const u = l / o
        let d = (l % o) * 32
        const g = a[l]
        let m = 0
        for (; !((g << (31 - m)) & 4294967295); ) m++
        return ((d += m), Int32Array.from([d, u]))
      }
      getBottomRightOnBit() {
        const o = this.rowSize,
          a = this.bits
        let l = a.length - 1
        for (; l >= 0 && a[l] === 0; ) l--
        if (l < 0) return null
        const u = Math.floor(l / o)
        let d = Math.floor(l % o) * 32
        const g = a[l]
        let m = 31
        for (; !(g >>> m); ) m--
        return ((d += m), Int32Array.from([d, u]))
      }
      getWidth() {
        return this.width
      }
      getHeight() {
        return this.height
      }
      getRowSize() {
        return this.rowSize
      }
      equals(o) {
        if (!(o instanceof _t)) return !1
        const a = o
        return (
          this.width === a.width &&
          this.height === a.height &&
          this.rowSize === a.rowSize &&
          N.equals(this.bits, a.bits)
        )
      }
      hashCode() {
        let o = this.width
        return (
          (o = 31 * o + this.width),
          (o = 31 * o + this.height),
          (o = 31 * o + this.rowSize),
          (o = 31 * o + N.hashCode(this.bits)),
          o
        )
      }
      toString(
        o = 'X ',
        a = '  ',
        l = `
`
      ) {
        return this.buildToString(o, a, l)
      }
      buildToString(o, a, l) {
        let u = new vt()
        for (let d = 0, g = this.height; d < g; d++) {
          for (let m = 0, b = this.width; m < b; m++) u.append(this.get(m, d) ? o : a)
          u.append(l)
        }
        return u.toString()
      }
      clone() {
        return new _t(this.width, this.height, this.rowSize, this.bits.slice())
      }
    }
    class H extends p {
      static getNotFoundInstance() {
        return new H()
      }
    }
    H.kind = 'NotFoundException'
    class xt extends S {
      constructor(o) {
        ;(super(o),
          (this.luminances = xt.EMPTY),
          (this.buckets = new Int32Array(xt.LUMINANCE_BUCKETS)))
      }
      getBlackRow(o, a) {
        const l = this.getLuminanceSource(),
          u = l.getWidth()
        ;(a == null || a.getSize() < u ? (a = new O(u)) : a.clear(), this.initArrays(u))
        const d = l.getRow(o, this.luminances),
          g = this.buckets
        for (let b = 0; b < u; b++) g[(d[b] & 255) >> xt.LUMINANCE_SHIFT]++
        const m = xt.estimateBlackPoint(g)
        if (u < 3) for (let b = 0; b < u; b++) (d[b] & 255) < m && a.set(b)
        else {
          let b = d[0] & 255,
            v = d[1] & 255
          for (let C = 1; C < u - 1; C++) {
            const T = d[C + 1] & 255
            ;((v * 4 - b - T) / 2 < m && a.set(C), (b = v), (v = T))
          }
        }
        return a
      }
      getBlackMatrix() {
        const o = this.getLuminanceSource(),
          a = o.getWidth(),
          l = o.getHeight(),
          u = new _t(a, l)
        this.initArrays(a)
        const d = this.buckets
        for (let b = 1; b < 5; b++) {
          const v = Math.floor((l * b) / 5),
            C = o.getRow(v, this.luminances),
            T = Math.floor((a * 4) / 5)
          for (let P = Math.floor(a / 5); P < T; P++) {
            const B = C[P] & 255
            d[B >> xt.LUMINANCE_SHIFT]++
          }
        }
        const g = xt.estimateBlackPoint(d),
          m = o.getMatrix()
        for (let b = 0; b < l; b++) {
          const v = b * a
          for (let C = 0; C < a; C++) (m[v + C] & 255) < g && u.set(C, b)
        }
        return u
      }
      createBinarizer(o) {
        return new xt(o)
      }
      initArrays(o) {
        this.luminances.length < o && (this.luminances = new Uint8ClampedArray(o))
        const a = this.buckets
        for (let l = 0; l < xt.LUMINANCE_BUCKETS; l++) a[l] = 0
      }
      static estimateBlackPoint(o) {
        const a = o.length
        let l = 0,
          u = 0,
          d = 0
        for (let C = 0; C < a; C++) (o[C] > d && ((u = C), (d = o[C])), o[C] > l && (l = o[C]))
        let g = 0,
          m = 0
        for (let C = 0; C < a; C++) {
          const T = C - u,
            P = o[C] * T * T
          P > m && ((g = C), (m = P))
        }
        if (u > g) {
          const C = u
          ;((u = g), (g = C))
        }
        if (g - u <= a / 16) throw new H()
        let b = g - 1,
          v = -1
        for (let C = g - 1; C > u; C--) {
          const T = C - u,
            P = T * T * (g - C) * (l - o[C])
          P > v && ((b = C), (v = P))
        }
        return b << xt.LUMINANCE_SHIFT
      }
    }
    ;((xt.LUMINANCE_BITS = 5),
      (xt.LUMINANCE_SHIFT = 8 - xt.LUMINANCE_BITS),
      (xt.LUMINANCE_BUCKETS = 1 << xt.LUMINANCE_BITS),
      (xt.EMPTY = Uint8ClampedArray.from([0])))
    class gt extends xt {
      constructor(o) {
        ;(super(o), (this.matrix = null))
      }
      getBlackMatrix() {
        if (this.matrix !== null) return this.matrix
        const o = this.getLuminanceSource(),
          a = o.getWidth(),
          l = o.getHeight()
        if (a >= gt.MINIMUM_DIMENSION && l >= gt.MINIMUM_DIMENSION) {
          const u = o.getMatrix()
          let d = a >> gt.BLOCK_SIZE_POWER
          a & gt.BLOCK_SIZE_MASK && d++
          let g = l >> gt.BLOCK_SIZE_POWER
          l & gt.BLOCK_SIZE_MASK && g++
          const m = gt.calculateBlackPoints(u, d, g, a, l),
            b = new _t(a, l)
          ;(gt.calculateThresholdForBlock(u, d, g, a, l, m, b), (this.matrix = b))
        } else this.matrix = super.getBlackMatrix()
        return this.matrix
      }
      createBinarizer(o) {
        return new gt(o)
      }
      static calculateThresholdForBlock(o, a, l, u, d, g, m) {
        const b = d - gt.BLOCK_SIZE,
          v = u - gt.BLOCK_SIZE
        for (let C = 0; C < l; C++) {
          let T = C << gt.BLOCK_SIZE_POWER
          T > b && (T = b)
          const P = gt.cap(C, 2, l - 3)
          for (let B = 0; B < a; B++) {
            let j = B << gt.BLOCK_SIZE_POWER
            j > v && (j = v)
            const U = gt.cap(B, 2, a - 3)
            let Y = 0
            for (let nt = -2; nt <= 2; nt++) {
              const et = g[P + nt]
              Y += et[U - 2] + et[U - 1] + et[U] + et[U + 1] + et[U + 2]
            }
            const K = Y / 25
            gt.thresholdBlock(o, j, T, K, u, m)
          }
        }
      }
      static cap(o, a, l) {
        return o < a ? a : o > l ? l : o
      }
      static thresholdBlock(o, a, l, u, d, g) {
        for (let m = 0, b = l * d + a; m < gt.BLOCK_SIZE; m++, b += d)
          for (let v = 0; v < gt.BLOCK_SIZE; v++) (o[b + v] & 255) <= u && g.set(a + v, l + m)
      }
      static calculateBlackPoints(o, a, l, u, d) {
        const g = d - gt.BLOCK_SIZE,
          m = u - gt.BLOCK_SIZE,
          b = new Array(l)
        for (let v = 0; v < l; v++) {
          b[v] = new Int32Array(a)
          let C = v << gt.BLOCK_SIZE_POWER
          C > g && (C = g)
          for (let T = 0; T < a; T++) {
            let P = T << gt.BLOCK_SIZE_POWER
            P > m && (P = m)
            let B = 0,
              j = 255,
              U = 0
            for (let K = 0, nt = C * u + P; K < gt.BLOCK_SIZE; K++, nt += u) {
              for (let et = 0; et < gt.BLOCK_SIZE; et++) {
                const $ = o[nt + et] & 255
                ;((B += $), $ < j && (j = $), $ > U && (U = $))
              }
              if (U - j > gt.MIN_DYNAMIC_RANGE)
                for (K++, nt += u; K < gt.BLOCK_SIZE; K++, nt += u)
                  for (let et = 0; et < gt.BLOCK_SIZE; et++) B += o[nt + et] & 255
            }
            let Y = B >> (gt.BLOCK_SIZE_POWER * 2)
            if (U - j <= gt.MIN_DYNAMIC_RANGE && ((Y = j / 2), v > 0 && T > 0)) {
              const K = (b[v - 1][T] + 2 * b[v][T - 1] + b[v - 1][T - 1]) / 4
              j < K && (Y = K)
            }
            b[v][T] = Y
          }
        }
        return b
      }
    }
    ;((gt.BLOCK_SIZE_POWER = 3),
      (gt.BLOCK_SIZE = 1 << gt.BLOCK_SIZE_POWER),
      (gt.BLOCK_SIZE_MASK = gt.BLOCK_SIZE - 1),
      (gt.MINIMUM_DIMENSION = gt.BLOCK_SIZE * 5),
      (gt.MIN_DYNAMIC_RANGE = 24))
    class ot {
      constructor(o, a) {
        ;((this.width = o), (this.height = a))
      }
      getWidth() {
        return this.width
      }
      getHeight() {
        return this.height
      }
      isCropSupported() {
        return !1
      }
      crop(o, a, l, u) {
        throw new J('This luminance source does not support cropping.')
      }
      isRotateSupported() {
        return !1
      }
      rotateCounterClockwise() {
        throw new J('This luminance source does not support rotation by 90 degrees.')
      }
      rotateCounterClockwise45() {
        throw new J('This luminance source does not support rotation by 45 degrees.')
      }
      toString() {
        const o = new Uint8ClampedArray(this.width)
        let a = new vt()
        for (let l = 0; l < this.height; l++) {
          const u = this.getRow(l, o)
          for (let d = 0; d < this.width; d++) {
            const g = u[d] & 255
            let m
            ;(g < 64 ? (m = '#') : g < 128 ? (m = '+') : g < 192 ? (m = '.') : (m = ' '),
              a.append(m))
          }
          a.append(`
`)
        }
        return a.toString()
      }
    }
    class ft extends ot {
      constructor(o) {
        ;(super(o.getWidth(), o.getHeight()), (this.delegate = o))
      }
      getRow(o, a) {
        const l = this.delegate.getRow(o, a),
          u = this.getWidth()
        for (let d = 0; d < u; d++) l[d] = 255 - (l[d] & 255)
        return l
      }
      getMatrix() {
        const o = this.delegate.getMatrix(),
          a = this.getWidth() * this.getHeight(),
          l = new Uint8ClampedArray(a)
        for (let u = 0; u < a; u++) l[u] = 255 - (o[u] & 255)
        return l
      }
      isCropSupported() {
        return this.delegate.isCropSupported()
      }
      crop(o, a, l, u) {
        return new ft(this.delegate.crop(o, a, l, u))
      }
      isRotateSupported() {
        return this.delegate.isRotateSupported()
      }
      invert() {
        return this.delegate
      }
      rotateCounterClockwise() {
        return new ft(this.delegate.rotateCounterClockwise())
      }
      rotateCounterClockwise45() {
        return new ft(this.delegate.rotateCounterClockwise45())
      }
    }
    class pt extends ot {
      constructor(o) {
        ;(super(o.width, o.height),
          (this.canvas = o),
          (this.tempCanvasElement = null),
          (this.buffer = pt.makeBufferFromCanvasImageData(o)))
      }
      static makeBufferFromCanvasImageData(o) {
        const a = o.getContext('2d').getImageData(0, 0, o.width, o.height)
        return pt.toGrayscaleBuffer(a.data, o.width, o.height)
      }
      static toGrayscaleBuffer(o, a, l) {
        const u = new Uint8ClampedArray(a * l)
        for (let d = 0, g = 0, m = o.length; d < m; d += 4, g++) {
          let b
          if (o[d + 3] === 0) b = 255
          else {
            const v = o[d],
              C = o[d + 1],
              T = o[d + 2]
            b = (306 * v + 601 * C + 117 * T + 512) >> 10
          }
          u[g] = b
        }
        return u
      }
      getRow(o, a) {
        if (o < 0 || o >= this.getHeight()) throw new w('Requested row is outside the image: ' + o)
        const l = this.getWidth(),
          u = o * l
        return (
          a === null
            ? (a = this.buffer.slice(u, u + l))
            : (a.length < l && (a = new Uint8ClampedArray(l)), a.set(this.buffer.slice(u, u + l))),
          a
        )
      }
      getMatrix() {
        return this.buffer
      }
      isCropSupported() {
        return !0
      }
      crop(o, a, l, u) {
        return (super.crop(o, a, l, u), this)
      }
      isRotateSupported() {
        return !0
      }
      rotateCounterClockwise() {
        return (this.rotate(-90), this)
      }
      rotateCounterClockwise45() {
        return (this.rotate(-45), this)
      }
      getTempCanvasElement() {
        if (this.tempCanvasElement === null) {
          const o = this.canvas.ownerDocument.createElement('canvas')
          ;((o.width = this.canvas.width),
            (o.height = this.canvas.height),
            (this.tempCanvasElement = o))
        }
        return this.tempCanvasElement
      }
      rotate(o) {
        const a = this.getTempCanvasElement(),
          l = a.getContext('2d'),
          u = o * pt.DEGREE_TO_RADIANS,
          d = this.canvas.width,
          g = this.canvas.height,
          m = Math.ceil(Math.abs(Math.cos(u)) * d + Math.abs(Math.sin(u)) * g),
          b = Math.ceil(Math.abs(Math.sin(u)) * d + Math.abs(Math.cos(u)) * g)
        return (
          (a.width = m),
          (a.height = b),
          l.translate(m / 2, b / 2),
          l.rotate(u),
          l.drawImage(this.canvas, d / -2, g / -2),
          (this.buffer = pt.makeBufferFromCanvasImageData(a)),
          this
        )
      }
      invert() {
        return new ft(this)
      }
    }
    pt.DEGREE_TO_RADIANS = Math.PI / 180
    class Ut {
      constructor(o, a, l) {
        ;((this.deviceId = o),
          (this.label = a),
          (this.kind = 'videoinput'),
          (this.groupId = l || void 0))
      }
      toJSON() {
        return {
          kind: this.kind,
          groupId: this.groupId,
          deviceId: this.deviceId,
          label: this.label,
        }
      }
    }
    var St =
      ((globalThis || ha || self || window || void 0) &&
        (globalThis || ha || self || window || void 0).__awaiter) ||
      function (I, o, a, l) {
        function u(d) {
          return d instanceof a
            ? d
            : new a(function (g) {
                g(d)
              })
        }
        return new (a || (a = Promise))(function (d, g) {
          function m(C) {
            try {
              v(l.next(C))
            } catch (T) {
              g(T)
            }
          }
          function b(C) {
            try {
              v(l.throw(C))
            } catch (T) {
              g(T)
            }
          }
          function v(C) {
            C.done ? d(C.value) : u(C.value).then(m, b)
          }
          v((l = l.apply(I, o || [])).next())
        })
      }
    class Te {
      constructor(o, a = 500, l) {
        ;((this.reader = o),
          (this.timeBetweenScansMillis = a),
          (this._hints = l),
          (this._stopContinuousDecode = !1),
          (this._stopAsyncDecode = !1),
          (this._timeBetweenDecodingAttempts = 0))
      }
      get hasNavigator() {
        return typeof navigator < 'u'
      }
      get isMediaDevicesSuported() {
        return this.hasNavigator && !!navigator.mediaDevices
      }
      get canEnumerateDevices() {
        return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices)
      }
      get timeBetweenDecodingAttempts() {
        return this._timeBetweenDecodingAttempts
      }
      set timeBetweenDecodingAttempts(o) {
        this._timeBetweenDecodingAttempts = o < 0 ? 0 : o
      }
      set hints(o) {
        this._hints = o || null
      }
      get hints() {
        return this._hints
      }
      listVideoInputDevices() {
        return St(this, void 0, void 0, function* () {
          if (!this.hasNavigator)
            throw new Error("Can't enumerate devices, navigator is not present.")
          if (!this.canEnumerateDevices)
            throw new Error("Can't enumerate devices, method not supported.")
          const o = yield navigator.mediaDevices.enumerateDevices(),
            a = []
          for (const l of o) {
            const u = l.kind === 'video' ? 'videoinput' : l.kind
            if (u !== 'videoinput') continue
            const d = l.deviceId || l.id,
              g = l.label || `Video device ${a.length + 1}`,
              m = l.groupId,
              b = { deviceId: d, label: g, kind: u, groupId: m }
            a.push(b)
          }
          return a
        })
      }
      getVideoInputDevices() {
        return St(this, void 0, void 0, function* () {
          return (yield this.listVideoInputDevices()).map((o) => new Ut(o.deviceId, o.label))
        })
      }
      findDeviceById(o) {
        return St(this, void 0, void 0, function* () {
          const a = yield this.listVideoInputDevices()
          return a ? a.find((l) => l.deviceId === o) : null
        })
      }
      decodeFromInputVideoDevice(o, a) {
        return St(this, void 0, void 0, function* () {
          return yield this.decodeOnceFromVideoDevice(o, a)
        })
      }
      decodeOnceFromVideoDevice(o, a) {
        return St(this, void 0, void 0, function* () {
          this.reset()
          let l
          o ? (l = { deviceId: { exact: o } }) : (l = { facingMode: 'environment' })
          const u = { video: l }
          return yield this.decodeOnceFromConstraints(u, a)
        })
      }
      decodeOnceFromConstraints(o, a) {
        return St(this, void 0, void 0, function* () {
          const l = yield navigator.mediaDevices.getUserMedia(o)
          return yield this.decodeOnceFromStream(l, a)
        })
      }
      decodeOnceFromStream(o, a) {
        return St(this, void 0, void 0, function* () {
          this.reset()
          const l = yield this.attachStreamToVideo(o, a)
          return yield this.decodeOnce(l)
        })
      }
      decodeFromInputVideoDeviceContinuously(o, a, l) {
        return St(this, void 0, void 0, function* () {
          return yield this.decodeFromVideoDevice(o, a, l)
        })
      }
      decodeFromVideoDevice(o, a, l) {
        return St(this, void 0, void 0, function* () {
          let u
          o ? (u = { deviceId: { exact: o } }) : (u = { facingMode: 'environment' })
          const d = { video: u }
          return yield this.decodeFromConstraints(d, a, l)
        })
      }
      decodeFromConstraints(o, a, l) {
        return St(this, void 0, void 0, function* () {
          const u = yield navigator.mediaDevices.getUserMedia(o)
          return yield this.decodeFromStream(u, a, l)
        })
      }
      decodeFromStream(o, a, l) {
        return St(this, void 0, void 0, function* () {
          this.reset()
          const u = yield this.attachStreamToVideo(o, a)
          return yield this.decodeContinuously(u, l)
        })
      }
      stopAsyncDecode() {
        this._stopAsyncDecode = !0
      }
      stopContinuousDecode() {
        this._stopContinuousDecode = !0
      }
      attachStreamToVideo(o, a) {
        return St(this, void 0, void 0, function* () {
          const l = this.prepareVideoElement(a)
          return (
            this.addVideoSource(l, o),
            (this.videoElement = l),
            (this.stream = o),
            yield this.playVideoOnLoadAsync(l),
            l
          )
        })
      }
      playVideoOnLoadAsync(o) {
        return new Promise((a, l) => this.playVideoOnLoad(o, () => a()))
      }
      playVideoOnLoad(o, a) {
        ;((this.videoEndedListener = () => this.stopStreams()),
          (this.videoCanPlayListener = () => this.tryPlayVideo(o)),
          o.addEventListener('ended', this.videoEndedListener),
          o.addEventListener('canplay', this.videoCanPlayListener),
          o.addEventListener('playing', a),
          this.tryPlayVideo(o))
      }
      isVideoPlaying(o) {
        return o.currentTime > 0 && !o.paused && !o.ended && o.readyState > 2
      }
      tryPlayVideo(o) {
        return St(this, void 0, void 0, function* () {
          if (this.isVideoPlaying(o)) {
            console.warn('Trying to play video that is already playing.')
            return
          }
          try {
            yield o.play()
          } catch {
            console.warn('It was not possible to play the video.')
          }
        })
      }
      getMediaElement(o, a) {
        const l = document.getElementById(o)
        if (!l) throw new y(`element with id '${o}' not found`)
        if (l.nodeName.toLowerCase() !== a.toLowerCase())
          throw new y(`element with id '${o}' must be an ${a} element`)
        return l
      }
      decodeFromImage(o, a) {
        if (!o && !a) throw new y('either imageElement with a src set or an url must be provided')
        return a && !o ? this.decodeFromImageUrl(a) : this.decodeFromImageElement(o)
      }
      decodeFromVideo(o, a) {
        if (!o && !a) throw new y('Either an element with a src set or an URL must be provided')
        return a && !o ? this.decodeFromVideoUrl(a) : this.decodeFromVideoElement(o)
      }
      decodeFromVideoContinuously(o, a, l) {
        if (o === void 0 && a === void 0)
          throw new y('Either an element with a src set or an URL must be provided')
        return a && !o
          ? this.decodeFromVideoUrlContinuously(a, l)
          : this.decodeFromVideoElementContinuously(o, l)
      }
      decodeFromImageElement(o) {
        if (!o) throw new y('An image element must be provided.')
        this.reset()
        const a = this.prepareImageElement(o)
        this.imageElement = a
        let l
        return (
          this.isImageLoaded(a)
            ? (l = this.decodeOnce(a, !1, !0))
            : (l = this._decodeOnLoadImage(a)),
          l
        )
      }
      decodeFromVideoElement(o) {
        const a = this._decodeFromVideoElementSetup(o)
        return this._decodeOnLoadVideo(a)
      }
      decodeFromVideoElementContinuously(o, a) {
        const l = this._decodeFromVideoElementSetup(o)
        return this._decodeOnLoadVideoContinuously(l, a)
      }
      _decodeFromVideoElementSetup(o) {
        if (!o) throw new y('A video element must be provided.')
        this.reset()
        const a = this.prepareVideoElement(o)
        return ((this.videoElement = a), a)
      }
      decodeFromImageUrl(o) {
        if (!o) throw new y('An URL must be provided.')
        this.reset()
        const a = this.prepareImageElement()
        this.imageElement = a
        const l = this._decodeOnLoadImage(a)
        return ((a.src = o), l)
      }
      decodeFromVideoUrl(o) {
        if (!o) throw new y('An URL must be provided.')
        this.reset()
        const a = this.prepareVideoElement(),
          l = this.decodeFromVideoElement(a)
        return ((a.src = o), l)
      }
      decodeFromVideoUrlContinuously(o, a) {
        if (!o) throw new y('An URL must be provided.')
        this.reset()
        const l = this.prepareVideoElement(),
          u = this.decodeFromVideoElementContinuously(l, a)
        return ((l.src = o), u)
      }
      _decodeOnLoadImage(o) {
        return new Promise((a, l) => {
          ;((this.imageLoadedListener = () => this.decodeOnce(o, !1, !0).then(a, l)),
            o.addEventListener('load', this.imageLoadedListener))
        })
      }
      _decodeOnLoadVideo(o) {
        return St(this, void 0, void 0, function* () {
          return (yield this.playVideoOnLoadAsync(o), yield this.decodeOnce(o))
        })
      }
      _decodeOnLoadVideoContinuously(o, a) {
        return St(this, void 0, void 0, function* () {
          ;(yield this.playVideoOnLoadAsync(o), this.decodeContinuously(o, a))
        })
      }
      isImageLoaded(o) {
        return !(!o.complete || o.naturalWidth === 0)
      }
      prepareImageElement(o) {
        let a
        return (
          typeof o > 'u' &&
            ((a = document.createElement('img')), (a.width = 200), (a.height = 200)),
          typeof o == 'string' && (a = this.getMediaElement(o, 'img')),
          o instanceof HTMLImageElement && (a = o),
          a
        )
      }
      prepareVideoElement(o) {
        let a
        return (
          !o &&
            typeof document < 'u' &&
            ((a = document.createElement('video')), (a.width = 200), (a.height = 200)),
          typeof o == 'string' && (a = this.getMediaElement(o, 'video')),
          o instanceof HTMLVideoElement && (a = o),
          a.setAttribute('autoplay', 'true'),
          a.setAttribute('muted', 'true'),
          a.setAttribute('playsinline', 'true'),
          a
        )
      }
      decodeOnce(o, a = !0, l = !0) {
        this._stopAsyncDecode = !1
        const u = (d, g) => {
          if (this._stopAsyncDecode) {
            ;(g(new H('Video stream has ended before any code could be detected.')),
              (this._stopAsyncDecode = void 0))
            return
          }
          try {
            const m = this.decode(o)
            d(m)
          } catch (m) {
            const b = a && m instanceof H,
              v = (m instanceof E || m instanceof V) && l
            if (b || v) return setTimeout(u, this._timeBetweenDecodingAttempts, d, g)
            g(m)
          }
        }
        return new Promise((d, g) => u(d, g))
      }
      decodeContinuously(o, a) {
        this._stopContinuousDecode = !1
        const l = () => {
          if (this._stopContinuousDecode) {
            this._stopContinuousDecode = void 0
            return
          }
          try {
            const u = this.decode(o)
            ;(a(u, null), setTimeout(l, this.timeBetweenScansMillis))
          } catch (u) {
            a(null, u)
            const d = u instanceof E || u instanceof V,
              g = u instanceof H
            ;(d || g) && setTimeout(l, this._timeBetweenDecodingAttempts)
          }
        }
        l()
      }
      decode(o) {
        const a = this.createBinaryBitmap(o)
        return this.decodeBitmap(a)
      }
      _isHTMLVideoElement(o) {
        return o.videoWidth !== 0
      }
      drawFrameOnCanvas(o, a, l) {
        ;(a ||
          (a = {
            sx: 0,
            sy: 0,
            sWidth: o.videoWidth,
            sHeight: o.videoHeight,
            dx: 0,
            dy: 0,
            dWidth: o.videoWidth,
            dHeight: o.videoHeight,
          }),
          l || (l = this.captureCanvasContext),
          l.drawImage(o, a.sx, a.sy, a.sWidth, a.sHeight, a.dx, a.dy, a.dWidth, a.dHeight))
      }
      drawImageOnCanvas(o, a, l = this.captureCanvasContext) {
        ;(a ||
          (a = {
            sx: 0,
            sy: 0,
            sWidth: o.naturalWidth,
            sHeight: o.naturalHeight,
            dx: 0,
            dy: 0,
            dWidth: o.naturalWidth,
            dHeight: o.naturalHeight,
          }),
          l || (l = this.captureCanvasContext),
          l.drawImage(o, a.sx, a.sy, a.sWidth, a.sHeight, a.dx, a.dy, a.dWidth, a.dHeight))
      }
      createBinaryBitmap(o) {
        ;(this.getCaptureCanvasContext(o),
          this._isHTMLVideoElement(o) ? this.drawFrameOnCanvas(o) : this.drawImageOnCanvas(o))
        const a = this.getCaptureCanvas(o),
          l = new pt(a),
          u = new gt(l)
        return new x(u)
      }
      getCaptureCanvasContext(o) {
        if (!this.captureCanvasContext) {
          const a = this.getCaptureCanvas(o).getContext('2d')
          this.captureCanvasContext = a
        }
        return this.captureCanvasContext
      }
      getCaptureCanvas(o) {
        if (!this.captureCanvas) {
          const a = this.createCaptureCanvas(o)
          this.captureCanvas = a
        }
        return this.captureCanvas
      }
      decodeBitmap(o) {
        return this.reader.decode(o, this._hints)
      }
      createCaptureCanvas(o) {
        if (typeof document > 'u') return (this._destroyCaptureCanvas(), null)
        const a = document.createElement('canvas')
        let l, u
        return (
          typeof o < 'u' &&
            (o instanceof HTMLVideoElement
              ? ((l = o.videoWidth), (u = o.videoHeight))
              : o instanceof HTMLImageElement &&
                ((l = o.naturalWidth || o.width), (u = o.naturalHeight || o.height))),
          (a.style.width = l + 'px'),
          (a.style.height = u + 'px'),
          (a.width = l),
          (a.height = u),
          a
        )
      }
      stopStreams() {
        ;(this.stream &&
          (this.stream.getVideoTracks().forEach((o) => o.stop()), (this.stream = void 0)),
          this._stopAsyncDecode === !1 && this.stopAsyncDecode(),
          this._stopContinuousDecode === !1 && this.stopContinuousDecode())
      }
      reset() {
        ;(this.stopStreams(),
          this._destroyVideoElement(),
          this._destroyImageElement(),
          this._destroyCaptureCanvas())
      }
      _destroyVideoElement() {
        this.videoElement &&
          (typeof this.videoEndedListener < 'u' &&
            this.videoElement.removeEventListener('ended', this.videoEndedListener),
          typeof this.videoPlayingEventListener < 'u' &&
            this.videoElement.removeEventListener('playing', this.videoPlayingEventListener),
          typeof this.videoCanPlayListener < 'u' &&
            this.videoElement.removeEventListener('loadedmetadata', this.videoCanPlayListener),
          this.cleanVideoSource(this.videoElement),
          (this.videoElement = void 0))
      }
      _destroyImageElement() {
        this.imageElement &&
          (this.imageLoadedListener !== void 0 &&
            this.imageElement.removeEventListener('load', this.imageLoadedListener),
          (this.imageElement.src = void 0),
          this.imageElement.removeAttribute('src'),
          (this.imageElement = void 0))
      }
      _destroyCaptureCanvas() {
        ;((this.captureCanvasContext = void 0), (this.captureCanvas = void 0))
      }
      addVideoSource(o, a) {
        try {
          o.srcObject = a
        } catch {
          o.src = URL.createObjectURL(a)
        }
      }
      cleanVideoSource(o) {
        try {
          o.srcObject = null
        } catch {
          o.src = ''
        }
        this.videoElement.removeAttribute('src')
      }
    }
    class Bt {
      constructor(o, a, l = a == null ? 0 : 8 * a.length, u, d, g = k.currentTimeMillis()) {
        ;((this.text = o),
          (this.rawBytes = a),
          (this.numBits = l),
          (this.resultPoints = u),
          (this.format = d),
          (this.timestamp = g),
          (this.text = o),
          (this.rawBytes = a),
          l == null ? (this.numBits = a == null ? 0 : 8 * a.length) : (this.numBits = l),
          (this.resultPoints = u),
          (this.format = d),
          (this.resultMetadata = null),
          g == null ? (this.timestamp = k.currentTimeMillis()) : (this.timestamp = g))
      }
      getText() {
        return this.text
      }
      getRawBytes() {
        return this.rawBytes
      }
      getNumBits() {
        return this.numBits
      }
      getResultPoints() {
        return this.resultPoints
      }
      getBarcodeFormat() {
        return this.format
      }
      getResultMetadata() {
        return this.resultMetadata
      }
      putMetadata(o, a) {
        ;(this.resultMetadata === null && (this.resultMetadata = new Map()),
          this.resultMetadata.set(o, a))
      }
      putAllMetadata(o) {
        o !== null &&
          (this.resultMetadata === null
            ? (this.resultMetadata = o)
            : (this.resultMetadata = new Map(o)))
      }
      addResultPoints(o) {
        const a = this.resultPoints
        if (a === null) this.resultPoints = o
        else if (o !== null && o.length > 0) {
          const l = new Array(a.length + o.length)
          ;(k.arraycopy(a, 0, l, 0, a.length),
            k.arraycopy(o, 0, l, a.length, o.length),
            (this.resultPoints = l))
        }
      }
      getTimestamp() {
        return this.timestamp
      }
      toString() {
        return this.text
      }
    }
    var Sn
    ;(function (I) {
      ;((I[(I.AZTEC = 0)] = 'AZTEC'),
        (I[(I.CODABAR = 1)] = 'CODABAR'),
        (I[(I.CODE_39 = 2)] = 'CODE_39'),
        (I[(I.CODE_93 = 3)] = 'CODE_93'),
        (I[(I.CODE_128 = 4)] = 'CODE_128'),
        (I[(I.DATA_MATRIX = 5)] = 'DATA_MATRIX'),
        (I[(I.EAN_8 = 6)] = 'EAN_8'),
        (I[(I.EAN_13 = 7)] = 'EAN_13'),
        (I[(I.ITF = 8)] = 'ITF'),
        (I[(I.MAXICODE = 9)] = 'MAXICODE'),
        (I[(I.PDF_417 = 10)] = 'PDF_417'),
        (I[(I.QR_CODE = 11)] = 'QR_CODE'),
        (I[(I.RSS_14 = 12)] = 'RSS_14'),
        (I[(I.RSS_EXPANDED = 13)] = 'RSS_EXPANDED'),
        (I[(I.UPC_A = 14)] = 'UPC_A'),
        (I[(I.UPC_E = 15)] = 'UPC_E'),
        (I[(I.UPC_EAN_EXTENSION = 16)] = 'UPC_EAN_EXTENSION'))
    })(Sn || (Sn = {}))
    var ut = Sn,
      $r
    ;(function (I) {
      ;((I[(I.OTHER = 0)] = 'OTHER'),
        (I[(I.ORIENTATION = 1)] = 'ORIENTATION'),
        (I[(I.BYTE_SEGMENTS = 2)] = 'BYTE_SEGMENTS'),
        (I[(I.ERROR_CORRECTION_LEVEL = 3)] = 'ERROR_CORRECTION_LEVEL'),
        (I[(I.ISSUE_NUMBER = 4)] = 'ISSUE_NUMBER'),
        (I[(I.SUGGESTED_PRICE = 5)] = 'SUGGESTED_PRICE'),
        (I[(I.POSSIBLE_COUNTRY = 6)] = 'POSSIBLE_COUNTRY'),
        (I[(I.UPC_EAN_EXTENSION = 7)] = 'UPC_EAN_EXTENSION'),
        (I[(I.PDF417_EXTRA_METADATA = 8)] = 'PDF417_EXTRA_METADATA'),
        (I[(I.STRUCTURED_APPEND_SEQUENCE = 9)] = 'STRUCTURED_APPEND_SEQUENCE'),
        (I[(I.STRUCTURED_APPEND_PARITY = 10)] = 'STRUCTURED_APPEND_PARITY'))
    })($r || ($r = {}))
    var Ne = $r
    class Js {
      constructor(o, a, l, u, d = -1, g = -1) {
        ;((this.rawBytes = o),
          (this.text = a),
          (this.byteSegments = l),
          (this.ecLevel = u),
          (this.structuredAppendSequenceNumber = d),
          (this.structuredAppendParity = g),
          (this.numBits = o == null ? 0 : 8 * o.length))
      }
      getRawBytes() {
        return this.rawBytes
      }
      getNumBits() {
        return this.numBits
      }
      setNumBits(o) {
        this.numBits = o
      }
      getText() {
        return this.text
      }
      getByteSegments() {
        return this.byteSegments
      }
      getECLevel() {
        return this.ecLevel
      }
      getErrorsCorrected() {
        return this.errorsCorrected
      }
      setErrorsCorrected(o) {
        this.errorsCorrected = o
      }
      getErasures() {
        return this.erasures
      }
      setErasures(o) {
        this.erasures = o
      }
      getOther() {
        return this.other
      }
      setOther(o) {
        this.other = o
      }
      hasStructuredAppend() {
        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0
      }
      getStructuredAppendParity() {
        return this.structuredAppendParity
      }
      getStructuredAppendSequenceNumber() {
        return this.structuredAppendSequenceNumber
      }
    }
    class ta {
      exp(o) {
        return this.expTable[o]
      }
      log(o) {
        if (o === 0) throw new w()
        return this.logTable[o]
      }
      static addOrSubtract(o, a) {
        return o ^ a
      }
    }
    class un {
      constructor(o, a) {
        if (a.length === 0) throw new w()
        this.field = o
        const l = a.length
        if (l > 1 && a[0] === 0) {
          let u = 1
          for (; u < l && a[u] === 0; ) u++
          u === l
            ? (this.coefficients = Int32Array.from([0]))
            : ((this.coefficients = new Int32Array(l - u)),
              k.arraycopy(a, u, this.coefficients, 0, this.coefficients.length))
        } else this.coefficients = a
      }
      getCoefficients() {
        return this.coefficients
      }
      getDegree() {
        return this.coefficients.length - 1
      }
      isZero() {
        return this.coefficients[0] === 0
      }
      getCoefficient(o) {
        return this.coefficients[this.coefficients.length - 1 - o]
      }
      evaluateAt(o) {
        if (o === 0) return this.getCoefficient(0)
        const a = this.coefficients
        let l
        if (o === 1) {
          l = 0
          for (let g = 0, m = a.length; g !== m; g++) {
            const b = a[g]
            l = ta.addOrSubtract(l, b)
          }
          return l
        }
        l = a[0]
        const u = a.length,
          d = this.field
        for (let g = 1; g < u; g++) l = ta.addOrSubtract(d.multiply(o, l), a[g])
        return l
      }
      addOrSubtract(o) {
        if (!this.field.equals(o.field))
          throw new w('GenericGFPolys do not have same GenericGF field')
        if (this.isZero()) return o
        if (o.isZero()) return this
        let a = this.coefficients,
          l = o.coefficients
        if (a.length > l.length) {
          const g = a
          ;((a = l), (l = g))
        }
        let u = new Int32Array(l.length)
        const d = l.length - a.length
        k.arraycopy(l, 0, u, 0, d)
        for (let g = d; g < l.length; g++) u[g] = ta.addOrSubtract(a[g - d], l[g])
        return new un(this.field, u)
      }
      multiply(o) {
        if (!this.field.equals(o.field))
          throw new w('GenericGFPolys do not have same GenericGF field')
        if (this.isZero() || o.isZero()) return this.field.getZero()
        const a = this.coefficients,
          l = a.length,
          u = o.coefficients,
          d = u.length,
          g = new Int32Array(l + d - 1),
          m = this.field
        for (let b = 0; b < l; b++) {
          const v = a[b]
          for (let C = 0; C < d; C++) g[b + C] = ta.addOrSubtract(g[b + C], m.multiply(v, u[C]))
        }
        return new un(m, g)
      }
      multiplyScalar(o) {
        if (o === 0) return this.field.getZero()
        if (o === 1) return this
        const a = this.coefficients.length,
          l = this.field,
          u = new Int32Array(a),
          d = this.coefficients
        for (let g = 0; g < a; g++) u[g] = l.multiply(d[g], o)
        return new un(l, u)
      }
      multiplyByMonomial(o, a) {
        if (o < 0) throw new w()
        if (a === 0) return this.field.getZero()
        const l = this.coefficients,
          u = l.length,
          d = new Int32Array(u + o),
          g = this.field
        for (let m = 0; m < u; m++) d[m] = g.multiply(l[m], a)
        return new un(g, d)
      }
      divide(o) {
        if (!this.field.equals(o.field))
          throw new w('GenericGFPolys do not have same GenericGF field')
        if (o.isZero()) throw new w('Divide by 0')
        const a = this.field
        let l = a.getZero(),
          u = this
        const d = o.getCoefficient(o.getDegree()),
          g = a.inverse(d)
        for (; u.getDegree() >= o.getDegree() && !u.isZero(); ) {
          const m = u.getDegree() - o.getDegree(),
            b = a.multiply(u.getCoefficient(u.getDegree()), g),
            v = o.multiplyByMonomial(m, b),
            C = a.buildMonomial(m, b)
          ;((l = l.addOrSubtract(C)), (u = u.addOrSubtract(v)))
        }
        return [l, u]
      }
      toString() {
        let o = ''
        for (let a = this.getDegree(); a >= 0; a--) {
          let l = this.getCoefficient(a)
          if (l !== 0) {
            if (
              (l < 0 ? ((o += ' - '), (l = -l)) : o.length > 0 && (o += ' + '), a === 0 || l !== 1)
            ) {
              const u = this.field.log(l)
              u === 0 ? (o += '1') : u === 1 ? (o += 'a') : ((o += 'a^'), (o += u))
            }
            a !== 0 && (a === 1 ? (o += 'x') : ((o += 'x^'), (o += a)))
          }
        }
        return o
      }
    }
    class zl extends p {}
    zl.kind = 'ArithmeticException'
    class Ft extends ta {
      constructor(o, a, l) {
        ;(super(), (this.primitive = o), (this.size = a), (this.generatorBase = l))
        const u = new Int32Array(a)
        let d = 1
        for (let m = 0; m < a; m++) ((u[m] = d), (d *= 2), d >= a && ((d ^= o), (d &= a - 1)))
        this.expTable = u
        const g = new Int32Array(a)
        for (let m = 0; m < a - 1; m++) g[u[m]] = m
        ;((this.logTable = g),
          (this.zero = new un(this, Int32Array.from([0]))),
          (this.one = new un(this, Int32Array.from([1]))))
      }
      getZero() {
        return this.zero
      }
      getOne() {
        return this.one
      }
      buildMonomial(o, a) {
        if (o < 0) throw new w()
        if (a === 0) return this.zero
        const l = new Int32Array(o + 1)
        return ((l[0] = a), new un(this, l))
      }
      inverse(o) {
        if (o === 0) throw new zl()
        return this.expTable[this.size - this.logTable[o] - 1]
      }
      multiply(o, a) {
        return o === 0 || a === 0
          ? 0
          : this.expTable[(this.logTable[o] + this.logTable[a]) % (this.size - 1)]
      }
      getSize() {
        return this.size
      }
      getGeneratorBase() {
        return this.generatorBase
      }
      toString() {
        return 'GF(0x' + M.toHexString(this.primitive) + ',' + this.size + ')'
      }
      equals(o) {
        return o === this
      }
    }
    ;((Ft.AZTEC_DATA_12 = new Ft(4201, 4096, 1)),
      (Ft.AZTEC_DATA_10 = new Ft(1033, 1024, 1)),
      (Ft.AZTEC_DATA_6 = new Ft(67, 64, 1)),
      (Ft.AZTEC_PARAM = new Ft(19, 16, 1)),
      (Ft.QR_CODE_FIELD_256 = new Ft(285, 256, 0)),
      (Ft.DATA_MATRIX_FIELD_256 = new Ft(301, 256, 1)),
      (Ft.AZTEC_DATA_8 = Ft.DATA_MATRIX_FIELD_256),
      (Ft.MAXICODE_FIELD_64 = Ft.AZTEC_DATA_6))
    class Xo extends p {}
    Xo.kind = 'ReedSolomonException'
    class dr extends p {}
    dr.kind = 'IllegalStateException'
    class ea {
      constructor(o) {
        this.field = o
      }
      decode(o, a) {
        const l = this.field,
          u = new un(l, o),
          d = new Int32Array(a)
        let g = !0
        for (let B = 0; B < a; B++) {
          const j = u.evaluateAt(l.exp(B + l.getGeneratorBase()))
          ;((d[d.length - 1 - B] = j), j !== 0 && (g = !1))
        }
        if (g) return
        const m = new un(l, d),
          b = this.runEuclideanAlgorithm(l.buildMonomial(a, 1), m, a),
          v = b[0],
          C = b[1],
          T = this.findErrorLocations(v),
          P = this.findErrorMagnitudes(C, T)
        for (let B = 0; B < T.length; B++) {
          const j = o.length - 1 - l.log(T[B])
          if (j < 0) throw new Xo('Bad error location')
          o[j] = Ft.addOrSubtract(o[j], P[B])
        }
      }
      runEuclideanAlgorithm(o, a, l) {
        if (o.getDegree() < a.getDegree()) {
          const B = o
          ;((o = a), (a = B))
        }
        const u = this.field
        let d = o,
          g = a,
          m = u.getZero(),
          b = u.getOne()
        for (; g.getDegree() >= ((l / 2) | 0); ) {
          let B = d,
            j = m
          if (((d = g), (m = b), d.isZero())) throw new Xo('r_{i-1} was zero')
          g = B
          let U = u.getZero()
          const Y = d.getCoefficient(d.getDegree()),
            K = u.inverse(Y)
          for (; g.getDegree() >= d.getDegree() && !g.isZero(); ) {
            const nt = g.getDegree() - d.getDegree(),
              et = u.multiply(g.getCoefficient(g.getDegree()), K)
            ;((U = U.addOrSubtract(u.buildMonomial(nt, et))),
              (g = g.addOrSubtract(d.multiplyByMonomial(nt, et))))
          }
          if (((b = U.multiply(m).addOrSubtract(j)), g.getDegree() >= d.getDegree()))
            throw new dr('Division algorithm failed to reduce polynomial?')
        }
        const v = b.getCoefficient(0)
        if (v === 0) throw new Xo('sigmaTilde(0) was zero')
        const C = u.inverse(v),
          T = b.multiplyScalar(C),
          P = g.multiplyScalar(C)
        return [T, P]
      }
      findErrorLocations(o) {
        const a = o.getDegree()
        if (a === 1) return Int32Array.from([o.getCoefficient(1)])
        const l = new Int32Array(a)
        let u = 0
        const d = this.field
        for (let g = 1; g < d.getSize() && u < a; g++)
          o.evaluateAt(g) === 0 && ((l[u] = d.inverse(g)), u++)
        if (u !== a) throw new Xo('Error locator degree does not match number of roots')
        return l
      }
      findErrorMagnitudes(o, a) {
        const l = a.length,
          u = new Int32Array(l),
          d = this.field
        for (let g = 0; g < l; g++) {
          const m = d.inverse(a[g])
          let b = 1
          for (let v = 0; v < l; v++)
            if (g !== v) {
              const C = d.multiply(a[v], m),
                T = C & 1 ? C & -2 : C | 1
              b = d.multiply(b, T)
            }
          ;((u[g] = d.multiply(o.evaluateAt(m), d.inverse(b))),
            d.getGeneratorBase() !== 0 && (u[g] = d.multiply(u[g], m)))
        }
        return u
      }
    }
    var Fe
    ;(function (I) {
      ;((I[(I.UPPER = 0)] = 'UPPER'),
        (I[(I.LOWER = 1)] = 'LOWER'),
        (I[(I.MIXED = 2)] = 'MIXED'),
        (I[(I.DIGIT = 3)] = 'DIGIT'),
        (I[(I.PUNCT = 4)] = 'PUNCT'),
        (I[(I.BINARY = 5)] = 'BINARY'))
    })(Fe || (Fe = {}))
    class qt {
      decode(o) {
        this.ddata = o
        let a = o.getBits(),
          l = this.extractBits(a),
          u = this.correctBits(l),
          d = qt.convertBoolArrayToByteArray(u),
          g = qt.getEncodedData(u),
          m = new Js(d, g, null, null)
        return (m.setNumBits(u.length), m)
      }
      static highLevelDecode(o) {
        return this.getEncodedData(o)
      }
      static getEncodedData(o) {
        let a = o.length,
          l = Fe.UPPER,
          u = Fe.UPPER,
          d = '',
          g = 0
        for (; g < a; )
          if (u === Fe.BINARY) {
            if (a - g < 5) break
            let m = qt.readCode(o, g, 5)
            if (((g += 5), m === 0)) {
              if (a - g < 11) break
              ;((m = qt.readCode(o, g, 11) + 31), (g += 11))
            }
            for (let b = 0; b < m; b++) {
              if (a - g < 8) {
                g = a
                break
              }
              const v = qt.readCode(o, g, 8)
              ;((d += rt.castAsNonUtf8Char(v)), (g += 8))
            }
            u = l
          } else {
            let m = u === Fe.DIGIT ? 4 : 5
            if (a - g < m) break
            let b = qt.readCode(o, g, m)
            g += m
            let v = qt.getCharacter(u, b)
            v.startsWith('CTRL_')
              ? ((l = u), (u = qt.getTable(v.charAt(5))), v.charAt(6) === 'L' && (l = u))
              : ((d += v), (u = l))
          }
        return d
      }
      static getTable(o) {
        switch (o) {
          case 'L':
            return Fe.LOWER
          case 'P':
            return Fe.PUNCT
          case 'M':
            return Fe.MIXED
          case 'D':
            return Fe.DIGIT
          case 'B':
            return Fe.BINARY
          case 'U':
          default:
            return Fe.UPPER
        }
      }
      static getCharacter(o, a) {
        switch (o) {
          case Fe.UPPER:
            return qt.UPPER_TABLE[a]
          case Fe.LOWER:
            return qt.LOWER_TABLE[a]
          case Fe.MIXED:
            return qt.MIXED_TABLE[a]
          case Fe.PUNCT:
            return qt.PUNCT_TABLE[a]
          case Fe.DIGIT:
            return qt.DIGIT_TABLE[a]
          default:
            throw new dr('Bad table')
        }
      }
      correctBits(o) {
        let a, l
        this.ddata.getNbLayers() <= 2
          ? ((l = 6), (a = Ft.AZTEC_DATA_6))
          : this.ddata.getNbLayers() <= 8
            ? ((l = 8), (a = Ft.AZTEC_DATA_8))
            : this.ddata.getNbLayers() <= 22
              ? ((l = 10), (a = Ft.AZTEC_DATA_10))
              : ((l = 12), (a = Ft.AZTEC_DATA_12))
        let u = this.ddata.getNbDatablocks(),
          d = o.length / l
        if (d < u) throw new V()
        let g = o.length % l,
          m = new Int32Array(d)
        for (let P = 0; P < d; P++, g += l) m[P] = qt.readCode(o, g, l)
        try {
          new ea(a).decode(m, d - u)
        } catch (P) {
          throw new V(P)
        }
        let b = (1 << l) - 1,
          v = 0
        for (let P = 0; P < u; P++) {
          let B = m[P]
          if (B === 0 || B === b) throw new V()
          ;(B === 1 || B === b - 1) && v++
        }
        let C = new Array(u * l - v),
          T = 0
        for (let P = 0; P < u; P++) {
          let B = m[P]
          if (B === 1 || B === b - 1) (C.fill(B > 1, T, T + l - 1), (T += l - 1))
          else for (let j = l - 1; j >= 0; --j) C[T++] = (B & (1 << j)) !== 0
        }
        return C
      }
      extractBits(o) {
        let a = this.ddata.isCompact(),
          l = this.ddata.getNbLayers(),
          u = (a ? 11 : 14) + l * 4,
          d = new Int32Array(u),
          g = new Array(this.totalBitsInLayer(l, a))
        if (a) for (let m = 0; m < d.length; m++) d[m] = m
        else {
          let m = u + 1 + 2 * M.truncDivision(M.truncDivision(u, 2) - 1, 15),
            b = u / 2,
            v = M.truncDivision(m, 2)
          for (let C = 0; C < b; C++) {
            let T = C + M.truncDivision(C, 15)
            ;((d[b - C - 1] = v - T - 1), (d[b + C] = v + T + 1))
          }
        }
        for (let m = 0, b = 0; m < l; m++) {
          let v = (l - m) * 4 + (a ? 9 : 12),
            C = m * 2,
            T = u - 1 - C
          for (let P = 0; P < v; P++) {
            let B = P * 2
            for (let j = 0; j < 2; j++)
              ((g[b + B + j] = o.get(d[C + j], d[C + P])),
                (g[b + 2 * v + B + j] = o.get(d[C + P], d[T - j])),
                (g[b + 4 * v + B + j] = o.get(d[T - j], d[T - P])),
                (g[b + 6 * v + B + j] = o.get(d[T - P], d[C + j])))
          }
          b += v * 8
        }
        return g
      }
      static readCode(o, a, l) {
        let u = 0
        for (let d = a; d < a + l; d++) ((u <<= 1), o[d] && (u |= 1))
        return u
      }
      static readByte(o, a) {
        let l = o.length - a
        return l >= 8 ? qt.readCode(o, a, 8) : qt.readCode(o, a, l) << (8 - l)
      }
      static convertBoolArrayToByteArray(o) {
        let a = new Uint8Array((o.length + 7) / 8)
        for (let l = 0; l < a.length; l++) a[l] = qt.readByte(o, 8 * l)
        return a
      }
      totalBitsInLayer(o, a) {
        return ((a ? 88 : 112) + 16 * o) * o
      }
    }
    ;((qt.UPPER_TABLE = [
      'CTRL_PS',
      ' ',
      'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
      'CTRL_LL',
      'CTRL_ML',
      'CTRL_DL',
      'CTRL_BS',
    ]),
      (qt.LOWER_TABLE = [
        'CTRL_PS',
        ' ',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'CTRL_US',
        'CTRL_ML',
        'CTRL_DL',
        'CTRL_BS',
      ]),
      (qt.MIXED_TABLE = [
        'CTRL_PS',
        ' ',
        '\\1',
        '\\2',
        '\\3',
        '\\4',
        '\\5',
        '\\6',
        '\\7',
        '\b',
        '	',
        `
`,
        '\\13',
        '\f',
        '\r',
        '\\33',
        '\\34',
        '\\35',
        '\\36',
        '\\37',
        '@',
        '\\',
        '^',
        '_',
        '`',
        '|',
        '~',
        '\\177',
        'CTRL_LL',
        'CTRL_UL',
        'CTRL_PL',
        'CTRL_BS',
      ]),
      (qt.PUNCT_TABLE = [
        '',
        '\r',
        `\r
`,
        '. ',
        ', ',
        ': ',
        '!',
        '"',
        '#',
        '$',
        '%',
        '&',
        "'",
        '(',
        ')',
        '*',
        '+',
        ',',
        '-',
        '.',
        '/',
        ':',
        ';',
        '<',
        '=',
        '>',
        '?',
        '[',
        ']',
        '{',
        '}',
        'CTRL_UL',
      ]),
      (qt.DIGIT_TABLE = [
        'CTRL_PS',
        ' ',
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9',
        ',',
        '.',
        'CTRL_UL',
        'CTRL_US',
      ]))
    class Dt {
      constructor() {}
      static round(o) {
        return o === NaN
          ? 0
          : o <= Number.MIN_SAFE_INTEGER
            ? Number.MIN_SAFE_INTEGER
            : o >= Number.MAX_SAFE_INTEGER
              ? Number.MAX_SAFE_INTEGER
              : (o + (o < 0 ? -0.5 : 0.5)) | 0
      }
      static distance(o, a, l, u) {
        const d = o - l,
          g = a - u
        return Math.sqrt(d * d + g * g)
      }
      static sum(o) {
        let a = 0
        for (let l = 0, u = o.length; l !== u; l++) {
          const d = o[l]
          a += d
        }
        return a
      }
    }
    class Hl {
      static floatToIntBits(o) {
        return o
      }
    }
    Hl.MAX_VALUE = Number.MAX_SAFE_INTEGER
    class ht {
      constructor(o, a) {
        ;((this.x = o), (this.y = a))
      }
      getX() {
        return this.x
      }
      getY() {
        return this.y
      }
      equals(o) {
        if (o instanceof ht) {
          const a = o
          return this.x === a.x && this.y === a.y
        }
        return !1
      }
      hashCode() {
        return 31 * Hl.floatToIntBits(this.x) + Hl.floatToIntBits(this.y)
      }
      toString() {
        return '(' + this.x + ',' + this.y + ')'
      }
      static orderBestPatterns(o) {
        const a = this.distance(o[0], o[1]),
          l = this.distance(o[1], o[2]),
          u = this.distance(o[0], o[2])
        let d, g, m
        if (
          (l >= a && l >= u
            ? ((g = o[0]), (d = o[1]), (m = o[2]))
            : u >= l && u >= a
              ? ((g = o[1]), (d = o[0]), (m = o[2]))
              : ((g = o[2]), (d = o[0]), (m = o[1])),
          this.crossProductZ(d, g, m) < 0)
        ) {
          const b = d
          ;((d = m), (m = b))
        }
        ;((o[0] = d), (o[1] = g), (o[2] = m))
      }
      static distance(o, a) {
        return Dt.distance(o.x, o.y, a.x, a.y)
      }
      static crossProductZ(o, a, l) {
        const u = a.x,
          d = a.y
        return (l.x - u) * (o.y - d) - (l.y - d) * (o.x - u)
      }
    }
    class Xl {
      constructor(o, a) {
        ;((this.bits = o), (this.points = a))
      }
      getBits() {
        return this.bits
      }
      getPoints() {
        return this.points
      }
    }
    class wp extends Xl {
      constructor(o, a, l, u, d) {
        ;(super(o, a), (this.compact = l), (this.nbDatablocks = u), (this.nbLayers = d))
      }
      getNbLayers() {
        return this.nbLayers
      }
      getNbDatablocks() {
        return this.nbDatablocks
      }
      isCompact() {
        return this.compact
      }
    }
    class Tr {
      constructor(o, a, l, u) {
        ;((this.image = o),
          (this.height = o.getHeight()),
          (this.width = o.getWidth()),
          a == null && (a = Tr.INIT_SIZE),
          l == null && (l = (o.getWidth() / 2) | 0),
          u == null && (u = (o.getHeight() / 2) | 0))
        const d = (a / 2) | 0
        if (
          ((this.leftInit = l - d),
          (this.rightInit = l + d),
          (this.upInit = u - d),
          (this.downInit = u + d),
          this.upInit < 0 ||
            this.leftInit < 0 ||
            this.downInit >= this.height ||
            this.rightInit >= this.width)
        )
          throw new H()
      }
      detect() {
        let o = this.leftInit,
          a = this.rightInit,
          l = this.upInit,
          u = this.downInit,
          d = !1,
          g = !0,
          m = !1,
          b = !1,
          v = !1,
          C = !1,
          T = !1
        const P = this.width,
          B = this.height
        for (; g; ) {
          g = !1
          let j = !0
          for (; (j || !b) && a < P; )
            ((j = this.containsBlackPoint(l, u, a, !1)), j ? (a++, (g = !0), (b = !0)) : b || a++)
          if (a >= P) {
            d = !0
            break
          }
          let U = !0
          for (; (U || !v) && u < B; )
            ((U = this.containsBlackPoint(o, a, u, !0)), U ? (u++, (g = !0), (v = !0)) : v || u++)
          if (u >= B) {
            d = !0
            break
          }
          let Y = !0
          for (; (Y || !C) && o >= 0; )
            ((Y = this.containsBlackPoint(l, u, o, !1)), Y ? (o--, (g = !0), (C = !0)) : C || o--)
          if (o < 0) {
            d = !0
            break
          }
          let K = !0
          for (; (K || !T) && l >= 0; )
            ((K = this.containsBlackPoint(o, a, l, !0)), K ? (l--, (g = !0), (T = !0)) : T || l--)
          if (l < 0) {
            d = !0
            break
          }
          g && (m = !0)
        }
        if (!d && m) {
          const j = a - o
          let U = null
          for (let et = 1; U === null && et < j; et++)
            U = this.getBlackPointOnSegment(o, u - et, o + et, u)
          if (U == null) throw new H()
          let Y = null
          for (let et = 1; Y === null && et < j; et++)
            Y = this.getBlackPointOnSegment(o, l + et, o + et, l)
          if (Y == null) throw new H()
          let K = null
          for (let et = 1; K === null && et < j; et++)
            K = this.getBlackPointOnSegment(a, l + et, a - et, l)
          if (K == null) throw new H()
          let nt = null
          for (let et = 1; nt === null && et < j; et++)
            nt = this.getBlackPointOnSegment(a, u - et, a - et, u)
          if (nt == null) throw new H()
          return this.centerEdges(nt, U, K, Y)
        } else throw new H()
      }
      getBlackPointOnSegment(o, a, l, u) {
        const d = Dt.round(Dt.distance(o, a, l, u)),
          g = (l - o) / d,
          m = (u - a) / d,
          b = this.image
        for (let v = 0; v < d; v++) {
          const C = Dt.round(o + v * g),
            T = Dt.round(a + v * m)
          if (b.get(C, T)) return new ht(C, T)
        }
        return null
      }
      centerEdges(o, a, l, u) {
        const d = o.getX(),
          g = o.getY(),
          m = a.getX(),
          b = a.getY(),
          v = l.getX(),
          C = l.getY(),
          T = u.getX(),
          P = u.getY(),
          B = Tr.CORR
        return d < this.width / 2
          ? [new ht(T - B, P + B), new ht(m + B, b + B), new ht(v - B, C - B), new ht(d + B, g - B)]
          : [new ht(T + B, P + B), new ht(m + B, b - B), new ht(v - B, C + B), new ht(d - B, g - B)]
      }
      containsBlackPoint(o, a, l, u) {
        const d = this.image
        if (u) {
          for (let g = o; g <= a; g++) if (d.get(g, l)) return !0
        } else for (let g = o; g <= a; g++) if (d.get(l, g)) return !0
        return !1
      }
    }
    ;((Tr.INIT_SIZE = 10), (Tr.CORR = 1))
    class Ih {
      static checkAndNudgePoints(o, a) {
        const l = o.getWidth(),
          u = o.getHeight()
        let d = !0
        for (let g = 0; g < a.length && d; g += 2) {
          const m = Math.floor(a[g]),
            b = Math.floor(a[g + 1])
          if (m < -1 || m > l || b < -1 || b > u) throw new H()
          ;((d = !1),
            m === -1 ? ((a[g] = 0), (d = !0)) : m === l && ((a[g] = l - 1), (d = !0)),
            b === -1 ? ((a[g + 1] = 0), (d = !0)) : b === u && ((a[g + 1] = u - 1), (d = !0)))
        }
        d = !0
        for (let g = a.length - 2; g >= 0 && d; g -= 2) {
          const m = Math.floor(a[g]),
            b = Math.floor(a[g + 1])
          if (m < -1 || m > l || b < -1 || b > u) throw new H()
          ;((d = !1),
            m === -1 ? ((a[g] = 0), (d = !0)) : m === l && ((a[g] = l - 1), (d = !0)),
            b === -1 ? ((a[g + 1] = 0), (d = !0)) : b === u && ((a[g + 1] = u - 1), (d = !0)))
        }
      }
    }
    class er {
      constructor(o, a, l, u, d, g, m, b, v) {
        ;((this.a11 = o),
          (this.a21 = a),
          (this.a31 = l),
          (this.a12 = u),
          (this.a22 = d),
          (this.a32 = g),
          (this.a13 = m),
          (this.a23 = b),
          (this.a33 = v))
      }
      static quadrilateralToQuadrilateral(o, a, l, u, d, g, m, b, v, C, T, P, B, j, U, Y) {
        const K = er.quadrilateralToSquare(o, a, l, u, d, g, m, b)
        return er.squareToQuadrilateral(v, C, T, P, B, j, U, Y).times(K)
      }
      transformPoints(o) {
        const a = o.length,
          l = this.a11,
          u = this.a12,
          d = this.a13,
          g = this.a21,
          m = this.a22,
          b = this.a23,
          v = this.a31,
          C = this.a32,
          T = this.a33
        for (let P = 0; P < a; P += 2) {
          const B = o[P],
            j = o[P + 1],
            U = d * B + b * j + T
          ;((o[P] = (l * B + g * j + v) / U), (o[P + 1] = (u * B + m * j + C) / U))
        }
      }
      transformPointsWithValues(o, a) {
        const l = this.a11,
          u = this.a12,
          d = this.a13,
          g = this.a21,
          m = this.a22,
          b = this.a23,
          v = this.a31,
          C = this.a32,
          T = this.a33,
          P = o.length
        for (let B = 0; B < P; B++) {
          const j = o[B],
            U = a[B],
            Y = d * j + b * U + T
          ;((o[B] = (l * j + g * U + v) / Y), (a[B] = (u * j + m * U + C) / Y))
        }
      }
      static squareToQuadrilateral(o, a, l, u, d, g, m, b) {
        const v = o - l + d - m,
          C = a - u + g - b
        if (v === 0 && C === 0) return new er(l - o, d - l, o, u - a, g - u, a, 0, 0, 1)
        {
          const T = l - d,
            P = m - d,
            B = u - g,
            j = b - g,
            U = T * j - P * B,
            Y = (v * j - P * C) / U,
            K = (T * C - v * B) / U
          return new er(l - o + Y * l, m - o + K * m, o, u - a + Y * u, b - a + K * b, a, Y, K, 1)
        }
      }
      static quadrilateralToSquare(o, a, l, u, d, g, m, b) {
        return er.squareToQuadrilateral(o, a, l, u, d, g, m, b).buildAdjoint()
      }
      buildAdjoint() {
        return new er(
          this.a22 * this.a33 - this.a23 * this.a32,
          this.a23 * this.a31 - this.a21 * this.a33,
          this.a21 * this.a32 - this.a22 * this.a31,
          this.a13 * this.a32 - this.a12 * this.a33,
          this.a11 * this.a33 - this.a13 * this.a31,
          this.a12 * this.a31 - this.a11 * this.a32,
          this.a12 * this.a23 - this.a13 * this.a22,
          this.a13 * this.a21 - this.a11 * this.a23,
          this.a11 * this.a22 - this.a12 * this.a21
        )
      }
      times(o) {
        return new er(
          this.a11 * o.a11 + this.a21 * o.a12 + this.a31 * o.a13,
          this.a11 * o.a21 + this.a21 * o.a22 + this.a31 * o.a23,
          this.a11 * o.a31 + this.a21 * o.a32 + this.a31 * o.a33,
          this.a12 * o.a11 + this.a22 * o.a12 + this.a32 * o.a13,
          this.a12 * o.a21 + this.a22 * o.a22 + this.a32 * o.a23,
          this.a12 * o.a31 + this.a22 * o.a32 + this.a32 * o.a33,
          this.a13 * o.a11 + this.a23 * o.a12 + this.a33 * o.a13,
          this.a13 * o.a21 + this.a23 * o.a22 + this.a33 * o.a23,
          this.a13 * o.a31 + this.a23 * o.a32 + this.a33 * o.a33
        )
      }
    }
    class bp extends Ih {
      sampleGrid(o, a, l, u, d, g, m, b, v, C, T, P, B, j, U, Y, K, nt, et) {
        const $ = er.quadrilateralToQuadrilateral(u, d, g, m, b, v, C, T, P, B, j, U, Y, K, nt, et)
        return this.sampleGridWithTransform(o, a, l, $)
      }
      sampleGridWithTransform(o, a, l, u) {
        if (a <= 0 || l <= 0) throw new H()
        const d = new _t(a, l),
          g = new Float32Array(2 * a)
        for (let m = 0; m < l; m++) {
          const b = g.length,
            v = m + 0.5
          for (let C = 0; C < b; C += 2) ((g[C] = C / 2 + 0.5), (g[C + 1] = v))
          ;(u.transformPoints(g), Ih.checkAndNudgePoints(o, g))
          try {
            for (let C = 0; C < b; C += 2)
              o.get(Math.floor(g[C]), Math.floor(g[C + 1])) && d.set(C / 2, m)
          } catch {
            throw new H()
          }
        }
        return d
      }
    }
    class Jr {
      static setGridSampler(o) {
        Jr.gridSampler = o
      }
      static getInstance() {
        return Jr.gridSampler
      }
    }
    Jr.gridSampler = new bp()
    class en {
      constructor(o, a) {
        ;((this.x = o), (this.y = a))
      }
      toResultPoint() {
        return new ht(this.getX(), this.getY())
      }
      getX() {
        return this.x
      }
      getY() {
        return this.y
      }
    }
    class vp {
      constructor(o) {
        ;((this.EXPECTED_CORNER_BITS = new Int32Array([3808, 476, 2107, 1799])), (this.image = o))
      }
      detect() {
        return this.detectMirror(!1)
      }
      detectMirror(o) {
        let a = this.getMatrixCenter(),
          l = this.getBullsEyeCorners(a)
        if (o) {
          let g = l[0]
          ;((l[0] = l[2]), (l[2] = g))
        }
        this.extractParameters(l)
        let u = this.sampleGrid(
            this.image,
            l[this.shift % 4],
            l[(this.shift + 1) % 4],
            l[(this.shift + 2) % 4],
            l[(this.shift + 3) % 4]
          ),
          d = this.getMatrixCornerPoints(l)
        return new wp(u, d, this.compact, this.nbDataBlocks, this.nbLayers)
      }
      extractParameters(o) {
        if (
          !this.isValidPoint(o[0]) ||
          !this.isValidPoint(o[1]) ||
          !this.isValidPoint(o[2]) ||
          !this.isValidPoint(o[3])
        )
          throw new H()
        let a = 2 * this.nbCenterLayers,
          l = new Int32Array([
            this.sampleLine(o[0], o[1], a),
            this.sampleLine(o[1], o[2], a),
            this.sampleLine(o[2], o[3], a),
            this.sampleLine(o[3], o[0], a),
          ])
        this.shift = this.getRotation(l, a)
        let u = 0
        for (let g = 0; g < 4; g++) {
          let m = l[(this.shift + g) % 4]
          this.compact
            ? ((u <<= 7), (u += (m >> 1) & 127))
            : ((u <<= 10), (u += ((m >> 2) & 992) + ((m >> 1) & 31)))
        }
        let d = this.getCorrectedParameterData(u, this.compact)
        this.compact
          ? ((this.nbLayers = (d >> 6) + 1), (this.nbDataBlocks = (d & 63) + 1))
          : ((this.nbLayers = (d >> 11) + 1), (this.nbDataBlocks = (d & 2047) + 1))
      }
      getRotation(o, a) {
        let l = 0
        ;(o.forEach((u, d, g) => {
          let m = ((u >> (a - 2)) << 1) + (u & 1)
          l = (l << 3) + m
        }),
          (l = ((l & 1) << 11) + (l >> 1)))
        for (let u = 0; u < 4; u++) if (M.bitCount(l ^ this.EXPECTED_CORNER_BITS[u]) <= 2) return u
        throw new H()
      }
      getCorrectedParameterData(o, a) {
        let l, u
        a ? ((l = 7), (u = 2)) : ((l = 10), (u = 4))
        let d = l - u,
          g = new Int32Array(l)
        for (let b = l - 1; b >= 0; --b) ((g[b] = o & 15), (o >>= 4))
        try {
          new ea(Ft.AZTEC_PARAM).decode(g, d)
        } catch {
          throw new H()
        }
        let m = 0
        for (let b = 0; b < u; b++) m = (m << 4) + g[b]
        return m
      }
      getBullsEyeCorners(o) {
        let a = o,
          l = o,
          u = o,
          d = o,
          g = !0
        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
          let T = this.getFirstDifferent(a, g, 1, -1),
            P = this.getFirstDifferent(l, g, 1, 1),
            B = this.getFirstDifferent(u, g, -1, 1),
            j = this.getFirstDifferent(d, g, -1, -1)
          if (this.nbCenterLayers > 2) {
            let U =
              (this.distancePoint(j, T) * this.nbCenterLayers) /
              (this.distancePoint(d, a) * (this.nbCenterLayers + 2))
            if (U < 0.75 || U > 1.25 || !this.isWhiteOrBlackRectangle(T, P, B, j)) break
          }
          ;((a = T), (l = P), (u = B), (d = j), (g = !g))
        }
        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) throw new H()
        this.compact = this.nbCenterLayers === 5
        let m = new ht(a.getX() + 0.5, a.getY() - 0.5),
          b = new ht(l.getX() + 0.5, l.getY() + 0.5),
          v = new ht(u.getX() - 0.5, u.getY() + 0.5),
          C = new ht(d.getX() - 0.5, d.getY() - 0.5)
        return this.expandSquare([m, b, v, C], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers)
      }
      getMatrixCenter() {
        let o, a, l, u
        try {
          let m = new Tr(this.image).detect()
          ;((o = m[0]), (a = m[1]), (l = m[2]), (u = m[3]))
        } catch {
          let m = this.image.getWidth() / 2,
            b = this.image.getHeight() / 2
          ;((o = this.getFirstDifferent(new en(m + 7, b - 7), !1, 1, -1).toResultPoint()),
            (a = this.getFirstDifferent(new en(m + 7, b + 7), !1, 1, 1).toResultPoint()),
            (l = this.getFirstDifferent(new en(m - 7, b + 7), !1, -1, 1).toResultPoint()),
            (u = this.getFirstDifferent(new en(m - 7, b - 7), !1, -1, -1).toResultPoint()))
        }
        let d = Dt.round((o.getX() + u.getX() + a.getX() + l.getX()) / 4),
          g = Dt.round((o.getY() + u.getY() + a.getY() + l.getY()) / 4)
        try {
          let m = new Tr(this.image, 15, d, g).detect()
          ;((o = m[0]), (a = m[1]), (l = m[2]), (u = m[3]))
        } catch {
          ;((o = this.getFirstDifferent(new en(d + 7, g - 7), !1, 1, -1).toResultPoint()),
            (a = this.getFirstDifferent(new en(d + 7, g + 7), !1, 1, 1).toResultPoint()),
            (l = this.getFirstDifferent(new en(d - 7, g + 7), !1, -1, 1).toResultPoint()),
            (u = this.getFirstDifferent(new en(d - 7, g - 7), !1, -1, -1).toResultPoint()))
        }
        return (
          (d = Dt.round((o.getX() + u.getX() + a.getX() + l.getX()) / 4)),
          (g = Dt.round((o.getY() + u.getY() + a.getY() + l.getY()) / 4)),
          new en(d, g)
        )
      }
      getMatrixCornerPoints(o) {
        return this.expandSquare(o, 2 * this.nbCenterLayers, this.getDimension())
      }
      sampleGrid(o, a, l, u, d) {
        let g = Jr.getInstance(),
          m = this.getDimension(),
          b = m / 2 - this.nbCenterLayers,
          v = m / 2 + this.nbCenterLayers
        return g.sampleGrid(
          o,
          m,
          m,
          b,
          b,
          v,
          b,
          v,
          v,
          b,
          v,
          a.getX(),
          a.getY(),
          l.getX(),
          l.getY(),
          u.getX(),
          u.getY(),
          d.getX(),
          d.getY()
        )
      }
      sampleLine(o, a, l) {
        let u = 0,
          d = this.distanceResultPoint(o, a),
          g = d / l,
          m = o.getX(),
          b = o.getY(),
          v = (g * (a.getX() - o.getX())) / d,
          C = (g * (a.getY() - o.getY())) / d
        for (let T = 0; T < l; T++)
          this.image.get(Dt.round(m + T * v), Dt.round(b + T * C)) && (u |= 1 << (l - T - 1))
        return u
      }
      isWhiteOrBlackRectangle(o, a, l, u) {
        let d = 3
        ;((o = new en(o.getX() - d, o.getY() + d)),
          (a = new en(a.getX() - d, a.getY() - d)),
          (l = new en(l.getX() + d, l.getY() - d)),
          (u = new en(u.getX() + d, u.getY() + d)))
        let g = this.getColor(u, o)
        if (g === 0) return !1
        let m = this.getColor(o, a)
        return m !== g || ((m = this.getColor(a, l)), m !== g)
          ? !1
          : ((m = this.getColor(l, u)), m === g)
      }
      getColor(o, a) {
        let l = this.distancePoint(o, a),
          u = (a.getX() - o.getX()) / l,
          d = (a.getY() - o.getY()) / l,
          g = 0,
          m = o.getX(),
          b = o.getY(),
          v = this.image.get(o.getX(), o.getY()),
          C = Math.ceil(l)
        for (let P = 0; P < C; P++)
          ((m += u), (b += d), this.image.get(Dt.round(m), Dt.round(b)) !== v && g++)
        let T = g / l
        return T > 0.1 && T < 0.9 ? 0 : T <= 0.1 === v ? 1 : -1
      }
      getFirstDifferent(o, a, l, u) {
        let d = o.getX() + l,
          g = o.getY() + u
        for (; this.isValid(d, g) && this.image.get(d, g) === a; ) ((d += l), (g += u))
        for (d -= l, g -= u; this.isValid(d, g) && this.image.get(d, g) === a; ) d += l
        for (d -= l; this.isValid(d, g) && this.image.get(d, g) === a; ) g += u
        return ((g -= u), new en(d, g))
      }
      expandSquare(o, a, l) {
        let u = l / (2 * a),
          d = o[0].getX() - o[2].getX(),
          g = o[0].getY() - o[2].getY(),
          m = (o[0].getX() + o[2].getX()) / 2,
          b = (o[0].getY() + o[2].getY()) / 2,
          v = new ht(m + u * d, b + u * g),
          C = new ht(m - u * d, b - u * g)
        ;((d = o[1].getX() - o[3].getX()),
          (g = o[1].getY() - o[3].getY()),
          (m = (o[1].getX() + o[3].getX()) / 2),
          (b = (o[1].getY() + o[3].getY()) / 2))
        let T = new ht(m + u * d, b + u * g),
          P = new ht(m - u * d, b - u * g)
        return [v, T, C, P]
      }
      isValid(o, a) {
        return o >= 0 && o < this.image.getWidth() && a > 0 && a < this.image.getHeight()
      }
      isValidPoint(o) {
        let a = Dt.round(o.getX()),
          l = Dt.round(o.getY())
        return this.isValid(a, l)
      }
      distancePoint(o, a) {
        return Dt.distance(o.getX(), o.getY(), a.getX(), a.getY())
      }
      distanceResultPoint(o, a) {
        return Dt.distance(o.getX(), o.getY(), a.getX(), a.getY())
      }
      getDimension() {
        return this.compact
          ? 4 * this.nbLayers + 11
          : this.nbLayers <= 4
            ? 4 * this.nbLayers + 15
            : 4 * this.nbLayers + 2 * (M.truncDivision(this.nbLayers - 4, 8) + 1) + 15
      }
    }
    class Gl {
      decode(o, a = null) {
        let l = null,
          u = new vp(o.getBlackMatrix()),
          d = null,
          g = null
        try {
          let C = u.detectMirror(!1)
          ;((d = C.getPoints()), this.reportFoundResultPoints(a, d), (g = new qt().decode(C)))
        } catch (C) {
          l = C
        }
        if (g == null)
          try {
            let C = u.detectMirror(!0)
            ;((d = C.getPoints()), this.reportFoundResultPoints(a, d), (g = new qt().decode(C)))
          } catch (C) {
            throw l ?? C
          }
        let m = new Bt(
            g.getText(),
            g.getRawBytes(),
            g.getNumBits(),
            d,
            ut.AZTEC,
            k.currentTimeMillis()
          ),
          b = g.getByteSegments()
        b != null && m.putMetadata(Ne.BYTE_SEGMENTS, b)
        let v = g.getECLevel()
        return (v != null && m.putMetadata(Ne.ERROR_CORRECTION_LEVEL, v), m)
      }
      reportFoundResultPoints(o, a) {
        if (o != null) {
          let l = o.get(z.NEED_RESULT_POINT_CALLBACK)
          l != null &&
            a.forEach((u, d, g) => {
              l.foundPossibleResultPoint(u)
            })
        }
      }
      reset() {}
    }
    class lb extends Te {
      constructor(o = 500) {
        super(new Gl(), o)
      }
    }
    class Ce {
      decode(o, a) {
        try {
          return this.doDecode(o, a)
        } catch {
          if (a && a.get(z.TRY_HARDER) === !0 && o.isRotateSupported()) {
            const l = o.rotateCounterClockwise(),
              u = this.doDecode(l, a),
              d = u.getResultMetadata()
            let g = 270
            ;(d !== null && d.get(Ne.ORIENTATION) === !0 && (g = g + (d.get(Ne.ORIENTATION) % 360)),
              u.putMetadata(Ne.ORIENTATION, g))
            const m = u.getResultPoints()
            if (m !== null) {
              const b = l.getHeight()
              for (let v = 0; v < m.length; v++) m[v] = new ht(b - m[v].getY() - 1, m[v].getX())
            }
            return u
          } else throw new H()
        }
      }
      reset() {}
      doDecode(o, a) {
        const l = o.getWidth(),
          u = o.getHeight()
        let d = new O(l)
        const g = a && a.get(z.TRY_HARDER) === !0,
          m = Math.max(1, u >> (g ? 8 : 5))
        let b
        g ? (b = u) : (b = 15)
        const v = Math.trunc(u / 2)
        for (let C = 0; C < b; C++) {
          const T = Math.trunc((C + 1) / 2),
            P = (C & 1) === 0,
            B = v + m * (P ? T : -T)
          if (B < 0 || B >= u) break
          try {
            d = o.getBlackRow(B, d)
          } catch {
            continue
          }
          for (let j = 0; j < 2; j++) {
            if (j === 1 && (d.reverse(), a && a.get(z.NEED_RESULT_POINT_CALLBACK) === !0)) {
              const U = new Map()
              ;(a.forEach((Y, K) => U.set(K, Y)), U.delete(z.NEED_RESULT_POINT_CALLBACK), (a = U))
            }
            try {
              const U = this.decodeRow(B, d, a)
              if (j === 1) {
                U.putMetadata(Ne.ORIENTATION, 180)
                const Y = U.getResultPoints()
                Y !== null &&
                  ((Y[0] = new ht(l - Y[0].getX() - 1, Y[0].getY())),
                  (Y[1] = new ht(l - Y[1].getX() - 1, Y[1].getY())))
              }
              return U
            } catch {}
          }
        }
        throw new H()
      }
      static recordPattern(o, a, l) {
        const u = l.length
        for (let v = 0; v < u; v++) l[v] = 0
        const d = o.getSize()
        if (a >= d) throw new H()
        let g = !o.get(a),
          m = 0,
          b = a
        for (; b < d; ) {
          if (o.get(b) !== g) l[m]++
          else {
            if (++m === u) break
            ;((l[m] = 1), (g = !g))
          }
          b++
        }
        if (!(m === u || (m === u - 1 && b === d))) throw new H()
      }
      static recordPatternInReverse(o, a, l) {
        let u = l.length,
          d = o.get(a)
        for (; a > 0 && u >= 0; ) o.get(--a) !== d && (u--, (d = !d))
        if (u >= 0) throw new H()
        Ce.recordPattern(o, a + 1, l)
      }
      static patternMatchVariance(o, a, l) {
        const u = o.length
        let d = 0,
          g = 0
        for (let v = 0; v < u; v++) ((d += o[v]), (g += a[v]))
        if (d < g) return Number.POSITIVE_INFINITY
        const m = d / g
        l *= m
        let b = 0
        for (let v = 0; v < u; v++) {
          const C = o[v],
            T = a[v] * m,
            P = C > T ? C - T : T - C
          if (P > l) return Number.POSITIVE_INFINITY
          b += P
        }
        return b / d
      }
    }
    class it extends Ce {
      static findStartPattern(o) {
        const a = o.getSize(),
          l = o.getNextSet(0)
        let u = 0,
          d = Int32Array.from([0, 0, 0, 0, 0, 0]),
          g = l,
          m = !1
        const b = 6
        for (let v = l; v < a; v++)
          if (o.get(v) !== m) d[u]++
          else {
            if (u === b - 1) {
              let C = it.MAX_AVG_VARIANCE,
                T = -1
              for (let P = it.CODE_START_A; P <= it.CODE_START_C; P++) {
                const B = Ce.patternMatchVariance(
                  d,
                  it.CODE_PATTERNS[P],
                  it.MAX_INDIVIDUAL_VARIANCE
                )
                B < C && ((C = B), (T = P))
              }
              if (T >= 0 && o.isRange(Math.max(0, g - (v - g) / 2), g, !1))
                return Int32Array.from([g, v, T])
              ;((g += d[0] + d[1]), (d = d.slice(2, d.length - 1)), (d[u - 1] = 0), (d[u] = 0), u--)
            } else u++
            ;((d[u] = 1), (m = !m))
          }
        throw new H()
      }
      static decodeCode(o, a, l) {
        Ce.recordPattern(o, l, a)
        let u = it.MAX_AVG_VARIANCE,
          d = -1
        for (let g = 0; g < it.CODE_PATTERNS.length; g++) {
          const m = it.CODE_PATTERNS[g],
            b = this.patternMatchVariance(a, m, it.MAX_INDIVIDUAL_VARIANCE)
          b < u && ((u = b), (d = g))
        }
        if (d >= 0) return d
        throw new H()
      }
      decodeRow(o, a, l) {
        const u = l && l.get(z.ASSUME_GS1) === !0,
          d = it.findStartPattern(a),
          g = d[2]
        let m = 0
        const b = new Uint8Array(20)
        b[m++] = g
        let v
        switch (g) {
          case it.CODE_START_A:
            v = it.CODE_CODE_A
            break
          case it.CODE_START_B:
            v = it.CODE_CODE_B
            break
          case it.CODE_START_C:
            v = it.CODE_CODE_C
            break
          default:
            throw new V()
        }
        let C = !1,
          T = !1,
          P = '',
          B = d[0],
          j = d[1]
        const U = Int32Array.from([0, 0, 0, 0, 0, 0])
        let Y = 0,
          K = 0,
          nt = g,
          et = 0,
          $ = !0,
          Tt = !1,
          Ct = !1
        for (; !C; ) {
          const ts = T
          switch (
            ((T = !1),
            (Y = K),
            (K = it.decodeCode(a, U, j)),
            (b[m++] = K),
            K !== it.CODE_STOP && ($ = !0),
            K !== it.CODE_STOP && (et++, (nt += et * K)),
            (B = j),
            (j += U.reduce((Bb, Fb) => Bb + Fb, 0)),
            K)
          ) {
            case it.CODE_START_A:
            case it.CODE_START_B:
            case it.CODE_START_C:
              throw new V()
          }
          switch (v) {
            case it.CODE_CODE_A:
              if (K < 64)
                (Ct === Tt
                  ? (P += String.fromCharCode(32 + K))
                  : (P += String.fromCharCode(32 + K + 128)),
                  (Ct = !1))
              else if (K < 96)
                (Ct === Tt
                  ? (P += String.fromCharCode(K - 64))
                  : (P += String.fromCharCode(K + 64)),
                  (Ct = !1))
              else
                switch ((K !== it.CODE_STOP && ($ = !1), K)) {
                  case it.CODE_FNC_1:
                    u && (P.length === 0 ? (P += ']C1') : (P += ''))
                  case it.CODE_FNC_2:
                  case it.CODE_FNC_3:
                  case it.CODE_FNC_4_A:
                    !Tt && Ct
                      ? ((Tt = !0), (Ct = !1))
                      : Tt && Ct
                        ? ((Tt = !1), (Ct = !1))
                        : (Ct = !0)
                  case it.CODE_SHIFT:
                    ;((T = !0), (v = it.CODE_CODE_B))
                  case it.CODE_CODE_B:
                    v = it.CODE_CODE_B
                  case it.CODE_CODE_C:
                    v = it.CODE_CODE_C
                    break
                  case it.CODE_STOP:
            case it.CODE_CODE_B:
              if (K < 96)
                (Ct === Tt
                  ? (P += String.fromCharCode(32 + K))
                  : (P += String.fromCharCode(32 + K + 128)),
                  (Ct = !1))
                switch ((K !== it.CODE_STOP && ($ = !1), K)) {
                  case it.CODE_FNC_1:
                    u && (P.length === 0 ? (P += ']C1') : (P += ''))
                  case it.CODE_FNC_2:
                  case it.CODE_FNC_3:
                  case it.CODE_FNC_4_B:
                    !Tt && Ct
                      ? ((Tt = !0), (Ct = !1))
                      : Tt && Ct
                        ? ((Tt = !1), (Ct = !1))
                        : (Ct = !0)
                  case it.CODE_SHIFT:
                    ;((T = !0), (v = it.CODE_CODE_A))
                  case it.CODE_CODE_A:
                    v = it.CODE_CODE_A
                    break
                  case it.CODE_CODE_C:
                    v = it.CODE_CODE_C
                    break
                  case it.CODE_STOP:
            case it.CODE_CODE_C:
              if (K < 100) (K < 10 && (P += '0'), (P += K))
                switch ((K !== it.CODE_STOP && ($ = !1), K)) {
                  case it.CODE_FNC_1:
                    u && (P.length === 0 ? (P += ']C1') : (P += ''))
                    break
                  case it.CODE_CODE_A:
                    v = it.CODE_CODE_A
                    break
                  case it.CODE_CODE_B:
                    v = it.CODE_CODE_B
                    break
                  case it.CODE_STOP:
          ts && (v = v === it.CODE_CODE_A ? it.CODE_CODE_B : it.CODE_CODE_A)
        if (((nt -= et * Y), nt % 103 !== Y)) throw new E()
        const rr = P.length
          (v === it.CODE_CODE_C ? (P = P.substring(0, rr - 2)) : (P = P.substring(0, rr - 1)))
          Zt = B + pn / 2,
          We = b.length,
          An = new Uint8Array(We)
        for (let ts = 0; ts < We; ts++) An[ts] = b[ts]
        const Jo = [new ht(gn, o), new ht(Zt, o)]
        return new Bt(P, An, 0, Jo, ut.CODE_128, new Date().getTime())
    ;((it.CODE_PATTERNS = [
                  case ie.CODE_FNC_1:
                    u && (D.length === 0 ? (D += ']C1') : (D += ''))
                    break
                  case ie.CODE_CODE_A:
                    v = ie.CODE_CODE_A
                    break
                  case ie.CODE_CODE_B:
                    v = ie.CODE_CODE_B
                    break
                  case ie.CODE_STOP:
                    C = !0
                    break
                }
              break
          }
          Js && (v = v === ie.CODE_CODE_A ? ie.CODE_CODE_B : ie.CODE_CODE_A)
        }
        const pn = j - B
        if (((j = a.getNextUnset(j)), !a.isRange(j, Math.min(a.getSize(), j + (j - B) / 2), !1)))
          throw new H()
        if (((ne -= te * Y), ne % 103 !== Y)) throw new E()
        const rr = D.length
        if (rr === 0) throw new H()
        rr > 0 &&
          $ &&
          (v === ie.CODE_CODE_C ? (D = D.substring(0, rr - 2)) : (D = D.substring(0, rr - 1)))
        const gn = (d[1] + d[0]) / 2,
          Ze = B + pn / 2,
          Ut = b.length,
          An = new Uint8Array(Ut)
        for (let Js = 0; Js < Ut; Js++) An[Js] = b[Js]
        const $s = [new he(gn, s), new he(Ze, s)]
        return new Be(D, An, 0, $s, ue.CODE_128, new Date().getTime())
      }
    }
    ;((ie.CODE_PATTERNS = [
      Int32Array.from([2, 1, 2, 2, 2, 2]),
      Int32Array.from([2, 2, 2, 1, 2, 2]),
      Int32Array.from([2, 2, 2, 2, 2, 1]),
      Int32Array.from([1, 2, 1, 2, 2, 3]),
      Int32Array.from([1, 2, 1, 3, 2, 2]),
      Int32Array.from([1, 3, 1, 2, 2, 2]),
      Int32Array.from([1, 2, 2, 2, 1, 3]),
      Int32Array.from([1, 2, 2, 3, 1, 2]),
      Int32Array.from([1, 3, 2, 2, 1, 2]),
      Int32Array.from([2, 2, 1, 2, 1, 3]),
      Int32Array.from([2, 2, 1, 3, 1, 2]),
      Int32Array.from([2, 3, 1, 2, 1, 2]),
      Int32Array.from([1, 1, 2, 2, 3, 2]),
      Int32Array.from([1, 2, 2, 1, 3, 2]),
      Int32Array.from([1, 2, 2, 2, 3, 1]),
      Int32Array.from([1, 1, 3, 2, 2, 2]),
      Int32Array.from([1, 2, 3, 1, 2, 2]),
      Int32Array.from([1, 2, 3, 2, 2, 1]),
      Int32Array.from([2, 2, 3, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 3, 2]),
      Int32Array.from([2, 2, 1, 2, 3, 1]),
      Int32Array.from([2, 1, 3, 2, 1, 2]),
      Int32Array.from([2, 2, 3, 1, 1, 2]),
      Int32Array.from([3, 1, 2, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 2, 2, 2]),
      Int32Array.from([3, 2, 1, 1, 2, 2]),
      Int32Array.from([3, 2, 1, 2, 2, 1]),
      Int32Array.from([3, 1, 2, 2, 1, 2]),
      Int32Array.from([3, 2, 2, 1, 1, 2]),
      Int32Array.from([3, 2, 2, 2, 1, 1]),
      Int32Array.from([2, 1, 2, 1, 2, 3]),
      Int32Array.from([2, 1, 2, 3, 2, 1]),
      Int32Array.from([2, 3, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 1, 3, 2, 3]),
      Int32Array.from([1, 3, 1, 1, 2, 3]),
      Int32Array.from([1, 3, 1, 3, 2, 1]),
      Int32Array.from([1, 1, 2, 3, 1, 3]),
      Int32Array.from([1, 3, 2, 1, 1, 3]),
      Int32Array.from([1, 3, 2, 3, 1, 1]),
      Int32Array.from([2, 1, 1, 3, 1, 3]),
      Int32Array.from([2, 3, 1, 1, 1, 3]),
      Int32Array.from([2, 3, 1, 3, 1, 1]),
      Int32Array.from([1, 1, 2, 1, 3, 3]),
      Int32Array.from([1, 1, 2, 3, 3, 1]),
      Int32Array.from([1, 3, 2, 1, 3, 1]),
      Int32Array.from([1, 1, 3, 1, 2, 3]),
      Int32Array.from([1, 1, 3, 3, 2, 1]),
      Int32Array.from([1, 3, 3, 1, 2, 1]),
      Int32Array.from([3, 1, 3, 1, 2, 1]),
      Int32Array.from([2, 1, 1, 3, 3, 1]),
      Int32Array.from([2, 3, 1, 1, 3, 1]),
      Int32Array.from([2, 1, 3, 1, 1, 3]),
      Int32Array.from([2, 1, 3, 3, 1, 1]),
      Int32Array.from([2, 1, 3, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 2, 3]),
      Int32Array.from([3, 1, 1, 3, 2, 1]),
      Int32Array.from([3, 3, 1, 1, 2, 1]),
      Int32Array.from([3, 1, 2, 1, 1, 3]),
      Int32Array.from([3, 1, 2, 3, 1, 1]),
      Int32Array.from([3, 3, 2, 1, 1, 1]),
      Int32Array.from([3, 1, 4, 1, 1, 1]),
      Int32Array.from([2, 2, 1, 4, 1, 1]),
      Int32Array.from([4, 3, 1, 1, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 2, 4]),
      Int32Array.from([1, 1, 1, 4, 2, 2]),
      Int32Array.from([1, 2, 1, 1, 2, 4]),
      Int32Array.from([1, 2, 1, 4, 2, 1]),
      Int32Array.from([1, 4, 1, 1, 2, 2]),
      Int32Array.from([1, 4, 1, 2, 2, 1]),
      Int32Array.from([1, 1, 2, 2, 1, 4]),
      Int32Array.from([1, 1, 2, 4, 1, 2]),
      Int32Array.from([1, 2, 2, 1, 1, 4]),
      Int32Array.from([1, 2, 2, 4, 1, 1]),
      Int32Array.from([1, 4, 2, 1, 1, 2]),
      Int32Array.from([1, 4, 2, 2, 1, 1]),
      Int32Array.from([2, 4, 1, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 1, 4]),
      Int32Array.from([4, 1, 3, 1, 1, 1]),
      Int32Array.from([2, 4, 1, 1, 1, 2]),
      Int32Array.from([1, 3, 4, 1, 1, 1]),
      (it.MAX_AVG_VARIANCE = 0.25),
      (it.MAX_INDIVIDUAL_VARIANCE = 0.7),
      (it.CODE_SHIFT = 98),
      (it.CODE_CODE_C = 99),
      (it.CODE_CODE_B = 100),
      (it.CODE_CODE_A = 101),
      (it.CODE_FNC_1 = 102),
      (it.CODE_FNC_2 = 97),
      (it.CODE_FNC_3 = 96),
      (it.CODE_FNC_4_A = 101),
      (it.CODE_FNC_4_B = 100),
      (it.CODE_START_A = 103),
      (it.CODE_START_B = 104),
      (it.CODE_START_C = 105),
      (it.CODE_STOP = 106))
    class Ae extends Ce {
      constructor(o = !1, a = !1) {
          (this.usingCheckDigit = o),
      decodeRow(o, a, l) {
        let d = Ae.findAsteriskPattern(a, u),
          Ae.recordPattern(a, g, u)
          let U = Ae.toNarrowWidePattern(u)
          if (U < 0) throw new H()
          ;((b = Ae.patternToChar(U)), (this.decodeRowResult += b), (v = g))
        for (let U of u) C += U
          let U = this.decodeRowResult.length - 1,
          for (let K = 0; K < U; K++)
            Y += Ae.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(K))
          if (this.decodeRowResult.charAt(U) !== Ae.ALPHABET_STRING.charAt(Y % 43)) throw new E()
          this.decodeRowResult = this.decodeRowResult.substring(0, U)
        let P
          ? (P = Ae.decodeExtended(this.decodeRowResult))
          : (P = this.decodeRowResult)
        return new Bt(P, null, 0, [new ht(B, o), new ht(j, o)], ut.CODE_39, new Date().getTime())
      static findAsteriskPattern(o, a) {
        let l = o.getSize(),
          u = o.getNextSet(0),
          if (o.get(v) !== m) a[d]++
                this.toNarrowWidePattern(a) === Ae.ASTERISK_ENCODING &&
                o.isRange(Math.max(0, g - Math.floor((v - g) / 2)), g, !1)
      static toNarrowWidePattern(o) {
        let a = o.length,
          for (let b of o) b < d && b > l && (d = b)
            let v = o[b]
              let v = o[b]
      static patternToChar(o) {
        for (let a = 0; a < Ae.CHARACTER_ENCODINGS.length; a++)
          if (Ae.CHARACTER_ENCODINGS[a] === o) return Ae.ALPHABET_STRING.charAt(a)
        if (o === Ae.ASTERISK_ENCODING) return '*'
      static decodeExtended(o) {
        let a = o.length,
          let d = o.charAt(u)
            let g = o.charAt(u + 1),
    ;((Ae.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%'),
      (Ae.CHARACTER_ENCODINGS = [
      (Ae.ASTERISK_ENCODING = 148))
    class Gt extends Ce {
      decodeRow(o, a, l) {
          g = new vt()
        Gt.decodeMiddle(a, u[1], d[0], g)
          b == null && (b = Gt.DEFAULT_ALLOWED_LENGTHS))
        const P = [new ht(u[1], o), new ht(d[0], o)]
        return new Bt(m, null, 0, P, ut.ITF, new Date().getTime())
      static decodeMiddle(o, a, l, u) {
          Ce.recordPattern(o, a, d)
          let b = Gt.decodeDigit(g)
      decodeStart(o) {
        let a = Gt.skipWhiteSpace(o),
          l = Gt.findGuardPattern(o, a, Gt.START_PATTERN)
        return ((this.narrowLineWidth = (l[1] - l[0]) / 4), this.validateQuietZone(o, l[0]), l)
      validateQuietZone(o, a) {
        for (let u = a - 1; l > 0 && u >= 0 && !o.get(u); u--) l--
      static skipWhiteSpace(o) {
        const a = o.getSize(),
          l = o.getNextSet(0)
      decodeEnd(o) {
        o.reverse()
          let a = Gt.skipWhiteSpace(o),
            l = Gt.findGuardPattern(o, a, Gt.END_PATTERN_REVERSED[0])
            d instanceof H && (l = Gt.findGuardPattern(o, a, Gt.END_PATTERN_REVERSED[1]))
          this.validateQuietZone(o, l[0])
          return ((l[0] = o.getSize() - l[1]), (l[1] = o.getSize() - u), l)
          o.reverse()
      static findGuardPattern(o, a, l) {
          g = o.getSize(),
          if (o.get(C) !== m) d[b]++
              if (Ce.patternMatchVariance(d, l, Gt.MAX_INDIVIDUAL_VARIANCE) < Gt.MAX_AVG_VARIANCE)
      static decodeDigit(o) {
        let a = Gt.MAX_AVG_VARIANCE,
          u = Gt.PATTERNS.length
          let g = Gt.PATTERNS[d],
            m = Ce.patternMatchVariance(o, g, Gt.MAX_INDIVIDUAL_VARIANCE)
    ;((Gt.PATTERNS = [
      (Gt.MAX_AVG_VARIANCE = 0.38),
      (Gt.MAX_INDIVIDUAL_VARIANCE = 0.5),
      (Gt.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14]),
      (Gt.START_PATTERN = Int32Array.from([1, 1, 1, 1])),
      (Gt.END_PATTERN_REVERSED = [Int32Array.from([1, 1, 2]), Int32Array.from([1, 1, 3])]))
    class fe extends Ce {
      static findStartGuardPattern(o) {
            (l = fe.findGuardPattern(o, u, !1, this.START_END_PATTERN, d)))
          m >= 0 && (a = o.isRange(m, g, !1))
      static checkChecksum(o) {
        return fe.checkStandardUPCEANChecksum(o)
      static checkStandardUPCEANChecksum(o) {
        let a = o.length
        let l = parseInt(o.charAt(a - 1), 10)
        return fe.getStandardUPCEANChecksum(o.substring(0, a - 1)) === l
      static getStandardUPCEANChecksum(o) {
        let a = o.length,
          let d = o.charAt(u).charCodeAt(0) - 48
          let d = o.charAt(u).charCodeAt(0) - 48
      static decodeEnd(o, a) {
        return fe.findGuardPattern(
          o,
          fe.START_END_PATTERN,
          new Int32Array(fe.START_END_PATTERN.length).fill(0)
      static findGuardPatternWithoutCounters(o, a, l, u) {
        return this.findGuardPattern(o, a, l, u, new Int32Array(u.length))
      static findGuardPattern(o, a, l, u, d) {
        let g = o.getSize()
        a = l ? o.getNextUnset(a) : o.getNextSet(a)
          if (o.get(T) !== C) d[m]++
              if (Ce.patternMatchVariance(d, u, fe.MAX_INDIVIDUAL_VARIANCE) < fe.MAX_AVG_VARIANCE)
              let P = d.slice(2, d.length - 1)
              for (let B = 0; B < m - 1; B++) d[B] = P[B]
      static decodeDigit(o, a, l, u) {
        this.recordPattern(o, l, a)
            C = Ce.patternMatchVariance(a, v, fe.MAX_INDIVIDUAL_VARIANCE)
    ;((fe.MAX_AVG_VARIANCE = 0.48),
      (fe.MAX_INDIVIDUAL_VARIANCE = 0.7),
      (fe.START_END_PATTERN = Int32Array.from([1, 1, 1])),
      (fe.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1])),
      (fe.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1])),
      (fe.L_PATTERNS = [
      decodeRow(o, a, l) {
          b = [new ht((l[0] + l[1]) / 2, o), new ht(d, o)],
          v = new Bt(g, null, 0, b, ut.UPC_EAN_EXTENSION, new Date().getTime())
      decodeMiddle(o, a, l) {
        let d = o.getSize(),
          let C = fe.decodeDigit(o, u, g, fe.L_AND_G_PATTERNS)
            v !== 4 && ((g = o.getNextSet(g)), (g = o.getNextUnset(g))))
      static extensionChecksum(o) {
        let a = o.length,
        for (let u = a - 2; u >= 0; u -= 2) l += o.charAt(u).charCodeAt(0) - 48
        for (let u = a - 1; u >= 0; u -= 2) l += o.charAt(u).charCodeAt(0) - 48
      determineCheckDigit(o) {
        for (let a = 0; a < 10; a++) if (o === this.CHECK_DIGIT_ENCODINGS[a]) return a
      static parseExtensionString(o) {
        if (o.length !== 5) return null
        let a = na.parseExtension5String(o)
        return a == null ? null : new Map([[Ne.SUGGESTED_PRICE, a]])
      static parseExtension5String(o) {
        switch (o.charAt(0)) {
            switch (o) {
        let l = parseInt(o.substring(1)),
    class _h {
      decodeRow(o, a, l) {
          m = _h.parseExtensionString(g),
          b = [new ht((l[0] + l[1]) / 2, o), new ht(d, o)],
          v = new Bt(g, null, 0, b, ut.UPC_EAN_EXTENSION, new Date().getTime())
      decodeMiddle(o, a, l) {
        let d = o.getSize(),
          let v = fe.decodeDigit(o, u, g, fe.L_AND_G_PATTERNS)
            b !== 1 && ((g = o.getNextSet(g)), (g = o.getNextUnset(g))))
      static parseExtensionString(o) {
        return o.length !== 2 ? null : new Map([[Ne.ISSUE_NUMBER, parseInt(o)]])
      static decodeRow(o, a, l) {
        let u = fe.findGuardPattern(
          return new na().decodeRow(o, a, u)
          return new _h().decodeRow(o, a, u)
    class jt extends fe {
          (jt.L_AND_G_PATTERNS = jt.L_PATTERNS.map((o) => Int32Array.from(o))))
        for (let o = 10; o < 20; o++) {
          let a = jt.L_PATTERNS[o - 10],
          jt.L_AND_G_PATTERNS[o] = l
      decodeRow(o, a, l) {
        let u = jt.findStartGuardPattern(a),
          const $ = new ht((u[0] + u[1]) / 2, o)
          const $ = new ht(m, o)
          const $ = new ht((v[0] + v[1]) / 2, o)
        let P = b.toString()
        if (P.length < 8) throw new V()
        if (!jt.checkChecksum(P)) throw new E()
          U = this.getBarcodeFormat(),
          Y = [new ht(B, o), new ht(j, o)],
          K = new Bt(P, null, 0, Y, U, new Date().getTime()),
          nt = 0
          let $ = xp.decodeRow(o, a, v[1])
          ;(K.putMetadata(Ne.UPC_EAN_EXTENSION, $.getText()),
            K.putAllMetadata($.getResultMetadata()),
            K.addResultPoints($.getResultPoints()),
            (nt = $.getText().length))
        let et = l == null ? null : l.get(z.ALLOWED_EAN_EXTENSIONS)
        if (et != null) {
          for (let Tt in et)
            if (nt.toString() === Tt) {
        return K
      decodeEnd(o, a) {
        return jt.findGuardPattern(
          o,
          jt.START_END_PATTERN,
          new Int32Array(jt.START_END_PATTERN.length).fill(0)
      static checkChecksum(o) {
        return jt.checkStandardUPCEANChecksum(o)
      static checkStandardUPCEANChecksum(o) {
        let a = o.length
        let l = parseInt(o.charAt(a - 1), 10)
        return jt.getStandardUPCEANChecksum(o.substring(0, a - 1)) === l
      static getStandardUPCEANChecksum(o) {
        let a = o.length,
          let d = o.charAt(u).charCodeAt(0) - 48
          let d = o.charAt(u).charCodeAt(0) - 48
    class zi extends jt {
      }
      decodeMiddle(o, a, l) {
        let d = o.getSize(),
          let v = jt.decodeDigit(o, u, g, jt.L_AND_G_PATTERNS)
          (g = jt.findGuardPattern(
            o,
            jt.MIDDLE_PATTERN,
            new Int32Array(jt.MIDDLE_PATTERN.length).fill(0)
          let v = jt.decodeDigit(o, u, g, jt.L_PATTERNS)
        return ut.EAN_13
      static determineFirstDigit(o, a) {
          if (a === this.FIRST_DIGIT_ENCODINGS[l]) return ((o = String.fromCharCode(48 + l) + o), o)
    class Ep extends jt {
      decodeMiddle(o, a, l) {
        let d = o.getSize(),
          let b = jt.decodeDigit(o, u, g, jt.L_PATTERNS)
        g = jt.findGuardPattern(
          o,
          jt.MIDDLE_PATTERN,
          new Int32Array(jt.MIDDLE_PATTERN.length).fill(0)
          let b = jt.decodeDigit(o, u, g, jt.L_PATTERNS)
        return ut.EAN_8
    class Cp extends jt {
        return ut.UPC_A
      }
      decode(o, a) {
        return this.maybeReturnResult(this.ean13Reader.decode(o))
      decodeRow(o, a, l) {
        return this.maybeReturnResult(this.ean13Reader.decodeRow(o, a, l))
      decodeMiddle(o, a, l) {
        return this.ean13Reader.decodeMiddle(o, a, l)
      maybeReturnResult(o) {
        let a = o.getText()
          let l = new Bt(a.substring(1), null, null, o.getResultPoints(), ut.UPC_A)
          return (o.getResultMetadata() != null && l.putAllMetadata(o.getResultMetadata()), l)
    class nr extends jt {
      }
      decodeMiddle(o, a, l) {
        const d = o.getSize()
          const C = nr.decodeDigit(o, u, g, nr.L_AND_G_PATTERNS)
      decodeEnd(o, a) {
        return nr.findGuardPatternWithoutCounters(o, a, !0, nr.MIDDLE_END_PATTERN)
      checkChecksum(o) {
        return jt.checkChecksum(nr.convertUPCEtoUPCA(o))
      static determineNumSysAndCheckDigit(o, a) {
              return d + o + g
        return ut.UPC_E
      static convertUPCEtoUPCA(o) {
        const a = o
          l = new vt()
        l.append(o.charAt(0))
        return (o.length >= 8 && l.append(o.charAt(7)), l.toString())
    class Rh extends Ce {
      constructor(o) {
        let a = o == null ? null : o.get(z.POSSIBLE_FORMATS),
          : (a.indexOf(ut.EAN_13) > -1 && l.push(new zi()),
            a.indexOf(ut.UPC_A) > -1 && l.push(new Cp()),
            a.indexOf(ut.EAN_8) > -1 && l.push(new Ep()),
            a.indexOf(ut.UPC_E) > -1 && l.push(new nr())),
      decodeRow(o, a, l) {
            const d = u.decodeRow(o, a, l),
              g = d.getBarcodeFormat() === ut.EAN_13 && d.getText().charAt(0) === '0',
              b = m == null || m.includes(ut.UPC_A)
                C = new Bt(
                  ut.UPC_A
        for (let o of this.readers) o.reset()
    class Ye extends Ce {
      parseFinderValue(o, a) {
          if (Ce.patternMatchVariance(o, a[l], Ye.MAX_INDIVIDUAL_VARIANCE) < Ye.MAX_AVG_VARIANCE)
      static count(o) {
        return Dt.sum(new Int32Array(o))
      static increment(o, a) {
        for (let d = 1; d < o.length; d++) a[d] > u && ((u = a[d]), (l = d))
        o[l]++
      static decrement(o, a) {
        for (let d = 1; d < o.length; d++) a[d] < u && ((u = a[d]), (l = d))
        o[l]--
      static isFinderPattern(o) {
        let a = o[0] + o[1],
          l = a + o[2] + o[3],
        if (u >= Ye.MIN_FINDER_PATTERN_RATIO && u <= Ye.MAX_FINDER_PATTERN_RATIO) {
          for (let m of o) (m > g && (g = m), m < d && (d = m))
        }
    ;((Ye.MAX_AVG_VARIANCE = 0.2),
      (Ye.MAX_INDIVIDUAL_VARIANCE = 0.45),
      (Ye.MIN_FINDER_PATTERN_RATIO = 9.5 / 12),
      (Ye.MAX_FINDER_PATTERN_RATIO = 12.5 / 14))
    class Go {
      constructor(o, a) {
        ;((this.value = o), (this.checksumPortion = a))
      equals(o) {
        if (!(o instanceof Go)) return !1
        const a = o
      constructor(o, a, l, u, d) {
        ;((this.value = o),
          (this.value = o),
          this.resultPoints.push(new ht(l, d)),
          this.resultPoints.push(new ht(u, d)))
      equals(o) {
        if (!(o instanceof Yl)) return !1
        const a = o
      static getRSSvalue(o, a, l) {
        for (let b of o) u += b
          m = o.length
          for (v = 1, g |= 1 << b; v < o[b]; v++, g &= ~(1 << b)) {
              for (let P = u - v - (m - b - 2); P > a; P--)
                T += fr.combins(u - v - P - 1, m - b - 3)
      static combins(o, a) {
        o - a > a ? ((u = a), (l = o - a)) : ((u = o - a), (l = a))
        for (let m = o; m > l; m--) ((d *= m), g <= u && ((d /= g), g++))
      static buildBitArray(o) {
        let a = o.length * 2 - 1
        o[o.length - 1].getRightChar() == null && (a -= 1)
          g = o[0].getRightChar().getValue()
        for (let m = 1; m < o.length; ++m) {
          let b = o[m],
      constructor(o, a) {
        a ? (this.decodedInformation = null) : ((this.finished = o), (this.decodedInformation = a))
      constructor(o) {
        this.newPosition = o
      constructor(o, a) {
        ;(super(o), (this.value = a))
      constructor(o, a, l) {
        ;(super(o),
      constructor(o, a, l) {
        if ((super(o), a < 0 || a > 10 || l < 0 || l > 10)) throw new V()
    class at {
      static parseFieldsInGeneralPurpose(o) {
        if (!o) return null
        if (o.length < 2) throw new H()
        let a = o.substring(0, 2)
        for (let d of at.TWO_DIGIT_DATA_LENGTH)
            return d[1] === at.VARIABLE_LENGTH
              ? at.processVariableAI(2, d[2], o)
              : at.processFixedAI(2, d[1], o)
        if (o.length < 3) throw new H()
        let l = o.substring(0, 3)
        for (let d of at.THREE_DIGIT_DATA_LENGTH)
            return d[1] === at.VARIABLE_LENGTH
              ? at.processVariableAI(3, d[2], o)
              : at.processFixedAI(3, d[1], o)
        for (let d of at.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH)
            return d[1] === at.VARIABLE_LENGTH
              ? at.processVariableAI(4, d[2], o)
              : at.processFixedAI(4, d[1], o)
        if (o.length < 4) throw new H()
        let u = o.substring(0, 4)
        for (let d of at.FOUR_DIGIT_DATA_LENGTH)
            return d[1] === at.VARIABLE_LENGTH
              ? at.processVariableAI(4, d[2], o)
              : at.processFixedAI(4, d[1], o)
      static processFixedAI(o, a, l) {
        if (l.length < o) throw new H()
        let u = l.substring(0, o)
        if (l.length < o + a) throw new H()
        let d = l.substring(o, o + a),
          g = l.substring(o + a),
          b = at.parseFieldsInGeneralPurpose(g)
      static processVariableAI(o, a, l) {
        let u = l.substring(0, o),
        l.length < o + a ? (d = l.length) : (d = o + a)
        let g = l.substring(o, d),
          v = at.parseFieldsInGeneralPurpose(m)
    ;((at.VARIABLE_LENGTH = []),
      (at.TWO_DIGIT_DATA_LENGTH = [
        ['10', at.VARIABLE_LENGTH, 20],
        ['21', at.VARIABLE_LENGTH, 20],
        ['22', at.VARIABLE_LENGTH, 29],
        ['30', at.VARIABLE_LENGTH, 8],
        ['37', at.VARIABLE_LENGTH, 8],
        ['90', at.VARIABLE_LENGTH, 30],
        ['91', at.VARIABLE_LENGTH, 30],
        ['92', at.VARIABLE_LENGTH, 30],
        ['93', at.VARIABLE_LENGTH, 30],
        ['94', at.VARIABLE_LENGTH, 30],
        ['95', at.VARIABLE_LENGTH, 30],
        ['96', at.VARIABLE_LENGTH, 30],
        ['97', at.VARIABLE_LENGTH, 3],
        ['98', at.VARIABLE_LENGTH, 30],
        ['99', at.VARIABLE_LENGTH, 30],
      (at.THREE_DIGIT_DATA_LENGTH = [
        ['240', at.VARIABLE_LENGTH, 30],
        ['241', at.VARIABLE_LENGTH, 30],
        ['242', at.VARIABLE_LENGTH, 6],
        ['250', at.VARIABLE_LENGTH, 30],
        ['251', at.VARIABLE_LENGTH, 30],
        ['253', at.VARIABLE_LENGTH, 17],
        ['254', at.VARIABLE_LENGTH, 20],
        ['400', at.VARIABLE_LENGTH, 30],
        ['401', at.VARIABLE_LENGTH, 30],
        ['403', at.VARIABLE_LENGTH, 30],
        ['420', at.VARIABLE_LENGTH, 20],
        ['421', at.VARIABLE_LENGTH, 15],
        ['423', at.VARIABLE_LENGTH, 15],
      (at.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
          g = -1,
          m = u.length
        for (let b = 0; b < m; b++) {
          let v = u[b],
            C = Ct.patternMatchVariance(a, v, ft.MAX_INDIVIDUAL_VARIANCE)
          C < d && ((d = C), (g = b))
        }
        if (g >= 0) return g
        throw new H()
      }
    }
    ;((ft.MAX_AVG_VARIANCE = 0.48),
      (ft.MAX_INDIVIDUAL_VARIANCE = 0.7),
      (ft.START_END_PATTERN = Int32Array.from([1, 1, 1])),
      (ft.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1])),
      (ft.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1])),
      (ft.L_PATTERNS = [
        Int32Array.from([3, 2, 1, 1]),
        Int32Array.from([2, 2, 2, 1]),
        Int32Array.from([2, 1, 2, 2]),
        Int32Array.from([1, 4, 1, 1]),
        Int32Array.from([1, 1, 3, 2]),
        Int32Array.from([1, 2, 3, 1]),
        Int32Array.from([1, 1, 1, 4]),
        Int32Array.from([1, 3, 1, 2]),
        Int32Array.from([1, 2, 1, 3]),
        Int32Array.from([3, 1, 1, 2]),
      ]))
    class na {
      constructor() {
        ;((this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5]),
          (this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0])),
          (this.decodeRowStringBuffer = ''))
      }
      decodeRow(s, a, l) {
        let u = this.decodeRowStringBuffer,
          d = this.decodeMiddle(a, l, u),
          g = u.toString(),
          m = na.parseExtensionString(g),
          b = [new he((l[0] + l[1]) / 2, s), new he(d, s)],
          v = new Be(g, null, 0, b, ue.UPC_EAN_EXTENSION, new Date().getTime())
        return (m != null && v.putAllMetadata(m), v)
      }
      decodeMiddle(s, a, l) {
        let u = this.decodeMiddleCounters
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g = a[1],
          m = 0
        for (let v = 0; v < 5 && g < d; v++) {
          let C = ft.decodeDigit(s, u, g, ft.L_AND_G_PATTERNS)
          l += String.fromCharCode(48 + (C % 10))
          for (let T of u) g += T
          ;(C >= 10 && (m |= 1 << (4 - v)),
            v !== 4 && ((g = s.getNextSet(g)), (g = s.getNextUnset(g))))
        }
        if (l.length !== 5) throw new H()
        let b = this.determineCheckDigit(m)
        if (na.extensionChecksum(l.toString()) !== b) throw new H()
        return g
      }
      static extensionChecksum(s) {
        let a = s.length,
          l = 0
        for (let u = a - 2; u >= 0; u -= 2) l += s.charAt(u).charCodeAt(0) - 48
        l *= 3
        for (let u = a - 1; u >= 0; u -= 2) l += s.charAt(u).charCodeAt(0) - 48
        return ((l *= 3), l % 10)
      }
      determineCheckDigit(s) {
        for (let a = 0; a < 10; a++) if (s === this.CHECK_DIGIT_ENCODINGS[a]) return a
        throw new H()
      }
      static parseExtensionString(s) {
        if (s.length !== 5) return null
        let a = na.parseExtension5String(s)
        return a == null ? null : new Map([[Rt.SUGGESTED_PRICE, a]])
      }
      static parseExtension5String(s) {
        let a
        switch (s.charAt(0)) {
          case '0':
            a = ''
            break
          case '5':
            a = '$'
            break
          case '9':
            switch (s) {
              case '90000':
                return null
              case '99991':
                return '0.00'
              case '99990':
                return 'Used'
            }
            a = ''
            break
          default:
            a = ''
            break
        }
        let l = parseInt(s.substring(1)),
          u = (l / 100).toString(),
          d = l % 100,
          g = d < 10 ? '0' + d : d.toString()
        return a + u + '.' + g
      }
    }
    class Ih {
      constructor() {
        ;((this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0])),
          (this.decodeRowStringBuffer = ''))
      }
      decodeRow(s, a, l) {
        let u = this.decodeRowStringBuffer,
          d = this.decodeMiddle(a, l, u),
          g = u.toString(),
          m = Ih.parseExtensionString(g),
          b = [new he((l[0] + l[1]) / 2, s), new he(d, s)],
          v = new Be(g, null, 0, b, ue.UPC_EAN_EXTENSION, new Date().getTime())
        return (m != null && v.putAllMetadata(m), v)
      }
      decodeMiddle(s, a, l) {
        let u = this.decodeMiddleCounters
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g = a[1],
          m = 0
        for (let b = 0; b < 2 && g < d; b++) {
          let v = ft.decodeDigit(s, u, g, ft.L_AND_G_PATTERNS)
          l += String.fromCharCode(48 + (v % 10))
          for (let C of u) g += C
          ;(v >= 10 && (m |= 1 << (1 - b)),
            b !== 1 && ((g = s.getNextSet(g)), (g = s.getNextUnset(g))))
        }
        if (l.length !== 2) throw new H()
        if (parseInt(l.toString()) % 4 !== m) throw new H()
        return g
      }
      static parseExtensionString(s) {
        return s.length !== 2 ? null : new Map([[Rt.ISSUE_NUMBER, parseInt(s)]])
      }
    }
    class xp {
      static decodeRow(s, a, l) {
        let u = ft.findGuardPattern(
          a,
          l,
          !1,
          this.EXTENSION_START_PATTERN,
          new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0)
        )
        try {
          return new na().decodeRow(s, a, u)
        } catch {
          return new Ih().decodeRow(s, a, u)
        }
      }
    }
    xp.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2])
    class je extends ft {
      constructor() {
        ;(super(),
          (this.decodeRowStringBuffer = ''),
          (je.L_AND_G_PATTERNS = je.L_PATTERNS.map((s) => Int32Array.from(s))))
        for (let s = 10; s < 20; s++) {
          let a = je.L_PATTERNS[s - 10],
            l = new Int32Array(a.length)
          for (let u = 0; u < a.length; u++) l[u] = a[a.length - u - 1]
          je.L_AND_G_PATTERNS[s] = l
        }
      }
      decodeRow(s, a, l) {
        let u = je.findStartGuardPattern(a),
          d = l == null ? null : l.get(z.NEED_RESULT_POINT_CALLBACK)
        if (d != null) {
          const $ = new he((u[0] + u[1]) / 2, s)
          d.foundPossibleResultPoint($)
        }
        let g = this.decodeMiddle(a, u, this.decodeRowStringBuffer),
          m = g.rowOffset,
          b = g.resultString
        if (d != null) {
          const $ = new he(m, s)
          d.foundPossibleResultPoint($)
        }
        let v = this.decodeEnd(a, m)
        if (d != null) {
          const $ = new he((v[0] + v[1]) / 2, s)
          d.foundPossibleResultPoint($)
        }
        let C = v[1],
          T = C + (C - v[0])
        if (T >= a.getSize() || !a.isRange(C, T, !1)) throw new H()
        let D = b.toString()
        if (D.length < 8) throw new V()
        if (!je.checkChecksum(D)) throw new E()
        let B = (u[1] + u[0]) / 2,
          j = (v[1] + v[0]) / 2,
          W = this.getBarcodeFormat(),
          Y = [new he(B, s), new he(j, s)],
          q = new Be(D, null, 0, Y, W, new Date().getTime()),
          ne = 0
        try {
          let $ = xp.decodeRow(s, a, v[1])
          ;(q.putMetadata(Rt.UPC_EAN_EXTENSION, $.getText()),
            q.putAllMetadata($.getResultMetadata()),
            q.addResultPoints($.getResultPoints()),
            (ne = $.getText().length))
        } catch {}
        let te = l == null ? null : l.get(z.ALLOWED_EAN_EXTENSIONS)
        if (te != null) {
          let $ = !1
          for (let Te in te)
            if (ne.toString() === Te) {
              $ = !0
              break
            }
          if (!$) throw new H()
        }
        return q
      }
      decodeEnd(s, a) {
        return je.findGuardPattern(
          s,
          a,
          !1,
          je.START_END_PATTERN,
          new Int32Array(je.START_END_PATTERN.length).fill(0)
        )
      }
      static checkChecksum(s) {
        return je.checkStandardUPCEANChecksum(s)
      }
      static checkStandardUPCEANChecksum(s) {
        let a = s.length
        if (a === 0) return !1
        let l = parseInt(s.charAt(a - 1), 10)
        return je.getStandardUPCEANChecksum(s.substring(0, a - 1)) === l
      }
      static getStandardUPCEANChecksum(s) {
        let a = s.length,
          l = 0
        for (let u = a - 1; u >= 0; u -= 2) {
          let d = s.charAt(u).charCodeAt(0) - 48
          if (d < 0 || d > 9) throw new V()
          l += d
        }
        l *= 3
        for (let u = a - 2; u >= 0; u -= 2) {
          let d = s.charAt(u).charCodeAt(0) - 48
          if (d < 0 || d > 9) throw new V()
          l += d
        }
        return (1e3 - l) % 10
      }
    }
    class zi extends je {
      constructor() {
        ;(super(), (this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0])))
      }
      decodeMiddle(s, a, l) {
        let u = this.decodeMiddleCounters
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g = a[1],
          m = 0
        for (let b = 0; b < 6 && g < d; b++) {
          let v = je.decodeDigit(s, u, g, je.L_AND_G_PATTERNS)
          l += String.fromCharCode(48 + (v % 10))
          for (let C of u) g += C
          v >= 10 && (m |= 1 << (5 - b))
        }
        ;((l = zi.determineFirstDigit(l, m)),
          (g = je.findGuardPattern(
            s,
            g,
            !0,
            je.MIDDLE_PATTERN,
            new Int32Array(je.MIDDLE_PATTERN.length).fill(0)
          )[1]))
        for (let b = 0; b < 6 && g < d; b++) {
          let v = je.decodeDigit(s, u, g, je.L_PATTERNS)
          l += String.fromCharCode(48 + v)
          for (let C of u) g += C
        }
        return { rowOffset: g, resultString: l }
      }
      getBarcodeFormat() {
        return ue.EAN_13
      }
      static determineFirstDigit(s, a) {
        for (let l = 0; l < 10; l++)
          if (a === this.FIRST_DIGIT_ENCODINGS[l]) return ((s = String.fromCharCode(48 + l) + s), s)
        throw new H()
      }
    }
    zi.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]
    class Ep extends je {
      constructor() {
        ;(super(), (this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0])))
      }
      decodeMiddle(s, a, l) {
        const u = this.decodeMiddleCounters
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g = a[1]
        for (let m = 0; m < 4 && g < d; m++) {
          let b = je.decodeDigit(s, u, g, je.L_PATTERNS)
          l += String.fromCharCode(48 + b)
          for (let v of u) g += v
        }
        g = je.findGuardPattern(
          s,
          g,
          !0,
          je.MIDDLE_PATTERN,
          new Int32Array(je.MIDDLE_PATTERN.length).fill(0)
        )[1]
        for (let m = 0; m < 4 && g < d; m++) {
          let b = je.decodeDigit(s, u, g, je.L_PATTERNS)
          l += String.fromCharCode(48 + b)
          for (let v of u) g += v
        }
        return { rowOffset: g, resultString: l }
      }
      getBarcodeFormat() {
        return ue.EAN_8
      }
    }
    class Cp extends je {
      constructor() {
        ;(super(...arguments), (this.ean13Reader = new zi()))
      }
      getBarcodeFormat() {
        return ue.UPC_A
      }
      decode(s, a) {
        return this.maybeReturnResult(this.ean13Reader.decode(s))
      }
      decodeRow(s, a, l) {
        return this.maybeReturnResult(this.ean13Reader.decodeRow(s, a, l))
      }
      decodeMiddle(s, a, l) {
        return this.ean13Reader.decodeMiddle(s, a, l)
      }
      maybeReturnResult(s) {
        let a = s.getText()
        if (a.charAt(0) === '0') {
          let l = new Be(a.substring(1), null, null, s.getResultPoints(), ue.UPC_A)
          return (s.getResultMetadata() != null && l.putAllMetadata(s.getResultMetadata()), l)
        } else throw new H()
      }
      reset() {
        this.ean13Reader.reset()
      }
    }
    class nr extends je {
      constructor() {
        ;(super(), (this.decodeMiddleCounters = new Int32Array(4)))
      }
      decodeMiddle(s, a, l) {
        const u = this.decodeMiddleCounters.map((v) => v)
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        const d = s.getSize()
        let g = a[1],
          m = 0
        for (let v = 0; v < 6 && g < d; v++) {
          const C = nr.decodeDigit(s, u, g, nr.L_AND_G_PATTERNS)
          l += String.fromCharCode(48 + (C % 10))
          for (let T of u) g += T
          C >= 10 && (m |= 1 << (5 - v))
        }
        let b = nr.determineNumSysAndCheckDigit(l, m)
        return { rowOffset: g, resultString: b }
      }
      decodeEnd(s, a) {
        return nr.findGuardPatternWithoutCounters(s, a, !0, nr.MIDDLE_END_PATTERN)
      }
      checkChecksum(s) {
        return je.checkChecksum(nr.convertUPCEtoUPCA(s))
      }
      static determineNumSysAndCheckDigit(s, a) {
        for (let l = 0; l <= 1; l++)
          for (let u = 0; u < 10; u++)
            if (a === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[l][u]) {
              let d = String.fromCharCode(48 + l),
                g = String.fromCharCode(48 + u)
              return d + s + g
            }
        throw H.getNotFoundInstance()
      }
      getBarcodeFormat() {
        return ue.UPC_E
      }
      static convertUPCEtoUPCA(s) {
        const a = s
            .slice(1, 7)
            .split('')
            .map((d) => d.charCodeAt(0)),
          l = new ve()
        l.append(s.charAt(0))
        let u = a[5]
        switch (u) {
          case 0:
          case 1:
          case 2:
            ;(l.appendChars(a, 0, 2), l.append(u), l.append('0000'), l.appendChars(a, 2, 3))
            break
          case 3:
            ;(l.appendChars(a, 0, 3), l.append('00000'), l.appendChars(a, 3, 2))
            break
          case 4:
            ;(l.appendChars(a, 0, 4), l.append('00000'), l.append(a[4]))
            break
          default:
            ;(l.appendChars(a, 0, 5), l.append('0000'), l.append(u))
            break
        }
        return (s.length >= 8 && l.append(s.charAt(7)), l.toString())
      }
    }
    ;((nr.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1])),
      (nr.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
        Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]),
        Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 26]),
      ]))
    class Nh extends Ct {
      constructor(s) {
        super()
        let a = s == null ? null : s.get(z.POSSIBLE_FORMATS),
          l = []
        ;(r(a)
          ? (l.push(new zi()), l.push(new Cp()), l.push(new Ep()), l.push(new nr()))
          : (a.indexOf(ue.EAN_13) > -1 && l.push(new zi()),
            a.indexOf(ue.UPC_A) > -1 && l.push(new Cp()),
            a.indexOf(ue.EAN_8) > -1 && l.push(new Ep()),
            a.indexOf(ue.UPC_E) > -1 && l.push(new nr())),
          (this.readers = l))
      }
      decodeRow(s, a, l) {
        for (let u of this.readers)
          try {
            const d = u.decodeRow(s, a, l),
              g = d.getBarcodeFormat() === ue.EAN_13 && d.getText().charAt(0) === '0',
              m = l == null ? null : l.get(z.POSSIBLE_FORMATS),
              b = m == null || m.includes(ue.UPC_A)
            if (g && b) {
              const v = d.getRawBytes(),
                C = new Be(
                  d.getText().substring(1),
                  v,
                  v ? v.length : null,
                  d.getResultPoints(),
                  ue.UPC_A
                )
              return (C.putAllMetadata(d.getResultMetadata()), C)
            }
            return d
          } catch {}
        throw new H()
      }
      reset() {
        for (let s of this.readers) s.reset()
      }
    }
    class Yt extends Ct {
      constructor() {
        ;(super(),
          (this.decodeFinderCounters = new Int32Array(4)),
          (this.dataCharacterCounters = new Int32Array(8)),
          (this.oddRoundingErrors = new Array(4)),
          (this.evenRoundingErrors = new Array(4)),
          (this.oddCounts = new Array(this.dataCharacterCounters.length / 2)),
          (this.evenCounts = new Array(this.dataCharacterCounters.length / 2)))
      }
      getDecodeFinderCounters() {
        return this.decodeFinderCounters
      }
      getDataCharacterCounters() {
        return this.dataCharacterCounters
      }
      getOddRoundingErrors() {
        return this.oddRoundingErrors
      }
      getEvenRoundingErrors() {
        return this.evenRoundingErrors
      }
      getOddCounts() {
        return this.oddCounts
      }
      getEvenCounts() {
        return this.evenCounts
      }
      parseFinderValue(s, a) {
        for (let l = 0; l < a.length; l++)
          if (Ct.patternMatchVariance(s, a[l], Yt.MAX_INDIVIDUAL_VARIANCE) < Yt.MAX_AVG_VARIANCE)
            return l
        throw new H()
      }
      static count(s) {
        return Pe.sum(new Int32Array(s))
      }
      static increment(s, a) {
        let l = 0,
          u = a[0]
        for (let d = 1; d < s.length; d++) a[d] > u && ((u = a[d]), (l = d))
        s[l]++
      }
      static decrement(s, a) {
        let l = 0,
          u = a[0]
        for (let d = 1; d < s.length; d++) a[d] < u && ((u = a[d]), (l = d))
        s[l]--
      }
      static isFinderPattern(s) {
        let a = s[0] + s[1],
          l = a + s[2] + s[3],
          u = a / l
        if (u >= Yt.MIN_FINDER_PATTERN_RATIO && u <= Yt.MAX_FINDER_PATTERN_RATIO) {
          let d = Number.MAX_SAFE_INTEGER,
            g = Number.MIN_SAFE_INTEGER
          for (let m of s) (m > g && (g = m), m < d && (d = m))
          return g < 10 * d
        }
        return !1
      }
    }
    ;((Yt.MAX_AVG_VARIANCE = 0.2),
      (Yt.MAX_INDIVIDUAL_VARIANCE = 0.45),
      (Yt.MIN_FINDER_PATTERN_RATIO = 9.5 / 12),
      (Yt.MAX_FINDER_PATTERN_RATIO = 12.5 / 14))
    class Xs {
      constructor(s, a) {
        ;((this.value = s), (this.checksumPortion = a))
      }
      getValue() {
        return this.value
      }
      getChecksumPortion() {
        return this.checksumPortion
      }
      toString() {
        return this.value + '(' + this.checksumPortion + ')'
      }
      equals(s) {
        if (!(s instanceof Xs)) return !1
        const a = s
        return this.value === a.value && this.checksumPortion === a.checksumPortion
      }
      hashCode() {
        return this.value ^ this.checksumPortion
      }
    }
    class Yl {
      constructor(s, a, l, u, d) {
        ;((this.value = s),
          (this.startEnd = a),
          (this.value = s),
          (this.startEnd = a),
          (this.resultPoints = new Array()),
          this.resultPoints.push(new he(l, d)),
          this.resultPoints.push(new he(u, d)))
      }
      getValue() {
        return this.value
      }
      getStartEnd() {
        return this.startEnd
      }
      getResultPoints() {
        return this.resultPoints
      }
      equals(s) {
        if (!(s instanceof Yl)) return !1
        const a = s
        return this.value === a.value
      }
      hashCode() {
        return this.value
      }
    }
    class fr {
      constructor() {}
      static getRSSvalue(s, a, l) {
        let u = 0
        for (let b of s) u += b
        let d = 0,
          g = 0,
          m = s.length
        for (let b = 0; b < m - 1; b++) {
          let v
          for (v = 1, g |= 1 << b; v < s[b]; v++, g &= ~(1 << b)) {
            let C = fr.combins(u - v - 1, m - b - 2)
            if (
              (l &&
                g === 0 &&
                u - v - (m - b - 1) >= m - b - 1 &&
                (C -= fr.combins(u - v - (m - b), m - b - 2)),
              m - b - 1 > 1)
            ) {
              let T = 0
              for (let D = u - v - (m - b - 2); D > a; D--)
                T += fr.combins(u - v - D - 1, m - b - 3)
              C -= T * (m - 1 - b)
            } else u - v > a && C--
            d += C
          }
          u -= v
        }
        return d
      }
      static combins(s, a) {
        let l, u
        s - a > a ? ((u = a), (l = s - a)) : ((u = s - a), (l = a))
        let d = 1,
          g = 1
        for (let m = s; m > l; m--) ((d *= m), g <= u && ((d /= g), g++))
        for (; g <= u; ) ((d /= g), g++)
        return d
      }
    }
    class cb {
      static buildBitArray(s) {
        let a = s.length * 2 - 1
        s[s.length - 1].getRightChar() == null && (a -= 1)
        let l = 12 * a,
          u = new O(l),
          d = 0,
          g = s[0].getRightChar().getValue()
        for (let m = 11; m >= 0; --m) (g & (1 << m) && u.set(d), d++)
        for (let m = 1; m < s.length; ++m) {
          let b = s[m],
            v = b.getLeftChar().getValue()
          for (let C = 11; C >= 0; --C) (v & (1 << C) && u.set(d), d++)
          if (b.getRightChar() != null) {
            let C = b.getRightChar().getValue()
            for (let T = 11; T >= 0; --T) (C & (1 << T) && u.set(d), d++)
          }
        }
        return u
      }
    }
    class Hi {
      constructor(s, a) {
        a ? (this.decodedInformation = null) : ((this.finished = s), (this.decodedInformation = a))
      }
      getDecodedInformation() {
        return this.decodedInformation
      }
      isFinished() {
        return this.finished
      }
    }
    class Th {
      constructor(s) {
        this.newPosition = s
      }
      getNewPosition() {
        return this.newPosition
      }
    }
    class hn extends Th {
      constructor(s, a) {
        ;(super(s), (this.value = a))
      }
      getValue() {
        return this.value
      }
      isFNC1() {
        return this.value === hn.FNC1
      }
    }
    hn.FNC1 = '$'
    class Xi extends Th {
      constructor(s, a, l) {
        ;(super(s),
          l
            ? ((this.remaining = !0), (this.remainingValue = this.remainingValue))
            : ((this.remaining = !1), (this.remainingValue = 0)),
          (this.newString = a))
      }
      getNewString() {
        return this.newString
      }
      isRemaining() {
        return this.remaining
      }
      getRemainingValue() {
        return this.remainingValue
      }
    }
    class Vn extends Th {
      constructor(s, a, l) {
        if ((super(s), a < 0 || a > 10 || l < 0 || l > 10)) throw new V()
        ;((this.firstDigit = a), (this.secondDigit = l))
      }
      getFirstDigit() {
        return this.firstDigit
      }
      getSecondDigit() {
        return this.secondDigit
      }
      getValue() {
        return this.firstDigit * 10 + this.secondDigit
      }
      isFirstDigitFNC1() {
        return this.firstDigit === Vn.FNC1
      }
      isSecondDigitFNC1() {
        return this.secondDigit === Vn.FNC1
      }
      isAnyFNC1() {
        return this.firstDigit === Vn.FNC1 || this.secondDigit === Vn.FNC1
      }
    }
    Vn.FNC1 = 10
    class ae {
      constructor() {}
      static parseFieldsInGeneralPurpose(s) {
        if (!s) return null
        if (s.length < 2) throw new H()
        let a = s.substring(0, 2)
        for (let d of ae.TWO_DIGIT_DATA_LENGTH)
          if (d[0] === a)
            return d[1] === ae.VARIABLE_LENGTH
              ? ae.processVariableAI(2, d[2], s)
              : ae.processFixedAI(2, d[1], s)
        if (s.length < 3) throw new H()
        let l = s.substring(0, 3)
        for (let d of ae.THREE_DIGIT_DATA_LENGTH)
          if (d[0] === l)
            return d[1] === ae.VARIABLE_LENGTH
              ? ae.processVariableAI(3, d[2], s)
              : ae.processFixedAI(3, d[1], s)
        for (let d of ae.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH)
          if (d[0] === l)
            return d[1] === ae.VARIABLE_LENGTH
              ? ae.processVariableAI(4, d[2], s)
              : ae.processFixedAI(4, d[1], s)
        if (s.length < 4) throw new H()
        let u = s.substring(0, 4)
        for (let d of ae.FOUR_DIGIT_DATA_LENGTH)
          if (d[0] === u)
            return d[1] === ae.VARIABLE_LENGTH
              ? ae.processVariableAI(4, d[2], s)
              : ae.processFixedAI(4, d[1], s)
        throw new H()
      }
      static processFixedAI(s, a, l) {
        if (l.length < s) throw new H()
        let u = l.substring(0, s)
        if (l.length < s + a) throw new H()
        let d = l.substring(s, s + a),
          g = l.substring(s + a),
          m = '(' + u + ')' + d,
          b = ae.parseFieldsInGeneralPurpose(g)
        return b == null ? m : m + b
      }
      static processVariableAI(s, a, l) {
        let u = l.substring(0, s),
          d
        l.length < s + a ? (d = l.length) : (d = s + a)
        let g = l.substring(s, d),
          m = l.substring(d),
          b = '(' + u + ')' + g,
          v = ae.parseFieldsInGeneralPurpose(m)
        return v == null ? b : b + v
      }
    }
    ;((ae.VARIABLE_LENGTH = []),
      (ae.TWO_DIGIT_DATA_LENGTH = [
        ['00', 18],
        ['01', 14],
        ['02', 14],
        ['10', ae.VARIABLE_LENGTH, 20],
        ['11', 6],
        ['12', 6],
        ['13', 6],
        ['15', 6],
        ['17', 6],
        ['20', 2],
        ['21', ae.VARIABLE_LENGTH, 20],
        ['22', ae.VARIABLE_LENGTH, 29],
        ['30', ae.VARIABLE_LENGTH, 8],
        ['37', ae.VARIABLE_LENGTH, 8],
        ['90', ae.VARIABLE_LENGTH, 30],
        ['91', ae.VARIABLE_LENGTH, 30],
        ['92', ae.VARIABLE_LENGTH, 30],
        ['93', ae.VARIABLE_LENGTH, 30],
        ['94', ae.VARIABLE_LENGTH, 30],
        ['95', ae.VARIABLE_LENGTH, 30],
        ['96', ae.VARIABLE_LENGTH, 30],
        ['97', ae.VARIABLE_LENGTH, 3],
        ['98', ae.VARIABLE_LENGTH, 30],
        ['99', ae.VARIABLE_LENGTH, 30],
      ]),
      (ae.THREE_DIGIT_DATA_LENGTH = [
        ['240', ae.VARIABLE_LENGTH, 30],
        ['241', ae.VARIABLE_LENGTH, 30],
        ['242', ae.VARIABLE_LENGTH, 6],
        ['250', ae.VARIABLE_LENGTH, 30],
        ['251', ae.VARIABLE_LENGTH, 30],
        ['253', ae.VARIABLE_LENGTH, 17],
        ['254', ae.VARIABLE_LENGTH, 20],
        ['400', ae.VARIABLE_LENGTH, 30],
        ['401', ae.VARIABLE_LENGTH, 30],
        ['402', 17],
        ['403', ae.VARIABLE_LENGTH, 30],
        ['410', 13],
        ['411', 13],
        ['412', 13],
        ['413', 13],
        ['414', 13],
        ['420', ae.VARIABLE_LENGTH, 20],
        ['421', ae.VARIABLE_LENGTH, 15],
        ['422', 3],
        ['423', ae.VARIABLE_LENGTH, 15],
        ['424', 3],
        ['425', 3],
        ['426', 3],
      ]),
      (ae.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
        ['310', 6],
        ['311', 6],
        ['312', 6],
        ['313', 6],
        ['314', 6],
        ['315', 6],
        ['316', 6],
        ['320', 6],
        ['321', 6],
        ['322', 6],
        ['323', 6],
        ['324', 6],
        ['325', 6],
        ['326', 6],
        ['327', 6],
        ['328', 6],
        ['329', 6],
        ['330', 6],
        ['331', 6],
        ['332', 6],
        ['333', 6],
        ['334', 6],
        ['335', 6],
        ['336', 6],
        ['390', at.VARIABLE_LENGTH, 15],
        ['391', at.VARIABLE_LENGTH, 18],
        ['392', at.VARIABLE_LENGTH, 15],
        ['393', at.VARIABLE_LENGTH, 18],
        ['703', at.VARIABLE_LENGTH, 30],
      (at.FOUR_DIGIT_DATA_LENGTH = [
        ['7002', at.VARIABLE_LENGTH, 30],
        ['8002', at.VARIABLE_LENGTH, 20],
        ['8003', at.VARIABLE_LENGTH, 30],
        ['8004', at.VARIABLE_LENGTH, 30],
        ['8007', at.VARIABLE_LENGTH, 30],
        ['8008', at.VARIABLE_LENGTH, 12],
        ['8020', at.VARIABLE_LENGTH, 25],
        ['8110', at.VARIABLE_LENGTH, 70],
        ['8200', at.VARIABLE_LENGTH, 70],
    class Yo {
      constructor(o) {
        ;((this.buffer = new vt()), (this.information = o))
      decodeAllCodes(o, a) {
            g = at.parseFieldsInGeneralPurpose(d.getNewString())
            (g != null && o.append(g),
        return o.toString()
      isStillNumeric(o) {
        if (o + 7 > this.information.getSize()) return o + 4 <= this.information.getSize()
        for (let a = o; a < o + 3; ++a) if (this.information.get(a)) return !0
        return this.information.get(o + 3)
      decodeNumeric(o) {
        if (o + 7 > this.information.getSize()) {
          let d = this.extractNumericValueFromBitArray(o, 4)
        let a = this.extractNumericValueFromBitArray(o, 7),
        return new Vn(o + 7, l, u)
      extractNumericValueFromBitArray(o, a) {
        return Yo.extractNumericValueFromBitArray(this.information, o, a)
      static extractNumericValueFromBitArray(o, a, l) {
        for (let d = 0; d < l; ++d) o.get(a + d) && (u |= 1 << (l - d - 1))
      decodeGeneralPurposeField(o, a) {
          this.current.setPosition(o))
        let o, a
              ? ((a = this.parseAlphaBlock()), (o = a.isFinished()))
                ? ((a = this.parseIsoIec646Block()), (o = a.isFinished()))
                : ((a = this.parseNumericBlock()), (o = a.isFinished())),
            l === this.current.getPosition() && !o)
        } while (!o)
          let o = this.decodeNumeric(this.current.getPosition())
          if ((this.current.setPosition(o.getNewPosition()), o.isFirstDigitFNC1())) {
              o.isSecondDigitFNC1()
                    o.getSecondDigit()
          if ((this.buffer.append(o.getFirstDigit()), o.isSecondDigitFNC1())) {
          this.buffer.append(o.getSecondDigit())
          let o = this.decodeIsoIec646(this.current.getPosition())
          if ((this.current.setPosition(o.getNewPosition()), o.isFNC1())) {
          this.buffer.append(o.getValue())
          let o = this.decodeAlphanumeric(this.current.getPosition())
          if ((this.current.setPosition(o.getNewPosition()), o.isFNC1())) {
          this.buffer.append(o.getValue())
      isStillIsoIec646(o) {
        if (o + 5 > this.information.getSize()) return !1
        let a = this.extractNumericValueFromBitArray(o, 5)
        if (o + 7 > this.information.getSize()) return !1
        let l = this.extractNumericValueFromBitArray(o, 7)
        if (o + 8 > this.information.getSize()) return !1
        let u = this.extractNumericValueFromBitArray(o, 8)
      decodeIsoIec646(o) {
        let a = this.extractNumericValueFromBitArray(o, 5)
        if (a === 15) return new hn(o + 5, hn.FNC1)
        if (a >= 5 && a < 15) return new hn(o + 5, '0' + (a - 5))
        let l = this.extractNumericValueFromBitArray(o, 7)
        if (l >= 64 && l < 90) return new hn(o + 7, '' + (l + 1))
        if (l >= 90 && l < 116) return new hn(o + 7, '' + (l + 7))
        let u = this.extractNumericValueFromBitArray(o, 8),
          l = d.getNewPosition()
        } while (!0)
        return s.toString()
      }
      isStillNumeric(s) {
        if (s + 7 > this.information.getSize()) return s + 4 <= this.information.getSize()
        for (let a = s; a < s + 3; ++a) if (this.information.get(a)) return !0
        return this.information.get(s + 3)
      }
      decodeNumeric(s) {
        if (s + 7 > this.information.getSize()) {
          let d = this.extractNumericValueFromBitArray(s, 4)
          return d === 0
            ? new Vn(this.information.getSize(), Vn.FNC1, Vn.FNC1)
            : new Vn(this.information.getSize(), d - 1, Vn.FNC1)
        }
        let a = this.extractNumericValueFromBitArray(s, 7),
          l = (a - 8) / 11,
          u = (a - 8) % 11
        return new Vn(s + 7, l, u)
      }
      extractNumericValueFromBitArray(s, a) {
        return Gs.extractNumericValueFromBitArray(this.information, s, a)
      }
      static extractNumericValueFromBitArray(s, a, l) {
        let u = 0
        for (let d = 0; d < l; ++d) s.get(a + d) && (u |= 1 << (l - d - 1))
        return u
      }
      decodeGeneralPurposeField(s, a) {
        ;(this.buffer.setLengthToZero(),
          a != null && this.buffer.append(a),
          this.current.setPosition(s))
        let l = this.parseBlocks()
        return l != null && l.isRemaining()
          ? new Xi(this.current.getPosition(), this.buffer.toString(), l.getRemainingValue())
          : new Xi(this.current.getPosition(), this.buffer.toString())
      }
      parseBlocks() {
        let s, a
        do {
          let l = this.current.getPosition()
          if (
            (this.current.isAlpha()
              ? ((a = this.parseAlphaBlock()), (s = a.isFinished()))
              : this.current.isIsoIec646()
                ? ((a = this.parseIsoIec646Block()), (s = a.isFinished()))
                : ((a = this.parseNumericBlock()), (s = a.isFinished())),
            l === this.current.getPosition() && !s)
          )
            break
        } while (!s)
        return a.getDecodedInformation()
      }
      parseNumericBlock() {
        for (; this.isStillNumeric(this.current.getPosition()); ) {
          let s = this.decodeNumeric(this.current.getPosition())
          if ((this.current.setPosition(s.getNewPosition()), s.isFirstDigitFNC1())) {
            let a
            return (
              s.isSecondDigitFNC1()
                ? (a = new Xi(this.current.getPosition(), this.buffer.toString()))
                : (a = new Xi(
                    this.current.getPosition(),
                    this.buffer.toString(),
                    s.getSecondDigit()
                  )),
              new Hi(!0, a)
            )
          }
          if ((this.buffer.append(s.getFirstDigit()), s.isSecondDigitFNC1())) {
            let a = new Xi(this.current.getPosition(), this.buffer.toString())
            return new Hi(!0, a)
          }
          this.buffer.append(s.getSecondDigit())
        }
        return (
          this.isNumericToAlphaNumericLatch(this.current.getPosition()) &&
            (this.current.setAlpha(), this.current.incrementPosition(4)),
          new Hi(!1)
        )
      }
      parseIsoIec646Block() {
        for (; this.isStillIsoIec646(this.current.getPosition()); ) {
          let s = this.decodeIsoIec646(this.current.getPosition())
          if ((this.current.setPosition(s.getNewPosition()), s.isFNC1())) {
            let a = new Xi(this.current.getPosition(), this.buffer.toString())
            return new Hi(!0, a)
          }
          this.buffer.append(s.getValue())
        }
        return (
          this.isAlphaOr646ToNumericLatch(this.current.getPosition())
            ? (this.current.incrementPosition(3), this.current.setNumeric())
            : this.isAlphaTo646ToAlphaLatch(this.current.getPosition()) &&
              (this.current.getPosition() + 5 < this.information.getSize()
                ? this.current.incrementPosition(5)
                : this.current.setPosition(this.information.getSize()),
              this.current.setAlpha()),
          new Hi(!1)
        )
      }
      parseAlphaBlock() {
        for (; this.isStillAlpha(this.current.getPosition()); ) {
          let s = this.decodeAlphanumeric(this.current.getPosition())
          if ((this.current.setPosition(s.getNewPosition()), s.isFNC1())) {
            let a = new Xi(this.current.getPosition(), this.buffer.toString())
            return new Hi(!0, a)
          }
          this.buffer.append(s.getValue())
        }
        return (
          this.isAlphaOr646ToNumericLatch(this.current.getPosition())
            ? (this.current.incrementPosition(3), this.current.setNumeric())
            : this.isAlphaTo646ToAlphaLatch(this.current.getPosition()) &&
              (this.current.getPosition() + 5 < this.information.getSize()
                ? this.current.incrementPosition(5)
                : this.current.setPosition(this.information.getSize()),
              this.current.setIsoIec646()),
          new Hi(!1)
        )
      }
      isStillIsoIec646(s) {
        if (s + 5 > this.information.getSize()) return !1
        let a = this.extractNumericValueFromBitArray(s, 5)
        if (a >= 5 && a < 16) return !0
        if (s + 7 > this.information.getSize()) return !1
        let l = this.extractNumericValueFromBitArray(s, 7)
        if (l >= 64 && l < 116) return !0
        if (s + 8 > this.information.getSize()) return !1
        let u = this.extractNumericValueFromBitArray(s, 8)
        return u >= 232 && u < 253
      }
      decodeIsoIec646(s) {
        let a = this.extractNumericValueFromBitArray(s, 5)
        if (a === 15) return new hn(s + 5, hn.FNC1)
        if (a >= 5 && a < 15) return new hn(s + 5, '0' + (a - 5))
        let l = this.extractNumericValueFromBitArray(s, 7)
        if (l >= 64 && l < 90) return new hn(s + 7, '' + (l + 1))
        if (l >= 90 && l < 116) return new hn(s + 7, '' + (l + 7))
        let u = this.extractNumericValueFromBitArray(s, 8),
          d
        switch (u) {
          case 232:
            d = '!'
            break
          case 233:
            d = '"'
            break
          case 234:
            d = '%'
            break
          case 235:
            d = '&'
            break
          case 236:
            d = "'"
            break
          case 237:
            d = '('
            break
          case 238:
            d = ')'
            break
          case 239:
            d = '*'
            break
          case 240:
            d = '+'
            break
          case 241:
            d = ','
            break
          case 242:
            d = '-'
            break
          case 243:
            d = '.'
            break
          case 244:
            d = '/'
            break
        return new hn(o + 8, d)
      isStillAlpha(o) {
        if (o + 5 > this.information.getSize()) return !1
        let a = this.extractNumericValueFromBitArray(o, 5)
        if (o + 6 > this.information.getSize()) return !1
        let l = this.extractNumericValueFromBitArray(o, 6)
      decodeAlphanumeric(o) {
        let a = this.extractNumericValueFromBitArray(o, 5)
        if (a === 15) return new hn(o + 5, hn.FNC1)
        if (a >= 5 && a < 15) return new hn(o + 5, '0' + (a - 5))
        let l = this.extractNumericValueFromBitArray(o, 6)
        if (l >= 32 && l < 58) return new hn(o + 6, '' + (l + 33))
        return new hn(o + 6, u)
      isAlphaTo646ToAlphaLatch(o) {
        if (o + 1 > this.information.getSize()) return !1
        for (let a = 0; a < 5 && a + o < this.information.getSize(); ++a)
            if (!this.information.get(o + 2)) return !1
          } else if (this.information.get(o + a)) return !1
      isAlphaOr646ToNumericLatch(o) {
        if (o + 3 > this.information.getSize()) return !1
        for (let a = o; a < o + 3; ++a) if (this.information.get(a)) return !1
      isNumericToAlphaNumericLatch(o) {
        if (o + 1 > this.information.getSize()) return !1
        for (let a = 0; a < 4 && a + o < this.information.getSize(); ++a)
          if (this.information.get(o + a)) return !1
    class Nh {
      constructor(o) {
        ;((this.information = o), (this.generalDecoder = new Yo(o)))
      }
    class dn extends Nh {
      constructor(o) {
        super(o)
      encodeCompressedGtin(o, a) {
        o.append('(01)')
        let l = o.length()
        ;(o.append('9'), this.encodeCompressedGtinWithoutAI(o, a, l))
      }
      encodeCompressedGtinWithoutAI(o, a, l) {
          ;(d / 100 === 0 && o.append('0'), d / 10 === 0 && o.append('0'), o.append(d))
        dn.appendCheckDigit(o, l)
      static appendCheckDigit(o, a) {
          let d = o.charAt(u + a).charCodeAt(0) - 48
        ;((l = 10 - (l % 10)), l === 10 && (l = 0), o.append(l))
    class Zo extends dn {
      constructor(o) {
        super(o)
        let o = new vt()
        o.append('(01)')
        let a = o.length(),
          l = this.getGeneralDecoder().extractNumericValueFromBitArray(Zo.HEADER_SIZE, 4)
          o.append(l),
          this.encodeCompressedGtinWithoutAI(o, Zo.HEADER_SIZE + 4, a),
          this.getGeneralDecoder().decodeAllCodes(o, Zo.HEADER_SIZE + 44)
    Zo.HEADER_SIZE = 4
    class Zl extends Nh {
      constructor(o) {
        super(o)
        let o = new vt()
        return this.getGeneralDecoder().decodeAllCodes(o, Zl.HEADER_SIZE)
    class ql extends dn {
      constructor(o) {
        super(o)
      encodeCompressedWeight(o, a, l) {
        this.addWeightCode(o, u)
        for (let m = 0; m < 5; ++m) (d / g === 0 && o.append('0'), (g /= 10))
        o.append(d)
    class pr extends ql {
      constructor(o) {
        super(o)
        if (this.getInformation().getSize() != pr.HEADER_SIZE + ql.GTIN_SIZE + pr.WEIGHT_SIZE)
        let o = new vt()
          this.encodeCompressedGtin(o, pr.HEADER_SIZE),
          this.encodeCompressedWeight(o, pr.HEADER_SIZE + ql.GTIN_SIZE, pr.WEIGHT_SIZE),
          o.toString()
      constructor(o) {
        super(o)
      addWeightCode(o, a) {
        o.append('(3103)')
      checkWeight(o) {
        return o
      constructor(o) {
        super(o)
      addWeightCode(o, a) {
        a < 1e4 ? o.append('(3202)') : o.append('(3203)')
      checkWeight(o) {
        return o < 1e4 ? o : o - 1e4
      constructor(o) {
        super(o)
      }
        let o = new vt()
        this.encodeCompressedGtin(o, gr.HEADER_SIZE)
        ;(o.append('(392'), o.append(a), o.append(')'))
        return (o.append(l.getNewString()), o.toString())
      constructor(o) {
        super(o)
        let o = new vt()
        this.encodeCompressedGtin(o, nn.HEADER_SIZE)
        ;(o.append('(393'), o.append(a), o.append(')'))
        ;(l / 100 == 0 && o.append('0'), l / 10 == 0 && o.append('0'), o.append(l))
        return (o.append(u.getNewString()), o.toString())
    class ie extends ql {
      constructor(o, a, l) {
        ;(super(o), (this.dateCode = l), (this.firstAIdigits = a))
          ie.HEADER_SIZE + ie.GTIN_SIZE + ie.WEIGHT_SIZE + ie.DATE_SIZE
        let o = new vt()
          this.encodeCompressedGtin(o, ie.HEADER_SIZE),
          this.encodeCompressedWeight(o, ie.HEADER_SIZE + ie.GTIN_SIZE, ie.WEIGHT_SIZE),
          this.encodeCompressedDate(o, ie.HEADER_SIZE + ie.GTIN_SIZE + ie.WEIGHT_SIZE),
          o.toString()
      encodeCompressedDate(o, a) {
        let l = this.getGeneralDecoder().extractNumericValueFromBitArray(a, ie.DATE_SIZE)
        ;(o.append('('), o.append(this.dateCode), o.append(')'))
        ;(g / 10 == 0 && o.append('0'),
          o.append(g),
          d / 10 == 0 && o.append('0'),
          o.append(d),
          u / 10 == 0 && o.append('0'),
          o.append(u))
      addWeightCode(o, a) {
        ;(o.append('('), o.append(this.firstAIdigits), o.append(a / 1e5), o.append(')'))
      checkWeight(o) {
        return o % 1e5
    ;((ie.HEADER_SIZE = 8), (ie.WEIGHT_SIZE = 20), (ie.DATE_SIZE = 16))
    function Sp(I) {
        if (I.get(1)) return new Zo(I)
        if (!I.get(2)) return new Zl(I)
        switch (Yo.extractNumericValueFromBitArray(I, 1, 4)) {
            return new ub(I)
            return new hb(I)
        switch (Yo.extractNumericValueFromBitArray(I, 1, 5)) {
            return new gr(I)
            return new nn(I)
        switch (Yo.extractNumericValueFromBitArray(I, 1, 7)) {
            return new ie(I, '310', '11')
            return new ie(I, '320', '11')
            return new ie(I, '310', '13')
            return new ie(I, '320', '13')
            return new ie(I, '310', '15')
            return new ie(I, '320', '15')
            return new ie(I, '310', '17')
            return new ie(I, '320', '17')
      } catch (o) {
        throw (console.log(o), new dr('unknown decoder: ' + I))
    class ti {
      constructor(o, a, l, u) {
        ;((this.leftchar = o), (this.rightchar = a), (this.finderpattern = l), (this.maybeLast = u))
      }
      static equals(o, a) {
        return o instanceof ti
          ? ti.equalsOrNull(o.leftchar, a.leftchar) &&
              ti.equalsOrNull(o.rightchar, a.rightchar) &&
              ti.equalsOrNull(o.finderpattern, a.finderpattern)
      }
      static equalsOrNull(o, a) {
        return o === null ? a === null : ti.equals(o, a)
      constructor(o, a, l) {
        ;((this.pairs = o), (this.rowNumber = a), (this.wasReversed = l))
      isEquivalent(o) {
        return this.checkEqualitity(this, o)
      equals(o, a) {
        return o instanceof Mh ? this.checkEqualitity(o, a) && o.wasReversed === a.wasReversed : !1
      checkEqualitity(o, a) {
        if (!o || !a) return
          o.forEach((u, d) => {
    class Q extends Ye {
      constructor(o) {
          (this.verbose = o === !0))
      decodeRow(o, a, l) {
          return Q.constructResult(this.decodeRow2pairs(o, a))
          Q.constructResult(this.decodeRow2pairs(o, a))
      decodeRow2pairs(o, a) {
            this.pairs.push(this.retrieveNextPair(a, this.pairs, o))
        if ((this.rows.length ? (u = !0) : (u = !1), this.storeRow(o, !1), u)) {
      checkRowsBoolean(o) {
        ;((this.pairs.length = 0), o && (this.rows = this.rows.reverse()))
        return (o && (this.rows = this.rows.reverse()), a)
      checkRows(o, a) {
          for (let g of o) this.pairs.push(g.getPairs())
          let d = new Array(o)
      static isValidSequence(o) {
          if (o.length > a.length) continue
          for (let u = 0; u < o.length; u++)
            if (o[u].getFinderPattern().getValue() != a[u]) {
      storeRow(o, a) {
          if (g.getRowNumber() > o) {
          (this.rows.push(l, new Mh(this.pairs, o, a)),
      removePartialRows(o, a) {
          if (l.getPairs().length !== o.length) {
            for (let u of l.getPairs()) for (let d of o) if (ti.equals(u, d)) break
      static isPartialRow(o, a) {
          for (let d of o) {
      static constructResult(o) {
        let a = cb.buildBitArray(o),
          u = o[0].getFinderPattern().getResultPoints(),
          d = o[o.length - 1].getFinderPattern().getResultPoints(),
        return new Bt(l, null, null, g, ut.RSS_EXPANDED, null)
        let o = this.pairs.get(0),
          a = o.getLeftChar(),
          l = o.getRightChar()
      static getNextSecondBar(o, a) {
          o.get(a)
            ? ((l = o.getNextUnset(a)), (l = o.getNextSet(l)))
            : ((l = o.getNextSet(a)), (l = o.getNextUnset(l))),
      }
      retrieveNextPair(o, a, l) {
          (this.findNextPair(o, a, m),
            (d = this.parseFoundFinderPattern(o, l, u)),
            d == null ? (m = Q.getNextSecondBar(o, this.startEnd[0])) : (g = !1))
        let b = this.decodeDataCharacter(o, d, u, !0)
          v = this.decodeDataCharacter(o, d, u, !1)
        return new ti(b, v, d, !0)
      isEmptyPair(o) {
        return o.length === 0
      findNextPair(o, a, l) {
        let d = o.getSize(),
        for (; g < d && ((b = !o.get(g)), !!b); ) g++
          if (o.get(T) != b) u[v]++
      static reverseCounters(o) {
        let a = o.length
          let u = o[l]
          ;((o[l] = o[a - l - 1]), (o[a - l - 1] = u))
      parseFoundFinderPattern(o, a, l) {
          for (; v >= 0 && !o.get(v); ) v--
            (g = o.getNextUnset(this.startEnd[1] + 1)),
      }
      decodeDataCharacter(o, a, l, u) {
        for (let Zt = 0; Zt < d.length; Zt++) d[Zt] = 0
        if (u) Q.recordPatternInReverse(o, a.getStartEnd()[0], d)
          Q.recordPattern(o, a.getStartEnd()[1], d)
          for (let Zt = 0, We = d.length - 1; Zt < We; Zt++, We--) {
            let An = d[Zt]
            ;((d[Zt] = d[We]), (d[We] = An))
          m = Dt.sum(new Int32Array(d)) / g,
          P = this.getEvenRoundingErrors()
        for (let Zt = 0; Zt < d.length; Zt++) {
          let We = (1 * d[Zt]) / m,
            An = We + 0.5
            if (We < 0.3) throw new H()
            if (We > 8.7) throw new H()
          let Jo = Zt / 2
          Zt & 1 ? ((C[Jo] = An), (P[Jo] = We - An)) : ((v[Jo] = An), (T[Jo] = We - An))
          U = 0
        for (let Zt = v.length - 1; Zt >= 0; Zt--) {
            let We = Q.WEIGHTS[B][2 * Zt]
            U += v[Zt] * We
          j += v[Zt]
        for (let Zt = C.length - 1; Zt >= 0; Zt--)
            let We = Q.WEIGHTS[B][2 * Zt + 1]
            Y += C[Zt] * We
        let K = U + Y
        let nt = (13 - j) / 2,
          et = Q.SYMBOL_WIDEST[nt],
          $ = 9 - et,
          Tt = fr.getRSSvalue(v, et, !0),
          Ct = fr.getRSSvalue(C, $, !1),
          pn = Q.EVEN_TOTAL_SUBSET[nt],
          rr = Q.GSUM[nt],
          gn = Tt * pn + Ct + rr
        return new Go(gn, K)
      }
      static isNotA1left(o, a, l) {
        return !(o.getValue() == 0 && a && l)
      }
      adjustOddEvenCounts(o) {
        let a = Dt.sum(new Int32Array(this.getOddCounts())),
          l = Dt.sum(new Int32Array(this.getEvenCounts())),
        let b = a + l - o,
        if (l == 38400) return
        ;(s.append('('), s.append(this.dateCode), s.append(')'))
        let u = l % 32
        l /= 32
        let d = (l % 12) + 1
        l /= 12
        let g = l
        ;(g / 10 == 0 && s.append('0'),
          s.append(g),
          d / 10 == 0 && s.append('0'),
          s.append(d),
          u / 10 == 0 && s.append('0'),
          s.append(u))
      }
      addWeightCode(s, a) {
        ;(s.append('('), s.append(this.firstAIdigits), s.append(a / 1e5), s.append(')'))
      }
      checkWeight(s) {
        return s % 1e5
      }
    }
    ;((it.HEADER_SIZE = 8), (it.WEIGHT_SIZE = 20), (it.DATE_SIZE = 16))
    function Sp(_) {
      try {
        if (_.get(1)) return new Ys(_)
        if (!_.get(2)) return new Zl(_)
        switch (Gs.extractNumericValueFromBitArray(_, 1, 4)) {
          case 4:
            return new ub(_)
          case 5:
            return new hb(_)
        }
        switch (Gs.extractNumericValueFromBitArray(_, 1, 5)) {
          case 12:
            return new gr(_)
          case 13:
            return new nn(_)
        }
        switch (Gs.extractNumericValueFromBitArray(_, 1, 7)) {
          case 56:
            return new it(_, '310', '11')
          case 57:
            return new it(_, '320', '11')
          case 58:
            return new it(_, '310', '13')
          case 59:
            return new it(_, '320', '13')
          case 60:
            return new it(_, '310', '15')
          case 61:
            return new it(_, '320', '15')
          case 62:
            return new it(_, '310', '17')
          case 63:
            return new it(_, '320', '17')
        }
      } catch (s) {
        throw (console.log(s), new dr('unknown decoder: ' + _))
      }
    }
    class ei {
      constructor(s, a, l, u) {
        ;((this.leftchar = s), (this.rightchar = a), (this.finderpattern = l), (this.maybeLast = u))
      }
      mayBeLast() {
        return this.maybeLast
      }
      getLeftChar() {
        return this.leftchar
      }
      getRightChar() {
        return this.rightchar
      }
      getFinderPattern() {
        return this.finderpattern
      }
      mustBeLast() {
        return this.rightchar == null
      }
      toString() {
        return (
          '[ ' +
          this.leftchar +
          ', ' +
          this.rightchar +
          ' : ' +
          (this.finderpattern == null ? 'null' : this.finderpattern.getValue()) +
          ' ]'
        )
      }
      static equals(s, a) {
        return s instanceof ei
          ? ei.equalsOrNull(s.leftchar, a.leftchar) &&
              ei.equalsOrNull(s.rightchar, a.rightchar) &&
              ei.equalsOrNull(s.finderpattern, a.finderpattern)
          : !1
      }
      static equalsOrNull(s, a) {
        return s === null ? a === null : ei.equals(s, a)
      }
      hashCode() {
        return this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue()
      }
    }
    class Mh {
      constructor(s, a, l) {
        ;((this.pairs = s), (this.rowNumber = a), (this.wasReversed = l))
      }
      getPairs() {
        return this.pairs
      }
      getRowNumber() {
        return this.rowNumber
      }
      isReversed() {
        return this.wasReversed
      }
      isEquivalent(s) {
        return this.checkEqualitity(this, s)
      }
      toString() {
        return '{ ' + this.pairs + ' }'
      }
      equals(s, a) {
        return s instanceof Mh ? this.checkEqualitity(s, a) && s.wasReversed === a.wasReversed : !1
      }
      checkEqualitity(s, a) {
        if (!s || !a) return
        let l
        return (
          s.forEach((u, d) => {
            a.forEach((g) => {
              u.getLeftChar().getValue() === g.getLeftChar().getValue() &&
                u.getRightChar().getValue() === g.getRightChar().getValue() &&
                u.getFinderPatter().getValue() === g.getFinderPatter().getValue() &&
                (l = !0)
            })
          }),
          l
        )
      }
    }
    class Q extends Yt {
      constructor(s) {
        ;(super(...arguments),
          (this.pairs = new Array(Q.MAX_PAIRS)),
          (this.rows = new Array()),
          (this.startEnd = [2]),
          (this.verbose = s === !0))
      }
      decodeRow(s, a, l) {
        ;((this.pairs.length = 0), (this.startFromEven = !1))
        try {
          return Q.constructResult(this.decodeRow2pairs(s, a))
        } catch (u) {
          this.verbose && console.log(u)
        }
        return (
          (this.pairs.length = 0),
          (this.startFromEven = !0),
          Q.constructResult(this.decodeRow2pairs(s, a))
        )
      }
      reset() {
        ;((this.pairs.length = 0), (this.rows.length = 0))
      }
      decodeRow2pairs(s, a) {
        let l = !1
        for (; !l; )
          try {
            this.pairs.push(this.retrieveNextPair(a, this.pairs, s))
          } catch (d) {
            if (d instanceof H) {
              if (!this.pairs.length) throw new H()
              l = !0
            }
          }
        if (this.checkChecksum()) return this.pairs
        let u
        if ((this.rows.length ? (u = !0) : (u = !1), this.storeRow(s, !1), u)) {
          let d = this.checkRowsBoolean(!1)
          if (d != null || ((d = this.checkRowsBoolean(!0)), d != null)) return d
        }
        throw new H()
      }
      checkRowsBoolean(s) {
        if (this.rows.length > 25) return ((this.rows.length = 0), null)
        ;((this.pairs.length = 0), s && (this.rows = this.rows.reverse()))
        let a = null
        try {
          a = this.checkRows(new Array(), 0)
        } catch (l) {
          this.verbose && console.log(l)
        }
        return (s && (this.rows = this.rows.reverse()), a)
      }
      checkRows(s, a) {
        for (let l = a; l < this.rows.length; l++) {
          let u = this.rows[l]
          this.pairs.length = 0
          for (let g of s) this.pairs.push(g.getPairs())
          if ((this.pairs.push(u.getPairs()), !Q.isValidSequence(this.pairs))) continue
          if (this.checkChecksum()) return this.pairs
          let d = new Array(s)
          d.push(u)
          try {
            return this.checkRows(d, l + 1)
          } catch (g) {
            this.verbose && console.log(g)
          }
        }
        throw new H()
      }
      static isValidSequence(s) {
        for (let a of Q.FINDER_PATTERN_SEQUENCES) {
          if (s.length > a.length) continue
          let l = !0
          for (let u = 0; u < s.length; u++)
            if (s[u].getFinderPattern().getValue() != a[u]) {
              l = !1
              break
            }
          if (l) return !0
        }
        return !1
      }
      storeRow(s, a) {
        let l = 0,
          u = !1,
          d = !1
        for (; l < this.rows.length; ) {
          let g = this.rows[l]
          if (g.getRowNumber() > s) {
            d = g.isEquivalent(this.pairs)
            break
          }
          ;((u = g.isEquivalent(this.pairs)), l++)
        }
        d ||
          u ||
          Q.isPartialRow(this.pairs, this.rows) ||
          (this.rows.push(l, new Mh(this.pairs, s, a)),
          this.removePartialRows(this.pairs, this.rows))
      }
      removePartialRows(s, a) {
        for (let l of a)
          if (l.getPairs().length !== s.length) {
            for (let u of l.getPairs()) for (let d of s) if (ei.equals(u, d)) break
          }
      }
      static isPartialRow(s, a) {
        for (let l of a) {
          let u = !0
          for (let d of s) {
            let g = !1
            for (let m of l.getPairs())
              if (d.equals(m)) {
                g = !0
                break
              }
            if (!g) {
              u = !1
              break
            }
          }
          if (u) return !0
        }
        return !1
      }
      getRows() {
        return this.rows
      }
      static constructResult(s) {
        let a = cb.buildBitArray(s),
          l = Sp(a).parseInformation(),
          u = s[0].getFinderPattern().getResultPoints(),
          d = s[s.length - 1].getFinderPattern().getResultPoints(),
          g = [u[0], u[1], d[0], d[1]]
        return new Be(l, null, null, g, ue.RSS_EXPANDED, null)
      }
      checkChecksum() {
        let s = this.pairs.get(0),
          a = s.getLeftChar(),
          l = s.getRightChar()
        if (l == null) return !1
        let u = l.getChecksumPortion(),
          d = 2
        for (let g = 1; g < this.pairs.size(); ++g) {
          let m = this.pairs.get(g)
          ;((u += m.getLeftChar().getChecksumPortion()), d++)
          let b = m.getRightChar()
          b != null && ((u += b.getChecksumPortion()), d++)
        }
        return ((u %= 211), 211 * (d - 4) + u == a.getValue())
      }
      static getNextSecondBar(s, a) {
        let l
        return (
          s.get(a)
            ? ((l = s.getNextUnset(a)), (l = s.getNextSet(l)))
            : ((l = s.getNextSet(a)), (l = s.getNextUnset(l))),
          l
        )
      }
      retrieveNextPair(s, a, l) {
        let u = a.length % 2 == 0
        this.startFromEven && (u = !u)
        let d,
          g = !0,
          m = -1
        do
          (this.findNextPair(s, a, m),
            (d = this.parseFoundFinderPattern(s, l, u)),
            d == null ? (m = Q.getNextSecondBar(s, this.startEnd[0])) : (g = !1))
        while (g)
        let b = this.decodeDataCharacter(s, d, u, !0)
        if (!this.isEmptyPair(a) && a[a.length - 1].mustBeLast()) throw new H()
        let v
        try {
          v = this.decodeDataCharacter(s, d, u, !1)
        } catch (C) {
          ;((v = null), this.verbose && console.log(C))
        }
        return new ei(b, v, d, !0)
      }
      isEmptyPair(s) {
        return s.length === 0
      }
      findNextPair(s, a, l) {
        let u = this.getDecodeFinderCounters()
        ;((u[0] = 0), (u[1] = 0), (u[2] = 0), (u[3] = 0))
        let d = s.getSize(),
          g
        l >= 0
          ? (g = l)
          : this.isEmptyPair(a)
            ? (g = 0)
            : (g = a[a.length - 1].getFinderPattern().getStartEnd()[1])
        let m = a.length % 2 != 0
        this.startFromEven && (m = !m)
        let b = !1
        for (; g < d && ((b = !s.get(g)), !!b); ) g++
        let v = 0,
          C = g
        for (let T = g; T < d; T++)
          if (s.get(T) != b) u[v]++
          else {
            if (v == 3) {
              if ((m && Q.reverseCounters(u), Q.isFinderPattern(u))) {
                ;((this.startEnd[0] = C), (this.startEnd[1] = T))
                return
              }
              ;(m && Q.reverseCounters(u),
                (C += u[0] + u[1]),
                (u[0] = u[2]),
                (u[1] = u[3]),
                (u[2] = 0),
                (u[3] = 0),
                v--)
            } else v++
            ;((u[v] = 1), (b = !b))
          }
        throw new H()
      }
      static reverseCounters(s) {
        let a = s.length
        for (let l = 0; l < a / 2; ++l) {
          let u = s[l]
          ;((s[l] = s[a - l - 1]), (s[a - l - 1] = u))
        }
      }
      parseFoundFinderPattern(s, a, l) {
        let u, d, g
        if (l) {
          let v = this.startEnd[0] - 1
          for (; v >= 0 && !s.get(v); ) v--
          ;(v++, (u = this.startEnd[0] - v), (d = v), (g = this.startEnd[1]))
        } else
          ((d = this.startEnd[0]),
            (g = s.getNextUnset(this.startEnd[1] + 1)),
            (u = g - this.startEnd[1]))
        let m = this.getDecodeFinderCounters()
        ;(k.arraycopy(m, 0, m, 1, m.length - 1), (m[0] = u))
        let b
        try {
          b = this.parseFinderValue(m, Q.FINDER_PATTERNS)
        } catch {
          return null
        }
        return new Yl(b, [d, g], d, g, a)
      }
      decodeDataCharacter(s, a, l, u) {
        let d = this.getDataCharacterCounters()
        for (let Ze = 0; Ze < d.length; Ze++) d[Ze] = 0
        if (u) Q.recordPatternInReverse(s, a.getStartEnd()[0], d)
        else {
          Q.recordPattern(s, a.getStartEnd()[1], d)
          for (let Ze = 0, Ut = d.length - 1; Ze < Ut; Ze++, Ut--) {
            let An = d[Ze]
            ;((d[Ze] = d[Ut]), (d[Ut] = An))
          }
        }
        let g = 17,
          m = Pe.sum(new Int32Array(d)) / g,
          b = (a.getStartEnd()[1] - a.getStartEnd()[0]) / 15
        if (Math.abs(m - b) / b > 0.3) throw new H()
        let v = this.getOddCounts(),
          C = this.getEvenCounts(),
          T = this.getOddRoundingErrors(),
          D = this.getEvenRoundingErrors()
        for (let Ze = 0; Ze < d.length; Ze++) {
          let Ut = (1 * d[Ze]) / m,
            An = Ut + 0.5
          if (An < 1) {
            if (Ut < 0.3) throw new H()
            An = 1
          } else if (An > 8) {
            if (Ut > 8.7) throw new H()
            An = 8
          }
          let $s = Ze / 2
          Ze & 1 ? ((C[$s] = An), (D[$s] = Ut - An)) : ((v[$s] = An), (T[$s] = Ut - An))
        }
        this.adjustOddEvenCounts(g)
        let B = 4 * a.getValue() + (l ? 0 : 2) + (u ? 0 : 1) - 1,
          j = 0,
          W = 0
        for (let Ze = v.length - 1; Ze >= 0; Ze--) {
          if (Q.isNotA1left(a, l, u)) {
            let Ut = Q.WEIGHTS[B][2 * Ze]
            W += v[Ze] * Ut
          }
          j += v[Ze]
        }
        let Y = 0
        for (let Ze = C.length - 1; Ze >= 0; Ze--)
          if (Q.isNotA1left(a, l, u)) {
            let Ut = Q.WEIGHTS[B][2 * Ze + 1]
            Y += C[Ze] * Ut
          }
        let q = W + Y
        if (j & 1 || j > 13 || j < 4) throw new H()
        let ne = (13 - j) / 2,
          te = Q.SYMBOL_WIDEST[ne],
          $ = 9 - te,
          Te = fr.getRSSvalue(v, te, !0),
          Ce = fr.getRSSvalue(C, $, !1),
          pn = Q.EVEN_TOTAL_SUBSET[ne],
          rr = Q.GSUM[ne],
          gn = Te * pn + Ce + rr
        return new Xs(gn, q)
      }
      static isNotA1left(s, a, l) {
        return !(s.getValue() == 0 && a && l)
      }
      adjustOddEvenCounts(s) {
        let a = Pe.sum(new Int32Array(this.getOddCounts())),
          l = Pe.sum(new Int32Array(this.getEvenCounts())),
          u = !1,
          d = !1
        a > 13 ? (d = !0) : a < 4 && (u = !0)
        let g = !1,
          m = !1
        l > 13 ? (m = !0) : l < 4 && (g = !0)
        let b = a + l - s,
          v = (a & 1) == 1,
          C = (l & 1) == 0
        if (b == 1)
          if (v) {
            if (C) throw new H()
            d = !0
          } else {
            if (!C) throw new H()
            m = !0
          }
        else if (b == -1)
          if (v) {
            if (C) throw new H()
            u = !0
          } else {
            if (!C) throw new H()
            g = !0
          }
        else if (b == 0) {
          if (v) {
            if (!C) throw new H()
            a < l ? ((u = !0), (m = !0)) : ((d = !0), (g = !0))
          } else if (C) throw new H()
        } else throw new H()
        if (u) {
          if (d) throw new H()
          Q.increment(this.getOddCounts(), this.getOddRoundingErrors())
        }
        if ((d && Q.decrement(this.getOddCounts(), this.getOddRoundingErrors()), g)) {
          if (m) throw new H()
          Q.increment(this.getEvenCounts(), this.getOddRoundingErrors())
        }
        m && Q.decrement(this.getEvenCounts(), this.getEvenRoundingErrors())
      }
    }
    ;((Q.SYMBOL_WIDEST = [7, 5, 4, 3, 1]),
      (Q.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204]),
      (Q.GSUM = [0, 348, 1388, 2948, 3988]),
      (Q.FINDER_PATTERNS = [
        Int32Array.from([1, 8, 4, 1]),
        Int32Array.from([3, 6, 4, 1]),
        Int32Array.from([3, 4, 6, 1]),
        Int32Array.from([3, 2, 8, 1]),
        Int32Array.from([2, 6, 5, 1]),
        Int32Array.from([2, 2, 9, 1]),
      ]),
      (Q.WEIGHTS = [
        [1, 3, 9, 27, 81, 32, 96, 77],
        [20, 60, 180, 118, 143, 7, 21, 63],
        [189, 145, 13, 39, 117, 140, 209, 205],
        [193, 157, 49, 147, 19, 57, 171, 91],
        [62, 186, 136, 197, 169, 85, 44, 132],
        [185, 133, 188, 142, 4, 12, 36, 108],
        [113, 128, 173, 97, 80, 29, 87, 50],
        [150, 28, 84, 41, 123, 158, 52, 156],
        [46, 138, 203, 187, 139, 206, 196, 166],
        [76, 17, 51, 153, 37, 111, 122, 155],
        [43, 129, 176, 106, 107, 110, 119, 146],
        [16, 48, 144, 10, 30, 90, 59, 177],
        [109, 116, 137, 200, 178, 112, 125, 164],
        [70, 210, 208, 202, 184, 130, 179, 115],
        [134, 191, 151, 31, 93, 68, 204, 190],
        [148, 22, 66, 198, 172, 94, 71, 2],
        [6, 18, 54, 162, 64, 192, 154, 40],
        [120, 149, 25, 75, 14, 42, 126, 167],
        [79, 26, 78, 23, 69, 207, 199, 175],
        [103, 98, 83, 38, 114, 131, 182, 124],
        [161, 61, 183, 127, 170, 88, 53, 159],
        [55, 165, 73, 8, 24, 72, 5, 15],
        [45, 135, 194, 160, 58, 174, 100, 89],
      ]),
      (Q.FINDER_PAT_A = 0),
      (Q.FINDER_PAT_B = 1),
      (Q.FINDER_PAT_C = 2),
      (Q.FINDER_PAT_D = 3),
      (Q.FINDER_PAT_E = 4),
      (Q.FINDER_PAT_F = 5),
      (Q.FINDER_PATTERN_SEQUENCES = [
        [Q.FINDER_PAT_A, Q.FINDER_PAT_A],
        [Q.FINDER_PAT_A, Q.FINDER_PAT_B, Q.FINDER_PAT_B],
        [Q.FINDER_PAT_A, Q.FINDER_PAT_C, Q.FINDER_PAT_B, Q.FINDER_PAT_D],
        [Q.FINDER_PAT_A, Q.FINDER_PAT_E, Q.FINDER_PAT_B, Q.FINDER_PAT_D, Q.FINDER_PAT_C],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_F,
        ],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_F,
          Q.FINDER_PAT_F,
        ],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_D,
        ],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_C,
          Q.FINDER_PAT_D,
          Q.FINDER_PAT_E,
          Q.FINDER_PAT_E,
        ],
        [
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_A,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_B,
          Q.FINDER_PAT_C,
    class db extends Go {
      constructor(o, a, l) {
        ;(super(o, a), (this.count = 0), (this.finderPattern = l))
    class pe extends Ye {
      decodeRow(o, a, l) {
        const u = this.decodePair(a, !1, o, l)
        ;(pe.addOrTally(this.possibleLeftPairs, u), a.reverse())
        let d = this.decodePair(a, !0, o, l)
        ;(pe.addOrTally(this.possibleRightPairs, d), a.reverse())
              if (m.getCount() > 1 && pe.checkChecksum(g, m)) return pe.constructResult(g, m)
      static addOrTally(o, a) {
        for (let u of o)
        l || o.push(a)
      static constructResult(o, a) {
        let l = 4537077 * o.getValue() + a.getValue(),
          d = new vt()
        let m = o.getFinderPattern().getResultPoints(),
        return new Bt(
          ut.RSS_14,
      static checkChecksum(o, a) {
        let l = (o.getChecksumPortion() + 16 * a.getChecksumPortion()) % 79,
          u = 9 * o.getFinderPattern().getValue() + a.getFinderPattern().getValue()
      decodePair(o, a, l, u) {
          let d = this.findFinderPattern(o, a),
            g = this.parseFoundFinderPattern(o, l, a, d),
            ;(a && (C = o.getSize() - 1 - C), m.foundPossibleResultPoint(new ht(C, l)))
          let b = this.decodeDataCharacter(o, g, !0),
            v = this.decodeDataCharacter(o, g, !1)
      decodeDataCharacter(o, a, l) {
        if (l) Ce.recordPatternInReverse(o, a.getStartEnd()[0], u)
          Ce.recordPattern(o, a.getStartEnd()[1] + 1, u)
          for (let Y = 0, K = u.length - 1; Y < K; Y++, K--) {
            let nt = u[Y]
            ;((u[Y] = u[K]), (u[K] = nt))
          g = Dt.sum(new Int32Array(u)) / d,
          let K = u[Y] / g,
            nt = Math.floor(K + 0.5)
          nt < 1 ? (nt = 1) : nt > 8 && (nt = 8)
          let et = Math.floor(Y / 2)
          Y & 1 ? ((b[et] = nt), (C[et] = K - nt)) : ((m[et] = nt), (v[et] = K - nt))
          P = 0
        for (let Y = m.length - 1; Y >= 0; Y--) ((P *= 9), (P += m[Y]), (T += m[Y]))
        let U = P + 3 * B
            K = pe.OUTSIDE_ODD_WIDEST[Y],
            nt = 9 - K,
            et = fr.getRSSvalue(m, K, !1),
            $ = fr.getRSSvalue(b, nt, !0),
            Tt = pe.OUTSIDE_EVEN_TOTAL_SUBSET[Y],
            Ct = pe.OUTSIDE_GSUM[Y]
          return new Go(et * Tt + $ + Ct, U)
            K = pe.INSIDE_ODD_WIDEST[Y],
            nt = 9 - K,
            et = fr.getRSSvalue(m, K, !0),
            $ = fr.getRSSvalue(b, nt, !1),
            Tt = pe.INSIDE_ODD_TOTAL_SUBSET[Y],
            Ct = pe.INSIDE_GSUM[Y]
          return new Go($ * Tt + et + Ct, U)
      findFinderPattern(o, a) {
        let u = o.getSize(),
        for (; g < u && ((d = !o.get(g)), a !== d); ) g++
          if (o.get(v) !== d) l[m]++
              if (Ye.isFinderPattern(l)) return [b, v]
      parseFoundFinderPattern(o, a, l, u) {
        let d = o.get(u[0]),
        for (; g >= 0 && d !== o.get(g); ) g--
        const C = this.parseFinderValue(v, pe.FINDER_PATTERNS)
          P = u[1]
          l && ((T = o.getSize() - 1 - T), (P = o.getSize() - 1 - P)),
          new Yl(C, [g, u[1]], T, P, a)
      adjustOddEvenCounts(o, a) {
        let l = Dt.sum(new Int32Array(this.getOddCounts())),
          u = Dt.sum(new Int32Array(this.getEvenCounts())),
        o
          C = (l & 1) === (o ? 1 : 0),
          Ye.increment(this.getOddCounts(), this.getOddRoundingErrors())
        if ((g && Ye.decrement(this.getOddCounts(), this.getOddRoundingErrors()), m)) {
          Ye.increment(this.getEvenCounts(), this.getOddRoundingErrors())
        b && Ye.decrement(this.getEvenCounts(), this.getEvenRoundingErrors())
    ;((pe.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126]),
      (pe.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81]),
      (pe.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715]),
      (pe.INSIDE_GSUM = [0, 336, 1036, 1516]),
      (pe.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1]),
      (pe.INSIDE_ODD_WIDEST = [2, 4, 6, 8]),
      (pe.FINDER_PATTERNS = [
    class qo extends Ce {
      constructor(o, a) {
        const l = o ? o.get(z.POSSIBLE_FORMATS) : null,
          u = o && o.get(z.ASSUME_CODE_39_CHECK_DIGIT) !== void 0
          ? ((l.includes(ut.EAN_13) ||
              l.includes(ut.UPC_A) ||
              l.includes(ut.EAN_8) ||
              l.includes(ut.UPC_E)) &&
              this.readers.push(new Rh(o)),
            l.includes(ut.CODE_39) && this.readers.push(new Ae(u)),
            l.includes(ut.CODE_128) && this.readers.push(new it()),
            l.includes(ut.ITF) && this.readers.push(new Gt()),
            l.includes(ut.RSS_14) && this.readers.push(new pe()),
            l.includes(ut.RSS_EXPANDED) && this.readers.push(new Q(this.verbose)))
          : (this.readers.push(new Rh(o)),
            this.readers.push(new Ae()),
            this.readers.push(new Rh(o)),
            this.readers.push(new it()),
            this.readers.push(new Gt()),
            this.readers.push(new pe()),
      decodeRow(o, a, l) {
            return this.readers[u].decodeRow(o, a, l)
        this.readers.forEach((o) => o.reset())
    class fb extends Te {
      constructor(o = 500, a) {
        super(new qo(a), o, a)
      }
    class Wt {
      constructor(o, a, l) {
        ;((this.ecCodewords = o), (this.ecBlocks = [a]), l && this.ecBlocks.push(l))
    class Vt {
      constructor(o, a) {
        ;((this.count = o), (this.dataCodewords = a))
    class Nt {
      constructor(o, a, l, u, d, g) {
        ;((this.versionNumber = o),
      static getVersionForDimensions(o, a) {
        if (o & 1 || a & 1) throw new V()
        for (let l of Nt.VERSIONS) if (l.symbolSizeRows === o && l.symbolSizeColumns === a) return l
          new Nt(1, 10, 10, 8, 8, new Wt(5, new Vt(1, 3))),
          new Nt(2, 12, 12, 10, 10, new Wt(7, new Vt(1, 5))),
          new Nt(3, 14, 14, 12, 12, new Wt(10, new Vt(1, 8))),
          new Nt(4, 16, 16, 14, 14, new Wt(12, new Vt(1, 12))),
          new Nt(5, 18, 18, 16, 16, new Wt(14, new Vt(1, 18))),
          new Nt(6, 20, 20, 18, 18, new Wt(18, new Vt(1, 22))),
          new Nt(7, 22, 22, 20, 20, new Wt(20, new Vt(1, 30))),
          new Nt(8, 24, 24, 22, 22, new Wt(24, new Vt(1, 36))),
          new Nt(9, 26, 26, 24, 24, new Wt(28, new Vt(1, 44))),
          new Nt(10, 32, 32, 14, 14, new Wt(36, new Vt(1, 62))),
          new Nt(11, 36, 36, 16, 16, new Wt(42, new Vt(1, 86))),
          new Nt(12, 40, 40, 18, 18, new Wt(48, new Vt(1, 114))),
          new Nt(13, 44, 44, 20, 20, new Wt(56, new Vt(1, 144))),
          new Nt(14, 48, 48, 22, 22, new Wt(68, new Vt(1, 174))),
          new Nt(15, 52, 52, 24, 24, new Wt(42, new Vt(2, 102))),
          new Nt(16, 64, 64, 14, 14, new Wt(56, new Vt(2, 140))),
          new Nt(17, 72, 72, 16, 16, new Wt(36, new Vt(4, 92))),
          new Nt(18, 80, 80, 18, 18, new Wt(48, new Vt(4, 114))),
          new Nt(19, 88, 88, 20, 20, new Wt(56, new Vt(4, 144))),
          new Nt(20, 96, 96, 22, 22, new Wt(68, new Vt(4, 174))),
          new Nt(21, 104, 104, 24, 24, new Wt(56, new Vt(6, 136))),
          new Nt(22, 120, 120, 18, 18, new Wt(68, new Vt(6, 175))),
          new Nt(23, 132, 132, 20, 20, new Wt(62, new Vt(8, 163))),
          new Nt(24, 144, 144, 22, 22, new Wt(62, new Vt(8, 156), new Vt(2, 155))),
          new Nt(25, 8, 18, 6, 16, new Wt(7, new Vt(1, 5))),
          new Nt(26, 8, 32, 6, 14, new Wt(11, new Vt(1, 10))),
          new Nt(27, 12, 26, 10, 24, new Wt(14, new Vt(1, 16))),
          new Nt(28, 12, 36, 10, 16, new Wt(18, new Vt(1, 22))),
          new Nt(29, 16, 36, 14, 16, new Wt(24, new Vt(1, 32))),
          new Nt(30, 16, 48, 14, 22, new Wt(28, new Vt(1, 49))),
    Nt.VERSIONS = Nt.buildVersions()
    class Dh {
      constructor(o) {
        const a = o.getHeight()
        ;((this.version = Dh.readVersion(o)),
          (this.mappingBitMatrix = this.extractDataRegion(o)),
          (this.readMappingMatrix = new _t(
      static readVersion(o) {
        const a = o.getHeight(),
          l = o.getWidth()
        return Nt.getVersionForDimensions(a, l)
      }
        const o = new Int8Array(this.version.getTotalCodewords())
            ((o[a++] = this.readCorner1(d, g) & 255), (l -= 2), (u += 2), (m = !0))
            ((o[a++] = this.readCorner2(d, g) & 255), (l -= 2), (u += 2), (b = !0))
            ((o[a++] = this.readCorner3(d, g) & 255), (l -= 2), (u += 2), (v = !0))
            ((o[a++] = this.readCorner4(d, g) & 255), (l -= 2), (u += 2), (C = !0))
                (o[a++] = this.readUtah(l, u, d, g) & 255),
                (o[a++] = this.readUtah(l, u, d, g) & 255),
        return o
      readModule(o, a, l, u) {
          o < 0 && ((o += l), (a += 4 - ((l + 4) & 7))),
          a < 0 && ((a += u), (o += 4 - ((u + 4) & 7))),
          this.readMappingMatrix.set(a, o),
          this.mappingBitMatrix.get(a, o)
      readUtah(o, a, l, u) {
          this.readModule(o - 2, a - 2, l, u) && (d |= 1),
          this.readModule(o - 2, a - 1, l, u) && (d |= 1),
          this.readModule(o - 1, a - 2, l, u) && (d |= 1),
          this.readModule(o - 1, a - 1, l, u) && (d |= 1),
          this.readModule(o - 1, a, l, u) && (d |= 1),
          this.readModule(o, a - 2, l, u) && (d |= 1),
          this.readModule(o, a - 1, l, u) && (d |= 1),
          this.readModule(o, a, l, u) && (d |= 1),
      readCorner1(o, a) {
          this.readModule(o - 1, 0, o, a) && (l |= 1),
          this.readModule(o - 1, 1, o, a) && (l |= 1),
          this.readModule(o - 1, 2, o, a) && (l |= 1),
          this.readModule(0, a - 2, o, a) && (l |= 1),
          this.readModule(0, a - 1, o, a) && (l |= 1),
          this.readModule(1, a - 1, o, a) && (l |= 1),
          this.readModule(2, a - 1, o, a) && (l |= 1),
          this.readModule(3, a - 1, o, a) && (l |= 1),
      readCorner2(o, a) {
        return (
          this.readModule(o - 3, 0, o, a) && (l |= 1),
          this.readModule(o - 2, 0, o, a) && (l |= 1),
          this.readModule(o - 1, 0, o, a) && (l |= 1),
          this.readModule(0, a - 4, o, a) && (l |= 1),
          this.readModule(0, a - 3, o, a) && (l |= 1),
          this.readModule(0, a - 2, o, a) && (l |= 1),
          this.readModule(0, a - 1, o, a) && (l |= 1),
          this.readModule(1, a - 1, o, a) && (l |= 1),
      readCorner3(o, a) {
          this.readModule(o - 1, 0, o, a) && (l |= 1),
          this.readModule(o - 1, a - 1, o, a) && (l |= 1),
          this.readModule(0, a - 3, o, a) && (l |= 1),
          this.readModule(0, a - 2, o, a) && (l |= 1),
          this.readModule(0, a - 1, o, a) && (l |= 1),
          this.readModule(1, a - 3, o, a) && (l |= 1),
          this.readModule(1, a - 2, o, a) && (l |= 1),
          this.readModule(1, a - 1, o, a) && (l |= 1),
      readCorner4(o, a) {
          this.readModule(o - 3, 0, o, a) && (l |= 1),
          this.readModule(o - 2, 0, o, a) && (l |= 1),
          this.readModule(o - 1, 0, o, a) && (l |= 1),
          this.readModule(0, a - 2, o, a) && (l |= 1),
          this.readModule(0, a - 1, o, a) && (l |= 1),
          this.readModule(1, a - 1, o, a) && (l |= 1),
          this.readModule(2, a - 1, o, a) && (l |= 1),
          this.readModule(3, a - 1, o, a) && (l |= 1),
      extractDataRegion(o) {
        if (o.getHeight() !== a) throw new w('Dimension of bitMatrix must match the version size')
          C = new _t(v, b)
          const P = T * u
            for (let U = 0; U < u; ++U) {
              const Y = T * (u + 2) + 1 + U,
                K = P + U
              for (let nt = 0; nt < d; ++nt) {
                const et = B * (d + 2) + 1 + nt
                if (o.get(et, Y)) {
                  const $ = j + nt
                  C.set($, K)
    class Ph {
      constructor(o, a) {
        ;((this.numDataCodewords = o), (this.codewords = a))
      static getDataBlocks(o, a) {
          for (let U = 0; U < j.getCount(); U++) {
              K = l.getECCodewords() + Y
            g[m++] = new Ph(Y, new Uint8Array(K))
        for (let j = 0; j < v; j++) for (let U = 0; U < m; U++) g[U].codewords[j] = o[C++]
          P = T ? 8 : m
        for (let j = 0; j < P; j++) g[j].codewords[b - 1] = o[C++]
          for (let U = 0; U < m; U++) {
            const Y = T ? (U + 8) % m : U,
              K = T && Y > 7 ? j - 1 : j
            g[Y].codewords[K] = o[C++]
        if (C !== o.length) throw new w()
      constructor(o) {
        ;((this.bytes = o), (this.byteOffset = 0), (this.bitOffset = 0))
      readBits(o) {
        if (o < 1 || o > 32 || o > this.available()) throw new w('' + o)
            m = o < g ? o : g,
          ;((a = (d[u] & v) >> b), (o -= m), (l += m), l === 8 && ((l = 0), u++))
        if (o > 0) {
          for (; o >= 8; ) ((a = (a << 8) | (d[u] & 255)), u++, (o -= 8))
          if (o > 0) {
            const g = 8 - o,
            ;((a = (a << o) | ((d[u] & m) >> g)), (l += o))
    var ke
    ;(function (I) {
      ;((I[(I.PAD_ENCODE = 0)] = 'PAD_ENCODE'),
        (I[(I.ASCII_ENCODE = 1)] = 'ASCII_ENCODE'),
        (I[(I.C40_ENCODE = 2)] = 'C40_ENCODE'),
        (I[(I.TEXT_ENCODE = 3)] = 'TEXT_ENCODE'),
        (I[(I.ANSIX12_ENCODE = 4)] = 'ANSIX12_ENCODE'),
        (I[(I.EDIFACT_ENCODE = 5)] = 'EDIFACT_ENCODE'),
        (I[(I.BASE256_ENCODE = 6)] = 'BASE256_ENCODE'))
    })(ke || (ke = {}))
    class ei {
      static decode(o) {
        const a = new Lh(o),
          l = new vt(),
          u = new vt(),
        let g = ke.ASCII_ENCODE
          if (g === ke.ASCII_ENCODE) g = this.decodeAsciiSegment(a, l, u)
              case ke.C40_ENCODE:
              case ke.TEXT_ENCODE:
              case ke.ANSIX12_ENCODE:
              case ke.EDIFACT_ENCODE:
              case ke.BASE256_ENCODE:
            g = ke.ASCII_ENCODE
        while (g !== ke.PAD_ENCODE && a.available() > 0)
          new Js(o, l.toString(), d.length === 0 ? null : d, null)
      static decodeAsciiSegment(o, a, l) {
          let d = o.readBits(8)
            return (u && (d += 128), a.append(String.fromCharCode(d - 1)), ke.ASCII_ENCODE)
          if (d === 129) return ke.PAD_ENCODE
                return ke.C40_ENCODE
                return ke.BASE256_ENCODE
                return ke.ANSIX12_ENCODE
                return ke.TEXT_ENCODE
                return ke.EDIFACT_ENCODE
                if (d !== 254 || o.available() !== 0) throw new V()
        } while (o.available() > 0)
        return ke.ASCII_ENCODE
      static decodeC40Segment(o, a) {
          if (o.available() === 8) return
          const g = o.readBits(8)
          this.parseTwoBytes(g, o.readBits(8), u)
        } while (o.available() > 0)
      static decodeTextSegment(o, a) {
          if (o.available() === 8) return
          const g = o.readBits(8)
          this.parseTwoBytes(g, o.readBits(8), u)
        } while (o.available() > 0)
      static decodeAnsiX12Segment(o, a) {
          if (o.available() === 8) return
          const u = o.readBits(8)
          this.parseTwoBytes(u, o.readBits(8), l)
        } while (o.available() > 0)
      }
      static parseTwoBytes(o, a, l) {
        let u = (o << 8) + a - 1,
      static decodeEdifactSegment(o, a) {
          if (o.available() <= 16) return
            let u = o.readBits(6)
              const d = 8 - o.getBitOffset()
              d !== 8 && o.readBits(d)
        } while (o.available() > 0)
      static decodeBase256Segment(o, a, l) {
        let u = 1 + o.getByteOffset()
        const d = this.unrandomize255State(o.readBits(8), u++)
            ? (g = (o.available() / 8) | 0)
              : (g = 250 * (d - 249) + this.unrandomize255State(o.readBits(8), u++)),
          if (o.available() < 8) throw new V()
          m[b] = this.unrandomize255State(o.readBits(8), u++)
          a.append(st.decode(m, rt.ISO88591))
      static unrandomize255State(o, a) {
          u = o - l
    ;((ei.C40_BASIC_SET_CHARS = [
      (ei.C40_SHIFT2_SET_CHARS = [
      (ei.TEXT_BASIC_SET_CHARS = [
      (ei.TEXT_SHIFT2_SET_CHARS = ei.C40_SHIFT2_SET_CHARS),
      (ei.TEXT_SHIFT3_SET_CHARS = [
        this.rsDecoder = new ea(Ft.DATA_MATRIX_FIELD_256)
      decode(o) {
        const a = new Dh(o),
          d = Ph.getDataBlocks(u, l)
            P = C.getNumDataCodewords()
          this.correctErrors(T, P)
          for (let B = 0; B < P; B++) m[B * b + v] = T[B]
        return ei.decode(m)
      }
      correctErrors(o, a) {
        const l = new Int32Array(o)
          this.rsDecoder.decode(l, o.length - a)
        for (let u = 0; u < a; u++) o[u] = l[u]
    class ve {
      constructor(o) {
        ;((this.image = o), (this.rectangleDetector = new Tr(this.image)))
        const o = this.rectangleDetector.detect()
        let a = this.detectSolid1(o)
        let v = ve.sampleGrid(this.image, l, u, d, g, m, b)
      static shiftPoint(o, a, l) {
        let u = (a.getX() - o.getX()) / (l + 1),
          d = (a.getY() - o.getY()) / (l + 1)
        return new ht(o.getX() + u, o.getY() + d)
      }
      static moveAway(o, a, l) {
        let u = o.getX(),
          d = o.getY()
        return (u < a ? (u -= 1) : (u += 1), d < l ? (d -= 1) : (d += 1), new ht(u, d))
      }
      detectSolid1(o) {
        let a = o[0],
          l = o[1],
          u = o[3],
          d = o[2],
      detectSolid2(o) {
        let a = o[0],
          l = o[1],
          u = o[2],
          d = o[3],
          m = ve.shiftPoint(l, u, (g + 1) * 4),
          b = ve.shiftPoint(u, l, (g + 1) * 4),
            ? ((o[0] = a), (o[1] = l), (o[2] = u), (o[3] = d))
            : ((o[0] = l), (o[1] = u), (o[2] = d), (o[3] = a)),
          o
      correctTopRight(o) {
        let a = o[0],
          l = o[1],
          u = o[2],
          d = o[3],
          b = ve.shiftPoint(a, l, (m + 1) * 4),
          v = ve.shiftPoint(u, l, (g + 1) * 4)
        let C = new ht(
          T = new ht(
        let P = this.transitionsBetween(b, C) + this.transitionsBetween(v, C),
        return P > B ? C : T
      shiftToModuleCenter(o) {
        let a = o[0],
          l = o[1],
          u = o[2],
          d = o[3],
          b = ve.shiftPoint(a, l, m * 4),
          v = ve.shiftPoint(u, l, g * 4)
        ;((a = ve.moveAway(a, C, T)),
          (l = ve.moveAway(l, C, T)),
          (u = ve.moveAway(u, C, T)),
          (d = ve.moveAway(d, C, T)))
        let P, B
          (b = ve.shiftPoint(a, l, m * 4)),
          (b = ve.shiftPoint(b, d, g * 4)),
          (P = ve.shiftPoint(l, a, m * 4)),
          (P = ve.shiftPoint(P, u, g * 4)),
          (v = ve.shiftPoint(u, d, m * 4)),
          (v = ve.shiftPoint(v, l, g * 4)),
          (B = ve.shiftPoint(d, u, m * 4)),
          (B = ve.shiftPoint(B, a, g * 4)),
          [b, P, v, B]
      isValid(o) {
          o.getX() >= 0 &&
          o.getX() < this.image.getWidth() &&
          o.getY() > 0 &&
          o.getY() < this.image.getHeight()
      }
      static sampleGrid(o, a, l, u, d, g, m) {
          o,
      transitionsBetween(o, a) {
        let l = Math.trunc(o.getX()),
          u = Math.trunc(o.getY()),
          let U = l
          ;((l = u), (u = U), (U = d), (d = g), (g = U))
          P = l < d ? 1 : -1,
        for (let U = l, Y = u; U !== d; U += P) {
          let K = this.image.get(m ? Y : U, m ? U : Y)
          if ((K !== j && (B++, (j = K)), (C += v), C > 0)) {
      decode(o, a = null) {
          const v = ni.extractPureBits(o.getBlackMatrix())
          const v = new ve(o.getBlackMatrix()).detect()
          g = new Bt(l.getText(), d, 8 * d.length, u, ut.DATA_MATRIX, k.currentTimeMillis()),
        m != null && g.putMetadata(Ne.BYTE_SEGMENTS, m)
        return (b != null && g.putMetadata(Ne.ERROR_CORRECTION_LEVEL, b), g)
      static extractPureBits(o) {
        const a = o.getTopLeftOnBit(),
          l = o.getBottomRightOnBit()
        const u = this.moduleSize(a, o)
        const T = new _t(b, v)
        for (let P = 0; P < v; P++) {
          const B = d + P * u
          for (let j = 0; j < b; j++) o.get(m + j * u, B) && T.set(j, P)
      static moduleSize(o, a) {
        let u = o[0]
        const d = o[1]
        const g = u - o[0]
    class gb extends Te {
      constructor(o = 500) {
        super(new ni(), o)
      }
    }
    var Ko
    ;(function (I) {
      ;((I[(I.L = 0)] = 'L'), (I[(I.M = 1)] = 'M'), (I[(I.Q = 2)] = 'Q'), (I[(I.H = 3)] = 'H'))
    })(Ko || (Ko = {}))
    class Kt {
      constructor(o, a, l) {
        ;((this.value = o),
          Kt.FOR_BITS.set(l, this),
          Kt.FOR_VALUE.set(o, this))
      static fromString(o) {
        switch (o) {
            return Kt.L
            return Kt.M
            return Kt.Q
            return Kt.H
            throw new y(o + 'not available')
      equals(o) {
        if (!(o instanceof Kt)) return !1
        const a = o
      static forBits(o) {
        if (o < 0 || o >= Kt.FOR_BITS.size) throw new w()
        return Kt.FOR_BITS.get(o)
      }
    ;((Kt.FOR_BITS = new Map()),
      (Kt.FOR_VALUE = new Map()),
      (Kt.L = new Kt(Ko.L, 'L', 1)),
      (Kt.M = new Kt(Ko.M, 'M', 0)),
      (Kt.Q = new Kt(Ko.Q, 'Q', 3)),
      (Kt.H = new Kt(Ko.H, 'H', 2)))
    class Ze {
      constructor(o) {
        ;((this.errorCorrectionLevel = Kt.forBits((o >> 3) & 3)), (this.dataMask = o & 7))
      static numBitsDiffering(o, a) {
        return M.bitCount(o ^ a)
      static decodeFormatInformation(o, a) {
        const l = Ze.doDecodeFormatInformation(o, a)
          : Ze.doDecodeFormatInformation(o ^ Ze.FORMAT_INFO_MASK_QR, a ^ Ze.FORMAT_INFO_MASK_QR)
      static doDecodeFormatInformation(o, a) {
        for (const d of Ze.FORMAT_INFO_DECODE_LOOKUP) {
          if (g === o || g === a) return new Ze(d[1])
          let m = Ze.numBitsDiffering(o, g)
            o !== a && ((m = Ze.numBitsDiffering(a, g)), m < l && ((u = d[1]), (l = m))))
        return l <= 3 ? new Ze(u) : null
      }
      equals(o) {
        if (!(o instanceof Ze)) return !1
        const a = o
    ;((Ze.FORMAT_INFO_MASK_QR = 21522),
      (Ze.FORMAT_INFO_DECODE_LOOKUP = [
      constructor(o, ...a) {
        ;((this.ecCodewordsPerBlock = o), (this.ecBlocks = a))
        let o = 0
        for (const l of a) o += l.getCount()
        return o
      constructor(o, a) {
        ;((this.count = o), (this.dataCodewords = a))
    class dt {
      constructor(o, a, ...l) {
        ;((this.versionNumber = o), (this.alignmentPatternCenters = a), (this.ecBlocks = l))
      getECBlocksForLevel(o) {
        return this.ecBlocks[o.getValue()]
      static getProvisionalVersionForDimension(o) {
        if (o % 4 !== 1) throw new V()
          return this.getVersionForNumber((o - 17) / 4)
      }
      static getVersionForNumber(o) {
        if (o < 1 || o > 40) throw new w()
        return dt.VERSIONS[o - 1]
      static decodeVersionInformation(o) {
        for (let u = 0; u < dt.VERSION_DECODE_INFO.length; u++) {
          const d = dt.VERSION_DECODE_INFO[u]
          if (d === o) return dt.getVersionForNumber(u + 7)
          const g = Ze.numBitsDiffering(o, d)
        return a <= 3 ? dt.getVersionForNumber(l) : null
        const o = this.getDimensionForVersion(),
          a = new _t(o)
        ;(a.setRegion(0, 0, 9, 9), a.setRegion(o - 8, 0, 8, 9), a.setRegion(0, o - 8, 9, 8))
          a.setRegion(6, 9, 1, o - 17),
          a.setRegion(9, 6, o - 17, 1),
          this.versionNumber > 6 && (a.setRegion(o - 11, 0, 3, 6), a.setRegion(0, o - 11, 6, 3)),
    ;((dt.VERSION_DECODE_INFO = Int32Array.from([
      (dt.VERSIONS = [
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
        new dt(
    var Me
    ;(function (I) {
      ;((I[(I.DATA_MASK_000 = 0)] = 'DATA_MASK_000'),
        (I[(I.DATA_MASK_001 = 1)] = 'DATA_MASK_001'),
        (I[(I.DATA_MASK_010 = 2)] = 'DATA_MASK_010'),
        (I[(I.DATA_MASK_011 = 3)] = 'DATA_MASK_011'),
        (I[(I.DATA_MASK_100 = 4)] = 'DATA_MASK_100'),
        (I[(I.DATA_MASK_101 = 5)] = 'DATA_MASK_101'),
        (I[(I.DATA_MASK_110 = 6)] = 'DATA_MASK_110'),
        (I[(I.DATA_MASK_111 = 7)] = 'DATA_MASK_111'))
    })(Me || (Me = {}))
    class Wn {
      constructor(o, a) {
        ;((this.value = o), (this.isMasked = a))
      }
      unmaskBitMatrix(o, a) {
        for (let l = 0; l < a; l++) for (let u = 0; u < a; u++) this.isMasked(l, u) && o.flip(u, l)
      }
    }
    Wn.values = new Map([
      [Me.DATA_MASK_000, new Wn(Me.DATA_MASK_000, (I, o) => ((I + o) & 1) === 0)],
      [Me.DATA_MASK_001, new Wn(Me.DATA_MASK_001, (I, o) => (I & 1) === 0)],
      [Me.DATA_MASK_010, new Wn(Me.DATA_MASK_010, (I, o) => o % 3 === 0)],
      [Me.DATA_MASK_011, new Wn(Me.DATA_MASK_011, (I, o) => (I + o) % 3 === 0)],
        Me.DATA_MASK_100,
        new Wn(Me.DATA_MASK_100, (I, o) => ((Math.floor(I / 2) + Math.floor(o / 3)) & 1) === 0),
      [Me.DATA_MASK_101, new Wn(Me.DATA_MASK_101, (I, o) => (I * o) % 6 === 0)],
      [Me.DATA_MASK_110, new Wn(Me.DATA_MASK_110, (I, o) => (I * o) % 6 < 3)],
      [Me.DATA_MASK_111, new Wn(Me.DATA_MASK_111, (I, o) => ((I + o + ((I * o) % 3)) & 1) === 0)],
      constructor(o) {
        const a = o.getHeight()
        this.bitMatrix = o
        let o = 0
        for (let d = 0; d < 6; d++) o = this.copyBit(d, 8, o)
        ;((o = this.copyBit(7, 8, o)), (o = this.copyBit(8, 8, o)), (o = this.copyBit(8, 7, o)))
        for (let d = 5; d >= 0; d--) o = this.copyBit(8, d, o)
          ((this.parsedFormatInfo = Ze.decodeFormatInformation(o, l)),
        const o = this.bitMatrix.getHeight(),
          a = Math.floor((o - 17) / 4)
        if (a <= 6) return dt.getVersionForNumber(a)
        const u = o - 11
        for (let g = 5; g >= 0; g--) for (let m = o - 9; m >= u; m--) l = this.copyBit(m, g, l)
        let d = dt.decodeVersionInformation(l)
        if (d !== null && d.getDimensionForVersion() === o) return ((this.parsedVersion = d), d)
        for (let g = 5; g >= 0; g--) for (let m = o - 9; m >= u; m--) l = this.copyBit(g, m, l)
        if (((d = dt.decodeVersionInformation(l)), d !== null && d.getDimensionForVersion() === o))
      copyBit(o, a, l) {
        return (this.isMirror ? this.bitMatrix.get(a, o) : this.bitMatrix.get(o, a))
        const o = this.readFormatInformation(),
          l = Wn.values.get(o.getDataMask()),
          for (let P = 0; P < u; P++) {
            const B = g ? u - 1 - P : P
        const o = Wn.values[this.parsedFormatInfo.getDataMask()],
        o.unmaskBitMatrix(this.bitMatrix, a)
      setMirror(o) {
        ;((this.parsedVersion = null), (this.parsedFormatInfo = null), (this.isMirror = o))
        const o = this.bitMatrix
        for (let a = 0, l = o.getWidth(); a < l; a++)
          for (let u = a + 1, d = o.getHeight(); u < d; u++)
            o.get(a, u) !== o.get(u, a) && (o.flip(u, a), o.flip(a, u))
      constructor(o, a) {
        ;((this.numDataCodewords = o), (this.codewords = a))
      static getDataBlocks(o, a, l) {
        if (o.length !== a.getTotalCodewords()) throw new w()
          for (let U = 0; U < j.getCount(); U++) {
              K = u.getECCodewordsPerBlock() + Y
            m[b++] = new Oh(Y, new Uint8Array(K))
          }
        let P = 0
        for (let j = 0; j < T; j++) for (let U = 0; U < b; U++) m[U].codewords[j] = o[P++]
        for (let j = C; j < b; j++) m[j].codewords[T] = o[P++]
          for (let U = 0; U < b; U++) {
            const Y = U < C ? j : j + 1
            m[U].codewords[Y] = o[P++]
      getCodewords() {
        return this.codewords
      }
    }
    var Un
    ;(function (I) {
      ;((I[(I.TERMINATOR = 0)] = 'TERMINATOR'),
        (I[(I.NUMERIC = 1)] = 'NUMERIC'),
        (I[(I.ALPHANUMERIC = 2)] = 'ALPHANUMERIC'),
        (I[(I.STRUCTURED_APPEND = 3)] = 'STRUCTURED_APPEND'),
        (I[(I.BYTE = 4)] = 'BYTE'),
        (I[(I.ECI = 5)] = 'ECI'),
        (I[(I.KANJI = 6)] = 'KANJI'),
        (I[(I.FNC1_FIRST_POSITION = 7)] = 'FNC1_FIRST_POSITION'),
        (I[(I.FNC1_SECOND_POSITION = 8)] = 'FNC1_SECOND_POSITION'),
        (I[(I.HANZI = 9)] = 'HANZI'))
    })(Un || (Un = {}))
    class mt {
      constructor(o, a, l, u) {
        ;((this.value = o),
          mt.FOR_BITS.set(u, this),
          mt.FOR_VALUE.set(o, this))
      static forBits(o) {
        const a = mt.FOR_BITS.get(o)
      getCharacterCountBits(o) {
        const a = o.getVersionNumber()
      equals(o) {
        if (!(o instanceof mt)) return !1
        const a = o
    ;((mt.FOR_BITS = new Map()),
      (mt.FOR_VALUE = new Map()),
      (mt.TERMINATOR = new mt(Un.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0)),
      (mt.NUMERIC = new mt(Un.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 1)),
      (mt.ALPHANUMERIC = new mt(Un.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 2)),
      (mt.STRUCTURED_APPEND = new mt(
        Un.STRUCTURED_APPEND,
      (mt.BYTE = new mt(Un.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 4)),
      (mt.ECI = new mt(Un.ECI, 'ECI', Int32Array.from([0, 0, 0]), 7)),
      (mt.KANJI = new mt(Un.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 8)),
      (mt.FNC1_FIRST_POSITION = new mt(
        Un.FNC1_FIRST_POSITION,
      (mt.FNC1_SECOND_POSITION = new mt(
        Un.FNC1_SECOND_POSITION,
      (mt.HANZI = new mt(Un.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 13)))
    class se {
      static decode(o, a, l, u) {
        const d = new Lh(o)
        let g = new vt()
            P
            if (d.available() < 4) P = mt.TERMINATOR
              P = mt.forBits(B)
            switch (P) {
              case mt.TERMINATOR:
              case mt.FNC1_FIRST_POSITION:
              case mt.FNC1_SECOND_POSITION:
              case mt.STRUCTURED_APPEND:
              case mt.ECI:
                const B = se.parseECIValue(d)
              case mt.HANZI:
                  U = d.readBits(P.getCharacterCountBits(a))
                j === se.GB2312_SUBSET && se.decodeHanziSegment(d, g, U)
                const Y = d.readBits(P.getCharacterCountBits(a))
                switch (P) {
                  case mt.NUMERIC:
                    se.decodeNumericSegment(d, g, Y)
                  case mt.ALPHANUMERIC:
                    se.decodeAlphanumericSegment(d, g, Y, T)
                  case mt.BYTE:
                    se.decodeByteSegment(d, g, Y, C, m, u)
                  case mt.KANJI:
                    se.decodeKanjiSegment(d, g, Y)
          } while (P !== mt.TERMINATOR)
        return new Js(
          o,
      static decodeHanziSegment(o, a, l) {
        if (l * 13 > o.available()) throw new V()
          const g = o.readBits(13)
          a.append(st.decode(u, rt.GB2312))
      static decodeKanjiSegment(o, a, l) {
        if (l * 13 > o.available()) throw new V()
          const g = o.readBits(13)
          a.append(st.decode(u, rt.SHIFT_JIS))
      static decodeByteSegment(o, a, l, u, d, g) {
        if (8 * l > o.available()) throw new V()
        for (let v = 0; v < l; v++) m[v] = o.readBits(8)
        u === null ? (b = rt.guessEncoding(m, g)) : (b = u.getName())
          a.append(st.decode(m, b))
      }
      static toAlphaNumericChar(o) {
        if (o >= se.ALPHANUMERIC_CHARS.length) throw new V()
        return se.ALPHANUMERIC_CHARS[o]
      static decodeAlphanumericSegment(o, a, l, u) {
          if (o.available() < 11) throw new V()
          const g = o.readBits(11)
          ;(a.append(se.toAlphaNumericChar(Math.floor(g / 45))),
            a.append(se.toAlphaNumericChar(g % 45)),
          if (o.available() < 6) throw new V()
          a.append(se.toAlphaNumericChar(o.readBits(6)))
      static decodeNumericSegment(o, a, l) {
          if (o.available() < 10) throw new V()
          const u = o.readBits(10)
          ;(a.append(se.toAlphaNumericChar(Math.floor(u / 100))),
            a.append(se.toAlphaNumericChar(Math.floor(u / 10) % 10)),
            a.append(se.toAlphaNumericChar(u % 10)),
          if (o.available() < 7) throw new V()
          const u = o.readBits(7)
          ;(a.append(se.toAlphaNumericChar(Math.floor(u / 10))),
            a.append(se.toAlphaNumericChar(u % 10)))
          if (o.available() < 4) throw new V()
          const u = o.readBits(4)
          a.append(se.toAlphaNumericChar(u))
      static parseECIValue(o) {
        const a = o.readBits(8)
          const l = o.readBits(8)
          const l = o.readBits(16)
    ;((se.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'),
      (se.GB2312_SUBSET = 1))
      constructor(o) {
        this.mirrored = o
      applyMirroredCorrection(o) {
        if (!this.mirrored || o === null || o.length < 3) return
        const a = o[0]
        ;((o[0] = o[2]), (o[2] = a))
        this.rsDecoder = new ea(Ft.QR_CODE_FIELD_256)
      decodeBooleanArray(o, a) {
        return this.decodeBitMatrix(_t.parseFromBooleanArray(o), a)
      decodeBitMatrix(o, a) {
        const l = new mb(o)
      decodeBitMatrixParser(o, a) {
        const l = o.readVersion(),
          u = o.readFormatInformation().getErrorCorrectionLevel(),
          d = o.readCodewords(),
            P = C.getNumDataCodewords()
          this.correctErrors(T, P)
          for (let B = 0; B < P; B++) b[v++] = T[B]
        return se.decode(b, l, u, a)
      correctErrors(o, a) {
        const l = new Int32Array(o)
          this.rsDecoder.decode(l, o.length - a)
        for (let u = 0; u < a; u++) o[u] = l[u]
    class Bh extends ht {
      constructor(o, a, l) {
        ;(super(o, a), (this.estimatedModuleSize = l))
      aboutEquals(o, a, l) {
        if (Math.abs(a - this.getY()) <= o && Math.abs(l - this.getX()) <= o) {
          const u = Math.abs(o - this.estimatedModuleSize)
      combineEstimate(o, a, l) {
          d = (this.getY() + o) / 2,
    class Kl {
      constructor(o, a, l, u, d, g, m) {
        ;((this.image = o),
        const o = this.startX,
          u = o + l,
          let C = o
                  const P = this.handlePossibleCenter(g, v, C)
                  if (P !== null) return P
            const P = this.handlePossibleCenter(g, v, u)
            if (P !== null) return P
      static centerFromEnd(o, a) {
        return a - o[2] - o[1] / 2
      foundPatternCross(o) {
        for (let u = 0; u < 3; u++) if (Math.abs(a - o[u]) >= l) return !1
      crossCheckVertical(o, a, l, u) {
        let b = o
        for (b = o + 1; b < g && d.get(a, b) && m[1] <= l; ) (m[1]++, b++)
            ? Kl.centerFromEnd(m, b)
      handlePossibleCenter(o, a, l) {
        const u = o[0] + o[1] + o[2],
          d = Kl.centerFromEnd(o, l),
          g = this.crossCheckVertical(a, d, 2 * o[1], u)
          const m = (o[0] + o[1] + o[2]) / 3
    class Fh extends ht {
      constructor(o, a, l, u) {
        ;(super(o, a),
      aboutEquals(o, a, l) {
        if (Math.abs(a - this.getY()) <= o && Math.abs(l - this.getX()) <= o) {
          const u = Math.abs(o - this.estimatedModuleSize)
      combineEstimate(o, a, l) {
          g = (this.count * this.getY() + o) / u,
      constructor(o) {
        ;((this.bottomLeft = o[0]), (this.topLeft = o[1]), (this.topRight = o[2]))
    class De {
      constructor(o, a) {
        ;((this.image = o),
      find(o) {
        const a = o != null && o.get(z.TRY_HARDER) !== void 0,
          l = o != null && o.get(z.PURE_BARCODE) !== void 0,
        let m = Math.floor((3 * d) / (4 * De.MAX_MODULES))
        ;(m < De.MIN_SKIP || a) && (m = De.MIN_SKIP)
          let P = 0
            if (u.get(B, T)) ((P & 1) === 1 && P++, v[P]++)
            else if (P & 1) v[P]++
            else if (P === 4)
              if (De.foundPatternCross(v)) {
                  ;((v[0] = v[2]), (v[1] = v[3]), (v[2] = v[4]), (v[3] = 1), (v[4] = 0), (P = 3))
                ;((P = 0), (v[0] = 0), (v[1] = 0), (v[2] = 0), (v[3] = 0), (v[4] = 0))
              } else ((v[0] = v[2]), (v[1] = v[3]), (v[2] = v[4]), (v[3] = 1), (v[4] = 0), (P = 3))
            else v[++P]++
          De.foundPatternCross(v) &&
        return (ht.orderBestPatterns(C), new wb(C))
      static centerFromEnd(o, a) {
        return a - o[4] - o[3] - o[2] / 2
      static foundPatternCross(o) {
          const g = o[d]
          Math.abs(l - o[0]) < u &&
          Math.abs(l - o[1]) < u &&
          Math.abs(3 * l - o[2]) < 3 * u &&
          Math.abs(l - o[3]) < u &&
          Math.abs(l - o[4]) < u
        const o = this.crossCheckStateCount
        return ((o[0] = 0), (o[1] = 0), (o[2] = 0), (o[3] = 0), (o[4] = 0), o)
      crossCheckDiagonal(o, a, l, u) {
        for (; o >= g && a >= g && m.get(a - g, o - g); ) (d[2]++, g++)
        if (o < g || a < g) return !1
        for (; o >= g && a >= g && !m.get(a - g, o - g) && d[1] <= l; ) (d[1]++, g++)
        if (o < g || a < g || d[1] > l) return !1
        for (; o >= g && a >= g && m.get(a - g, o - g) && d[0] <= l; ) (d[0]++, g++)
        for (g = 1; o + g < b && a + g < v && m.get(a + g, o + g); ) (d[2]++, g++)
        if (o + g >= b || a + g >= v) return !1
        for (; o + g < b && a + g < v && !m.get(a + g, o + g) && d[3] < l; ) (d[3]++, g++)
        if (o + g >= b || a + g >= v || d[3] >= l) return !1
        for (; o + g < b && a + g < v && m.get(a + g, o + g) && d[4] < l; ) (d[4]++, g++)
        return Math.abs(C - u) < 2 * u && De.foundPatternCross(d)
      crossCheckVertical(o, a, l, u) {
        let b = o
        for (b = o + 1; b < g && d.get(a, b); ) (m[2]++, b++)
          : De.foundPatternCross(m)
            ? De.centerFromEnd(m, b)
      crossCheckHorizontal(o, a, l, u) {
        let b = o
        for (b = o + 1; b < g && d.get(b, a); ) (m[2]++, b++)
          : De.foundPatternCross(m)
            ? De.centerFromEnd(m, b)
      handlePossibleCenter(o, a, l, u) {
        const d = o[0] + o[1] + o[2] + o[3] + o[4]
        let g = De.centerFromEnd(o, l),
          m = this.crossCheckVertical(a, Math.floor(g), o[2], d)
          ((g = this.crossCheckHorizontal(Math.floor(g), Math.floor(m), o[2], d)),
          !isNaN(g) && (!u || this.crossCheckDiagonal(Math.floor(m), Math.floor(g), o[2], d)))
          for (let T = 0, P = C.length; T < P; T++) {
        let o = null
          if (a.getCount() >= De.CENTER_QUORUM)
            if (o == null) o = a
                Math.floor((Math.abs(o.getX() - a.getX()) - Math.abs(o.getY() - a.getY())) / 2)
        let o = 0,
          g.getCount() >= De.CENTER_QUORUM && (o++, (a += g.getEstimatedModuleSize()))
        if (o < 3) return !1
        const o = this.possibleCenters.length
        if (o < 3) throw new H()
        if (o > 3) {
          l = u / o
          let g = Math.sqrt(d / o - l * l)
          }
    ;((De.CENTER_QUORUM = 2), (De.MIN_SKIP = 3), (De.MAX_MODULES = 57))
      constructor(o) {
        this.image = o
      detect(o) {
        this.resultPointCallback = o == null ? null : o.get(z.NEED_RESULT_POINT_CALLBACK)
        const a = new De(this.image, this.resultPointCallback).find(o)
      processFinderPatternInfo(o) {
        const a = o.getTopLeft(),
          l = o.getTopRight(),
          u = o.getBottomLeft(),
          m = dt.getProvisionalVersionForDimension(g),
            U = 1 - 3 / b,
            Y = Math.floor(a.getX() + U * (B - a.getX())),
            K = Math.floor(a.getY() + U * (j - a.getY()))
          for (let nt = 4; nt <= 16; nt <<= 1)
              v = this.findAlignmentInRegion(d, Y, K, nt)
            } catch (et) {
              if (!(et instanceof H)) throw et
        let P
        return (v === null ? (P = [u, a, l]) : (P = [u, a, l, v]), new Xl(T, P))
      static createTransform(o, a, l, u, d) {
            : ((m = a.getX() - o.getX() + l.getX()),
              (b = a.getY() - o.getY() + l.getY()),
          er.quadrilateralToQuadrilateral(
            o.getX(),
            o.getY(),
      static sampleGrid(o, a, l) {
        return Jr.getInstance().sampleGridWithTransform(o, l, l, a)
      static computeDimension(o, a, l, u) {
        const d = Dt.round(ht.distance(o, a) / u),
          g = Dt.round(ht.distance(o, l) / u)
      calculateModuleSize(o, a, l) {
        return (this.calculateModuleSizeOneWay(o, a) + this.calculateModuleSizeOneWay(o, l)) / 2
      calculateModuleSizeOneWay(o, a) {
            Math.floor(o.getX()),
            Math.floor(o.getY()),
            Math.floor(o.getX()),
            Math.floor(o.getY())
      sizeOfBlackWhiteBlackRunBothWays(o, a, l, u) {
        let d = this.sizeOfBlackWhiteBlackRun(o, a, l, u),
          m = o - (l - o)
          ? ((g = o / (o - m)), (m = 0))
            ((g = (this.image.getWidth() - 1 - o) / (m - o)), (m = this.image.getWidth() - 1))
          (m = Math.floor(o + (m - o) * g)),
          (d += this.sizeOfBlackWhiteBlackRun(o, a, m, b)),
      sizeOfBlackWhiteBlackRun(o, a, l, u) {
        const d = Math.abs(u - a) > Math.abs(l - o)
          let B = o
          ;((o = a), (a = B), (B = l), (l = u), (u = B))
        const g = Math.abs(l - o),
        const v = o < l ? 1 : -1,
        const P = l + v
        for (let B = o, j = a; B !== P; B += v) {
          const U = d ? j : B,
          if ((T === 1) === this.image.get(U, Y)) {
            if (T === 2) return Dt.distance(B, j, o, a)
        return T === 2 ? Dt.distance(l + v, u, o, a) : NaN
      findAlignmentInRegion(o, a, l, u) {
        const d = Math.floor(u * o),
        if (m - g < o * 3) throw new H('Alignment top exceeds estimated module size.')
        if (v - b < o * 3) throw new H('Alignment bottom exceeds estimated module size.')
        return new Kl(this.image, g, b, m - g, v - b, o, this.resultPointCallback).find()
      decode(o, a) {
          const b = ri.extractPureBits(o.getBlackMatrix())
          const b = new ra(o.getBlackMatrix()).detect(a)
        const d = new Bt(l.getText(), l.getRawBytes(), void 0, u, ut.QR_CODE, void 0),
        g !== null && d.putMetadata(Ne.BYTE_SEGMENTS, g)
          m !== null && d.putMetadata(Ne.ERROR_CORRECTION_LEVEL, m),
            (d.putMetadata(Ne.STRUCTURED_APPEND_SEQUENCE, l.getStructuredAppendSequenceNumber()),
            d.putMetadata(Ne.STRUCTURED_APPEND_PARITY, l.getStructuredAppendParity())),
      static extractPureBits(o) {
        const a = o.getTopLeftOnBit(),
          l = o.getBottomRightOnBit()
        const u = this.moduleSize(a, o)
        if (g - d !== b - m && ((b = m + (g - d)), b >= o.getWidth())) throw new H()
        const P = m + Math.floor((v - 1) * u) - b
        if (P > 0) {
          if (P > T) throw new H()
          m -= P
        const j = new _t(v, C)
        for (let U = 0; U < C; U++) {
          const Y = d + Math.floor(U * u)
          for (let K = 0; K < v; K++) o.get(m + Math.floor(K * u), Y) && j.set(K, U)
      static moduleSize(o, a) {
        let d = o[0],
          g = o[1],
        return (d - o[0]) / 7
    class Et {
      static getBitCountSum(o) {
        return Dt.sum(o)
      static toIntArray(o) {
        if (o == null || !o.length) return Et.EMPTY_INT_ARRAY
        const a = new Int32Array(o.length)
        for (const u of o) a[l++] = u
      static getCodeword(o) {
        const a = N.binarySearch(Et.SYMBOL_TABLE, o & 262143)
        return a < 0 ? -1 : (Et.CODEWORD_TABLE[a] - 1) % Et.NUMBER_OF_CODEWORDS
    ;((Et.NUMBER_OF_CODEWORDS = 929),
      (Et.MAX_CODEWORDS_IN_BARCODE = Et.NUMBER_OF_CODEWORDS - 1),
      (Et.MIN_ROWS_IN_BARCODE = 3),
      (Et.MAX_ROWS_IN_BARCODE = 90),
      (Et.MODULES_IN_CODEWORD = 17),
      (Et.MODULES_IN_STOP_PATTERN = 18),
      (Et.BARS_IN_MODULE = 8),
      (Et.EMPTY_INT_ARRAY = new Int32Array([])),
      (Et.SYMBOL_TABLE = Int32Array.from([
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
    ]),
      (ti.C40_SHIFT2_SET_CHARS = [
        '!',
        '"',
        '#',
        '$',
        '%',
        '&',
        "'",
        '(',
        ')',
        '*',
        '+',
        ',',
        '-',
        '.',
        '/',
        ':',
        ';',
        '<',
        '=',
        '>',
        '?',
        '@',
        '[',
        '\\',
        ']',
        '^',
        '_',
      ]),
      (ti.TEXT_BASIC_SET_CHARS = [
        '*',
        '*',
        '*',
        ' ',
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
      ]),
      (ti.TEXT_SHIFT2_SET_CHARS = ti.C40_SHIFT2_SET_CHARS),
      (ti.TEXT_SHIFT3_SET_CHARS = [
        '`',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        '{',
        '|',
        '}',
        '~',
        '',
      ]))
    class pb {
      constructor() {
        this.rsDecoder = new ta(Fe.DATA_MATRIX_FIELD_256)
      }
      decode(s) {
        const a = new Ph(s),
          l = a.getVersion(),
          u = a.readCodewords(),
          d = Dh.getDataBlocks(u, l)
        let g = 0
        for (let v of d) g += v.getNumDataCodewords()
        const m = new Uint8Array(g),
          b = d.length
        for (let v = 0; v < b; v++) {
          const C = d[v],
            T = C.getCodewords(),
            D = C.getNumDataCodewords()
          this.correctErrors(T, D)
          for (let B = 0; B < D; B++) m[B * b + v] = T[B]
        }
        return ti.decode(m)
      }
      correctErrors(s, a) {
        const l = new Int32Array(s)
        try {
          this.rsDecoder.decode(l, s.length - a)
        } catch {
          throw new E()
        }
        for (let u = 0; u < a; u++) s[u] = l[u]
      }
    }
    class vt {
      constructor(s) {
        ;((this.image = s), (this.rectangleDetector = new Tr(this.image)))
      }
      detect() {
        const s = this.rectangleDetector.detect()
        let a = this.detectSolid1(s)
        if (((a = this.detectSolid2(a)), (a[3] = this.correctTopRight(a)), !a[3])) throw new H()
        a = this.shiftToModuleCenter(a)
        const l = a[0],
          u = a[1],
          d = a[2],
          g = a[3]
        let m = this.transitionsBetween(l, g) + 1,
          b = this.transitionsBetween(d, g) + 1
        ;((m & 1) === 1 && (m += 1),
          (b & 1) === 1 && (b += 1),
          4 * m < 7 * b && 4 * b < 7 * m && (m = b = Math.max(m, b)))
        let v = vt.sampleGrid(this.image, l, u, d, g, m, b)
        return new Xl(v, [l, u, d, g])
      }
      static shiftPoint(s, a, l) {
        let u = (a.getX() - s.getX()) / (l + 1),
          d = (a.getY() - s.getY()) / (l + 1)
        return new he(s.getX() + u, s.getY() + d)
      }
      static moveAway(s, a, l) {
        let u = s.getX(),
          d = s.getY()
        return (u < a ? (u -= 1) : (u += 1), d < l ? (d -= 1) : (d += 1), new he(u, d))
      }
      detectSolid1(s) {
        let a = s[0],
          l = s[1],
          u = s[3],
          d = s[2],
          g = this.transitionsBetween(a, l),
          m = this.transitionsBetween(l, u),
          b = this.transitionsBetween(u, d),
          v = this.transitionsBetween(d, a),
          C = g,
          T = [d, a, l, u]
        return (
          C > m && ((C = m), (T[0] = a), (T[1] = l), (T[2] = u), (T[3] = d)),
          C > b && ((C = b), (T[0] = l), (T[1] = u), (T[2] = d), (T[3] = a)),
          C > v && ((T[0] = u), (T[1] = d), (T[2] = a), (T[3] = l)),
          T
        )
      }
      detectSolid2(s) {
        let a = s[0],
          l = s[1],
          u = s[2],
          d = s[3],
          g = this.transitionsBetween(a, d),
          m = vt.shiftPoint(l, u, (g + 1) * 4),
          b = vt.shiftPoint(u, l, (g + 1) * 4),
          v = this.transitionsBetween(m, a),
          C = this.transitionsBetween(b, d)
        return (
          v < C
            ? ((s[0] = a), (s[1] = l), (s[2] = u), (s[3] = d))
            : ((s[0] = l), (s[1] = u), (s[2] = d), (s[3] = a)),
          s
        )
      }
      correctTopRight(s) {
        let a = s[0],
          l = s[1],
          u = s[2],
          d = s[3],
          g = this.transitionsBetween(a, d),
          m = this.transitionsBetween(l, d),
          b = vt.shiftPoint(a, l, (m + 1) * 4),
          v = vt.shiftPoint(u, l, (g + 1) * 4)
        ;((g = this.transitionsBetween(b, d)), (m = this.transitionsBetween(v, d)))
        let C = new he(
            d.getX() + (u.getX() - l.getX()) / (g + 1),
            d.getY() + (u.getY() - l.getY()) / (g + 1)
          ),
          T = new he(
            d.getX() + (a.getX() - l.getX()) / (m + 1),
            d.getY() + (a.getY() - l.getY()) / (m + 1)
          )
        if (!this.isValid(C)) return this.isValid(T) ? T : null
        if (!this.isValid(T)) return C
        let D = this.transitionsBetween(b, C) + this.transitionsBetween(v, C),
          B = this.transitionsBetween(b, T) + this.transitionsBetween(v, T)
        return D > B ? C : T
      }
      shiftToModuleCenter(s) {
        let a = s[0],
          l = s[1],
          u = s[2],
          d = s[3],
          g = this.transitionsBetween(a, d) + 1,
          m = this.transitionsBetween(u, d) + 1,
          b = vt.shiftPoint(a, l, m * 4),
          v = vt.shiftPoint(u, l, g * 4)
        ;((g = this.transitionsBetween(b, d) + 1),
          (m = this.transitionsBetween(v, d) + 1),
          (g & 1) === 1 && (g += 1),
          (m & 1) === 1 && (m += 1))
        let C = (a.getX() + l.getX() + u.getX() + d.getX()) / 4,
          T = (a.getY() + l.getY() + u.getY() + d.getY()) / 4
        ;((a = vt.moveAway(a, C, T)),
          (l = vt.moveAway(l, C, T)),
          (u = vt.moveAway(u, C, T)),
          (d = vt.moveAway(d, C, T)))
        let D, B
        return (
          (b = vt.shiftPoint(a, l, m * 4)),
          (b = vt.shiftPoint(b, d, g * 4)),
          (D = vt.shiftPoint(l, a, m * 4)),
          (D = vt.shiftPoint(D, u, g * 4)),
          (v = vt.shiftPoint(u, d, m * 4)),
          (v = vt.shiftPoint(v, l, g * 4)),
          (B = vt.shiftPoint(d, u, m * 4)),
          (B = vt.shiftPoint(B, a, g * 4)),
          [b, D, v, B]
        )
      }
      isValid(s) {
        return (
          s.getX() >= 0 &&
          s.getX() < this.image.getWidth() &&
          s.getY() > 0 &&
          s.getY() < this.image.getHeight()
        )
      }
      static sampleGrid(s, a, l, u, d, g, m) {
        return Jr.getInstance().sampleGrid(
          s,
          g,
          m,
          0.5,
          0.5,
          g - 0.5,
          0.5,
          g - 0.5,
          m - 0.5,
          0.5,
          m - 0.5,
          a.getX(),
          a.getY(),
          d.getX(),
          d.getY(),
          u.getX(),
          u.getY(),
          l.getX(),
          l.getY()
        )
      }
      transitionsBetween(s, a) {
        let l = Math.trunc(s.getX()),
          u = Math.trunc(s.getY()),
          d = Math.trunc(a.getX()),
          g = Math.trunc(a.getY()),
          m = Math.abs(g - u) > Math.abs(d - l)
        if (m) {
          let W = l
          ;((l = u), (u = W), (W = d), (d = g), (g = W))
        }
        let b = Math.abs(d - l),
          v = Math.abs(g - u),
          C = -b / 2,
          T = u < g ? 1 : -1,
          D = l < d ? 1 : -1,
          B = 0,
          j = this.image.get(m ? u : l, m ? l : u)
        for (let W = l, Y = u; W !== d; W += D) {
          let q = this.image.get(m ? Y : W, m ? W : Y)
          if ((q !== j && (B++, (j = q)), (C += v), C > 0)) {
            if (Y === g) break
            ;((Y += T), (C -= b))
          }
        }
        return B
      }
    }
    class ni {
      constructor() {
        this.decoder = new pb()
      }
      decode(s, a = null) {
        let l, u
        if (a != null && a.has(z.PURE_BARCODE)) {
          const v = ni.extractPureBits(s.getBlackMatrix())
          ;((l = this.decoder.decode(v)), (u = ni.NO_POINTS))
        } else {
          const v = new vt(s.getBlackMatrix()).detect()
          ;((l = this.decoder.decode(v.getBits())), (u = v.getPoints()))
        }
        const d = l.getRawBytes(),
          g = new Be(l.getText(), d, 8 * d.length, u, ue.DATA_MATRIX, k.currentTimeMillis()),
          m = l.getByteSegments()
        m != null && g.putMetadata(Rt.BYTE_SEGMENTS, m)
        const b = l.getECLevel()
        return (b != null && g.putMetadata(Rt.ERROR_CORRECTION_LEVEL, b), g)
      }
      reset() {}
      static extractPureBits(s) {
        const a = s.getTopLeftOnBit(),
          l = s.getBottomRightOnBit()
        if (a == null || l == null) throw new H()
        const u = this.moduleSize(a, s)
        let d = a[1]
        const g = l[1]
        let m = a[0]
        const b = (l[0] - m + 1) / u,
          v = (g - d + 1) / u
        if (b <= 0 || v <= 0) throw new H()
        const C = u / 2
        ;((d += C), (m += C))
        const T = new Ie(b, v)
        for (let D = 0; D < v; D++) {
          const B = d + D * u
          for (let j = 0; j < b; j++) s.get(m + j * u, B) && T.set(j, D)
        }
        return T
      }
      static moduleSize(s, a) {
        const l = a.getWidth()
        let u = s[0]
        const d = s[1]
        for (; u < l && a.get(u, d); ) u++
        if (u === l) throw new H()
        const g = u - s[0]
        if (g === 0) throw new H()
        return g
      }
    }
    ni.NO_POINTS = []
    class gb extends Tt {
      constructor(s = 500) {
        super(new ni(), s)
      }
    }
    var Ks
    ;(function (_) {
      ;((_[(_.L = 0)] = 'L'), (_[(_.M = 1)] = 'M'), (_[(_.Q = 2)] = 'Q'), (_[(_.H = 3)] = 'H'))
    })(Ks || (Ks = {}))
    class qe {
      constructor(s, a, l) {
        ;((this.value = s),
          (this.stringValue = a),
          (this.bits = l),
          qe.FOR_BITS.set(l, this),
          qe.FOR_VALUE.set(s, this))
      }
      getValue() {
        return this.value
      }
      getBits() {
        return this.bits
      }
      static fromString(s) {
        switch (s) {
          case 'L':
            return qe.L
          case 'M':
            return qe.M
          case 'Q':
            return qe.Q
          case 'H':
            return qe.H
          default:
            throw new y(s + 'not available')
        }
      }
      toString() {
        return this.stringValue
      }
      equals(s) {
        if (!(s instanceof qe)) return !1
        const a = s
        return this.value === a.value
      }
      static forBits(s) {
        if (s < 0 || s >= qe.FOR_BITS.size) throw new w()
        return qe.FOR_BITS.get(s)
      }
    }
    ;((qe.FOR_BITS = new Map()),
      (qe.FOR_VALUE = new Map()),
      (qe.L = new qe(Ks.L, 'L', 1)),
      (qe.M = new qe(Ks.M, 'M', 0)),
      (qe.Q = new qe(Ks.Q, 'Q', 3)),
      (qe.H = new qe(Ks.H, 'H', 2)))
    class Zt {
      constructor(s) {
        ;((this.errorCorrectionLevel = qe.forBits((s >> 3) & 3)), (this.dataMask = s & 7))
      }
      static numBitsDiffering(s, a) {
        return M.bitCount(s ^ a)
      }
      static decodeFormatInformation(s, a) {
        const l = Zt.doDecodeFormatInformation(s, a)
        return l !== null
          ? l
          : Zt.doDecodeFormatInformation(s ^ Zt.FORMAT_INFO_MASK_QR, a ^ Zt.FORMAT_INFO_MASK_QR)
      }
      static doDecodeFormatInformation(s, a) {
        let l = Number.MAX_SAFE_INTEGER,
          u = 0
        for (const d of Zt.FORMAT_INFO_DECODE_LOOKUP) {
          const g = d[0]
          if (g === s || g === a) return new Zt(d[1])
          let m = Zt.numBitsDiffering(s, g)
          ;(m < l && ((u = d[1]), (l = m)),
            s !== a && ((m = Zt.numBitsDiffering(a, g)), m < l && ((u = d[1]), (l = m))))
        }
        return l <= 3 ? new Zt(u) : null
      }
      getErrorCorrectionLevel() {
        return this.errorCorrectionLevel
      }
      getDataMask() {
        return this.dataMask
      }
      hashCode() {
        return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask
      }
      equals(s) {
        if (!(s instanceof Zt)) return !1
        const a = s
        return this.errorCorrectionLevel === a.errorCorrectionLevel && this.dataMask === a.dataMask
      }
    }
    ;((Zt.FORMAT_INFO_MASK_QR = 21522),
      (Zt.FORMAT_INFO_DECODE_LOOKUP = [
        Int32Array.from([21522, 0]),
        Int32Array.from([20773, 1]),
        Int32Array.from([24188, 2]),
        Int32Array.from([23371, 3]),
        Int32Array.from([17913, 4]),
        Int32Array.from([16590, 5]),
        Int32Array.from([20375, 6]),
        Int32Array.from([19104, 7]),
        Int32Array.from([30660, 8]),
        Int32Array.from([29427, 9]),
        Int32Array.from([32170, 10]),
        Int32Array.from([30877, 11]),
        Int32Array.from([26159, 12]),
        Int32Array.from([25368, 13]),
        Int32Array.from([27713, 14]),
        Int32Array.from([26998, 15]),
        Int32Array.from([5769, 16]),
        Int32Array.from([5054, 17]),
        Int32Array.from([7399, 18]),
        Int32Array.from([6608, 19]),
        Int32Array.from([1890, 20]),
        Int32Array.from([597, 21]),
        Int32Array.from([3340, 22]),
        Int32Array.from([2107, 23]),
        Int32Array.from([13663, 24]),
        Int32Array.from([12392, 25]),
        Int32Array.from([16177, 26]),
        Int32Array.from([14854, 27]),
        Int32Array.from([9396, 28]),
        Int32Array.from([8579, 29]),
        Int32Array.from([11994, 30]),
        Int32Array.from([11245, 31]),
      ]))
    class G {
      constructor(s, ...a) {
        ;((this.ecCodewordsPerBlock = s), (this.ecBlocks = a))
      }
      getECCodewordsPerBlock() {
        return this.ecCodewordsPerBlock
      }
      getNumBlocks() {
        let s = 0
        const a = this.ecBlocks
        for (const l of a) s += l.getCount()
        return s
      }
      getTotalECCodewords() {
        return this.ecCodewordsPerBlock * this.getNumBlocks()
      }
      getECBlocks() {
        return this.ecBlocks
      }
    }
    class L {
      constructor(s, a) {
        ;((this.count = s), (this.dataCodewords = a))
      }
      getCount() {
        return this.count
      }
      getDataCodewords() {
        return this.dataCodewords
      }
    }
    class de {
      constructor(s, a, ...l) {
        ;((this.versionNumber = s), (this.alignmentPatternCenters = a), (this.ecBlocks = l))
        let u = 0
        const d = l[0].getECCodewordsPerBlock(),
          g = l[0].getECBlocks()
        for (const m of g) u += m.getCount() * (m.getDataCodewords() + d)
        this.totalCodewords = u
      }
      getVersionNumber() {
        return this.versionNumber
      }
      getAlignmentPatternCenters() {
        return this.alignmentPatternCenters
      }
      getTotalCodewords() {
        return this.totalCodewords
      }
      getDimensionForVersion() {
        return 17 + 4 * this.versionNumber
      }
      getECBlocksForLevel(s) {
        return this.ecBlocks[s.getValue()]
      }
      static getProvisionalVersionForDimension(s) {
        if (s % 4 !== 1) throw new V()
        try {
          return this.getVersionForNumber((s - 17) / 4)
        } catch {
          throw new V()
        }
      }
      static getVersionForNumber(s) {
        if (s < 1 || s > 40) throw new w()
        return de.VERSIONS[s - 1]
      }
      static decodeVersionInformation(s) {
        let a = Number.MAX_SAFE_INTEGER,
          l = 0
        for (let u = 0; u < de.VERSION_DECODE_INFO.length; u++) {
          const d = de.VERSION_DECODE_INFO[u]
          if (d === s) return de.getVersionForNumber(u + 7)
          const g = Zt.numBitsDiffering(s, d)
          g < a && ((l = u + 7), (a = g))
        }
        return a <= 3 ? de.getVersionForNumber(l) : null
      }
      buildFunctionPattern() {
        const s = this.getDimensionForVersion(),
          a = new Ie(s)
        ;(a.setRegion(0, 0, 9, 9), a.setRegion(s - 8, 0, 8, 9), a.setRegion(0, s - 8, 9, 8))
        const l = this.alignmentPatternCenters.length
        for (let u = 0; u < l; u++) {
          const d = this.alignmentPatternCenters[u] - 2
          for (let g = 0; g < l; g++)
            (u === 0 && (g === 0 || g === l - 1)) ||
              (u === l - 1 && g === 0) ||
              a.setRegion(this.alignmentPatternCenters[g] - 2, d, 5, 5)
        }
        return (
          a.setRegion(6, 9, 1, s - 17),
          a.setRegion(9, 6, s - 17, 1),
          this.versionNumber > 6 && (a.setRegion(s - 11, 0, 3, 6), a.setRegion(0, s - 11, 6, 3)),
          a
        )
      }
      toString() {
        return '' + this.versionNumber
      }
    }
    ;((de.VERSION_DECODE_INFO = Int32Array.from([
      31892, 34236, 39577, 42195, 48118, 51042, 55367, 58893, 63784, 68472, 70749, 76311, 79154,
      84390, 87683, 92361, 96236, 102084, 102881, 110507, 110734, 117786, 119615, 126325, 127568,
      133589, 136944, 141498, 145311, 150283, 152622, 158308, 161089, 167017,
    ])),
      (de.VERSIONS = [
        new de(
          1,
          new Int32Array(0),
          new G(7, new L(1, 19)),
          new G(10, new L(1, 16)),
          new G(13, new L(1, 13)),
          new G(17, new L(1, 9))
        ),
        new de(
          2,
          Int32Array.from([6, 18]),
          new G(10, new L(1, 34)),
          new G(16, new L(1, 28)),
          new G(22, new L(1, 22)),
          new G(28, new L(1, 16))
        ),
        new de(
          3,
          Int32Array.from([6, 22]),
          new G(15, new L(1, 55)),
          new G(26, new L(1, 44)),
          new G(18, new L(2, 17)),
          new G(22, new L(2, 13))
        ),
        new de(
          4,
          Int32Array.from([6, 26]),
          new G(20, new L(1, 80)),
          new G(18, new L(2, 32)),
          new G(26, new L(2, 24)),
          new G(16, new L(4, 9))
        ),
        new de(
          5,
          Int32Array.from([6, 30]),
          new G(26, new L(1, 108)),
          new G(24, new L(2, 43)),
          new G(18, new L(2, 15), new L(2, 16)),
          new G(22, new L(2, 11), new L(2, 12))
        ),
        new de(
          6,
          Int32Array.from([6, 34]),
          new G(18, new L(2, 68)),
          new G(16, new L(4, 27)),
          new G(24, new L(4, 19)),
          new G(28, new L(4, 15))
        ),
        new de(
          7,
          Int32Array.from([6, 22, 38]),
          new G(20, new L(2, 78)),
          new G(18, new L(4, 31)),
          new G(18, new L(2, 14), new L(4, 15)),
          new G(26, new L(4, 13), new L(1, 14))
        ),
        new de(
          8,
          Int32Array.from([6, 24, 42]),
          new G(24, new L(2, 97)),
          new G(22, new L(2, 38), new L(2, 39)),
          new G(22, new L(4, 18), new L(2, 19)),
          new G(26, new L(4, 14), new L(2, 15))
        ),
        new de(
          9,
          Int32Array.from([6, 26, 46]),
          new G(30, new L(2, 116)),
          new G(22, new L(3, 36), new L(2, 37)),
          new G(20, new L(4, 16), new L(4, 17)),
          new G(24, new L(4, 12), new L(4, 13))
        ),
        new de(
          10,
          Int32Array.from([6, 28, 50]),
          new G(18, new L(2, 68), new L(2, 69)),
          new G(26, new L(4, 43), new L(1, 44)),
          new G(24, new L(6, 19), new L(2, 20)),
          new G(28, new L(6, 15), new L(2, 16))
        ),
        new de(
          11,
          Int32Array.from([6, 30, 54]),
          new G(20, new L(4, 81)),
          new G(30, new L(1, 50), new L(4, 51)),
          new G(28, new L(4, 22), new L(4, 23)),
          new G(24, new L(3, 12), new L(8, 13))
        ),
        new de(
          12,
          Int32Array.from([6, 32, 58]),
          new G(24, new L(2, 92), new L(2, 93)),
          new G(22, new L(6, 36), new L(2, 37)),
          new G(26, new L(4, 20), new L(6, 21)),
          new G(28, new L(7, 14), new L(4, 15))
        ),
        new de(
          13,
          Int32Array.from([6, 34, 62]),
          new G(26, new L(4, 107)),
          new G(22, new L(8, 37), new L(1, 38)),
          new G(24, new L(8, 20), new L(4, 21)),
          new G(22, new L(12, 11), new L(4, 12))
        ),
        new de(
          14,
          Int32Array.from([6, 26, 46, 66]),
          new G(30, new L(3, 115), new L(1, 116)),
          new G(24, new L(4, 40), new L(5, 41)),
          new G(20, new L(11, 16), new L(5, 17)),
          new G(24, new L(11, 12), new L(5, 13))
        ),
        new de(
          15,
          Int32Array.from([6, 26, 48, 70]),
          new G(22, new L(5, 87), new L(1, 88)),
          new G(24, new L(5, 41), new L(5, 42)),
          new G(30, new L(5, 24), new L(7, 25)),
          new G(24, new L(11, 12), new L(7, 13))
        ),
        new de(
          16,
          Int32Array.from([6, 26, 50, 74]),
          new G(24, new L(5, 98), new L(1, 99)),
          new G(28, new L(7, 45), new L(3, 46)),
          new G(24, new L(15, 19), new L(2, 20)),
          new G(30, new L(3, 15), new L(13, 16))
        ),
        new de(
          17,
          Int32Array.from([6, 30, 54, 78]),
          new G(28, new L(1, 107), new L(5, 108)),
          new G(28, new L(10, 46), new L(1, 47)),
          new G(28, new L(1, 22), new L(15, 23)),
          new G(28, new L(2, 14), new L(17, 15))
        ),
        new de(
          18,
          Int32Array.from([6, 30, 56, 82]),
          new G(30, new L(5, 120), new L(1, 121)),
          new G(26, new L(9, 43), new L(4, 44)),
          new G(28, new L(17, 22), new L(1, 23)),
          new G(28, new L(2, 14), new L(19, 15))
        ),
        new de(
          19,
          Int32Array.from([6, 30, 58, 86]),
          new G(28, new L(3, 113), new L(4, 114)),
          new G(26, new L(3, 44), new L(11, 45)),
          new G(26, new L(17, 21), new L(4, 22)),
          new G(26, new L(9, 13), new L(16, 14))
        ),
        new de(
          20,
          Int32Array.from([6, 34, 62, 90]),
          new G(28, new L(3, 107), new L(5, 108)),
          new G(26, new L(3, 41), new L(13, 42)),
          new G(30, new L(15, 24), new L(5, 25)),
          new G(28, new L(15, 15), new L(10, 16))
        ),
        new de(
          21,
          Int32Array.from([6, 28, 50, 72, 94]),
          new G(28, new L(4, 116), new L(4, 117)),
          new G(26, new L(17, 42)),
          new G(28, new L(17, 22), new L(6, 23)),
          new G(30, new L(19, 16), new L(6, 17))
        ),
        new de(
          22,
          Int32Array.from([6, 26, 50, 74, 98]),
          new G(28, new L(2, 111), new L(7, 112)),
          new G(28, new L(17, 46)),
          new G(30, new L(7, 24), new L(16, 25)),
          new G(24, new L(34, 13))
        ),
        new de(
          23,
          Int32Array.from([6, 30, 54, 78, 102]),
          new G(30, new L(4, 121), new L(5, 122)),
          new G(28, new L(4, 47), new L(14, 48)),
          new G(30, new L(11, 24), new L(14, 25)),
          new G(30, new L(16, 15), new L(14, 16))
        ),
        new de(
          24,
          Int32Array.from([6, 28, 54, 80, 106]),
          new G(30, new L(6, 117), new L(4, 118)),
          new G(28, new L(6, 45), new L(14, 46)),
          new G(30, new L(11, 24), new L(16, 25)),
          new G(30, new L(30, 16), new L(2, 17))
        ),
        new de(
          25,
          Int32Array.from([6, 32, 58, 84, 110]),
          new G(26, new L(8, 106), new L(4, 107)),
          new G(28, new L(8, 47), new L(13, 48)),
          new G(30, new L(7, 24), new L(22, 25)),
          new G(30, new L(22, 15), new L(13, 16))
        ),
        new de(
          26,
          Int32Array.from([6, 30, 58, 86, 114]),
          new G(28, new L(10, 114), new L(2, 115)),
          new G(28, new L(19, 46), new L(4, 47)),
          new G(28, new L(28, 22), new L(6, 23)),
          new G(30, new L(33, 16), new L(4, 17))
        ),
        new de(
          27,
          Int32Array.from([6, 34, 62, 90, 118]),
          new G(30, new L(8, 122), new L(4, 123)),
          new G(28, new L(22, 45), new L(3, 46)),
          new G(30, new L(8, 23), new L(26, 24)),
          new G(30, new L(12, 15), new L(28, 16))
        ),
        new de(
          28,
          Int32Array.from([6, 26, 50, 74, 98, 122]),
          new G(30, new L(3, 117), new L(10, 118)),
          new G(28, new L(3, 45), new L(23, 46)),
          new G(30, new L(4, 24), new L(31, 25)),
          new G(30, new L(11, 15), new L(31, 16))
        ),
        new de(
          29,
          Int32Array.from([6, 30, 54, 78, 102, 126]),
          new G(30, new L(7, 116), new L(7, 117)),
          new G(28, new L(21, 45), new L(7, 46)),
          new G(30, new L(1, 23), new L(37, 24)),
          new G(30, new L(19, 15), new L(26, 16))
        ),
        new de(
          30,
          Int32Array.from([6, 26, 52, 78, 104, 130]),
          new G(30, new L(5, 115), new L(10, 116)),
          new G(28, new L(19, 47), new L(10, 48)),
          new G(30, new L(15, 24), new L(25, 25)),
          new G(30, new L(23, 15), new L(25, 16))
        ),
        new de(
          31,
          Int32Array.from([6, 30, 56, 82, 108, 134]),
          new G(30, new L(13, 115), new L(3, 116)),
          new G(28, new L(2, 46), new L(29, 47)),
          new G(30, new L(42, 24), new L(1, 25)),
          new G(30, new L(23, 15), new L(28, 16))
        ),
        new de(
          32,
          Int32Array.from([6, 34, 60, 86, 112, 138]),
          new G(30, new L(17, 115)),
          new G(28, new L(10, 46), new L(23, 47)),
          new G(30, new L(10, 24), new L(35, 25)),
          new G(30, new L(19, 15), new L(35, 16))
        ),
        new de(
          33,
          Int32Array.from([6, 30, 58, 86, 114, 142]),
          new G(30, new L(17, 115), new L(1, 116)),
          new G(28, new L(14, 46), new L(21, 47)),
          new G(30, new L(29, 24), new L(19, 25)),
          new G(30, new L(11, 15), new L(46, 16))
        ),
        new de(
          34,
          Int32Array.from([6, 34, 62, 90, 118, 146]),
          new G(30, new L(13, 115), new L(6, 116)),
          new G(28, new L(14, 46), new L(23, 47)),
          new G(30, new L(44, 24), new L(7, 25)),
          new G(30, new L(59, 16), new L(1, 17))
        ),
        new de(
          35,
          Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
          new G(30, new L(12, 121), new L(7, 122)),
          new G(28, new L(12, 47), new L(26, 48)),
          new G(30, new L(39, 24), new L(14, 25)),
          new G(30, new L(22, 15), new L(41, 16))
        ),
        new de(
          36,
          Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
          new G(30, new L(6, 121), new L(14, 122)),
          new G(28, new L(6, 47), new L(34, 48)),
          new G(30, new L(46, 24), new L(10, 25)),
          new G(30, new L(2, 15), new L(64, 16))
        ),
        new de(
          37,
          Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
          new G(30, new L(17, 122), new L(4, 123)),
          new G(28, new L(29, 46), new L(14, 47)),
          new G(30, new L(49, 24), new L(10, 25)),
          new G(30, new L(24, 15), new L(46, 16))
        ),
        new de(
          38,
          Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
          new G(30, new L(4, 122), new L(18, 123)),
          new G(28, new L(13, 46), new L(32, 47)),
          new G(30, new L(48, 24), new L(14, 25)),
          new G(30, new L(42, 15), new L(32, 16))
        ),
        new de(
          39,
          Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
          new G(30, new L(20, 117), new L(4, 118)),
          new G(28, new L(40, 47), new L(7, 48)),
          new G(30, new L(43, 24), new L(22, 25)),
          new G(30, new L(10, 15), new L(67, 16))
        ),
        new de(
          40,
          Int32Array.from([6, 30, 58, 86, 114, 142, 170]),
          new G(30, new L(19, 118), new L(6, 119)),
          new G(28, new L(18, 47), new L(31, 48)),
          new G(30, new L(34, 24), new L(34, 25)),
          new G(30, new L(20, 15), new L(61, 16))
        ),
      ]))
    var Mt
    ;(function (_) {
      ;((_[(_.DATA_MASK_000 = 0)] = 'DATA_MASK_000'),
        (_[(_.DATA_MASK_001 = 1)] = 'DATA_MASK_001'),
        (_[(_.DATA_MASK_010 = 2)] = 'DATA_MASK_010'),
        (_[(_.DATA_MASK_011 = 3)] = 'DATA_MASK_011'),
        (_[(_.DATA_MASK_100 = 4)] = 'DATA_MASK_100'),
        (_[(_.DATA_MASK_101 = 5)] = 'DATA_MASK_101'),
        (_[(_.DATA_MASK_110 = 6)] = 'DATA_MASK_110'),
        (_[(_.DATA_MASK_111 = 7)] = 'DATA_MASK_111'))
    })(Mt || (Mt = {}))
    class Un {
      constructor(s, a) {
        ;((this.value = s), (this.isMasked = a))
      }
      unmaskBitMatrix(s, a) {
        for (let l = 0; l < a; l++) for (let u = 0; u < a; u++) this.isMasked(l, u) && s.flip(u, l)
      }
    }
    Un.values = new Map([
      [Mt.DATA_MASK_000, new Un(Mt.DATA_MASK_000, (_, s) => ((_ + s) & 1) === 0)],
      [Mt.DATA_MASK_001, new Un(Mt.DATA_MASK_001, (_, s) => (_ & 1) === 0)],
      [Mt.DATA_MASK_010, new Un(Mt.DATA_MASK_010, (_, s) => s % 3 === 0)],
      [Mt.DATA_MASK_011, new Un(Mt.DATA_MASK_011, (_, s) => (_ + s) % 3 === 0)],
      [
        Mt.DATA_MASK_100,
        new Un(Mt.DATA_MASK_100, (_, s) => ((Math.floor(_ / 2) + Math.floor(s / 3)) & 1) === 0),
      ],
      [Mt.DATA_MASK_101, new Un(Mt.DATA_MASK_101, (_, s) => (_ * s) % 6 === 0)],
      [Mt.DATA_MASK_110, new Un(Mt.DATA_MASK_110, (_, s) => (_ * s) % 6 < 3)],
      [Mt.DATA_MASK_111, new Un(Mt.DATA_MASK_111, (_, s) => ((_ + s + ((_ * s) % 3)) & 1) === 0)],
    ])
    class mb {
      constructor(s) {
        const a = s.getHeight()
        if (a < 21 || (a & 3) !== 1) throw new V()
        this.bitMatrix = s
      }
      readFormatInformation() {
        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== void 0)
          return this.parsedFormatInfo
        let s = 0
        for (let d = 0; d < 6; d++) s = this.copyBit(d, 8, s)
        ;((s = this.copyBit(7, 8, s)), (s = this.copyBit(8, 8, s)), (s = this.copyBit(8, 7, s)))
        for (let d = 5; d >= 0; d--) s = this.copyBit(8, d, s)
        const a = this.bitMatrix.getHeight()
        let l = 0
        const u = a - 7
        for (let d = a - 1; d >= u; d--) l = this.copyBit(8, d, l)
        for (let d = a - 8; d < a; d++) l = this.copyBit(d, 8, l)
        if (
          ((this.parsedFormatInfo = Zt.decodeFormatInformation(s, l)),
          this.parsedFormatInfo !== null)
        )
          return this.parsedFormatInfo
        throw new V()
      }
      readVersion() {
        if (this.parsedVersion !== null && this.parsedVersion !== void 0) return this.parsedVersion
        const s = this.bitMatrix.getHeight(),
          a = Math.floor((s - 17) / 4)
        if (a <= 6) return de.getVersionForNumber(a)
        let l = 0
        const u = s - 11
        for (let g = 5; g >= 0; g--) for (let m = s - 9; m >= u; m--) l = this.copyBit(m, g, l)
        let d = de.decodeVersionInformation(l)
        if (d !== null && d.getDimensionForVersion() === s) return ((this.parsedVersion = d), d)
        l = 0
        for (let g = 5; g >= 0; g--) for (let m = s - 9; m >= u; m--) l = this.copyBit(g, m, l)
        if (((d = de.decodeVersionInformation(l)), d !== null && d.getDimensionForVersion() === s))
          return ((this.parsedVersion = d), d)
        throw new V()
      }
      copyBit(s, a, l) {
        return (this.isMirror ? this.bitMatrix.get(a, s) : this.bitMatrix.get(s, a))
          ? (l << 1) | 1
          : l << 1
      }
      readCodewords() {
        const s = this.readFormatInformation(),
          a = this.readVersion(),
          l = Un.values.get(s.getDataMask()),
          u = this.bitMatrix.getHeight()
        l.unmaskBitMatrix(this.bitMatrix, u)
        const d = a.buildFunctionPattern()
        let g = !0
        const m = new Uint8Array(a.getTotalCodewords())
        let b = 0,
          v = 0,
          C = 0
        for (let T = u - 1; T > 0; T -= 2) {
          T === 6 && T--
          for (let D = 0; D < u; D++) {
            const B = g ? u - 1 - D : D
            for (let j = 0; j < 2; j++)
              d.get(T - j, B) ||
                (C++,
                (v <<= 1),
                this.bitMatrix.get(T - j, B) && (v |= 1),
                C === 8 && ((m[b++] = v), (C = 0), (v = 0)))
          }
          g = !g
        }
        if (b !== a.getTotalCodewords()) throw new V()
        return m
      }
      remask() {
        if (this.parsedFormatInfo === null) return
        const s = Un.values[this.parsedFormatInfo.getDataMask()],
          a = this.bitMatrix.getHeight()
        s.unmaskBitMatrix(this.bitMatrix, a)
      }
      setMirror(s) {
        ;((this.parsedVersion = null), (this.parsedFormatInfo = null), (this.isMirror = s))
      }
      mirror() {
        const s = this.bitMatrix
        for (let a = 0, l = s.getWidth(); a < l; a++)
          for (let u = a + 1, d = s.getHeight(); u < d; u++)
            s.get(a, u) !== s.get(u, a) && (s.flip(u, a), s.flip(a, u))
      }
    }
    class Oh {
      constructor(s, a) {
        ;((this.numDataCodewords = s), (this.codewords = a))
      }
      static getDataBlocks(s, a, l) {
        if (s.length !== a.getTotalCodewords()) throw new w()
        const u = a.getECBlocksForLevel(l)
        let d = 0
        const g = u.getECBlocks()
        for (const j of g) d += j.getCount()
        const m = new Array(d)
        let b = 0
        for (const j of g)
          for (let W = 0; W < j.getCount(); W++) {
            const Y = j.getDataCodewords(),
              q = u.getECCodewordsPerBlock() + Y
            m[b++] = new Oh(Y, new Uint8Array(q))
          }
        const v = m[0].codewords.length
        let C = m.length - 1
        for (; C >= 0 && m[C].codewords.length !== v; ) C--
        C++
        const T = v - u.getECCodewordsPerBlock()
        let D = 0
        for (let j = 0; j < T; j++) for (let W = 0; W < b; W++) m[W].codewords[j] = s[D++]
        for (let j = C; j < b; j++) m[j].codewords[T] = s[D++]
        const B = m[0].codewords.length
        for (let j = T; j < B; j++)
          for (let W = 0; W < b; W++) {
            const Y = W < C ? j : j + 1
            m[W].codewords[Y] = s[D++]
          }
        return m
      }
      getNumDataCodewords() {
        return this.numDataCodewords
      }
      getCodewords() {
        return this.codewords
      }
    }
    var Wn
    ;(function (_) {
      ;((_[(_.TERMINATOR = 0)] = 'TERMINATOR'),
        (_[(_.NUMERIC = 1)] = 'NUMERIC'),
        (_[(_.ALPHANUMERIC = 2)] = 'ALPHANUMERIC'),
        (_[(_.STRUCTURED_APPEND = 3)] = 'STRUCTURED_APPEND'),
        (_[(_.BYTE = 4)] = 'BYTE'),
        (_[(_.ECI = 5)] = 'ECI'),
        (_[(_.KANJI = 6)] = 'KANJI'),
        (_[(_.FNC1_FIRST_POSITION = 7)] = 'FNC1_FIRST_POSITION'),
        (_[(_.FNC1_SECOND_POSITION = 8)] = 'FNC1_SECOND_POSITION'),
        (_[(_.HANZI = 9)] = 'HANZI'))
    })(Wn || (Wn = {}))
    class me {
      constructor(s, a, l, u) {
        ;((this.value = s),
          (this.stringValue = a),
          (this.characterCountBitsForVersions = l),
          (this.bits = u),
          me.FOR_BITS.set(u, this),
          me.FOR_VALUE.set(s, this))
      }
      static forBits(s) {
        const a = me.FOR_BITS.get(s)
        if (a === void 0) throw new w()
        return a
      }
      getCharacterCountBits(s) {
        const a = s.getVersionNumber()
        let l
        return (
          a <= 9 ? (l = 0) : a <= 26 ? (l = 1) : (l = 2),
          this.characterCountBitsForVersions[l]
        )
      }
      getValue() {
        return this.value
      }
      getBits() {
        return this.bits
      }
      equals(s) {
        if (!(s instanceof me)) return !1
        const a = s
        return this.value === a.value
      }
      toString() {
        return this.stringValue
      }
    }
    ;((me.FOR_BITS = new Map()),
      (me.FOR_VALUE = new Map()),
      (me.TERMINATOR = new me(Wn.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0)),
      (me.NUMERIC = new me(Wn.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 1)),
      (me.ALPHANUMERIC = new me(Wn.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 2)),
      (me.STRUCTURED_APPEND = new me(
        Wn.STRUCTURED_APPEND,
        'STRUCTURED_APPEND',
        Int32Array.from([0, 0, 0]),
        3
      )),
      (me.BYTE = new me(Wn.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 4)),
      (me.ECI = new me(Wn.ECI, 'ECI', Int32Array.from([0, 0, 0]), 7)),
      (me.KANJI = new me(Wn.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 8)),
      (me.FNC1_FIRST_POSITION = new me(
        Wn.FNC1_FIRST_POSITION,
        'FNC1_FIRST_POSITION',
        Int32Array.from([0, 0, 0]),
        5
      )),
      (me.FNC1_SECOND_POSITION = new me(
        Wn.FNC1_SECOND_POSITION,
        'FNC1_SECOND_POSITION',
        Int32Array.from([0, 0, 0]),
        9
      )),
      (me.HANZI = new me(Wn.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 13)))
    class ot {
      static decode(s, a, l, u) {
        const d = new Lh(s)
        let g = new ve()
        const m = new Array()
        let b = -1,
          v = -1
        try {
          let C = null,
            T = !1,
            D
          do {
            if (d.available() < 4) D = me.TERMINATOR
            else {
              const B = d.readBits(4)
              D = me.forBits(B)
            }
            switch (D) {
              case me.TERMINATOR:
                break
              case me.FNC1_FIRST_POSITION:
              case me.FNC1_SECOND_POSITION:
                T = !0
                break
              case me.STRUCTURED_APPEND:
                if (d.available() < 16) throw new V()
                ;((b = d.readBits(8)), (v = d.readBits(8)))
                break
              case me.ECI:
                const B = ot.parseECIValue(d)
                if (((C = Z.getCharacterSetECIByValue(B)), C === null)) throw new V()
                break
              case me.HANZI:
                const j = d.readBits(4),
                  W = d.readBits(D.getCharacterCountBits(a))
                j === ot.GB2312_SUBSET && ot.decodeHanziSegment(d, g, W)
                break
              default:
                const Y = d.readBits(D.getCharacterCountBits(a))
                switch (D) {
                  case me.NUMERIC:
                    ot.decodeNumericSegment(d, g, Y)
                    break
                  case me.ALPHANUMERIC:
                    ot.decodeAlphanumericSegment(d, g, Y, T)
                    break
                  case me.BYTE:
                    ot.decodeByteSegment(d, g, Y, C, m, u)
                    break
                  case me.KANJI:
                    ot.decodeKanjiSegment(d, g, Y)
                    break
                  default:
                    throw new V()
                }
                break
            }
          } while (D !== me.TERMINATOR)
        } catch {
          throw new V()
        }
        return new Jo(
          s,
          g.toString(),
          m.length === 0 ? null : m,
          l === null ? null : l.toString(),
          b,
          v
        )
      }
      static decodeHanziSegment(s, a, l) {
        if (l * 13 > s.available()) throw new V()
        const u = new Uint8Array(2 * l)
        let d = 0
        for (; l > 0; ) {
          const g = s.readBits(13)
          let m = (((g / 96) << 8) & 4294967295) | g % 96
          ;(m < 959 ? (m += 41377) : (m += 42657),
            (u[d] = (m >> 8) & 255),
            (u[d + 1] = m & 255),
            (d += 2),
            l--)
        }
        try {
          a.append(oe.decode(u, re.GB2312))
        } catch (g) {
          throw new V(g)
        }
      }
      static decodeKanjiSegment(s, a, l) {
        if (l * 13 > s.available()) throw new V()
        const u = new Uint8Array(2 * l)
        let d = 0
        for (; l > 0; ) {
          const g = s.readBits(13)
          let m = (((g / 192) << 8) & 4294967295) | g % 192
          ;(m < 7936 ? (m += 33088) : (m += 49472), (u[d] = m >> 8), (u[d + 1] = m), (d += 2), l--)
        }
        try {
          a.append(oe.decode(u, re.SHIFT_JIS))
        } catch (g) {
          throw new V(g)
        }
      }
      static decodeByteSegment(s, a, l, u, d, g) {
        if (8 * l > s.available()) throw new V()
        const m = new Uint8Array(l)
        for (let v = 0; v < l; v++) m[v] = s.readBits(8)
        let b
        u === null ? (b = re.guessEncoding(m, g)) : (b = u.getName())
        try {
          a.append(oe.decode(m, b))
        } catch (v) {
          throw new V(v)
        }
        d.push(m)
      }
      static toAlphaNumericChar(s) {
        if (s >= ot.ALPHANUMERIC_CHARS.length) throw new V()
        return ot.ALPHANUMERIC_CHARS[s]
      }
      static decodeAlphanumericSegment(s, a, l, u) {
        const d = a.length()
        for (; l > 1; ) {
          if (s.available() < 11) throw new V()
          const g = s.readBits(11)
          ;(a.append(ot.toAlphaNumericChar(Math.floor(g / 45))),
            a.append(ot.toAlphaNumericChar(g % 45)),
            (l -= 2))
        }
        if (l === 1) {
          if (s.available() < 6) throw new V()
          a.append(ot.toAlphaNumericChar(s.readBits(6)))
        }
        if (u)
          for (let g = d; g < a.length(); g++)
            a.charAt(g) === '%' &&
              (g < a.length() - 1 && a.charAt(g + 1) === '%'
                ? a.deleteCharAt(g + 1)
                : a.setCharAt(g, ''))
      }
      static decodeNumericSegment(s, a, l) {
        for (; l >= 3; ) {
          if (s.available() < 10) throw new V()
          const u = s.readBits(10)
          if (u >= 1e3) throw new V()
          ;(a.append(ot.toAlphaNumericChar(Math.floor(u / 100))),
            a.append(ot.toAlphaNumericChar(Math.floor(u / 10) % 10)),
            a.append(ot.toAlphaNumericChar(u % 10)),
            (l -= 3))
        }
        if (l === 2) {
          if (s.available() < 7) throw new V()
          const u = s.readBits(7)
          if (u >= 100) throw new V()
          ;(a.append(ot.toAlphaNumericChar(Math.floor(u / 10))),
            a.append(ot.toAlphaNumericChar(u % 10)))
        } else if (l === 1) {
          if (s.available() < 4) throw new V()
          const u = s.readBits(4)
          if (u >= 10) throw new V()
          a.append(ot.toAlphaNumericChar(u))
        }
      }
      static parseECIValue(s) {
        const a = s.readBits(8)
        if (!(a & 128)) return a & 127
        if ((a & 192) === 128) {
          const l = s.readBits(8)
          return (((a & 63) << 8) & 4294967295) | l
        }
        if ((a & 224) === 192) {
          const l = s.readBits(16)
          return (((a & 31) << 16) & 4294967295) | l
        }
        throw new V()
      }
    }
    ;((ot.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'),
      (ot.GB2312_SUBSET = 1))
    class Ap {
      constructor(s) {
        this.mirrored = s
      }
      isMirrored() {
        return this.mirrored
      }
      applyMirroredCorrection(s) {
        if (!this.mirrored || s === null || s.length < 3) return
        const a = s[0]
        ;((s[0] = s[2]), (s[2] = a))
      }
    }
    class yb {
      constructor() {
        this.rsDecoder = new ta(Fe.QR_CODE_FIELD_256)
      }
      decodeBooleanArray(s, a) {
        return this.decodeBitMatrix(Ie.parseFromBooleanArray(s), a)
      }
      decodeBitMatrix(s, a) {
        const l = new mb(s)
        let u = null
        try {
          return this.decodeBitMatrixParser(l, a)
        } catch (d) {
          u = d
        }
        try {
          ;(l.remask(), l.setMirror(!0), l.readVersion(), l.readFormatInformation(), l.mirror())
          const d = this.decodeBitMatrixParser(l, a)
          return (d.setOther(new Ap(!0)), d)
        } catch (d) {
          throw u !== null ? u : d
        }
      }
      decodeBitMatrixParser(s, a) {
        const l = s.readVersion(),
          u = s.readFormatInformation().getErrorCorrectionLevel(),
          d = s.readCodewords(),
          g = Oh.getDataBlocks(d, l, u)
        let m = 0
        for (const C of g) m += C.getNumDataCodewords()
        const b = new Uint8Array(m)
        let v = 0
        for (const C of g) {
          const T = C.getCodewords(),
            D = C.getNumDataCodewords()
          this.correctErrors(T, D)
          for (let B = 0; B < D; B++) b[v++] = T[B]
        }
        return ot.decode(b, l, u, a)
      }
      correctErrors(s, a) {
        const l = new Int32Array(s)
        try {
          this.rsDecoder.decode(l, s.length - a)
        } catch {
          throw new E()
        }
        for (let u = 0; u < a; u++) s[u] = l[u]
      }
    }
    class Bh extends he {
      constructor(s, a, l) {
        ;(super(s, a), (this.estimatedModuleSize = l))
      }
      aboutEquals(s, a, l) {
        if (Math.abs(a - this.getY()) <= s && Math.abs(l - this.getX()) <= s) {
          const u = Math.abs(s - this.estimatedModuleSize)
          return u <= 1 || u <= this.estimatedModuleSize
        }
        return !1
      }
      combineEstimate(s, a, l) {
        const u = (this.getX() + a) / 2,
          d = (this.getY() + s) / 2,
          g = (this.estimatedModuleSize + l) / 2
        return new Bh(u, d, g)
      }
    }
    class ql {
      constructor(s, a, l, u, d, g, m) {
        ;((this.image = s),
          (this.startX = a),
          (this.startY = l),
          (this.width = u),
          (this.height = d),
          (this.moduleSize = g),
          (this.resultPointCallback = m),
          (this.possibleCenters = []),
          (this.crossCheckStateCount = new Int32Array(3)))
      }
      find() {
        const s = this.startX,
          a = this.height,
          l = this.width,
          u = s + l,
          d = this.startY + a / 2,
          g = new Int32Array(3),
          m = this.image
        for (let b = 0; b < a; b++) {
          const v = d + (b & 1 ? -Math.floor((b + 1) / 2) : Math.floor((b + 1) / 2))
          ;((g[0] = 0), (g[1] = 0), (g[2] = 0))
          let C = s
          for (; C < u && !m.get(C, v); ) C++
          let T = 0
          for (; C < u; ) {
            if (m.get(C, v))
              if (T === 1) g[1]++
              else if (T === 2) {
                if (this.foundPatternCross(g)) {
                  const D = this.handlePossibleCenter(g, v, C)
                  if (D !== null) return D
                }
                ;((g[0] = g[2]), (g[1] = 1), (g[2] = 0), (T = 1))
              } else g[++T]++
            else (T === 1 && T++, g[T]++)
            C++
          }
          if (this.foundPatternCross(g)) {
            const D = this.handlePossibleCenter(g, v, u)
            if (D !== null) return D
          }
        }
        if (this.possibleCenters.length !== 0) return this.possibleCenters[0]
        throw new H()
      }
      static centerFromEnd(s, a) {
        return a - s[2] - s[1] / 2
      }
      foundPatternCross(s) {
        const a = this.moduleSize,
          l = a / 2
        for (let u = 0; u < 3; u++) if (Math.abs(a - s[u]) >= l) return !1
        return !0
      }
      crossCheckVertical(s, a, l, u) {
        const d = this.image,
          g = d.getHeight(),
          m = this.crossCheckStateCount
        ;((m[0] = 0), (m[1] = 0), (m[2] = 0))
        let b = s
        for (; b >= 0 && d.get(a, b) && m[1] <= l; ) (m[1]++, b--)
        if (b < 0 || m[1] > l) return NaN
        for (; b >= 0 && !d.get(a, b) && m[0] <= l; ) (m[0]++, b--)
        if (m[0] > l) return NaN
        for (b = s + 1; b < g && d.get(a, b) && m[1] <= l; ) (m[1]++, b++)
        if (b === g || m[1] > l) return NaN
        for (; b < g && !d.get(a, b) && m[2] <= l; ) (m[2]++, b++)
        if (m[2] > l) return NaN
        const v = m[0] + m[1] + m[2]
        return 5 * Math.abs(v - u) >= 2 * u
          ? NaN
          : this.foundPatternCross(m)
            ? ql.centerFromEnd(m, b)
            : NaN
      }
      handlePossibleCenter(s, a, l) {
        const u = s[0] + s[1] + s[2],
          d = ql.centerFromEnd(s, l),
          g = this.crossCheckVertical(a, d, 2 * s[1], u)
        if (!isNaN(g)) {
          const m = (s[0] + s[1] + s[2]) / 3
          for (const v of this.possibleCenters)
            if (v.aboutEquals(m, g, d)) return v.combineEstimate(g, d, m)
          const b = new Bh(d, g, m)
          ;(this.possibleCenters.push(b),
            this.resultPointCallback !== null &&
              this.resultPointCallback !== void 0 &&
              this.resultPointCallback.foundPossibleResultPoint(b))
        }
        return null
      }
    }
    class Fh extends he {
      constructor(s, a, l, u) {
        ;(super(s, a),
          (this.estimatedModuleSize = l),
          (this.count = u),
          u === void 0 && (this.count = 1))
      }
      getEstimatedModuleSize() {
        return this.estimatedModuleSize
      }
      getCount() {
        return this.count
      }
      aboutEquals(s, a, l) {
        if (Math.abs(a - this.getY()) <= s && Math.abs(l - this.getX()) <= s) {
          const u = Math.abs(s - this.estimatedModuleSize)
          return u <= 1 || u <= this.estimatedModuleSize
        }
        return !1
      }
      combineEstimate(s, a, l) {
        const u = this.count + 1,
          d = (this.count * this.getX() + a) / u,
          g = (this.count * this.getY() + s) / u,
          m = (this.count * this.estimatedModuleSize + l) / u
        return new Fh(d, g, m, u)
      }
    }
    class wb {
      constructor(s) {
        ;((this.bottomLeft = s[0]), (this.topLeft = s[1]), (this.topRight = s[2]))
      }
      getBottomLeft() {
        return this.bottomLeft
      }
      getTopLeft() {
        return this.topLeft
      }
      getTopRight() {
        return this.topRight
      }
    }
    class Pt {
      constructor(s, a) {
        ;((this.image = s),
          (this.resultPointCallback = a),
          (this.possibleCenters = []),
          (this.crossCheckStateCount = new Int32Array(5)),
          (this.resultPointCallback = a))
      }
      getImage() {
        return this.image
      }
      getPossibleCenters() {
        return this.possibleCenters
      }
      find(s) {
        const a = s != null && s.get(z.TRY_HARDER) !== void 0,
          l = s != null && s.get(z.PURE_BARCODE) !== void 0,
          u = this.image,
          d = u.getHeight(),
          g = u.getWidth()
        let m = Math.floor((3 * d) / (4 * Pt.MAX_MODULES))
        ;(m < Pt.MIN_SKIP || a) && (m = Pt.MIN_SKIP)
        let b = !1
        const v = new Int32Array(5)
        for (let T = m - 1; T < d && !b; T += m) {
          ;((v[0] = 0), (v[1] = 0), (v[2] = 0), (v[3] = 0), (v[4] = 0))
          let D = 0
          for (let B = 0; B < g; B++)
            if (u.get(B, T)) ((D & 1) === 1 && D++, v[D]++)
            else if (D & 1) v[D]++
            else if (D === 4)
              if (Pt.foundPatternCross(v)) {
                if (this.handlePossibleCenter(v, T, B, l) === !0)
                  if (((m = 2), this.hasSkipped === !0)) b = this.haveMultiplyConfirmedCenters()
                  else {
                    const j = this.findRowSkip()
                    j > v[2] && ((T += j - v[2] - m), (B = g - 1))
                  }
                else {
                  ;((v[0] = v[2]), (v[1] = v[3]), (v[2] = v[4]), (v[3] = 1), (v[4] = 0), (D = 3))
                  continue
                }
                ;((D = 0), (v[0] = 0), (v[1] = 0), (v[2] = 0), (v[3] = 0), (v[4] = 0))
              } else ((v[0] = v[2]), (v[1] = v[3]), (v[2] = v[4]), (v[3] = 1), (v[4] = 0), (D = 3))
            else v[++D]++
          Pt.foundPatternCross(v) &&
            this.handlePossibleCenter(v, T, g, l) === !0 &&
            ((m = v[0]), this.hasSkipped && (b = this.haveMultiplyConfirmedCenters()))
        }
        const C = this.selectBestPatterns()
        return (he.orderBestPatterns(C), new wb(C))
      }
      static centerFromEnd(s, a) {
        return a - s[4] - s[3] - s[2] / 2
      }
      static foundPatternCross(s) {
        let a = 0
        for (let d = 0; d < 5; d++) {
          const g = s[d]
          if (g === 0) return !1
          a += g
        }
        if (a < 7) return !1
        const l = a / 7,
          u = l / 2
        return (
          Math.abs(l - s[0]) < u &&
          Math.abs(l - s[1]) < u &&
          Math.abs(3 * l - s[2]) < 3 * u &&
          Math.abs(l - s[3]) < u &&
          Math.abs(l - s[4]) < u
        )
      }
      getCrossCheckStateCount() {
        const s = this.crossCheckStateCount
        return ((s[0] = 0), (s[1] = 0), (s[2] = 0), (s[3] = 0), (s[4] = 0), s)
      }
      crossCheckDiagonal(s, a, l, u) {
        const d = this.getCrossCheckStateCount()
        let g = 0
        const m = this.image
        for (; s >= g && a >= g && m.get(a - g, s - g); ) (d[2]++, g++)
        if (s < g || a < g) return !1
        for (; s >= g && a >= g && !m.get(a - g, s - g) && d[1] <= l; ) (d[1]++, g++)
        if (s < g || a < g || d[1] > l) return !1
        for (; s >= g && a >= g && m.get(a - g, s - g) && d[0] <= l; ) (d[0]++, g++)
        if (d[0] > l) return !1
        const b = m.getHeight(),
          v = m.getWidth()
        for (g = 1; s + g < b && a + g < v && m.get(a + g, s + g); ) (d[2]++, g++)
        if (s + g >= b || a + g >= v) return !1
        for (; s + g < b && a + g < v && !m.get(a + g, s + g) && d[3] < l; ) (d[3]++, g++)
        if (s + g >= b || a + g >= v || d[3] >= l) return !1
        for (; s + g < b && a + g < v && m.get(a + g, s + g) && d[4] < l; ) (d[4]++, g++)
        if (d[4] >= l) return !1
        const C = d[0] + d[1] + d[2] + d[3] + d[4]
        return Math.abs(C - u) < 2 * u && Pt.foundPatternCross(d)
      }
      crossCheckVertical(s, a, l, u) {
        const d = this.image,
          g = d.getHeight(),
          m = this.getCrossCheckStateCount()
        let b = s
        for (; b >= 0 && d.get(a, b); ) (m[2]++, b--)
        if (b < 0) return NaN
        for (; b >= 0 && !d.get(a, b) && m[1] <= l; ) (m[1]++, b--)
        if (b < 0 || m[1] > l) return NaN
        for (; b >= 0 && d.get(a, b) && m[0] <= l; ) (m[0]++, b--)
        if (m[0] > l) return NaN
        for (b = s + 1; b < g && d.get(a, b); ) (m[2]++, b++)
        if (b === g) return NaN
        for (; b < g && !d.get(a, b) && m[3] < l; ) (m[3]++, b++)
        if (b === g || m[3] >= l) return NaN
        for (; b < g && d.get(a, b) && m[4] < l; ) (m[4]++, b++)
        if (m[4] >= l) return NaN
        const v = m[0] + m[1] + m[2] + m[3] + m[4]
        return 5 * Math.abs(v - u) >= 2 * u
          ? NaN
          : Pt.foundPatternCross(m)
            ? Pt.centerFromEnd(m, b)
            : NaN
      }
      crossCheckHorizontal(s, a, l, u) {
        const d = this.image,
          g = d.getWidth(),
          m = this.getCrossCheckStateCount()
        let b = s
        for (; b >= 0 && d.get(b, a); ) (m[2]++, b--)
        if (b < 0) return NaN
        for (; b >= 0 && !d.get(b, a) && m[1] <= l; ) (m[1]++, b--)
        if (b < 0 || m[1] > l) return NaN
        for (; b >= 0 && d.get(b, a) && m[0] <= l; ) (m[0]++, b--)
        if (m[0] > l) return NaN
        for (b = s + 1; b < g && d.get(b, a); ) (m[2]++, b++)
        if (b === g) return NaN
        for (; b < g && !d.get(b, a) && m[3] < l; ) (m[3]++, b++)
        if (b === g || m[3] >= l) return NaN
        for (; b < g && d.get(b, a) && m[4] < l; ) (m[4]++, b++)
        if (m[4] >= l) return NaN
        const v = m[0] + m[1] + m[2] + m[3] + m[4]
        return 5 * Math.abs(v - u) >= u
          ? NaN
          : Pt.foundPatternCross(m)
            ? Pt.centerFromEnd(m, b)
            : NaN
      }
      handlePossibleCenter(s, a, l, u) {
        const d = s[0] + s[1] + s[2] + s[3] + s[4]
        let g = Pt.centerFromEnd(s, l),
          m = this.crossCheckVertical(a, Math.floor(g), s[2], d)
        if (
          !isNaN(m) &&
          ((g = this.crossCheckHorizontal(Math.floor(g), Math.floor(m), s[2], d)),
          !isNaN(g) && (!u || this.crossCheckDiagonal(Math.floor(m), Math.floor(g), s[2], d)))
        ) {
          const b = d / 7
          let v = !1
          const C = this.possibleCenters
          for (let T = 0, D = C.length; T < D; T++) {
            const B = C[T]
            if (B.aboutEquals(b, m, g)) {
              ;((C[T] = B.combineEstimate(m, g, b)), (v = !0))
              break
            }
          }
          if (!v) {
            const T = new Fh(g, m, b)
            ;(C.push(T),
              this.resultPointCallback !== null &&
                this.resultPointCallback !== void 0 &&
                this.resultPointCallback.foundPossibleResultPoint(T))
          }
          return !0
        }
        return !1
      }
      findRowSkip() {
        if (this.possibleCenters.length <= 1) return 0
        let s = null
        for (const a of this.possibleCenters)
          if (a.getCount() >= Pt.CENTER_QUORUM)
            if (s == null) s = a
            else
              return (
                (this.hasSkipped = !0),
                Math.floor((Math.abs(s.getX() - a.getX()) - Math.abs(s.getY() - a.getY())) / 2)
              )
        return 0
      }
      haveMultiplyConfirmedCenters() {
        let s = 0,
          a = 0
        const l = this.possibleCenters.length
        for (const g of this.possibleCenters)
          g.getCount() >= Pt.CENTER_QUORUM && (s++, (a += g.getEstimatedModuleSize()))
        if (s < 3) return !1
        const u = a / l
        let d = 0
        for (const g of this.possibleCenters) d += Math.abs(g.getEstimatedModuleSize() - u)
        return d <= 0.05 * a
      }
      selectBestPatterns() {
        const s = this.possibleCenters.length
        if (s < 3) throw new H()
        const a = this.possibleCenters
        let l
        if (s > 3) {
          let u = 0,
            d = 0
          for (const b of this.possibleCenters) {
            const v = b.getEstimatedModuleSize()
            ;((u += v), (d += v * v))
          }
          l = u / s
          let g = Math.sqrt(d / s - l * l)
          a.sort((b, v) => {
            const C = Math.abs(v.getEstimatedModuleSize() - l),
              T = Math.abs(b.getEstimatedModuleSize() - l)
            return C < T ? -1 : C > T ? 1 : 0
          })
          const m = Math.max(0.2 * l, g)
          for (let b = 0; b < a.length && a.length > 3; b++) {
            const v = a[b]
            Math.abs(v.getEstimatedModuleSize() - l) > m && (a.splice(b, 1), b--)
          }
        }
        if (a.length > 3) {
          let u = 0
          for (const d of a) u += d.getEstimatedModuleSize()
          ;((l = u / a.length),
            a.sort((d, g) => {
              if (g.getCount() === d.getCount()) {
                const m = Math.abs(g.getEstimatedModuleSize() - l),
                  b = Math.abs(d.getEstimatedModuleSize() - l)
                return m < b ? 1 : m > b ? -1 : 0
              } else return g.getCount() - d.getCount()
            }),
            a.splice(3))
        }
        return [a[0], a[1], a[2]]
      }
    }
    ;((Pt.CENTER_QUORUM = 2), (Pt.MIN_SKIP = 3), (Pt.MAX_MODULES = 57))
    class ra {
      constructor(s) {
        this.image = s
      }
      getImage() {
        return this.image
      }
      getResultPointCallback() {
        return this.resultPointCallback
      }
      detect(s) {
        this.resultPointCallback = s == null ? null : s.get(z.NEED_RESULT_POINT_CALLBACK)
        const a = new Pt(this.image, this.resultPointCallback).find(s)
        return this.processFinderPatternInfo(a)
      }
      processFinderPatternInfo(s) {
        const a = s.getTopLeft(),
          l = s.getTopRight(),
          u = s.getBottomLeft(),
          d = this.calculateModuleSize(a, l, u)
        if (d < 1) throw new H('No pattern found in proccess finder.')
        const g = ra.computeDimension(a, l, u, d),
          m = de.getProvisionalVersionForDimension(g),
          b = m.getDimensionForVersion() - 7
        let v = null
        if (m.getAlignmentPatternCenters().length > 0) {
          const B = l.getX() - a.getX() + u.getX(),
            j = l.getY() - a.getY() + u.getY(),
            W = 1 - 3 / b,
            Y = Math.floor(a.getX() + W * (B - a.getX())),
            q = Math.floor(a.getY() + W * (j - a.getY()))
          for (let ne = 4; ne <= 16; ne <<= 1)
            try {
              v = this.findAlignmentInRegion(d, Y, q, ne)
              break
            } catch (te) {
              if (!(te instanceof H)) throw te
            }
        }
        const C = ra.createTransform(a, l, u, v, g),
          T = ra.sampleGrid(this.image, C, g)
        let D
        return (v === null ? (D = [u, a, l]) : (D = [u, a, l, v]), new Xl(T, D))
      }
      static createTransform(s, a, l, u, d) {
        const g = d - 3.5
        let m, b, v, C
        return (
          u !== null
            ? ((m = u.getX()), (b = u.getY()), (v = g - 3), (C = v))
            : ((m = a.getX() - s.getX() + l.getX()),
              (b = a.getY() - s.getY() + l.getY()),
              (v = g),
              (C = g)),
          tr.quadrilateralToQuadrilateral(
            3.5,
            3.5,
            g,
            3.5,
            v,
            C,
            3.5,
            g,
            s.getX(),
            s.getY(),
            a.getX(),
            a.getY(),
            m,
            b,
            l.getX(),
            l.getY()
          )
        )
      }
      static sampleGrid(s, a, l) {
        return Jr.getInstance().sampleGridWithTransform(s, l, l, a)
      }
      static computeDimension(s, a, l, u) {
        const d = Pe.round(he.distance(s, a) / u),
          g = Pe.round(he.distance(s, l) / u)
        let m = Math.floor((d + g) / 2) + 7
        switch (m & 3) {
          case 0:
            m++
            break
          case 2:
            m--
            break
          case 3:
            throw new H('Dimensions could be not found.')
        }
        return m
      }
      calculateModuleSize(s, a, l) {
        return (this.calculateModuleSizeOneWay(s, a) + this.calculateModuleSizeOneWay(s, l)) / 2
      }
      calculateModuleSizeOneWay(s, a) {
        const l = this.sizeOfBlackWhiteBlackRunBothWays(
            Math.floor(s.getX()),
            Math.floor(s.getY()),
            Math.floor(a.getX()),
            Math.floor(a.getY())
          ),
          u = this.sizeOfBlackWhiteBlackRunBothWays(
            Math.floor(a.getX()),
            Math.floor(a.getY()),
            Math.floor(s.getX()),
            Math.floor(s.getY())
          )
        return isNaN(l) ? u / 7 : isNaN(u) ? l / 7 : (l + u) / 14
      }
      sizeOfBlackWhiteBlackRunBothWays(s, a, l, u) {
        let d = this.sizeOfBlackWhiteBlackRun(s, a, l, u),
          g = 1,
          m = s - (l - s)
        m < 0
          ? ((g = s / (s - m)), (m = 0))
          : m >= this.image.getWidth() &&
            ((g = (this.image.getWidth() - 1 - s) / (m - s)), (m = this.image.getWidth() - 1))
        let b = Math.floor(a - (u - a) * g)
        return (
          (g = 1),
          b < 0
            ? ((g = a / (a - b)), (b = 0))
            : b >= this.image.getHeight() &&
              ((g = (this.image.getHeight() - 1 - a) / (b - a)), (b = this.image.getHeight() - 1)),
          (m = Math.floor(s + (m - s) * g)),
          (d += this.sizeOfBlackWhiteBlackRun(s, a, m, b)),
          d - 1
        )
      }
      sizeOfBlackWhiteBlackRun(s, a, l, u) {
        const d = Math.abs(u - a) > Math.abs(l - s)
        if (d) {
          let B = s
          ;((s = a), (a = B), (B = l), (l = u), (u = B))
        }
        const g = Math.abs(l - s),
          m = Math.abs(u - a)
        let b = -g / 2
        const v = s < l ? 1 : -1,
          C = a < u ? 1 : -1
        let T = 0
        const D = l + v
        for (let B = s, j = a; B !== D; B += v) {
          const W = d ? j : B,
            Y = d ? B : j
          if ((T === 1) === this.image.get(W, Y)) {
            if (T === 2) return Pe.distance(B, j, s, a)
            T++
          }
          if (((b += m), b > 0)) {
            if (j === u) break
            ;((j += C), (b -= g))
          }
        }
        return T === 2 ? Pe.distance(l + v, u, s, a) : NaN
      }
      findAlignmentInRegion(s, a, l, u) {
        const d = Math.floor(u * s),
          g = Math.max(0, a - d),
          m = Math.min(this.image.getWidth() - 1, a + d)
        if (m - g < s * 3) throw new H('Alignment top exceeds estimated module size.')
        const b = Math.max(0, l - d),
          v = Math.min(this.image.getHeight() - 1, l + d)
        if (v - b < s * 3) throw new H('Alignment bottom exceeds estimated module size.')
        return new ql(this.image, g, b, m - g, v - b, s, this.resultPointCallback).find()
      }
    }
    class ri {
      constructor() {
        this.decoder = new yb()
      }
      getDecoder() {
        return this.decoder
      }
      decode(s, a) {
        let l, u
        if (a != null && a.get(z.PURE_BARCODE) !== void 0) {
          const b = ri.extractPureBits(s.getBlackMatrix())
          ;((l = this.decoder.decodeBitMatrix(b, a)), (u = ri.NO_POINTS))
        } else {
          const b = new ra(s.getBlackMatrix()).detect(a)
          ;((l = this.decoder.decodeBitMatrix(b.getBits(), a)), (u = b.getPoints()))
        }
        l.getOther() instanceof Ap && l.getOther().applyMirroredCorrection(u)
        const d = new Be(l.getText(), l.getRawBytes(), void 0, u, ue.QR_CODE, void 0),
          g = l.getByteSegments()
        g !== null && d.putMetadata(Rt.BYTE_SEGMENTS, g)
        const m = l.getECLevel()
        return (
          m !== null && d.putMetadata(Rt.ERROR_CORRECTION_LEVEL, m),
          l.hasStructuredAppend() &&
            (d.putMetadata(Rt.STRUCTURED_APPEND_SEQUENCE, l.getStructuredAppendSequenceNumber()),
            d.putMetadata(Rt.STRUCTURED_APPEND_PARITY, l.getStructuredAppendParity())),
          d
        )
      }
      reset() {}
      static extractPureBits(s) {
        const a = s.getTopLeftOnBit(),
          l = s.getBottomRightOnBit()
        if (a === null || l === null) throw new H()
        const u = this.moduleSize(a, s)
        let d = a[1],
          g = l[1],
          m = a[0],
          b = l[0]
        if (m >= b || d >= g) throw new H()
        if (g - d !== b - m && ((b = m + (g - d)), b >= s.getWidth())) throw new H()
        const v = Math.round((b - m + 1) / u),
          C = Math.round((g - d + 1) / u)
        if (v <= 0 || C <= 0) throw new H()
        if (C !== v) throw new H()
        const T = Math.floor(u / 2)
        ;((d += T), (m += T))
        const D = m + Math.floor((v - 1) * u) - b
        if (D > 0) {
          if (D > T) throw new H()
          m -= D
        }
        const B = d + Math.floor((C - 1) * u) - g
        if (B > 0) {
          if (B > T) throw new H()
          d -= B
        }
        const j = new Ie(v, C)
        for (let W = 0; W < C; W++) {
          const Y = d + Math.floor(W * u)
          for (let q = 0; q < v; q++) s.get(m + Math.floor(q * u), Y) && j.set(q, W)
        }
        return j
      }
      static moduleSize(s, a) {
        const l = a.getHeight(),
          u = a.getWidth()
        let d = s[0],
          g = s[1],
          m = !0,
          b = 0
        for (; d < u && g < l; ) {
          if (m !== a.get(d, g)) {
            if (++b === 5) break
            m = !m
          }
          ;(d++, g++)
        }
        if (d === u || g === l) throw new H()
        return (d - s[0]) / 7
      }
    }
    ri.NO_POINTS = new Array()
    class Ee {
      PDF417Common() {}
      static getBitCountSum(s) {
        return Pe.sum(s)
      }
      static toIntArray(s) {
        if (s == null || !s.length) return Ee.EMPTY_INT_ARRAY
        const a = new Int32Array(s.length)
        let l = 0
        for (const u of s) a[l++] = u
        return a
      }
      static getCodeword(s) {
        const a = R.binarySearch(Ee.SYMBOL_TABLE, s & 262143)
        return a < 0 ? -1 : (Ee.CODEWORD_TABLE[a] - 1) % Ee.NUMBER_OF_CODEWORDS
      }
    }
    ;((Ee.NUMBER_OF_CODEWORDS = 929),
      (Ee.MAX_CODEWORDS_IN_BARCODE = Ee.NUMBER_OF_CODEWORDS - 1),
      (Ee.MIN_ROWS_IN_BARCODE = 3),
      (Ee.MAX_ROWS_IN_BARCODE = 90),
      (Ee.MODULES_IN_CODEWORD = 17),
      (Ee.MODULES_IN_STOP_PATTERN = 18),
      (Ee.BARS_IN_MODULE = 8),
      (Ee.EMPTY_INT_ARRAY = new Int32Array([])),
      (Ee.SYMBOL_TABLE = Int32Array.from([
        66142, 66170, 66206, 66236, 66290, 66292, 66350, 66382, 66396, 66454, 66470, 66476, 66594,
        66600, 66614, 66626, 66628, 66632, 66640, 66654, 66662, 66668, 66682, 66690, 66718, 66720,
        66748, 66758, 66776, 66798, 66802, 66804, 66820, 66824, 66832, 66846, 66848, 66876, 66880,
        66936, 66950, 66956, 66968, 66992, 67006, 67022, 67036, 67042, 67044, 67048, 67062, 67118,
        67150, 67164, 67214, 67228, 67256, 67294, 67322, 67350, 67366, 67372, 67398, 67404, 67416,
        67438, 67474, 67476, 67490, 67492, 67496, 67510, 67618, 67624, 67650, 67656, 67664, 67678,
        67686, 67692, 67706, 67714, 67716, 67728, 67742, 67744, 67772, 67782, 67788, 67800, 67822,
        67826, 67828, 67842, 67848, 67870, 67872, 67900, 67904, 67960, 67974, 67992, 68016, 68030,
        68046, 68060, 68066, 68068, 68072, 68086, 68104, 68112, 68126, 68128, 68156, 68160, 68216,
        68336, 68358, 68364, 68376, 68400, 68414, 68448, 68476, 68494, 68508, 68536, 68546, 68548,
        68552, 68560, 68574, 68582, 68588, 68654, 68686, 68700, 68706, 68708, 68712, 68726, 68750,
        68764, 68792, 68802, 68804, 68808, 68816, 68830, 68838, 68844, 68858, 68878, 68892, 68920,
        68976, 68990, 68994, 68996, 69e3, 69008, 69022, 69024, 69052, 69062, 69068, 69080, 69102,
        69106, 69108, 69142, 69158, 69164, 69190, 69208, 69230, 69254, 69260, 69272, 69296, 69310,
        69326, 69340, 69386, 69394, 69396, 69410, 69416, 69430, 69442, 69444, 69448, 69456, 69470,
        69478, 69484, 69554, 69556, 69666, 69672, 69698, 69704, 69712, 69726, 69754, 69762, 69764,
        69776, 69790, 69792, 69820, 69830, 69836, 69848, 69870, 69874, 69876, 69890, 69918, 69920,
        69948, 69952, 70008, 70022, 70040, 70064, 70078, 70094, 70108, 70114, 70116, 70120, 70134,
        70152, 70174, 70176, 70264, 70384, 70412, 70448, 70462, 70496, 70524, 70542, 70556, 70584,
        70594, 70600, 70608, 70622, 70630, 70636, 70664, 70672, 70686, 70688, 70716, 70720, 70776,
        70896, 71136, 71180, 71192, 71216, 71230, 71264, 71292, 71360, 71416, 71452, 71480, 71536,
        71550, 71554, 71556, 71560, 71568, 71582, 71584, 71612, 71622, 71628, 71640, 71662, 71726,
        71732, 71758, 71772, 71778, 71780, 71784, 71798, 71822, 71836, 71864, 71874, 71880, 71888,
        71902, 71910, 71916, 71930, 71950, 71964, 71992, 72048, 72062, 72066, 72068, 72080, 72094,
        72096, 72124, 72134, 72140, 72152, 72174, 72178, 72180, 72206, 72220, 72248, 72304, 72318,
        72416, 72444, 72456, 72464, 72478, 72480, 72508, 72512, 72568, 72588, 72600, 72624, 72638,
        72654, 72668, 72674, 72676, 72680, 72694, 72726, 72742, 72748, 72774, 72780, 72792, 72814,
        72838, 72856, 72880, 72894, 72910, 72924, 72930, 72932, 72936, 72950, 72966, 72972, 72984,
        73008, 73022, 73056, 73084, 73102, 73116, 73144, 73156, 73160, 73168, 73182, 73190, 73196,
        73210, 73226, 73234, 73236, 73250, 73252, 73256, 73270, 73282, 73284, 73296, 73310, 73318,
        73324, 73346, 73348, 73352, 73360, 73374, 73376, 73404, 73414, 73420, 73432, 73454, 73498,
        73518, 73522, 73524, 73550, 73564, 73570, 73572, 73576, 73590, 73800, 73822, 73858, 73860,
        73872, 73886, 73888, 73916, 73944, 73970, 73972, 73992, 74014, 74016, 74044, 74048, 74104,
        74118, 74136, 74160, 74174, 74210, 74212, 74216, 74230, 74244, 74256, 74270, 74272, 74360,
        74480, 74502, 74508, 74544, 74558, 74592, 74620, 74638, 74652, 74680, 74690, 74696, 74704,
        74726, 74732, 74782, 74784, 74812, 74992, 75232, 75288, 75326, 75360, 75388, 75456, 75512,
        75576, 75632, 75646, 75650, 75652, 75664, 75678, 75680, 75708, 75718, 75724, 75736, 75758,
        75808, 75836, 75840, 75896, 76016, 76256, 76736, 76824, 76848, 76862, 76896, 76924, 76992,
        77048, 77296, 77340, 77368, 77424, 77438, 77536, 77564, 77572, 77576, 77584, 77600, 77628,
        77632, 77688, 77702, 77708, 77720, 77744, 77758, 77774, 77788, 77870, 77902, 77916, 77922,
        77928, 77966, 77980, 78008, 78018, 78024, 78032, 78046, 78060, 78074, 78094, 78136, 78192,
        78206, 78210, 78212, 78224, 78238, 78240, 78268, 78278, 78284, 78296, 78322, 78324, 78350,
        78364, 78448, 78462, 78560, 78588, 78600, 78622, 78624, 78652, 78656, 78712, 78726, 78744,
        78768, 78782, 78798, 78812, 78818, 78820, 78824, 78838, 78862, 78876, 78904, 78960, 78974,
        79072, 79100, 79296, 79352, 79368, 79376, 79390, 79392, 79420, 79424, 79480, 79600, 79628,
        79640, 79664, 79678, 79712, 79740, 79772, 79800, 79810, 79812, 79816, 79824, 79838, 79846,
        79852, 79894, 79910, 79916, 79942, 79948, 79960, 79982, 79988, 80006, 80024, 80048, 80062,
        80078, 80092, 80098, 80100, 80104, 80134, 80140, 80176, 80190, 80224, 80252, 80270, 80284,
        80312, 80328, 80336, 80350, 80358, 80364, 80378, 80390, 80396, 80408, 80432, 80446, 80480,
        80508, 80576, 80632, 80654, 80668, 80696, 80752, 80766, 80776, 80784, 80798, 80800, 80828,
        80844, 80856, 80878, 80882, 80884, 80914, 80916, 80930, 80932, 80936, 80950, 80962, 80968,
        80976, 80990, 80998, 81004, 81026, 81028, 81040, 81054, 81056, 81084, 81094, 81100, 81112,
        81134, 81154, 81156, 81160, 81168, 81182, 81184, 81212, 81216, 81272, 81286, 81292, 81304,
        81328, 81342, 81358, 81372, 81380, 81384, 81398, 81434, 81454, 81458, 81460, 81486, 81500,
        81506, 81508, 81512, 81526, 81550, 81564, 81592, 81602, 81604, 81608, 81616, 81630, 81638,
        81644, 81702, 81708, 81722, 81734, 81740, 81752, 81774, 81778, 81780, 82050, 82078, 82080,
        82108, 82180, 82184, 82192, 82206, 82208, 82236, 82240, 82296, 82316, 82328, 82352, 82366,
        82402, 82404, 82408, 82440, 82448, 82462, 82464, 82492, 82496, 82552, 82672, 82694, 82700,
        82712, 82736, 82750, 82784, 82812, 82830, 82882, 82884, 82888, 82896, 82918, 82924, 82952,
        82960, 82974, 82976, 83004, 83008, 83064, 83184, 83424, 83468, 83480, 83504, 83518, 83552,
        83580, 83648, 83704, 83740, 83768, 83824, 83838, 83842, 83844, 83848, 83856, 83872, 83900,
        83910, 83916, 83928, 83950, 83984, 84e3, 84028, 84032, 84088, 84208, 84448, 84928, 85040,
        85054, 85088, 85116, 85184, 85240, 85488, 85560, 85616, 85630, 85728, 85756, 85764, 85768,
        85776, 85790, 85792, 85820, 85824, 85880, 85894, 85900, 85912, 85936, 85966, 85980, 86048,
        86080, 86136, 86256, 86496, 86976, 88160, 88188, 88256, 88312, 88560, 89056, 89200, 89214,
        89312, 89340, 89536, 89592, 89608, 89616, 89632, 89664, 89720, 89840, 89868, 89880, 89904,
        89952, 89980, 89998, 90012, 90040, 90190, 90204, 90254, 90268, 90296, 90306, 90308, 90312,
        90334, 90382, 90396, 90424, 90480, 90494, 90500, 90504, 90512, 90526, 90528, 90556, 90566,
        90572, 90584, 90610, 90612, 90638, 90652, 90680, 90736, 90750, 90848, 90876, 90884, 90888,
        90896, 90910, 90912, 90940, 90944, 91e3, 91014, 91020, 91032, 91056, 91070, 91086, 91100,
        91106, 91108, 91112, 91126, 91150, 91164, 91192, 91248, 91262, 91360, 91388, 91584, 91640,
        91664, 91678, 91680, 91708, 91712, 91768, 91888, 91928, 91952, 91966, 92e3, 92028, 92046,
        92060, 92088, 92098, 92100, 92104, 92112, 92126, 92134, 92140, 92188, 92216, 92272, 92384,
        92412, 92608, 92664, 93168, 93200, 93214, 93216, 93244, 93248, 93304, 93424, 93664, 93720,
        93744, 93758, 93792, 93820, 93888, 93944, 93980, 94008, 94064, 94078, 94084, 94088, 94096,
        94110, 94112, 94140, 94150, 94156, 94168, 94246, 94252, 94278, 94284, 94296, 94318, 94342,
        94348, 94360, 94384, 94398, 94414, 94428, 94440, 94470, 94476, 94488, 94512, 94526, 94560,
        94588, 94606, 94620, 94648, 94658, 94660, 94664, 94672, 94686, 94694, 94700, 94714, 94726,
        94732, 94744, 94768, 94782, 94816, 94844, 94912, 94968, 94990, 95004, 95032, 95088, 95102,
        95112, 95120, 95134, 95136, 95164, 95180, 95192, 95214, 95218, 95220, 95244, 95256, 95280,
        95294, 95328, 95356, 95424, 95480, 95728, 95758, 95772, 95800, 95856, 95870, 95968, 95996,
        96008, 96016, 96030, 96032, 96060, 96064, 96120, 96152, 96176, 96190, 96220, 96226, 96228,
        96232, 96290, 96292, 96296, 96310, 96322, 96324, 96328, 96336, 96350, 96358, 96364, 96386,
        96388, 96392, 96400, 96414, 96416, 96444, 96454, 96460, 96472, 96494, 96498, 96500, 96514,
        96516, 96520, 96528, 96542, 96544, 96572, 96576, 96632, 96646, 96652, 96664, 96688, 96702,
        96718, 96732, 96738, 96740, 96744, 96758, 96772, 96776, 96784, 96798, 96800, 96828, 96832,
        96888, 97008, 97030, 97036, 97048, 97072, 97086, 97120, 97148, 97166, 97180, 97208, 97220,
        97224, 97232, 97246, 97254, 97260, 97326, 97330, 97332, 97358, 97372, 97378, 97380, 97384,
        97398, 97422, 97436, 97464, 97474, 97476, 97480, 97488, 97502, 97510, 97516, 97550, 97564,
        97592, 97648, 97666, 97668, 97672, 97680, 97694, 97696, 97724, 97734, 97740, 97752, 97774,
        97830, 97836, 97850, 97862, 97868, 97880, 97902, 97906, 97908, 97926, 97932, 97944, 97968,
        97998, 98012, 98018, 98020, 98024, 98038, 98618, 98674, 98676, 98838, 98854, 98874, 98892,
        98904, 98926, 98930, 98932, 98968, 99006, 99042, 99044, 99048, 99062, 99166, 99194, 99246,
        99286, 99350, 99366, 99372, 99386, 99398, 99416, 99438, 99442, 99444, 99462, 99504, 99518,
        99534, 99548, 99554, 99556, 99560, 99574, 99590, 99596, 99608, 99632, 99646, 99680, 99708,
        99726, 99740, 99768, 99778, 99780, 99784, 99792, 99806, 99814, 99820, 99834, 99858, 99860,
        99874, 99880, 99894, 99906, 99920, 99934, 99962, 99970, 99972, 99976, 99984, 99998, 1e5,
        100028, 100038, 100044, 100056, 100078, 100082, 100084, 100142, 100174, 100188, 100246,
        100262, 100268, 100306, 100308, 100390, 100396, 100410, 100422, 100428, 100440, 100462,
        100466, 100468, 100486, 100504, 100528, 100542, 100558, 100572, 100578, 100580, 100584,
        100598, 100620, 100656, 100670, 100704, 100732, 100750, 100792, 100802, 100808, 100816,
        100830, 100838, 100844, 100858, 100888, 100912, 100926, 100960, 100988, 101056, 101112,
        101148, 101176, 101232, 101246, 101250, 101252, 101256, 101264, 101278, 101280, 101308,
        101318, 101324, 101336, 101358, 101362, 101364, 101410, 101412, 101416, 101430, 101442,
        101448, 101456, 101470, 101478, 101498, 101506, 101508, 101520, 101534, 101536, 101564,
        101580, 101618, 101620, 101636, 101640, 101648, 101662, 101664, 101692, 101696, 101752,
        101766, 101784, 101838, 101858, 101860, 101864, 101934, 101938, 101940, 101966, 101980,
        101986, 101988, 101992, 102030, 102044, 102072, 102082, 102084, 102088, 102096, 102138,
        102166, 102182, 102188, 102214, 102220, 102232, 102254, 102282, 102290, 102292, 102306,
        102308, 102312, 102326, 102444, 102458, 102470, 102476, 102488, 102514, 102516, 102534,
        102552, 102576, 102590, 102606, 102620, 102626, 102632, 102646, 102662, 102668, 102704,
        102718, 102752, 102780, 102798, 102812, 102840, 102850, 102856, 102864, 102878, 102886,
        102892, 102906, 102936, 102974, 103008, 103036, 103104, 103160, 103224, 103280, 103294,
        103298, 103300, 103312, 103326, 103328, 103356, 103366, 103372, 103384, 103406, 103410,
        103412, 103472, 103486, 103520, 103548, 103616, 103672, 103920, 103992, 104048, 104062,
        104160, 104188, 104194, 104196, 104200, 104208, 104224, 104252, 104256, 104312, 104326,
        104332, 104344, 104368, 104382, 104398, 104412, 104418, 104420, 104424, 104482, 104484,
        104514, 104520, 104528, 104542, 104550, 104570, 104578, 104580, 104592, 104606, 104608,
        104636, 104652, 104690, 104692, 104706, 104712, 104734, 104736, 104764, 104768, 104824,
        104838, 104856, 104910, 104930, 104932, 104936, 104968, 104976, 104990, 104992, 105020,
        105024, 105080, 105200, 105240, 105278, 105312, 105372, 105410, 105412, 105416, 105424,
        105446, 105518, 105524, 105550, 105564, 105570, 105572, 105576, 105614, 105628, 105656,
        105666, 105672, 105680, 105702, 105722, 105742, 105756, 105784, 105840, 105854, 105858,
        105860, 105864, 105872, 105888, 105932, 105970, 105972, 106006, 106022, 106028, 106054,
        106060, 106072, 106100, 106118, 106124, 106136, 106160, 106174, 106190, 106210, 106212,
        106216, 106250, 106258, 106260, 106274, 106276, 106280, 106306, 106308, 106312, 106320,
        106334, 106348, 106394, 106414, 106418, 106420, 106566, 106572, 106610, 106612, 106630,
        106636, 106648, 106672, 106686, 106722, 106724, 106728, 106742, 106758, 106764, 106776,
        106800, 106814, 106848, 106876, 106894, 106908, 106936, 106946, 106948, 106952, 106960,
        106974, 106982, 106988, 107032, 107056, 107070, 107104, 107132, 107200, 107256, 107292,
        107320, 107376, 107390, 107394, 107396, 107400, 107408, 107422, 107424, 107452, 107462,
        107468, 107480, 107502, 107506, 107508, 107544, 107568, 107582, 107616, 107644, 107712,
        107768, 108016, 108060, 108088, 108144, 108158, 108256, 108284, 108290, 108292, 108296,
        108304, 108318, 108320, 108348, 108352, 108408, 108422, 108428, 108440, 108464, 108478,
        108494, 108508, 108514, 108516, 108520, 108592, 108640, 108668, 108736, 108792, 109040,
        109536, 109680, 109694, 109792, 109820, 110016, 110072, 110084, 110088, 110096, 110112,
        110140, 110144, 110200, 110320, 110342, 110348, 110360, 110384, 110398, 110432, 110460,
        110478, 110492, 110520, 110532, 110536, 110544, 110558, 110658, 110686, 110714, 110722,
        110724, 110728, 110736, 110750, 110752, 110780, 110796, 110834, 110836, 110850, 110852,
        110856, 110864, 110878, 110880, 110908, 110912, 110968, 110982, 111e3, 111054, 111074,
        111076, 111080, 111108, 111112, 111120, 111134, 111136, 111164, 111168, 111224, 111344,
        111372, 111422, 111456, 111516, 111554, 111556, 111560, 111568, 111590, 111632, 111646,
        111648, 111676, 111680, 111736, 111856, 112096, 112152, 112224, 112252, 112320, 112440,
        112514, 112516, 112520, 112528, 112542, 112544, 112588, 112686, 112718, 112732, 112782,
        112796, 112824, 112834, 112836, 112840, 112848, 112870, 112890, 112910, 112924, 112952,
        113008, 113022, 113026, 113028, 113032, 113040, 113054, 113056, 113100, 113138, 113140,
        113166, 113180, 113208, 113264, 113278, 113376, 113404, 113416, 113424, 113440, 113468,
        113472, 113560, 113614, 113634, 113636, 113640, 113686, 113702, 113708, 113734, 113740,
        113752, 113778, 113780, 113798, 113804, 113816, 113840, 113854, 113870, 113890, 113892,
        113896, 113926, 113932, 113944, 113968, 113982, 114016, 114044, 114076, 114114, 114116,
        114120, 114128, 114150, 114170, 114194, 114196, 114210, 114212, 114216, 114242, 114244,
        114248, 114256, 114270, 114278, 114306, 114308, 114312, 114320, 114334, 114336, 114364,
        114380, 114420, 114458, 114478, 114482, 114484, 114510, 114524, 114530, 114532, 114536,
        114842, 114866, 114868, 114970, 114994, 114996, 115042, 115044, 115048, 115062, 115130,
        115226, 115250, 115252, 115278, 115292, 115298, 115300, 115304, 115318, 115342, 115394,
        115396, 115400, 115408, 115422, 115430, 115436, 115450, 115478, 115494, 115514, 115526,
        115532, 115570, 115572, 115738, 115758, 115762, 115764, 115790, 115804, 115810, 115812,
        115816, 115830, 115854, 115868, 115896, 115906, 115912, 115920, 115934, 115942, 115948,
        115962, 115996, 116024, 116080, 116094, 116098, 116100, 116104, 116112, 116126, 116128,
        116156, 116166, 116172, 116184, 116206, 116210, 116212, 116246, 116262, 116268, 116282,
        116294, 116300, 116312, 116334, 116338, 116340, 116358, 116364, 116376, 116400, 116414,
        116430, 116444, 116450, 116452, 116456, 116498, 116500, 116514, 116520, 116534, 116546,
        116548, 116552, 116560, 116574, 116582, 116588, 116602, 116654, 116694, 116714, 116762,
        116782, 116786, 116788, 116814, 116828, 116834, 116836, 116840, 116854, 116878, 116892,
        116920, 116930, 116936, 116944, 116958, 116966, 116972, 116986, 117006, 117048, 117104,
        117118, 117122, 117124, 117136, 117150, 117152, 117180, 117190, 117196, 117208, 117230,
        117234, 117236, 117304, 117360, 117374, 117472, 117500, 117506, 117508, 117512, 117520,
        117536, 117564, 117568, 117624, 117638, 117644, 117656, 117680, 117694, 117710, 117724,
        117730, 117732, 117736, 117750, 117782, 117798, 117804, 117818, 117830, 117848, 117874,
        117876, 117894, 117936, 117950, 117966, 117986, 117988, 117992, 118022, 118028, 118040,
        118064, 118078, 118112, 118140, 118172, 118210, 118212, 118216, 118224, 118238, 118246,
        118266, 118306, 118312, 118338, 118352, 118366, 118374, 118394, 118402, 118404, 118408,
        118416, 118430, 118432, 118460, 118476, 118514, 118516, 118574, 118578, 118580, 118606,
        118620, 118626, 118628, 118632, 118678, 118694, 118700, 118730, 118738, 118740, 118830,
        118834, 118836, 118862, 118876, 118882, 118884, 118888, 118902, 118926, 118940, 118968,
        118978, 118980, 118984, 118992, 119006, 119014, 119020, 119034, 119068, 119096, 119152,
        119166, 119170, 119172, 119176, 119184, 119198, 119200, 119228, 119238, 119244, 119256,
        119278, 119282, 119284, 119324, 119352, 119408, 119422, 119520, 119548, 119554, 119556,
        119560, 119568, 119582, 119584, 119612, 119616, 119672, 119686, 119692, 119704, 119728,
        119742, 119758, 119772, 119778, 119780, 119784, 119798, 119920, 119934, 120032, 120060,
        120256, 120312, 120324, 120328, 120336, 120352, 120384, 120440, 120560, 120582, 120588,
        120600, 120624, 120638, 120672, 120700, 120718, 120732, 120760, 120770, 120772, 120776,
        120784, 120798, 120806, 120812, 120870, 120876, 120890, 120902, 120908, 120920, 120946,
        120948, 120966, 120972, 120984, 121008, 121022, 121038, 121058, 121060, 121064, 121078,
        121100, 121112, 121136, 121150, 121184, 121212, 121244, 121282, 121284, 121288, 121296,
        121318, 121338, 121356, 121368, 121392, 121406, 121440, 121468, 121536, 121592, 121656,
        121730, 121732, 121736, 121744, 121758, 121760, 121804, 121842, 121844, 121890, 121922,
        121924, 121928, 121936, 121950, 121958, 121978, 121986, 121988, 121992, 122e3, 122014,
        122016, 122044, 122060, 122098, 122100, 122116, 122120, 122128, 122142, 122144, 122172,
        122176, 122232, 122246, 122264, 122318, 122338, 122340, 122344, 122414, 122418, 122420,
        122446, 122460, 122466, 122468, 122472, 122510, 122524, 122552, 122562, 122564, 122568,
        122576, 122598, 122618, 122646, 122662, 122668, 122694, 122700, 122712, 122738, 122740,
        122762, 122770, 122772, 122786, 122788, 122792, 123018, 123026, 123028, 123042, 123044,
        123048, 123062, 123098, 123146, 123154, 123156, 123170, 123172, 123176, 123190, 123202,
        123204, 123208, 123216, 123238, 123244, 123258, 123290, 123314, 123316, 123402, 123410,
        123412, 123426, 123428, 123432, 123446, 123458, 123464, 123472, 123486, 123494, 123500,
        123514, 123522, 123524, 123528, 123536, 123552, 123580, 123590, 123596, 123608, 123630,
        123634, 123636, 123674, 123698, 123700, 123740, 123746, 123748, 123752, 123834, 123914,
        123922, 123924, 123938, 123944, 123958, 123970, 123976, 123984, 123998, 124006, 124012,
      (Et.CODEWORD_TABLE = Int32Array.from([
        124146, 124148, 124162, 124164, 124168, 124176, 124190, 124192, 124220, 124224, 124280,
        124294, 124300, 124312, 124336, 124350, 124366, 124380, 124386, 124388, 124392, 124406,
        124442, 124462, 124466, 124468, 124494, 124508, 124514, 124520, 124558, 124572, 124600,
        124610, 124612, 124616, 124624, 124646, 124666, 124694, 124710, 124716, 124730, 124742,
        124748, 124760, 124786, 124788, 124818, 124820, 124834, 124836, 124840, 124854, 124946,
        124948, 124962, 124964, 124968, 124982, 124994, 124996, 125e3, 125008, 125022, 125030,
        125036, 125050, 125058, 125060, 125064, 125072, 125086, 125088, 125116, 125126, 125132,
        125144, 125166, 125170, 125172, 125186, 125188, 125192, 125200, 125216, 125244, 125248,
        125304, 125318, 125324, 125336, 125360, 125374, 125390, 125404, 125410, 125412, 125416,
        125430, 125444, 125448, 125456, 125472, 125504, 125560, 125680, 125702, 125708, 125720,
        125744, 125758, 125792, 125820, 125838, 125852, 125880, 125890, 125892, 125896, 125904,
        125918, 125926, 125932, 125978, 125998, 126002, 126004, 126030, 126044, 126050, 126052,
        126056, 126094, 126108, 126136, 126146, 126148, 126152, 126160, 126182, 126202, 126222,
        126236, 126264, 126320, 126334, 126338, 126340, 126344, 126352, 126366, 126368, 126412,
        126450, 126452, 126486, 126502, 126508, 126522, 126534, 126540, 126552, 126574, 126578,
        126580, 126598, 126604, 126616, 126640, 126654, 126670, 126684, 126690, 126692, 126696,
        126738, 126754, 126756, 126760, 126774, 126786, 126788, 126792, 126800, 126814, 126822,
        126828, 126842, 126894, 126898, 126900, 126934, 127126, 127142, 127148, 127162, 127178,
        127186, 127188, 127254, 127270, 127276, 127290, 127302, 127308, 127320, 127342, 127346,
        127348, 127370, 127378, 127380, 127394, 127396, 127400, 127450, 127510, 127526, 127532,
        127546, 127558, 127576, 127598, 127602, 127604, 127622, 127628, 127640, 127664, 127678,
        127694, 127708, 127714, 127716, 127720, 127734, 127754, 127762, 127764, 127778, 127784,
        127810, 127812, 127816, 127824, 127838, 127846, 127866, 127898, 127918, 127922, 127924,
        128022, 128038, 128044, 128058, 128070, 128076, 128088, 128110, 128114, 128116, 128134,
        128140, 128152, 128176, 128190, 128206, 128220, 128226, 128228, 128232, 128246, 128262,
        128268, 128280, 128304, 128318, 128352, 128380, 128398, 128412, 128440, 128450, 128452,
        128456, 128464, 128478, 128486, 128492, 128506, 128522, 128530, 128532, 128546, 128548,
        128552, 128566, 128578, 128580, 128584, 128592, 128606, 128614, 128634, 128642, 128644,
        128648, 128656, 128670, 128672, 128700, 128716, 128754, 128756, 128794, 128814, 128818,
        128820, 128846, 128860, 128866, 128868, 128872, 128886, 128918, 128934, 128940, 128954,
        128978, 128980, 129178, 129198, 129202, 129204, 129238, 129258, 129306, 129326, 129330,
        129332, 129358, 129372, 129378, 129380, 129384, 129398, 129430, 129446, 129452, 129466,
        129482, 129490, 129492, 129562, 129582, 129586, 129588, 129614, 129628, 129634, 129636,
        129640, 129654, 129678, 129692, 129720, 129730, 129732, 129736, 129744, 129758, 129766,
        129772, 129814, 129830, 129836, 129850, 129862, 129868, 129880, 129902, 129906, 129908,
        129930, 129938, 129940, 129954, 129956, 129960, 129974, 130010,
      ])),
      (Ee.CODEWORD_TABLE = Int32Array.from([
        2627, 1819, 2622, 2621, 1813, 1812, 2729, 2724, 2723, 2779, 2774, 2773, 902, 896, 908, 868,
        865, 861, 859, 2511, 873, 871, 1780, 835, 2493, 825, 2491, 842, 837, 844, 1764, 1762, 811,
        810, 809, 2483, 807, 2482, 806, 2480, 815, 814, 813, 812, 2484, 817, 816, 1745, 1744, 1742,
        1746, 2655, 2637, 2635, 2626, 2625, 2623, 2628, 1820, 2752, 2739, 2737, 2728, 2727, 2725,
        2730, 2785, 2783, 2778, 2777, 2775, 2780, 787, 781, 747, 739, 736, 2413, 754, 752, 1719,
        692, 689, 681, 2371, 678, 2369, 700, 697, 694, 703, 1688, 1686, 642, 638, 2343, 631, 2341,
        627, 2338, 651, 646, 643, 2345, 654, 652, 1652, 1650, 1647, 1654, 601, 599, 2322, 596, 2321,
        594, 2319, 2317, 611, 610, 608, 606, 2324, 603, 2323, 615, 614, 612, 1617, 1616, 1614, 1612,
        616, 1619, 1618, 2575, 2538, 2536, 905, 901, 898, 909, 2509, 2507, 2504, 870, 867, 864, 860,
        2512, 875, 872, 1781, 2490, 2489, 2487, 2485, 1748, 836, 834, 832, 830, 2494, 827, 2492,
        843, 841, 839, 845, 1765, 1763, 2701, 2676, 2674, 2653, 2648, 2656, 2634, 2633, 2631, 2629,
        1821, 2638, 2636, 2770, 2763, 2761, 2750, 2745, 2753, 2736, 2735, 2733, 2731, 1848, 2740,
        2738, 2786, 2784, 591, 588, 576, 569, 566, 2296, 1590, 537, 534, 526, 2276, 522, 2274, 545,
        542, 539, 548, 1572, 1570, 481, 2245, 466, 2242, 462, 2239, 492, 485, 482, 2249, 496, 494,
        1534, 1531, 1528, 1538, 413, 2196, 406, 2191, 2188, 425, 419, 2202, 415, 2199, 432, 430,
        427, 1472, 1467, 1464, 433, 1476, 1474, 368, 367, 2160, 365, 2159, 362, 2157, 2155, 2152,
        378, 377, 375, 2166, 372, 2165, 369, 2162, 383, 381, 379, 2168, 1419, 1418, 1416, 1414, 385,
        1411, 384, 1423, 1422, 1420, 1424, 2461, 802, 2441, 2439, 790, 786, 783, 794, 2409, 2406,
        2403, 750, 742, 738, 2414, 756, 753, 1720, 2367, 2365, 2362, 2359, 1663, 693, 691, 684,
        2373, 680, 2370, 702, 699, 696, 704, 1690, 1687, 2337, 2336, 2334, 2332, 1624, 2329, 1622,
        640, 637, 2344, 634, 2342, 630, 2340, 650, 648, 645, 2346, 655, 653, 1653, 1651, 1649, 1655,
        2612, 2597, 2595, 2571, 2568, 2565, 2576, 2534, 2529, 2526, 1787, 2540, 2537, 907, 904, 900,
        910, 2503, 2502, 2500, 2498, 1768, 2495, 1767, 2510, 2508, 2506, 869, 866, 863, 2513, 876,
        874, 1782, 2720, 2713, 2711, 2697, 2694, 2691, 2702, 2672, 2670, 2664, 1828, 2678, 2675,
        2647, 2646, 2644, 2642, 1823, 2639, 1822, 2654, 2652, 2650, 2657, 2771, 1855, 2765, 2762,
        1850, 1849, 2751, 2749, 2747, 2754, 353, 2148, 344, 342, 336, 2142, 332, 2140, 345, 1375,
        1373, 306, 2130, 299, 2128, 295, 2125, 319, 314, 311, 2132, 1354, 1352, 1349, 1356, 262,
        257, 2101, 253, 2096, 2093, 274, 273, 267, 2107, 263, 2104, 280, 278, 275, 1316, 1311, 1308,
        1320, 1318, 2052, 202, 2050, 2044, 2040, 219, 2063, 212, 2060, 208, 2055, 224, 221, 2066,
        1260, 1258, 1252, 231, 1248, 229, 1266, 1264, 1261, 1268, 155, 1998, 153, 1996, 1994, 1991,
        1988, 165, 164, 2007, 162, 2006, 159, 2003, 2e3, 172, 171, 169, 2012, 166, 2010, 1186, 1184,
        1182, 1179, 175, 1176, 173, 1192, 1191, 1189, 1187, 176, 1194, 1193, 2313, 2307, 2305, 592,
        589, 2294, 2292, 2289, 578, 572, 568, 2297, 580, 1591, 2272, 2267, 2264, 1547, 538, 536,
        529, 2278, 525, 2275, 547, 544, 541, 1574, 1571, 2237, 2235, 2229, 1493, 2225, 1489, 478,
        2247, 470, 2244, 465, 2241, 493, 488, 484, 2250, 498, 495, 1536, 1533, 1530, 1539, 2187,
        2186, 2184, 2182, 1432, 2179, 1430, 2176, 1427, 414, 412, 2197, 409, 2195, 405, 2193, 2190,
        426, 424, 421, 2203, 418, 2201, 431, 429, 1473, 1471, 1469, 1466, 434, 1477, 1475, 2478,
        2472, 2470, 2459, 2457, 2454, 2462, 803, 2437, 2432, 2429, 1726, 2443, 2440, 792, 789, 785,
        2401, 2399, 2393, 1702, 2389, 1699, 2411, 2408, 2405, 745, 741, 2415, 758, 755, 1721, 2358,
        2357, 2355, 2353, 1661, 2350, 1660, 2347, 1657, 2368, 2366, 2364, 2361, 1666, 690, 687,
        2374, 683, 2372, 701, 698, 705, 1691, 1689, 2619, 2617, 2610, 2608, 2605, 2613, 2593, 2588,
        2585, 1803, 2599, 2596, 2563, 2561, 2555, 1797, 2551, 1795, 2573, 2570, 2567, 2577, 2525,
        2524, 2522, 2520, 1786, 2517, 1785, 2514, 1783, 2535, 2533, 2531, 2528, 1788, 2541, 2539,
        906, 903, 911, 2721, 1844, 2715, 2712, 1838, 1836, 2699, 2696, 2693, 2703, 1827, 1826, 1824,
        2673, 2671, 2669, 2666, 1829, 2679, 2677, 1858, 1857, 2772, 1854, 1853, 1851, 1856, 2766,
        2764, 143, 1987, 139, 1986, 135, 133, 131, 1984, 128, 1983, 125, 1981, 138, 137, 136, 1985,
        1133, 1132, 1130, 112, 110, 1974, 107, 1973, 104, 1971, 1969, 122, 121, 119, 117, 1977, 114,
        1976, 124, 1115, 1114, 1112, 1110, 1117, 1116, 84, 83, 1953, 81, 1952, 78, 1950, 1948, 1945,
        94, 93, 91, 1959, 88, 1958, 85, 1955, 99, 97, 95, 1961, 1086, 1085, 1083, 1081, 1078, 100,
        1090, 1089, 1087, 1091, 49, 47, 1917, 44, 1915, 1913, 1910, 1907, 59, 1926, 56, 1925, 53,
        1922, 1919, 66, 64, 1931, 61, 1929, 1042, 1040, 1038, 71, 1035, 70, 1032, 68, 1048, 1047,
        1045, 1043, 1050, 1049, 12, 10, 1869, 1867, 1864, 1861, 21, 1880, 19, 1877, 1874, 1871, 28,
        1888, 25, 1886, 22, 1883, 982, 980, 977, 974, 32, 30, 991, 989, 987, 984, 34, 995, 994, 992,
        2151, 2150, 2147, 2146, 2144, 356, 355, 354, 2149, 2139, 2138, 2136, 2134, 1359, 343, 341,
        338, 2143, 335, 2141, 348, 347, 346, 1376, 1374, 2124, 2123, 2121, 2119, 1326, 2116, 1324,
        310, 308, 305, 2131, 302, 2129, 298, 2127, 320, 318, 316, 313, 2133, 322, 321, 1355, 1353,
        1351, 1357, 2092, 2091, 2089, 2087, 1276, 2084, 1274, 2081, 1271, 259, 2102, 256, 2100, 252,
        2098, 2095, 272, 269, 2108, 266, 2106, 281, 279, 277, 1317, 1315, 1313, 1310, 282, 1321,
        1319, 2039, 2037, 2035, 2032, 1203, 2029, 1200, 1197, 207, 2053, 205, 2051, 201, 2049, 2046,
        2043, 220, 218, 2064, 215, 2062, 211, 2059, 228, 226, 223, 2069, 1259, 1257, 1254, 232,
        1251, 230, 1267, 1265, 1263, 2316, 2315, 2312, 2311, 2309, 2314, 2304, 2303, 2301, 2299,
        1593, 2308, 2306, 590, 2288, 2287, 2285, 2283, 1578, 2280, 1577, 2295, 2293, 2291, 579, 577,
        574, 571, 2298, 582, 581, 1592, 2263, 2262, 2260, 2258, 1545, 2255, 1544, 2252, 1541, 2273,
        2271, 2269, 2266, 1550, 535, 532, 2279, 528, 2277, 546, 543, 549, 1575, 1573, 2224, 2222,
        2220, 1486, 2217, 1485, 2214, 1482, 1479, 2238, 2236, 2234, 2231, 1496, 2228, 1492, 480,
        477, 2248, 473, 2246, 469, 2243, 490, 487, 2251, 497, 1537, 1535, 1532, 2477, 2476, 2474,
        2479, 2469, 2468, 2466, 2464, 1730, 2473, 2471, 2453, 2452, 2450, 2448, 1729, 2445, 1728,
        2460, 2458, 2456, 2463, 805, 804, 2428, 2427, 2425, 2423, 1725, 2420, 1724, 2417, 1722,
        2438, 2436, 2434, 2431, 1727, 2444, 2442, 793, 791, 788, 795, 2388, 2386, 2384, 1697, 2381,
        1696, 2378, 1694, 1692, 2402, 2400, 2398, 2395, 1703, 2392, 1701, 2412, 2410, 2407, 751,
        748, 744, 2416, 759, 757, 1807, 2620, 2618, 1806, 1805, 2611, 2609, 2607, 2614, 1802, 1801,
        1799, 2594, 2592, 2590, 2587, 1804, 2600, 2598, 1794, 1793, 1791, 1789, 2564, 2562, 2560,
        2557, 1798, 2554, 1796, 2574, 2572, 2569, 2578, 1847, 1846, 2722, 1843, 1842, 1840, 1845,
        2716, 2714, 1835, 1834, 1832, 1830, 1839, 1837, 2700, 2698, 2695, 2704, 1817, 1811, 1810,
        897, 862, 1777, 829, 826, 838, 1760, 1758, 808, 2481, 1741, 1740, 1738, 1743, 2624, 1818,
        2726, 2776, 782, 740, 737, 1715, 686, 679, 695, 1682, 1680, 639, 628, 2339, 647, 644, 1645,
        1643, 1640, 1648, 602, 600, 597, 595, 2320, 593, 2318, 609, 607, 604, 1611, 1610, 1608,
        1606, 613, 1615, 1613, 2328, 926, 924, 892, 886, 899, 857, 850, 2505, 1778, 824, 823, 821,
        819, 2488, 818, 2486, 833, 831, 828, 840, 1761, 1759, 2649, 2632, 2630, 2746, 2734, 2732,
        2782, 2781, 570, 567, 1587, 531, 527, 523, 540, 1566, 1564, 476, 467, 463, 2240, 486, 483,
        1524, 1521, 1518, 1529, 411, 403, 2192, 399, 2189, 423, 416, 1462, 1457, 1454, 428, 1468,
        1465, 2210, 366, 363, 2158, 360, 2156, 357, 2153, 376, 373, 370, 2163, 1410, 1409, 1407,
        1405, 382, 1402, 380, 1417, 1415, 1412, 1421, 2175, 2174, 777, 774, 771, 784, 732, 725, 722,
        2404, 743, 1716, 676, 674, 668, 2363, 665, 2360, 685, 1684, 1681, 626, 624, 622, 2335, 620,
        2333, 617, 2330, 641, 635, 649, 1646, 1644, 1642, 2566, 928, 925, 2530, 2527, 894, 891, 888,
        2501, 2499, 2496, 858, 856, 854, 851, 1779, 2692, 2668, 2665, 2645, 2643, 2640, 2651, 2768,
        2759, 2757, 2744, 2743, 2741, 2748, 352, 1382, 340, 337, 333, 1371, 1369, 307, 300, 296,
        2126, 315, 312, 1347, 1342, 1350, 261, 258, 250, 2097, 246, 2094, 271, 268, 264, 1306, 1301,
        1298, 276, 1312, 1309, 2115, 203, 2048, 195, 2045, 191, 2041, 213, 209, 2056, 1246, 1244,
        1238, 225, 1234, 222, 1256, 1253, 1249, 1262, 2080, 2079, 154, 1997, 150, 1995, 147, 1992,
        1989, 163, 160, 2004, 156, 2001, 1175, 1174, 1172, 1170, 1167, 170, 1164, 167, 1185, 1183,
        1180, 1177, 174, 1190, 1188, 2025, 2024, 2022, 587, 586, 564, 559, 556, 2290, 573, 1588,
        520, 518, 512, 2268, 508, 2265, 530, 1568, 1565, 461, 457, 2233, 450, 2230, 446, 2226, 479,
        471, 489, 1526, 1523, 1520, 397, 395, 2185, 392, 2183, 389, 2180, 2177, 410, 2194, 402, 422,
        1463, 1461, 1459, 1456, 1470, 2455, 799, 2433, 2430, 779, 776, 773, 2397, 2394, 2390, 734,
        728, 724, 746, 1717, 2356, 2354, 2351, 2348, 1658, 677, 675, 673, 670, 667, 688, 1685, 1683,
        2606, 2589, 2586, 2559, 2556, 2552, 927, 2523, 2521, 2518, 2515, 1784, 2532, 895, 893, 890,
        2718, 2709, 2707, 2689, 2687, 2684, 2663, 2662, 2660, 2658, 1825, 2667, 2769, 1852, 2760,
        2758, 142, 141, 1139, 1138, 134, 132, 129, 126, 1982, 1129, 1128, 1126, 1131, 113, 111, 108,
        105, 1972, 101, 1970, 120, 118, 115, 1109, 1108, 1106, 1104, 123, 1113, 1111, 82, 79, 1951,
        75, 1949, 72, 1946, 92, 89, 86, 1956, 1077, 1076, 1074, 1072, 98, 1069, 96, 1084, 1082,
        1079, 1088, 1968, 1967, 48, 45, 1916, 42, 1914, 39, 1911, 1908, 60, 57, 54, 1923, 50, 1920,
        1031, 1030, 1028, 1026, 67, 1023, 65, 1020, 62, 1041, 1039, 1036, 1033, 69, 1046, 1044,
        1944, 1943, 1941, 11, 9, 1868, 7, 1865, 1862, 1859, 20, 1878, 16, 1875, 13, 1872, 970, 968,
        966, 963, 29, 960, 26, 23, 983, 981, 978, 975, 33, 971, 31, 990, 988, 985, 1906, 1904, 1902,
        993, 351, 2145, 1383, 331, 330, 328, 326, 2137, 323, 2135, 339, 1372, 1370, 294, 293, 291,
        289, 2122, 286, 2120, 283, 2117, 309, 303, 317, 1348, 1346, 1344, 245, 244, 242, 2090, 239,
        2088, 236, 2085, 2082, 260, 2099, 249, 270, 1307, 1305, 1303, 1300, 1314, 189, 2038, 186,
        2036, 183, 2033, 2030, 2026, 206, 198, 2047, 194, 216, 1247, 1245, 1243, 1240, 227, 1237,
        1255, 2310, 2302, 2300, 2286, 2284, 2281, 565, 563, 561, 558, 575, 1589, 2261, 2259, 2256,
        2253, 1542, 521, 519, 517, 514, 2270, 511, 533, 1569, 1567, 2223, 2221, 2218, 2215, 1483,
        2211, 1480, 459, 456, 453, 2232, 449, 474, 491, 1527, 1525, 1522, 2475, 2467, 2465, 2451,
        2449, 2446, 801, 800, 2426, 2424, 2421, 2418, 1723, 2435, 780, 778, 775, 2387, 2385, 2382,
        2379, 1695, 2375, 1693, 2396, 735, 733, 730, 727, 749, 1718, 2616, 2615, 2604, 2603, 2601,
        2584, 2583, 2581, 2579, 1800, 2591, 2550, 2549, 2547, 2545, 1792, 2542, 1790, 2558, 929,
        2719, 1841, 2710, 2708, 1833, 1831, 2690, 2688, 2686, 1815, 1809, 1808, 1774, 1756, 1754,
        1737, 1736, 1734, 1739, 1816, 1711, 1676, 1674, 633, 629, 1638, 1636, 1633, 1641, 598, 1605,
        1604, 1602, 1600, 605, 1609, 1607, 2327, 887, 853, 1775, 822, 820, 1757, 1755, 1584, 524,
        1560, 1558, 468, 464, 1514, 1511, 1508, 1519, 408, 404, 400, 1452, 1447, 1444, 417, 1458,
        1455, 2208, 364, 361, 358, 2154, 1401, 1400, 1398, 1396, 374, 1393, 371, 1408, 1406, 1403,
        1413, 2173, 2172, 772, 726, 723, 1712, 672, 669, 666, 682, 1678, 1675, 625, 623, 621, 618,
        2331, 636, 632, 1639, 1637, 1635, 920, 918, 884, 880, 889, 849, 848, 847, 846, 2497, 855,
        852, 1776, 2641, 2742, 2787, 1380, 334, 1367, 1365, 301, 297, 1340, 1338, 1335, 1343, 255,
        251, 247, 1296, 1291, 1288, 265, 1302, 1299, 2113, 204, 196, 192, 2042, 1232, 1230, 1224,
        214, 1220, 210, 1242, 1239, 1235, 1250, 2077, 2075, 151, 148, 1993, 144, 1990, 1163, 1162,
        1160, 1158, 1155, 161, 1152, 157, 1173, 1171, 1168, 1165, 168, 1181, 1178, 2021, 2020, 2018,
        2023, 585, 560, 557, 1585, 516, 509, 1562, 1559, 458, 447, 2227, 472, 1516, 1513, 1510, 398,
        396, 393, 390, 2181, 386, 2178, 407, 1453, 1451, 1449, 1446, 420, 1460, 2209, 769, 764, 720,
        712, 2391, 729, 1713, 664, 663, 661, 659, 2352, 656, 2349, 671, 1679, 1677, 2553, 922, 919,
        2519, 2516, 885, 883, 881, 2685, 2661, 2659, 2767, 2756, 2755, 140, 1137, 1136, 130, 127,
        1125, 1124, 1122, 1127, 109, 106, 102, 1103, 1102, 1100, 1098, 116, 1107, 1105, 1980, 80,
        76, 73, 1947, 1068, 1067, 1065, 1063, 90, 1060, 87, 1075, 1073, 1070, 1080, 1966, 1965, 46,
        43, 40, 1912, 36, 1909, 1019, 1018, 1016, 1014, 58, 1011, 55, 1008, 51, 1029, 1027, 1024,
        1021, 63, 1037, 1034, 1940, 1939, 1937, 1942, 8, 1866, 4, 1863, 1, 1860, 956, 954, 952, 949,
        946, 17, 14, 969, 967, 964, 961, 27, 957, 24, 979, 976, 972, 1901, 1900, 1898, 1896, 986,
        1905, 1903, 350, 349, 1381, 329, 327, 324, 1368, 1366, 292, 290, 287, 284, 2118, 304, 1341,
      constructor(o, a) {
        ;((this.bits = o), (this.points = a))
    class At {
      static detectMultiple(o, a, l) {
        let u = o.getBlackMatrix(),
          d = At.detect(l, u)
        return (d.length || ((u = u.clone()), u.rotate180(), (d = At.detect(l, u))), new bb(u, d))
      static detect(o, a) {
          const m = At.findVertices(a, u, d)
            u += At.ROW_STEP
          if (((g = !0), l.push(m), !o)) break
      static findVertices(o, a, l) {
        const u = o.getHeight(),
          d = o.getWidth(),
          At.copyToResult(
            At.findRowsWithPattern(o, u, d, a, l, At.START_PATTERN),
            At.INDEXES_START_PATTERN
          At.copyToResult(
            At.findRowsWithPattern(o, u, d, a, l, At.STOP_PATTERN),
            At.INDEXES_STOP_PATTERN
      static copyToResult(o, a, l) {
        for (let u = 0; u < l.length; u++) o[l[u]] = a[u]
      static findRowsWithPattern(o, a, l, u, d, g) {
        for (; u < a; u += At.ROW_STEP) {
          let T = At.findGuardPattern(o, d, u, l, !1, g, v)
              const P = At.findGuardPattern(o, d, --u, l, !1, g, v)
              if (P != null) T = P
            ;((m[0] = new ht(T[0], u)), (m[1] = new ht(T[1], u)), (b = !0))
            P = Int32Array.from([Math.trunc(m[0].getX()), Math.trunc(m[1].getX())])
            const B = At.findGuardPattern(o, P[0], C, l, !1, g, v)
              Math.abs(P[0] - B[0]) < At.MAX_PATTERN_DRIFT &&
              Math.abs(P[1] - B[1]) < At.MAX_PATTERN_DRIFT
              ((P = B), (T = 0))
              if (T > At.SKIPPED_ROW_COUNT_MAX) break
          ;((C -= T + 1), (m[2] = new ht(P[0], C)), (m[3] = new ht(P[1], C)))
        return (C - u < At.BARCODE_MIN_HEIGHT && N.fill(m, null), m)
      static findGuardPattern(o, a, l, u, d, g, m) {
        N.fillWithin(m, 0, m.length, 0)
        for (; o.get(b, l) && b > 0 && v++ < At.MAX_PIXEL_DRIFT; ) b--
          P = g.length
          if (o.get(C, l) !== B) m[T]++
            if (T === P - 1) {
              if (At.patternMatchVariance(m, g, At.MAX_INDIVIDUAL_VARIANCE) < At.MAX_AVG_VARIANCE)
        return T === P - 1 &&
          At.patternMatchVariance(m, g, At.MAX_INDIVIDUAL_VARIANCE) < At.MAX_AVG_VARIANCE
      static patternMatchVariance(o, a, l) {
        let u = o.length,
        for (let v = 0; v < u; v++) ((d += o[v]), (g += a[v]))
          let C = o[v],
            P = C > T ? C - T : T - C
          if (P > l) return 1 / 0
          b += P
    ;((At.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5])),
      (At.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3])),
      (At.MAX_AVG_VARIANCE = 0.42),
      (At.MAX_INDIVIDUAL_VARIANCE = 0.8),
      (At.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3])),
      (At.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1])),
      (At.MAX_PIXEL_DRIFT = 3),
      (At.MAX_PATTERN_DRIFT = 5),
      (At.SKIPPED_ROW_COUNT_MAX = 25),
      (At.ROW_STEP = 5),
      (At.BARCODE_MIN_HEIGHT = 10))
    class je {
      constructor(o, a) {
        this.field = o
      getCoefficient(o) {
        return this.coefficients[this.coefficients.length - 1 - o]
      evaluateAt(o) {
        if (o === 0) return this.getCoefficient(0)
        if (o === 1) {
          a = this.field.add(this.field.multiply(o, a), this.coefficients[u])
      add(o) {
        if (!this.field.equals(o.field))
        if (this.isZero()) return o
        if (o.isZero()) return this
          l = o.coefficients
        return new je(this.field, u)
      subtract(o) {
        if (!this.field.equals(o.field))
        return o.isZero() ? this : this.add(o.negative())
      multiply(o) {
        return o instanceof je ? this.multiplyOther(o) : this.multiplyScalar(o)
      multiplyOther(o) {
        if (!this.field.equals(o.field))
        if (this.isZero() || o.isZero()) return new je(this.field, new Int32Array([0]))
          u = o.coefficients,
        return new je(this.field, g)
        let o = this.coefficients.length,
          a = new Int32Array(o)
        for (let l = 0; l < o; l++) a[l] = this.field.subtract(0, this.coefficients[l])
        return new je(this.field, a)
      }
      multiplyScalar(o) {
        if (o === 0) return new je(this.field, new Int32Array([0]))
        if (o === 1) return this
        for (let u = 0; u < a; u++) l[u] = this.field.multiply(this.coefficients[u], o)
        return new je(this.field, l)
      }
      multiplyByMonomial(o, a) {
        if (o < 0) throw new w()
        if (a === 0) return new je(this.field, new Int32Array([0]))
          u = new Int32Array(l + o)
        return new je(this.field, u)
        let o = new vt()
            (l < 0 ? (o.append(' - '), (l = -l)) : o.length() > 0 && o.append(' + '),
            (a === 0 || l !== 1) && o.append(l),
            a !== 0 && (a === 1 ? o.append('x') : (o.append('x^'), o.append(a))))
        return o.toString()
      add(o, a) {
        return (o + a) % this.modulus
      subtract(o, a) {
        return (this.modulus + o - a) % this.modulus
      exp(o) {
        return this.expTable[o]
      log(o) {
        if (o === 0) throw new w()
        return this.logTable[o]
      inverse(o) {
        if (o === 0) throw new zl()
        return this.expTable[this.modulus - this.logTable[o] - 1]
      multiply(o, a) {
        return o === 0 || a === 0
          : this.expTable[(this.logTable[o] + this.logTable[a]) % (this.modulus - 1)]
      equals(o) {
        return o === this
      constructor(o, a) {
          (this.modulus = o),
          (this.expTable = new Int32Array(o)),
          (this.logTable = new Int32Array(o)))
        for (let u = 0; u < o; u++) ((this.expTable[u] = l), (l = (l * a) % o))
        for (let u = 0; u < o - 1; u++) this.logTable[this.expTable[u]] = u
        ;((this.zero = new je(this, new Int32Array([0]))),
          (this.one = new je(this, new Int32Array([1]))))
      buildMonomial(o, a) {
        if (o < 0) throw new w()
        let l = new Int32Array(o + 1)
        return ((l[0] = a), new je(this, l))
      }
    jh.PDF417_GF = new jh(Et.NUMBER_OF_CODEWORDS, 3)
      decode(o, a, l) {
        let u = new je(this.field, o),
          let U = u.evaluateAt(this.field.exp(j))
          ;((d[a - j] = U), U !== 0 && (g = !0))
            let U = this.field.exp(o.length - 1 - j),
              Y = new je(this.field, new Int32Array([this.field.subtract(0, U), 1]))
        let b = new je(this.field, d),
          P = this.findErrorLocations(C),
          B = this.findErrorMagnitudes(T, C, P)
        for (let j = 0; j < P.length; j++) {
          let U = o.length - 1 - this.field.log(P[j])
          if (U < 0) throw E.getChecksumInstance()
          o[U] = this.field.subtract(o[U], B[j])
        return P.length
      runEuclideanAlgorithm(o, a, l) {
        if (o.getDegree() < a.getDegree()) {
          let P = o
          ;((o = a), (a = P))
        let u = o,
          let P = u,
          d = P
            U = u.getCoefficient(u.getDegree()),
            Y = this.field.inverse(U)
            let K = d.getDegree() - u.getDegree(),
              nt = this.field.multiply(d.getCoefficient(d.getDegree()), Y)
            ;((j = j.add(this.field.buildMonomial(K, nt))),
              (d = d.subtract(u.multiplyByMonomial(K, nt))))
      findErrorLocations(o) {
        let a = o.getDegree(),
          o.evaluateAt(d) === 0 && ((l[u] = this.field.inverse(d)), u++)
      findErrorMagnitudes(o, a, l) {
        let g = new je(this.field, d),
            T = this.field.subtract(0, o.evaluateAt(C)),
            P = this.field.inverse(g.evaluateAt(C))
          b[v] = this.field.multiply(T, P)
      constructor(o, a, l, u, d) {
        o instanceof Gi ? this.constructor_2(o) : this.constructor_1(o, a, l, u, d)
      constructor_1(o, a, l, u, d) {
          ? ((a = new ht(0, u.getY())), (l = new ht(0, d.getY())))
            ((u = new ht(o.getWidth() - 1, a.getY())), (d = new ht(o.getWidth() - 1, l.getY()))),
          (this.image = o),
      constructor_2(o) {
        ;((this.image = o.image),
          (this.topLeft = o.getTopLeft()),
          (this.bottomLeft = o.getBottomLeft()),
          (this.topRight = o.getTopRight()),
          (this.bottomRight = o.getBottomRight()),
          (this.minX = o.getMinX()),
          (this.maxX = o.getMaxX()),
          (this.minY = o.getMinY()),
          (this.maxY = o.getMaxY()))
      }
      static merge(o, a) {
        return o == null
            ? o
            : new Gi(o.image, o.topLeft, o.bottomLeft, a.topRight, a.bottomRight)
      addMissingRows(o, a, l) {
        if (o > 0) {
            v = Math.trunc(b.getY() - o)
          let C = new ht(b.getX(), v)
          let C = new ht(b.getX(), v)
      constructor(o, a, l, u) {
        ;((this.columnCount = o),
      static form(o, a) {
          let P = C ? parseInt(C.substr(1)) : void 0,
              B = parseInt(a[l]).toString(P || 16)
              B = parseFloat(parseInt(a[l], P || 10).toPrecision(g)).toFixed(0)
          B = typeof B == 'object' ? JSON.stringify(B) : (+B).toString(P)
            U = b && b[0] + '' == '0' ? '0' : ' '
          for (; B.length < j; ) B = m !== void 0 ? B + U : U + B
        return o.replace(d, u)
      }
      format(o, ...a) {
        this.buffer += ia.form(o, a)
      }
    class oa {
      constructor(o) {
        ;((this.boundingBox = new Gi(o)),
          (this.codewords = new Array(o.getMaxY() - o.getMinY() + 1)))
      getCodewordNearby(o) {
        let a = this.getCodeword(o)
        for (let l = 1; l < oa.MAX_NEARBY_DISTANCE; l++) {
          let u = this.imageRowToCodewordIndex(o) - l
            ((u = this.imageRowToCodewordIndex(o) + l),
        }
      imageRowToCodewordIndex(o) {
        return o - this.boundingBox.getMinY()
      setCodeword(o, a) {
        this.codewords[this.imageRowToCodewordIndex(o)] = a
      getCodeword(o) {
        return this.codewords[this.imageRowToCodewordIndex(o)]
        const o = new ia()
            o.format('%3d:    |   %n', a++)
          o.format('%3d: %3d|%3d%n', a++, l.getRowNumber(), l.getValue())
        return o.toString()
    oa.MAX_NEARBY_DISTANCE = 5
    class sa {
      setValue(o) {
        o = Math.trunc(o)
        let a = this.values.get(o)
        ;(a == null && (a = 0), a++, this.values.set(o, a))
        let o = -1,
          d.getValue() > o
            ? ((o = d.getValue()), (a = []), a.push(d.getKey()))
            : d.getValue() === o && a.push(d.getKey())
        return Et.toIntArray(a)
      getConfidence(o) {
        return this.values.get(o)
    class Ip extends oa {
      constructor(o, a) {
        ;(super(o), (this._isLeft = a))
        for (let o of this.getCodewords()) o != null && o.setRowNumberAsRowIndicatorColumn()
      }
      adjustCompleteIndicatorColumnRowNumbers(o) {
        ;(this.setRowNumbers(), this.removeIncorrectCodewords(a, o))
          let P = a[T],
            B = P.getRowNumber() - b
          else if (B === 1) ((v = Math.max(v, C)), (C = 1), (b = P.getRowNumber()))
          else if (B < 0 || P.getRowNumber() >= o.getRowCount() || B > T) a[T] = null
            let U = j >= T
            for (let Y = 1; Y <= j && !U; Y++) U = a[T - Y] != null
            U ? (a[T] = null) : ((b = P.getRowNumber()), (C = 1))
        let o = this.getBarcodeMetadata()
        if (o == null) return null
        this.adjustIncompleteIndicatorColumnRowNumbers(o)
        let a = new Int32Array(o.getRowCount())
      adjustIncompleteIndicatorColumnRowNumbers(o) {
              : C.getRowNumber() >= o.getRowCount()
        let o = this.getCodewords(),
          a = new sa(),
          l = new sa(),
          u = new sa(),
          d = new sa()
        for (let m of o) {
          l.getValue()[0] + u.getValue()[0] < Et.MIN_ROWS_IN_BARCODE ||
          l.getValue()[0] + u.getValue()[0] > Et.MAX_ROWS_IN_BARCODE
        return (this.removeIncorrectCodewords(o, g), g)
      }
      removeIncorrectCodewords(o, a) {
        for (let l = 0; l < o.length; l++) {
          let u = o[l]
          if (o[l] == null) continue
            o[l] = null
              d * 3 + 1 !== a.getRowCountUpperPart() && (o[l] = null)
                (o[l] = null)
              d + 1 !== a.getColumnCount() && (o[l] = null)
      constructor(o, a) {
          (this.barcodeMetadata = o),
          (this.barcodeColumnCount = o.getColumnCount()),
        let o = Et.MAX_CODEWORDS_IN_BARCODE,
        do ((a = o), (o = this.adjustRowNumbersAndGetCount()))
        while (o > 0 && o < a)
      adjustIndicatorColumnRowNumbers(o) {
        o != null && o.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata)
        let o = this.adjustRowNumbersByRow()
        if (o === 0) return 0
        return o
        let o = this.detectionResultColumns[0].getCodewords(),
        for (let l = 0; l < o.length; l++)
          if (o[l] != null && a[l] != null && o[l].getRowNumber() === a[l].getRowNumber())
                (d.setRowNumber(o[l].getRowNumber()),
        let o = 0,
            m != null && ((d = aa.adjustRowNumberIfValid(u, d, m)), m.hasValidRowNumber() || o++)
        return o
      }
        let o = 0,
            m != null && ((d = aa.adjustRowNumberIfValid(u, d, m)), m.hasValidRowNumber() || o++)
        return o
      static adjustRowNumberIfValid(o, a, l) {
            (l.isValidRowNumber(o) ? (l.setRowNumber(o), (a = 0)) : ++a),
      adjustRowNumbers(o, a, l) {
        if (!this.detectionResultColumns[o - 1]) return
          d = this.detectionResultColumns[o - 1].getCodewords(),
        this.detectionResultColumns[o + 1] != null &&
          (g = this.detectionResultColumns[o + 1].getCodewords())
      }
      static adjustRowNumber(o, a) {
          : a.hasValidRowNumber() && a.getBucket() === o.getBucket()
            ? (o.setRowNumber(a.getRowNumber()), !0)
      }
      setBoundingBox(o) {
        this.boundingBox = o
      setDetectionResultColumn(o, a) {
        this.detectionResultColumns[o] = a
      getDetectionResultColumn(o) {
        return this.detectionResultColumns[o]
        let o = this.detectionResultColumns[0]
        o == null && (o = this.detectionResultColumns[this.barcodeColumnCount + 1])
        for (let l = 0; l < o.getCodewords().length; l++) {
      constructor(o, a, l, u) {
          (this.startX = Math.trunc(o)),
      }
      isValidRowNumber(o) {
        return o !== la.BARCODE_ROW_UNKNOWN && this.bucket === (o % 3) * 3
      }
      setRowNumber(o) {
        this.rowNumber = o
        for (let o = 0; o < Et.SYMBOL_TABLE.length; o++) {
          let a = Et.SYMBOL_TABLE[o],
          for (let u = 0; u < Et.BARS_IN_MODULE; u++) {
              fn.RATIOS_TABLE[o] || (fn.RATIOS_TABLE[o] = new Array(Et.BARS_IN_MODULE)),
              (fn.RATIOS_TABLE[o][Et.BARS_IN_MODULE - u - 1] = Math.fround(
                d / Et.MODULES_IN_CODEWORD
      static getDecodedValue(o) {
        let a = fn.getDecodedCodewordValue(fn.sampleBitCounts(o))
        return a !== -1 ? a : fn.getClosestDecodedValue(o)
      static sampleBitCounts(o) {
        let a = Dt.sum(o),
          l = new Int32Array(Et.BARS_IN_MODULE),
        for (let g = 0; g < Et.MODULES_IN_CODEWORD; g++) {
          let m = a / (2 * Et.MODULES_IN_CODEWORD) + (g * a) / Et.MODULES_IN_CODEWORD
          ;(d + o[u] <= m && ((d += o[u]), u++), l[u]++)
      static getDecodedCodewordValue(o) {
        let a = fn.getBitValue(o)
        return Et.getCodeword(a) === -1 ? -1 : a
      static getBitValue(o) {
        for (let l = 0; l < o.length; l++)
          for (let u = 0; u < o[l]; u++) a = (a << 1) | (l % 2 === 0 ? 1 : 0)
      static getClosestDecodedValue(o) {
        let a = Dt.sum(o),
          l = new Array(Et.BARS_IN_MODULE)
        if (a > 1) for (let g = 0; g < l.length; g++) l[g] = Math.fround(o[g] / a)
          for (let v = 0; v < Et.BARS_IN_MODULE; v++) {
          m < u && ((u = m), (d = Et.SYMBOL_TABLE[g]))
      (fn.RATIOS_TABLE = new Array(Et.SYMBOL_TABLE.length).map(
        (I) => new Array(Et.BARS_IN_MODULE)
    class _p {
      setSegmentIndex(o) {
        this.segmentIndex = o
      setFileId(o) {
        this.fileId = o
      setOptionalData(o) {
        this.optionalData = o
      setLastSegment(o) {
        this.lastSegment = o
      setSegmentCount(o) {
        this.segmentCount = o
      setSender(o) {
        this.sender = o
      setAddressee(o) {
        this.addressee = o
      setFileName(o) {
        this.fileName = o
      setFileSize(o) {
        this.fileSize = o
      setChecksum(o) {
        this.checksum = o
      setTimestamp(o) {
        this.timestamp = o
    class Rp {
      static parseLong(o, a = void 0) {
        return parseInt(o, a)
      writeBytes(o) {
        this.writeBytesOffset(o, 0, o.length)
      }
      writeBytesOffset(o, a, l) {
        if (o == null) throw new Tp()
        if (a < 0 || a > o.length || l < 0 || a + l > o.length || a + l < 0) throw new D()
        if (l !== 0) for (let u = 0; u < l; u++) this.write(o[a + u])
      constructor(o = 32) {
        if ((super(), (this.count = 0), o < 0)) throw new w('Negative initial size: ' + o)
        this.buf = new Uint8Array(o)
      ensureCapacity(o) {
        o - this.buf.length > 0 && this.grow(o)
      grow(o) {
        if ((a - o < 0 && (a = o), a < 0)) {
          if (o < 0) throw new Cb()
        this.buf = N.copyOfUint8Array(this.buf, a)
      write(o) {
        ;(this.ensureCapacity(this.count + 1), (this.buf[this.count] = o), (this.count += 1))
      writeBytesOffset(o, a, l) {
        if (a < 0 || a > o.length || l < 0 || a + l - o.length > 0) throw new D()
          k.arraycopy(o, a, this.buf, this.count, l),
      writeTo(o) {
        o.writeBytesOffset(this.buf, 0, this.count)
        return N.copyOfUint8Array(this.buf, this.count)
      toString(o) {
        return o
          ? typeof o == 'string'
            ? this.toString_string(o)
            : this.toString_number(o)
      toString_string(o) {
      toString_number(o) {
    var Xt
    ;(function (I) {
      ;((I[(I.ALPHA = 0)] = 'ALPHA'),
        (I[(I.LOWER = 1)] = 'LOWER'),
        (I[(I.MIXED = 2)] = 'MIXED'),
        (I[(I.PUNCT = 3)] = 'PUNCT'),
        (I[(I.ALPHA_SHIFT = 4)] = 'ALPHA_SHIFT'),
        (I[(I.PUNCT_SHIFT = 5)] = 'PUNCT_SHIFT'))
    })(Xt || (Xt = {}))
    function Np() {
    function ii(I) {
      if ((typeof Ql > 'u' && (Ql = Np()), Ql === null)) throw new Error('BigInt is not supported!')
      return Ql(I)
      let I = []
      I[0] = ii(1)
      let o = ii(900)
      I[1] = o
      for (let a = 2; a < 16; a++) I[a] = I[a - 1] * o
      return I
    }
    class q {
      static decode(o, a) {
        let l = new vt(''),
          g = o[d++],
          m = new _p()
        for (; d < o[0]; ) {
            case q.TEXT_COMPACTION_MODE_LATCH:
              d = q.textCompaction(o, d, l)
            case q.BYTE_COMPACTION_MODE_LATCH:
            case q.BYTE_COMPACTION_MODE_LATCH_6:
              d = q.byteCompaction(g, o, u, d, l)
            case q.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
              l.append(o[d++])
            case q.NUMERIC_COMPACTION_MODE_LATCH:
              d = q.numericCompaction(o, d, l)
            case q.ECI_CHARSET:
              Z.getCharacterSetECIByValue(o[d++])
            case q.ECI_GENERAL_PURPOSE:
            case q.ECI_USER_DEFINED:
            case q.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              d = q.decodeMacroBlock(o, d, m)
            case q.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
            case q.MACRO_PDF417_TERMINATOR:
              ;(d--, (d = q.textCompaction(o, d, l)))
          if (d < o.length) g = o[d++]
        let b = new Js(null, l.toString(), null, a)
      static decodeMacroBlock(o, a, l) {
        if (a + q.NUMBER_OF_SEQUENCE_CODEWORDS > o[0]) throw V.getFormatInstance()
        let u = new Int32Array(q.NUMBER_OF_SEQUENCE_CODEWORDS)
        for (let m = 0; m < q.NUMBER_OF_SEQUENCE_CODEWORDS; m++, a++) u[m] = o[a]
        l.setSegmentIndex(M.parseInt(q.decodeBase900toBase10(u, q.NUMBER_OF_SEQUENCE_CODEWORDS)))
        let d = new vt()
        ;((a = q.textCompaction(o, a, d)), l.setFileId(d.toString()))
        for (o[a] === q.BEGIN_MACRO_PDF417_OPTIONAL_FIELD && (g = a + 1); a < o[0]; )
          switch (o[a]) {
            case q.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              switch ((a++, o[a])) {
                case q.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                  let m = new vt()
                  ;((a = q.textCompaction(o, a + 1, m)), l.setFileName(m.toString()))
                case q.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                  let b = new vt()
                  ;((a = q.textCompaction(o, a + 1, b)), l.setSender(b.toString()))
                case q.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                  let v = new vt()
                  ;((a = q.textCompaction(o, a + 1, v)), l.setAddressee(v.toString()))
                case q.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                  let C = new vt()
                  ;((a = q.numericCompaction(o, a + 1, C)),
                case q.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                  let T = new vt()
                  ;((a = q.numericCompaction(o, a + 1, T)),
                    l.setTimestamp(Rp.parseLong(T.toString())))
                case q.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                  let P = new vt()
                  ;((a = q.numericCompaction(o, a + 1, P)), l.setChecksum(M.parseInt(P.toString())))
                case q.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                  let B = new vt()
                  ;((a = q.numericCompaction(o, a + 1, B)),
                    l.setFileSize(Rp.parseLong(B.toString())))
            case q.MACRO_PDF417_TERMINATOR:
          ;(l.isLastSegment() && m--, l.setOptionalData(N.copyOfRange(o, g, g + m)))
      static textCompaction(o, a, l) {
        let u = new Int32Array((o[0] - a) * 2),
          d = new Int32Array((o[0] - a) * 2),
        for (; a < o[0] && !m; ) {
          let b = o[a++]
          if (b < q.TEXT_COMPACTION_MODE_LATCH) ((u[g] = b / 30), (u[g + 1] = b % 30), (g += 2))
              case q.TEXT_COMPACTION_MODE_LATCH:
                u[g++] = q.TEXT_COMPACTION_MODE_LATCH
              case q.BYTE_COMPACTION_MODE_LATCH:
              case q.BYTE_COMPACTION_MODE_LATCH_6:
              case q.NUMERIC_COMPACTION_MODE_LATCH:
              case q.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case q.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case q.MACRO_PDF417_TERMINATOR:
              case q.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                ;((u[g] = q.MODE_SHIFT_TO_BYTE_COMPACTION_MODE), (b = o[a++]), (d[g] = b), g++)
        return (q.decodeTextCompaction(u, d, g, l), a)
      static decodeTextCompaction(o, a, l, u) {
        let d = Xt.ALPHA,
          g = Xt.ALPHA,
          let b = o[m],
            case Xt.ALPHA:
                  case q.LL:
                    d = Xt.LOWER
                  case q.ML:
                    d = Xt.MIXED
                  case q.PS:
                    ;((g = d), (d = Xt.PUNCT_SHIFT))
                  case q.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                  case q.TEXT_COMPACTION_MODE_LATCH:
                    d = Xt.ALPHA
            case Xt.LOWER:
                  case q.AS:
                    ;((g = d), (d = Xt.ALPHA_SHIFT))
                  case q.ML:
                    d = Xt.MIXED
                  case q.PS:
                    ;((g = d), (d = Xt.PUNCT_SHIFT))
                  case q.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                  case q.TEXT_COMPACTION_MODE_LATCH:
                    d = Xt.ALPHA
            case Xt.MIXED:
              if (b < q.PL) v = q.MIXED_CHARS[b]
                  case q.PL:
                    d = Xt.PUNCT
                  case q.LL:
                    d = Xt.LOWER
                  case q.AL:
                    d = Xt.ALPHA
                  case q.PS:
                    ;((g = d), (d = Xt.PUNCT_SHIFT))
                  case q.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                  case q.TEXT_COMPACTION_MODE_LATCH:
                    d = Xt.ALPHA
            case Xt.PUNCT:
              if (b < q.PAL) v = q.PUNCT_CHARS[b]
                  case q.PAL:
                    d = Xt.ALPHA
                  case q.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                  case q.TEXT_COMPACTION_MODE_LATCH:
                    d = Xt.ALPHA
            case Xt.ALPHA_SHIFT:
                  case q.TEXT_COMPACTION_MODE_LATCH:
                    d = Xt.ALPHA
            case Xt.PUNCT_SHIFT:
              if (((d = g), b < q.PAL)) v = q.PUNCT_CHARS[b]
                  case q.PAL:
                    d = Xt.ALPHA
                  case q.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                  case q.TEXT_COMPACTION_MODE_LATCH:
                    d = Xt.ALPHA
      static byteCompaction(o, a, l, u, d) {
        switch (o) {
          case q.BYTE_COMPACTION_MODE_LATCH:
                case q.TEXT_COMPACTION_MODE_LATCH:
                case q.BYTE_COMPACTION_MODE_LATCH:
                case q.NUMERIC_COMPACTION_MODE_LATCH:
                case q.BYTE_COMPACTION_MODE_LATCH_6:
                case q.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                case q.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case q.MACRO_PDF417_TERMINATOR:
                    for (let P = 0; P < 6; ++P) g.write(Number(ii(b) >> ii(8 * (5 - P))))
            u === a[0] && T < q.TEXT_COMPACTION_MODE_LATCH && (C[m++] = T)
            for (let P = 0; P < m; P++) g.write(C[P])
          case q.BYTE_COMPACTION_MODE_LATCH_6:
              let P = a[u++]
              if (P < q.TEXT_COMPACTION_MODE_LATCH) (m++, (b = 900 * b + P))
                switch (P) {
                  case q.TEXT_COMPACTION_MODE_LATCH:
                  case q.BYTE_COMPACTION_MODE_LATCH:
                  case q.NUMERIC_COMPACTION_MODE_LATCH:
                  case q.BYTE_COMPACTION_MODE_LATCH_6:
                  case q.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  case q.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case q.MACRO_PDF417_TERMINATOR:
        return (d.append(st.decode(g.toByteArray(), l)), u)
      static numericCompaction(o, a, l) {
          g = new Int32Array(q.MAX_NUMERIC_CODEWORDS)
        for (; a < o[0] && !d; ) {
          let m = o[a++]
          if ((a === o[0] && (d = !0), m < q.TEXT_COMPACTION_MODE_LATCH)) ((g[u] = m), u++)
              case q.TEXT_COMPACTION_MODE_LATCH:
              case q.BYTE_COMPACTION_MODE_LATCH:
              case q.BYTE_COMPACTION_MODE_LATCH_6:
              case q.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case q.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case q.MACRO_PDF417_TERMINATOR:
          ;(u % q.MAX_NUMERIC_CODEWORDS === 0 || m === q.NUMERIC_COMPACTION_MODE_LATCH || d) &&
            (l.append(q.decodeBase900toBase10(g, u)), (u = 0))
      static decodeBase900toBase10(o, a) {
        for (let d = 0; d < a; d++) l += q.EXP900[a - d - 1] * ii(o[d])
    ;((q.TEXT_COMPACTION_MODE_LATCH = 900),
      (q.BYTE_COMPACTION_MODE_LATCH = 901),
      (q.NUMERIC_COMPACTION_MODE_LATCH = 902),
      (q.BYTE_COMPACTION_MODE_LATCH_6 = 924),
      (q.ECI_USER_DEFINED = 925),
      (q.ECI_GENERAL_PURPOSE = 926),
      (q.ECI_CHARSET = 927),
      (q.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928),
      (q.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923),
      (q.MACRO_PDF417_TERMINATOR = 922),
      (q.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913),
      (q.MAX_NUMERIC_CODEWORDS = 15),
      (q.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0),
      (q.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1),
      (q.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2),
      (q.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3),
      (q.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4),
      (q.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5),
      (q.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6),
      (q.PL = 25),
      (q.LL = 27),
      (q.AS = 27),
      (q.ML = 28),
      (q.AL = 28),
      (q.PS = 29),
      (q.PAL = 29),
      (q.PUNCT_CHARS = `;<>@[\\]_\`~!\r	,:
      (q.MIXED_CHARS = '0123456789&\r	,:#-.$/+%*=^'),
      (q.EXP900 = Np() ? Ab() : []),
      (q.NUMBER_OF_SEQUENCE_CODEWORDS = 2))
    class kt {
      static decode(o, a, l, u, d, g, m) {
        let b = new Gi(o, a, l, u, d),
            (a != null && (v = kt.getRowIndicatorColumn(o, b, a, !0, g, m)),
            u != null && (C = kt.getRowIndicatorColumn(o, b, u, !1, g, m)),
            (T = kt.merge(v, C)),
          let U = T.getBoundingBox()
          if (j && U != null && (U.getMinY() < b.getMinY() || U.getMaxY() > b.getMaxY())) b = U
        let P = T.getBarcodeColumnCount() + 1
        ;(T.setDetectionResultColumn(0, v), T.setDetectionResultColumn(P, C))
        for (let j = 1; j <= P; j++) {
          let U = B ? j : P - j
          if (T.getDetectionResultColumn(U) !== void 0) continue
          ;(U === 0 || U === P ? (Y = new Ip(b, U === 0)) : (Y = new oa(b)),
            T.setDetectionResultColumn(U, Y))
          let K = -1,
            nt = K
          for (let et = b.getMinY(); et <= b.getMaxY(); et++) {
            if (((K = kt.getStartColumn(T, U, et, B)), K < 0 || K > b.getMaxX())) {
              if (nt === -1) continue
              K = nt
            let $ = kt.detectCodeword(o, b.getMinX(), b.getMaxX(), B, K, et, g, m)
              (Y.setCodeword(et, $),
              (nt = K),
        return kt.createDecoderResult(T)
      static merge(o, a) {
        if (o == null && a == null) return null
        let l = kt.getBarcodeMetadata(o, a)
        let u = Gi.merge(kt.adjustBoundingBox(o), kt.adjustBoundingBox(a))
      static adjustBoundingBox(o) {
        if (o == null) return null
        let a = o.getRowHeights()
        let l = kt.getMax(a),
        let d = o.getCodewords()
        return o.getBoundingBox().addMissingRows(u, g, o.isLeft())
      static getMax(o) {
        for (let l of o) a = Math.max(a, l)
      }
      static getBarcodeMetadata(o, a) {
        if (o == null || (l = o.getBarcodeMetadata()) == null)
      static getRowIndicatorColumn(o, a, l, u, d, g) {
        let m = new Ip(a, u)
            let P = kt.detectCodeword(o, 0, o.getWidth(), u, C, T, d, g)
            P != null && (m.setCodeword(T, P), u ? (C = P.getStartX()) : (C = P.getEndX()))
      static adjustCodewordCount(o, a) {
            o.getBarcodeColumnCount() * o.getBarcodeRowCount() -
            kt.getNumberOfECCodeWords(o.getBarcodeECLevel())
          if (d < 1 || d > Et.MAX_CODEWORDS_IN_BARCODE) throw H.getNotFoundInstance()
      static createDecoderResult(o) {
        let a = kt.createBarcodeMatrix(o)
        kt.adjustCodewordCount(o, a)
          u = new Int32Array(o.getBarcodeRowCount() * o.getBarcodeColumnCount()),
        for (let b = 0; b < o.getBarcodeRowCount(); b++)
          for (let v = 0; v < o.getBarcodeColumnCount(); v++) {
              T = b * o.getBarcodeColumnCount() + v
        return kt.createDecoderResultFromAmbiguousValues(
          o.getBarcodeECLevel(),
          Et.toIntArray(l),
          Et.toIntArray(g),
      static createDecoderResultFromAmbiguousValues(o, a, l, u, d) {
            return kt.decodeCodewords(a, o, l)
      static createBarcodeMatrix(o) {
          { length: o.getBarcodeRowCount() },
          () => new Array(o.getBarcodeColumnCount() + 2)
        for (let u = 0; u < a.length; u++) for (let d = 0; d < a[u].length; d++) a[u][d] = new sa()
        for (let u of o.getDetectionResultColumns()) {
      static isValidBarcodeColumn(o, a) {
        return a >= 0 && a <= o.getBarcodeColumnCount() + 1
      static getStartColumn(o, a, l, u) {
          (kt.isValidBarcodeColumn(o, a - d) &&
            (g = o.getDetectionResultColumn(a - d).getCodeword(l)),
        if (((g = o.getDetectionResultColumn(a).getCodewordNearby(l)), g != null))
          (kt.isValidBarcodeColumn(o, a - d) &&
            (g = o.getDetectionResultColumn(a - d).getCodewordNearby(l)),
        for (; kt.isValidBarcodeColumn(o, a - d); ) {
          for (let b of o.getDetectionResultColumn(a).getCodewords())
        return u ? o.getBoundingBox().getMinX() : o.getBoundingBox().getMaxX()
      static detectCodeword(o, a, l, u, d, g, m, b) {
        d = kt.adjustCodewordStartColumn(o, a, l, u, d, g)
        let v = kt.getModuleBitCount(o, a, l, u, d, g)
          T = Dt.sum(v)
            let U = v[j]
            ;((v[j] = v[v.length - 1 - j]), (v[v.length - 1 - j] = U))
          }
        if (!kt.checkCodewordSkew(T, m, b)) return null
        let P = fn.getDecodedValue(v),
          B = Et.getCodeword(P)
        return B === -1 ? null : new la(d, C, kt.getCodewordBucketNumber(P), B)
      static getModuleBitCount(o, a, l, u, d, g) {
          o.get(m, g) === T ? (b[v]++, (m += C)) : (v++, (T = !T))
      static getNumberOfECCodeWords(o) {
        return 2 << o
      static adjustCodewordStartColumn(o, a, l, u, d, g) {
          for (; (u ? m >= a : m < l) && u === o.get(m, g); ) {
            if (Math.abs(d - m) > kt.CODEWORD_SKEW_SIZE) return d
      static checkCodewordSkew(o, a, l) {
        return a - kt.CODEWORD_SKEW_SIZE <= o && o <= l + kt.CODEWORD_SKEW_SIZE
      static decodeCodewords(o, a, l) {
        if (o.length === 0) throw V.getFormatInstance()
          d = kt.correctErrors(o, l, u)
        kt.verifyCodewordCount(o, u)
        let g = q.decode(o, '' + a)
      static correctErrors(o, a, l) {
        if ((a != null && a.length > l / 2 + kt.MAX_ERRORS) || l < 0 || l > kt.MAX_EC_CODEWORDS)
        return kt.errorCorrection.decode(o, l, a)
      static verifyCodewordCount(o, a) {
        if (o.length < 4) throw V.getFormatInstance()
        let l = o[0]
        if (l > o.length) throw V.getFormatInstance()
          if (a < o.length) o[0] = o.length - a
      static getBitCountForCodeword(o) {
        for (; !((o & 1) !== l && ((l = o & 1), u--, u < 0)); ) (a[u]++, (o >>= 1))
      static getCodewordBucketNumber(o) {
        return o instanceof Int32Array
          ? this.getCodewordBucketNumber_Int32Array(o)
          : this.getCodewordBucketNumber_number(o)
      static getCodewordBucketNumber_number(o) {
        return kt.getCodewordBucketNumber(kt.getBitCountForCodeword(o))
      static getCodewordBucketNumber_Int32Array(o) {
        return (o[0] - o[2] + o[4] - o[6] + 9) % 9
      static toString(o) {
        for (let l = 0; l < o.length; l++) {
          for (let u = 0; u < o[l].length; u++) {
            let d = o[l][u]
    ;((kt.CODEWORD_SKEW_SIZE = 2),
      (kt.MAX_ERRORS = 3),
      (kt.MAX_EC_CODEWORDS = 512),
      (kt.errorCorrection = new kp()))
    class Ve {
      decode(o, a = null) {
        let l = Ve.decode(o, a, !1)
      decodeMultiple(o, a = null) {
          return Ve.decode(o, a, !0)
      static decode(o, a, l) {
          d = At.detectMultiple(o, a, l)
          const m = kt.decode(
              Ve.getMinCodewordWidth(g),
              Ve.getMaxCodewordWidth(g)
            b = new Bt(m.getText(), m.getRawBytes(), void 0, g, ut.PDF_417)
          b.putMetadata(Ne.ERROR_CORRECTION_LEVEL, m.getECLevel())
          ;(v != null && b.putMetadata(Ne.PDF417_EXTRA_METADATA, v), u.push(b))
      static getMaxWidth(o, a) {
        return o == null || a == null ? 0 : Math.trunc(Math.abs(o.getX() - a.getX()))
      static getMinWidth(o, a) {
        return o == null || a == null ? M.MAX_VALUE : Math.trunc(Math.abs(o.getX() - a.getX()))
      static getMaxCodewordWidth(o) {
              Ve.getMaxWidth(o[0], o[4]),
              (Ve.getMaxWidth(o[6], o[2]) * Et.MODULES_IN_CODEWORD) / Et.MODULES_IN_STOP_PATTERN
              Ve.getMaxWidth(o[1], o[5]),
              (Ve.getMaxWidth(o[7], o[3]) * Et.MODULES_IN_CODEWORD) / Et.MODULES_IN_STOP_PATTERN
      static getMinCodewordWidth(o) {
              Ve.getMinWidth(o[0], o[4]),
              (Ve.getMinWidth(o[6], o[2]) * Et.MODULES_IN_CODEWORD) / Et.MODULES_IN_STOP_PATTERN
              Ve.getMinWidth(o[1], o[5]),
              (Ve.getMinWidth(o[7], o[3]) * Et.MODULES_IN_CODEWORD) / Et.MODULES_IN_STOP_PATTERN
      constructor(o, a) {
        ;((this.verbose = o === !0), a && this.setHints(a))
      decode(o, a) {
        return (a && this.setHints(a), this.decodeInternal(o))
      decodeWithState(o) {
          this.decodeInternal(o)
      setHints(o) {
        this.hints = o
        const a = !r(o) && o.get(z.TRY_HARDER) === !0,
          l = r(o) ? null : o.get(z.POSSIBLE_FORMATS),
              g === ut.UPC_A ||
              g === ut.UPC_E ||
              g === ut.EAN_13 ||
              g === ut.EAN_8 ||
              g === ut.CODABAR ||
              g === ut.CODE_39 ||
              g === ut.CODE_93 ||
              g === ut.CODE_128 ||
              g === ut.ITF ||
              g === ut.RSS_14 ||
              g === ut.RSS_EXPANDED
          ;(d && !a && u.push(new qo(o, this.verbose)),
            l.includes(ut.QR_CODE) && u.push(new ri()),
            l.includes(ut.DATA_MATRIX) && u.push(new ni()),
            l.includes(ut.AZTEC) && u.push(new Gl()),
            l.includes(ut.PDF_417) && u.push(new Ve()),
            d && a && u.push(new qo(o, this.verbose)))
          (a || u.push(new qo(o, this.verbose)),
          u.push(new Ve()),
          a && u.push(new qo(o, this.verbose))),
        if (this.readers !== null) for (const o of this.readers) o.reset()
      decodeInternal(o) {
            return a.decode(o, this.hints)
      }
    class kb extends Te {
      constructor(o = null, a = 500) {
        ;(l.setHints(o), super(l, a))
      decodeBitmap(o) {
        return this.reader.decodeWithState(o)
    class Ib extends Te {
      constructor(o = 500) {
        super(new Ve(), o)
    class _b extends Te {
      constructor(o = 500) {
        super(new ri(), o)
    ;(function (I) {
      ;((I[(I.ERROR_CORRECTION = 0)] = 'ERROR_CORRECTION'),
        (I[(I.CHARACTER_SET = 1)] = 'CHARACTER_SET'),
        (I[(I.DATA_MATRIX_SHAPE = 2)] = 'DATA_MATRIX_SHAPE'),
        (I[(I.MIN_SIZE = 3)] = 'MIN_SIZE'),
        (I[(I.MAX_SIZE = 4)] = 'MAX_SIZE'),
        (I[(I.MARGIN = 5)] = 'MARGIN'),
        (I[(I.PDF417_COMPACT = 6)] = 'PDF417_COMPACT'),
        (I[(I.PDF417_COMPACTION = 7)] = 'PDF417_COMPACTION'),
        (I[(I.PDF417_DIMENSIONS = 8)] = 'PDF417_DIMENSIONS'),
        (I[(I.AZTEC_LAYERS = 9)] = 'AZTEC_LAYERS'),
        (I[(I.QR_VERSION = 10)] = 'QR_VERSION'))
    var Ie = Vh
    class Wh {
      constructor(o) {
        ;((this.field = o),
          this.cachedGenerators.push(new un(o, Int32Array.from([1]))))
      buildGenerator(o) {
        if (o >= a.length) {
          for (let d = a.length; d <= o; d++) {
        return a[o]
      encode(o, a) {
        const l = o.length - a
        k.arraycopy(o, 0, d, 0, l)
        for (let v = 0; v < b; v++) o[l + v] = 0
        k.arraycopy(m, 0, o, l + b, m.length)
    class ge {
      static applyMaskPenaltyRule1(o) {
        return ge.applyMaskPenaltyRule1Internal(o, !0) + ge.applyMaskPenaltyRule1Internal(o, !1)
      static applyMaskPenaltyRule2(o) {
        const l = o.getArray(),
          u = o.getWidth(),
          d = o.getHeight()
        return ge.N2 * a
      static applyMaskPenaltyRule3(o) {
        const l = o.getArray(),
          u = o.getWidth(),
          d = o.getHeight()
              (ge.isWhiteHorizontal(b, m - 4, m) || ge.isWhiteHorizontal(b, m + 7, m + 11)) &&
                (ge.isWhiteVertical(l, m, g - 4, g) || ge.isWhiteVertical(l, m, g + 7, g + 11)) &&
        return a * ge.N3
      static isWhiteHorizontal(o, a, l) {
        ;((a = Math.max(a, 0)), (l = Math.min(l, o.length)))
        for (let u = a; u < l; u++) if (o[u] === 1) return !1
      static isWhiteVertical(o, a, l, u) {
        ;((l = Math.max(l, 0)), (u = Math.min(u, o.length)))
        for (let d = l; d < u; d++) if (o[d][a] === 1) return !1
      static applyMaskPenaltyRule4(o) {
        const l = o.getArray(),
          u = o.getWidth(),
          d = o.getHeight()
        const g = o.getHeight() * o.getWidth()
        return Math.floor((Math.abs(a * 2 - g) * 10) / g) * ge.N4
      static getDataMaskBit(o, a, l) {
        switch (o) {
            throw new w('Invalid mask pattern: ' + o)
      static applyMaskPenaltyRule1Internal(o, a) {
        const u = a ? o.getHeight() : o.getWidth(),
          d = a ? o.getWidth() : o.getHeight(),
          g = o.getArray()
            T === v ? b++ : (b >= 5 && (l += ge.N1 + (b - 5)), (b = 1), (v = T))
          b >= 5 && (l += ge.N1 + (b - 5))
    ;((ge.N1 = 3), (ge.N2 = 3), (ge.N3 = 40), (ge.N4 = 10))
      constructor(o, a) {
        ;((this.width = o), (this.height = a))
        for (let u = 0; u !== a; u++) l[u] = new Uint8Array(o)
      get(o, a) {
        return this.bytes[a][o]
      setNumber(o, a, l) {
        this.bytes[a][o] = l
      setBoolean(o, a, l) {
        this.bytes[a][o] = l ? 1 : 0
      clear(o) {
        for (const a of this.bytes) N.fill(a, o)
      equals(o) {
        if (!(o instanceof Jl)) return !1
        const a = o
        const o = new vt()
                o.append(' 0')
                o.append(' 1')
                o.append('  ')
          o.append(`
        return o.toString()
        const o = new vt()
          o.append(`<<
          o.append(' mode: '),
          o.append(this.mode ? this.mode.toString() : 'null'),
          o.append(`
          o.append(this.ecLevel ? this.ecLevel.toString() : 'null'),
          o.append(`
          o.append(this.version ? this.version.toString() : 'null'),
          o.append(`
          o.append(this.maskPattern.toString()),
            ? (o.append(`
              o.append(this.matrix.toString()))
            : o.append(`
          o.append(`>>
          o.toString()
      setMode(o) {
        this.mode = o
      setECLevel(o) {
        this.ecLevel = o
      }
      setVersion(o) {
        this.version = o
      }
      setMaskPattern(o) {
        this.maskPattern = o
      }
      setMatrix(o) {
        this.matrix = o
      }
      static isValidMaskPattern(o) {
        return o >= 0 && o < Yi.NUM_MASK_PATTERNS
      }
    class Yt extends p {}
    Yt.kind = 'WriterException'
    class wt {
      static clearMatrix(o) {
        o.clear(255)
      }
      static buildMatrix(o, a, l, u, d) {
        ;(wt.clearMatrix(d),
          wt.embedBasicPatterns(l, d),
          wt.embedTypeInfo(a, u, d),
          wt.maybeEmbedVersionInfo(l, d),
          wt.embedDataBits(o, u, d))
      }
      static embedBasicPatterns(o, a) {
        ;(wt.embedPositionDetectionPatternsAndSeparators(a),
          wt.embedDarkDotAtLeftBottomCorner(a),
          wt.maybeEmbedPositionAdjustmentPatterns(o, a),
          wt.embedTimingPatterns(a))
      }
      static embedTypeInfo(o, a, l) {
        wt.makeTypeInfoBits(o, a, u)
            b = wt.TYPE_INFO_COORDINATES[d],
        }
      static maybeEmbedVersionInfo(o, a) {
        if (o.getVersionNumber() < 7) return
        wt.makeVersionInfoBits(o, l)
      static embedDataBits(o, a, l) {
              if (!wt.isEmpty(l.get(v, m))) continue
              ;(u < o.getSize() ? ((C = o.get(u)), ++u) : (C = !1),
                a !== 255 && ge.getDataMaskBit(a, v, m) && (C = !C),
        if (u !== o.getSize()) throw new Yt('Not all bits consumed: ' + u + '/' + o.getSize())
      static findMSBSet(o) {
        return 32 - M.numberOfLeadingZeros(o)
      }
      static calculateBCHCode(o, a) {
        const l = wt.findMSBSet(a)
        for (o <<= l - 1; wt.findMSBSet(o) >= l; ) o ^= a << (wt.findMSBSet(o) - l)
        return o
      static makeTypeInfoBits(o, a, l) {
        if (!Yi.isValidMaskPattern(a)) throw new Yt('Invalid mask pattern')
        const u = (o.getBits() << 3) | a
        const d = wt.calculateBCHCode(u, wt.TYPE_INFO_POLY)
        if ((g.appendBits(wt.TYPE_INFO_MASK_PATTERN, 15), l.xor(g), l.getSize() !== 15))
          throw new Yt('should not happen but we got: ' + l.getSize())
      static makeVersionInfoBits(o, a) {
        a.appendBits(o.getVersionNumber(), 6)
        const l = wt.calculateBCHCode(o.getVersionNumber(), wt.VERSION_INFO_POLY)
          throw new Yt('should not happen but we got: ' + a.getSize())
      }
      static isEmpty(o) {
        return o === 255
      }
      static embedTimingPatterns(o) {
        for (let a = 8; a < o.getWidth() - 8; ++a) {
          ;(wt.isEmpty(o.get(a, 6)) && o.setNumber(a, 6, l),
            wt.isEmpty(o.get(6, a)) && o.setNumber(6, a, l))
      static embedDarkDotAtLeftBottomCorner(o) {
        if (o.get(8, o.getHeight() - 8) === 0) throw new Yt()
        o.setNumber(8, o.getHeight() - 8, 1)
      static embedHorizontalSeparationPattern(o, a, l) {
          if (!wt.isEmpty(l.get(o + u, a))) throw new Yt()
          l.setNumber(o + u, a, 0)
      static embedVerticalSeparationPattern(o, a, l) {
          if (!wt.isEmpty(l.get(o, a + u))) throw new Yt()
          l.setNumber(o, a + u, 0)
      static embedPositionAdjustmentPattern(o, a, l) {
          const d = wt.POSITION_ADJUSTMENT_PATTERN[u]
          for (let g = 0; g < 5; ++g) l.setNumber(o + g, a + u, d[g])
      static embedPositionDetectionPattern(o, a, l) {
          const d = wt.POSITION_DETECTION_PATTERN[u]
          for (let g = 0; g < 7; ++g) l.setNumber(o + g, a + u, d[g])
      static embedPositionDetectionPatternsAndSeparators(o) {
        const a = wt.POSITION_DETECTION_PATTERN[0].length
        ;(wt.embedPositionDetectionPattern(0, 0, o),
          wt.embedPositionDetectionPattern(o.getWidth() - a, 0, o),
          wt.embedPositionDetectionPattern(0, o.getWidth() - a, o))
        ;(wt.embedHorizontalSeparationPattern(0, l - 1, o),
          wt.embedHorizontalSeparationPattern(o.getWidth() - l, l - 1, o),
          wt.embedHorizontalSeparationPattern(0, o.getWidth() - l, o))
        ;(wt.embedVerticalSeparationPattern(u, 0, o),
          wt.embedVerticalSeparationPattern(o.getHeight() - u - 1, 0, o),
          wt.embedVerticalSeparationPattern(u, o.getHeight() - u, o))
      }
      static maybeEmbedPositionAdjustmentPatterns(o, a) {
        if (o.getVersionNumber() < 2) return
        const l = o.getVersionNumber() - 1,
          u = wt.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[l]
                wt.isEmpty(a.get(v, m)) &&
                wt.embedPositionAdjustmentPattern(v - 2, m - 2, a)
      }
    ;((wt.POSITION_DETECTION_PATTERN = Array.from([
      (wt.POSITION_ADJUSTMENT_PATTERN = Array.from([
      (wt.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
      (wt.TYPE_INFO_COORDINATES = Array.from([
      (wt.VERSION_INFO_POLY = 7973),
      (wt.TYPE_INFO_POLY = 1335),
      (wt.TYPE_INFO_MASK_PATTERN = 21522))
    class Rb {
      constructor(o, a) {
        ;((this.dataBytes = o), (this.errorCorrectionBytes = a))
      }
    class Jt {
      static calculateMaskPenalty(o) {
          ge.applyMaskPenaltyRule1(o) +
          ge.applyMaskPenaltyRule2(o) +
          ge.applyMaskPenaltyRule3(o) +
          ge.applyMaskPenaltyRule4(o)
      static encode(o, a, l = null) {
        let u = Jt.DEFAULT_BYTE_MODE_ENCODING
        const d = l !== null && l.get(Ie.CHARACTER_SET) !== void 0
        d && (u = l.get(Ie.CHARACTER_SET).toString())
        const g = this.chooseMode(o, u),
        if (g === mt.BYTE && (d || Jt.DEFAULT_BYTE_MODE_ENCODING !== u)) {
          const et = Z.getCharacterSetECIByName(u)
          et !== void 0 && this.appendECI(et, m)
        this.appendBytes(o, g, b, u)
        if (l !== null && l.get(Ie.QR_VERSION) !== void 0) {
          const et = Number.parseInt(l.get(Ie.QR_VERSION).toString(), 10)
          v = dt.getVersionForNumber(et)
          if (!this.willFit($, v, a)) throw new Yt('Data too big for requested version')
        const T = g === mt.BYTE ? b.getSizeInBytes() : o.length
        const P = v.getECBlocksForLevel(a),
          B = v.getTotalCodewords() - P.getTotalECCodewords()
        const j = this.interleaveWithECBytes(C, v.getTotalCodewords(), B, P.getNumBlocks()),
          U = new Yi()
        ;(U.setECLevel(a), U.setMode(g), U.setVersion(v))
          K = new Jl(Y, Y),
          nt = this.chooseMaskPattern(j, a, v, K)
        return (U.setMaskPattern(nt), wt.buildMatrix(j, a, v, nt, K), U.setMatrix(K), U)
      static recommendVersion(o, a, l, u) {
        const d = this.calculateBitsNeeded(a, l, u, dt.getVersionForNumber(1)),
          g = this.chooseVersion(d, o),
        return this.chooseVersion(m, o)
      static calculateBitsNeeded(o, a, l, u) {
        return a.getSize() + o.getCharacterCountBits(u) + l.getSize()
      static getAlphanumericCode(o) {
        return o < Jt.ALPHANUMERIC_TABLE.length ? Jt.ALPHANUMERIC_TABLE[o] : -1
      static chooseMode(o, a = null) {
        if (Z.SJIS.getName() === a && this.isOnlyDoubleByteKanji(o)) return mt.KANJI
        for (let d = 0, g = o.length; d < g; ++d) {
          const m = o.charAt(d)
          if (Jt.isDigit(m)) l = !0
          else return mt.BYTE
        return u ? mt.ALPHANUMERIC : l ? mt.NUMERIC : mt.BYTE
      static isOnlyDoubleByteKanji(o) {
          a = st.encode(o, Z.SJIS)
      }
      static chooseMaskPattern(o, a, l, u) {
          wt.buildMatrix(o, a, l, m, u)
      }
      static chooseVersion(o, a) {
          const u = dt.getVersionForNumber(l)
          if (Jt.willFit(o, u, a)) return u
        throw new Yt('Data too big')
      static willFit(o, a, l) {
          m = (o + 7) / 8
      static terminateBits(o, a) {
        const l = o * 8
          throw new Yt('data bits cannot fit in the QR Code' + a.getSize() + ' > ' + l)
        const d = o - a.getSizeInBytes()
        if (a.getSize() !== l) throw new Yt('Bits size does not equal capacity')
      }
      static getNumDataBytesAndNumECBytesForBlockID(o, a, l, u, d, g) {
        if (u >= l) throw new Yt('Block ID too large')
        const m = o % l,
          v = Math.floor(o / l),
          P = T + 1,
          j = C - P
        if (B !== j) throw new Yt('EC bytes mismatch')
        if (l !== b + m) throw new Yt('RS blocks mismatch')
        if (o !== (T + B) * b + (P + j) * m) throw new Yt('Total bytes mismatch')
        u < b ? ((d[0] = T), (g[0] = B)) : ((d[0] = P), (g[0] = j))
      }
      static interleaveWithECBytes(o, a, l, u) {
        if (o.getSizeInBytes() !== l) throw new Yt('Number of bits and data bytes does not match')
            P = new Int32Array(1)
          Jt.getNumDataBytesAndNumECBytesForBlockID(a, l, u, C, T, P)
          o.toBytes(8 * d, j, 0, B)
          const U = Jt.generateECBytes(j, P[0])
          ;(b.push(new Rb(j, U)), (g = Math.max(g, B)), (m = Math.max(m, U.length)), (d += T[0]))
        if (l !== d) throw new Yt('Data bytes does not match offset')
            const P = T.getDataBytes()
            C < P.length && v.appendBits(P[C], 8)
            const P = T.getErrorCorrectionBytes()
            C < P.length && v.appendBits(P[C], 8)
          throw new Yt('Interleaving error: ' + a + ' and ' + v.getSizeInBytes() + ' differ.')
      static generateECBytes(o, a) {
        const l = o.length,
        for (let g = 0; g < l; g++) u[g] = o[g] & 255
        new Wh(Ft.QR_CODE_FIELD_256).encode(u, a)
      static appendModeInfo(o, a) {
        a.appendBits(o.getBits(), 4)
      static appendLengthInfo(o, a, l, u) {
        if (o >= 1 << d) throw new Yt(o + ' is bigger than ' + ((1 << d) - 1))
        u.appendBits(o, d)
      static appendBytes(o, a, l, u) {
          case mt.NUMERIC:
            Jt.appendNumericBytes(o, l)
          case mt.ALPHANUMERIC:
            Jt.appendAlphanumericBytes(o, l)
          case mt.BYTE:
            Jt.append8BitBytes(o, l, u)
          case mt.KANJI:
            Jt.appendKanjiBytes(o, l)
            throw new Yt('Invalid mode: ' + a)
      static getDigit(o) {
        return o.charCodeAt(0) - 48
      static isDigit(o) {
        const a = Jt.getDigit(o)
      static appendNumericBytes(o, a) {
        const l = o.length
          const d = Jt.getDigit(o.charAt(u))
            const g = Jt.getDigit(o.charAt(u + 1)),
              m = Jt.getDigit(o.charAt(u + 2))
            const g = Jt.getDigit(o.charAt(u + 1))
      static appendAlphanumericBytes(o, a) {
        const l = o.length
          const d = Jt.getAlphanumericCode(o.charCodeAt(u))
          if (d === -1) throw new Yt()
            const g = Jt.getAlphanumericCode(o.charCodeAt(u + 1))
            if (g === -1) throw new Yt()
      static append8BitBytes(o, a, l) {
          u = st.encode(o, l)
          throw new Yt(d)
      static appendKanjiBytes(o, a) {
          l = st.encode(o, Z.SJIS)
          throw new Yt(d)
            throw new Yt('Invalid byte sequence')
      static appendECI(o, a) {
        ;(a.appendBits(mt.ECI.getBits(), 4), a.appendBits(o.getValue(), 8))
    ;((Jt.ALPHANUMERIC_TABLE = Int32Array.from([
      (Jt.DEFAULT_BYTE_MODE_ENCODING = Z.UTF8.getName()))
      write(o, a, l, u = null) {
        if (o.length === 0) throw new w('Found empty contents')
        let d = Kt.L,
          (u.get(Ie.ERROR_CORRECTION) !== void 0 &&
            (d = Kt.fromString(u.get(Ie.ERROR_CORRECTION).toString())),
          u.get(Ie.MARGIN) !== void 0 && (g = Number.parseInt(u.get(Ie.MARGIN).toString(), 10)))
        const m = Jt.encode(o, d, u)
      writeToDom(o, a, l, u, d = null) {
        typeof o == 'string' && (o = document.querySelector(o))
        o && o.appendChild(g)
      renderResult(o, a, l, u) {
        const d = o.getMatrix()
          P = Math.min(Math.floor(C / b), Math.floor(T / v)),
          B = Math.floor((C - g * P) / 2),
          j = Math.floor((T - m * P) / 2),
          U = this.createSVGElement(C, T)
        for (let Y = 0, K = j; Y < m; Y++, K += P)
          for (let nt = 0, et = B; nt < g; nt++, et += P)
            if (d.get(nt, Y) === 1) {
              const $ = this.createSvgRectElement(et, K, P, P)
              U.appendChild($)
        return U
      createSVGElement(o, a) {
          l.setAttributeNS(null, 'height', o.toString()),
      createSvgRectElement(o, a, l, u) {
          d.setAttributeNS(null, 'x', o.toString()),
      }
    class Qo {
      encode(o, a, l, u, d) {
        if (o.length === 0) throw new w('Found empty contents')
        if (a !== ut.QR_CODE) throw new w('Can only encode QR_CODE, but got ' + a)
        let g = Kt.L,
          m = Qo.QUIET_ZONE_SIZE
          (d.get(Ie.ERROR_CORRECTION) !== void 0 &&
            (g = Kt.fromString(d.get(Ie.ERROR_CORRECTION).toString())),
          d.get(Ie.MARGIN) !== void 0 && (m = Number.parseInt(d.get(Ie.MARGIN).toString(), 10)))
        const b = Jt.encode(o, g, d)
        return Qo.renderResult(b, l, u, m)
      }
      static renderResult(o, a, l, u) {
        const d = o.getMatrix()
          P = Math.min(Math.floor(C / b), Math.floor(T / v)),
          B = Math.floor((C - g * P) / 2),
          j = Math.floor((T - m * P) / 2),
          U = new _t(C, T)
        for (let Y = 0, K = j; Y < m; Y++, K += P)
          for (let nt = 0, et = B; nt < g; nt++, et += P)
            d.get(nt, Y) === 1 && U.setRegion(et, K, P, P)
        return U
    Qo.QUIET_ZONE_SIZE = 4
      encode(o, a, l, u, d) {
          case ut.QR_CODE:
            g = new Qo()
        return g.encode(o, a, l, u, d)
    class mr extends ot {
      constructor(o, a, l, u, d, g, m, b) {
          (this.yuvData = o),
      getRow(o, a) {
        if (o < 0 || o >= this.getHeight()) throw new w('Requested row is outside the image: ' + o)
        const u = (o + this.top) * this.dataWidth + this.left
        const o = this.getWidth(),
        if (o === this.dataWidth && a === this.dataHeight) return this.yuvData
        const l = o * a,
        if (o === this.dataWidth) return (k.arraycopy(this.yuvData, d, u, 0, l), u)
          const m = g * o
          ;(k.arraycopy(this.yuvData, d, u, m, o), (d += this.dataWidth))
      crop(o, a, l, u) {
          this.left + o,
        const o = this.getWidth() / mr.THUMBNAIL_SCALE_FACTOR,
          l = new Int32Array(o * a),
          const m = g * o
          for (let b = 0; b < o; b++) {
      reverseHorizontal(o, a) {
          const g = d + o / 2
          for (let m = d, b = d + o - 1; m < g; m++, b--) {
        return new ft(this)
    class Uh extends ot {
      constructor(o, a, l, u, d, g, m) {
          o.BYTES_PER_ELEMENT === 4)
            const T = o[C],
              P = (T >> 16) & 255,
            v[C] = ((P + B + j) / 4) & 255
        } else this.luminances = o
      getRow(o, a) {
        if (o < 0 || o >= this.getHeight()) throw new w('Requested row is outside the image: ' + o)
        const u = (o + this.top) * this.dataWidth + this.left
        const o = this.getWidth(),
        if (o === this.dataWidth && a === this.dataHeight) return this.luminances
        const l = o * a,
        if (o === this.dataWidth) return (k.arraycopy(this.luminances, d, u, 0, l), u)
          const m = g * o
          ;(k.arraycopy(this.luminances, d, u, m, o), (d += this.dataWidth))
      crop(o, a, l, u) {
        return new Uh(
          this.left + o,
        return new ft(this)
    class Dp extends Z {
      static forName(o) {
        return this.getCharacterSetECIByName(o)
    class Pp {
      setCompact(o) {
        this.compact = o
      setSize(o) {
        this.size = o
      setLayers(o) {
        this.layers = o
      setCodeWords(o) {
        this.codeWords = o
      setMatrix(o) {
        this.matrix = o
      static singletonList(o) {
        return [o]
      static min(o, a) {
        return o.sort(a)[0]
    class Nb {
      constructor(o) {
        this.previous = o
    class $o extends Nb {
      constructor(o, a, l) {
        ;(super(o), (this.value = a), (this.bitCount = l))
      appendTo(o, a) {
        o.appendBits(this.value, this.bitCount)
      add(o, a) {
        return new $o(this, o, a)
      addBinaryShift(o, a) {
          new $o(this, o, a)
        let o = this.value & ((1 << this.bitCount) - 1)
          (o |= 1 << this.bitCount),
          '<' + M.toBinaryString(o | (1 << this.bitCount)).substring(1) + '>'
    class Hh extends $o {
      constructor(o, a, l) {
        ;(super(o, 0, 0), (this.binaryShiftStart = a), (this.binaryShiftByteCount = l))
      appendTo(o, a) {
            (o.appendBits(31, 5),
              ? o.appendBits(this.binaryShiftByteCount - 31, 16)
                ? o.appendBits(Math.min(this.binaryShiftByteCount, 31), 5)
                : o.appendBits(this.binaryShiftByteCount - 31, 5)),
            o.appendBits(a[this.binaryShiftStart + l], 8))
      addBinaryShift(o, a) {
        return new Hh(this, o, a)
    function Mb(I, o, a) {
      return new Hh(I, o, a)
    function ca(I, o, a) {
      return new $o(I, o, a)
    const Db = ['UPPER', 'LOWER', 'DIGIT', 'MIXED', 'PUNCT'],
      oi = 0,
      tc = 1,
      Pb = new $o(null, 0, 0),
    function Lb(I) {
      for (let o of I) N.fill(o, -1)
        (I[oi][yr] = 0),
        (I[tc][yr] = 0),
        (I[tc][oi] = 28),
        (I[Op][yr] = 0),
        (I[zn][yr] = 0),
        (I[zn][oi] = 15),
        I
    const Bp = Lb(N.createInt32Array(6, 6))
      constructor(o, a, l, u) {
        ;((this.token = o), (this.mode = a), (this.binaryShiftByteCount = l), (this.bitCount = u))
      latchAndAppend(o, a) {
        if (o !== this.mode) {
          let g = Xh[this.mode][o]
        let d = o === zn ? 4 : 5
        return ((u = ca(u, a, d)), new wr(u, o, 0, l + d))
      shiftAndAppend(o, a) {
          (l = ca(l, Bp[this.mode][o], u)),
      addBinaryShiftChar(o) {
          let m = Xh[l][oi]
          ;((a = ca(a, m & 65535, m >> 16)), (u += m >> 16), (l = oi))
        return (g.binaryShiftByteCount === 2078 && (g = g.endBinaryShift(o + 1)), g)
      endBinaryShift(o) {
          (a = Mb(a, o - this.binaryShiftByteCount, this.binaryShiftByteCount)),
      isBetterThanOrEqualTo(o) {
        let a = this.bitCount + (Xh[this.mode][o.mode] >> 16)
          this.binaryShiftByteCount < o.binaryShiftByteCount
            ? (a += wr.calculateBinaryShiftCost(o) - wr.calculateBinaryShiftCost(this))
            : this.binaryShiftByteCount > o.binaryShiftByteCount &&
              o.binaryShiftByteCount > 0 &&
          a <= o.bitCount
      toBitArray(o) {
        for (let u = this.endBinaryShift(o.length).token; u !== null; u = u.getPrevious())
        for (const u of a) u.appendTo(l, o)
        return rt.format(
          Db[this.mode],
      static calculateBinaryShiftCost(o) {
        return o.binaryShiftByteCount > 62
          : o.binaryShiftByteCount > 31
            : o.binaryShiftByteCount > 0
    wr.INITIAL_STATE = new wr(Pb, oi, 0, 0)
    function Ob(I) {
      const o = rt.getCharCode(' '),
        a = rt.getCharCode('.'),
        l = rt.getCharCode(',')
      I[oi][o] = 1
      const u = rt.getCharCode('Z'),
        d = rt.getCharCode('A')
      for (let P = d; P <= u; P++) I[oi][P] = P - d + 2
      I[tc][o] = 1
      const g = rt.getCharCode('z'),
        m = rt.getCharCode('a')
      for (let P = m; P <= g; P++) I[tc][P] = P - m + 2
      I[zn][o] = 1
      const b = rt.getCharCode('9'),
        v = rt.getCharCode('0')
      for (let P = v; P <= b; P++) I[zn][P] = P - v + 2
      ;((I[zn][l] = 12), (I[zn][a] = 13))
      for (let P = 0; P < C.length; P++) I[Op][rt.getCharCode(C[P])] = P
      for (let P = 0; P < T.length; P++)
        rt.getCharCode(T[P]) > 0 && (I[yr][rt.getCharCode(T[P])] = P)
      return I
    const Gh = Ob(N.createInt32Array(5, 256))
      constructor(o) {
        this.text = o
      }
        const o = rt.getCharCode(' '),
          a = rt.getCharCode(`
            case rt.getCharCode('\r'):
            case rt.getCharCode('.'):
              d = g === o ? 3 : 0
            case rt.getCharCode(','):
              d = g === o ? 4 : 0
            case rt.getCharCode(':'):
              d = g === o ? 5 : 0
      updateStateListForChar(o, a) {
        for (let u of o) this.updateStateForChar(u, a, l)
      updateStateForChar(o, a, l) {
          d = Gh[o.getMode()][u] > 0,
            if ((g == null && (g = o.endBinaryShift(a)), !d || m === o.getMode() || m === zn)) {
            if (!d && Bp[o.getMode()][m] >= 0) {
        if (o.getBinaryShiftByteCount() > 0 || Gh[o.getMode()][u] === 0) {
          let m = o.addBinaryShiftChar(a)
      static updateStateListForPair(o, a, l) {
        for (let d of o) this.updateStateForPair(d, a, l, u)
      static updateStateForPair(o, a, l, u) {
        let d = o.endBinaryShift(a)
          o.getMode() !== yr && u.push(d.shiftAndAppend(yr, l)),
        if (o.getBinaryShiftByteCount() > 0) {
          let g = o.addBinaryShiftChar(a).addBinaryShiftChar(a + 1)
      static simplifyStates(o) {
        for (const l of o) {
    class Pt {
      static encodeBytes(o) {
        return Pt.encode(o, Pt.DEFAULT_EC_PERCENT, Pt.DEFAULT_AZTEC_LAYERS)
      static encode(o, a, l) {
        let u = new ua(o).encode(),
        if (l !== Pt.DEFAULT_AZTEC_LAYERS) {
          if (((m = l < 0), (b = Math.abs(l)), b > (m ? Pt.MAX_NB_BITS_COMPACT : Pt.MAX_NB_BITS)))
            throw new w(rt.format('Illegal value %s for layers', l))
          ;((v = Pt.totalBitsInLayer(b, m)), (C = Pt.WORD_SIZE[b]))
          if (((T = Pt.stuffBits(u, C)), T.getSize() + d > $))
            if ($ > Pt.MAX_NB_BITS) throw new w('Data too large for an Aztec code')
            if (((m = $ <= 3), (b = m ? $ + 1 : $), (v = Pt.totalBitsInLayer(b, m)), g > v))
            ;(T == null || C !== Pt.WORD_SIZE[b]) &&
              ((C = Pt.WORD_SIZE[b]), (T = Pt.stuffBits(u, C)))
            let Tt = v - (v % C)
            if (!(m && T.getSize() > C * 64) && T.getSize() + d <= Tt) break
        let P = Pt.generateCheckWords(T, v, C),
          j = Pt.generateModeMessage(m, b, B),
          U = (m ? 11 : 14) + b * 4,
          Y = new Int32Array(U),
          K
          K = U
          K = U + 1 + 2 * M.truncDivision(M.truncDivision(U, 2) - 1, 15)
          let $ = M.truncDivision(U, 2),
            Tt = M.truncDivision(K, 2)
          for (let Ct = 0; Ct < $; Ct++) {
            let pn = Ct + M.truncDivision(Ct, 15)
            ;((Y[$ - Ct - 1] = Tt - pn - 1), (Y[$ + Ct] = Tt + pn + 1))
        let nt = new _t(K)
        for (let $ = 0, Tt = 0; $ < b; $++) {
          let Ct = (b - $) * 4 + (m ? 9 : 12)
          for (let pn = 0; pn < Ct; pn++) {
              (P.get(Tt + rr + gn) && nt.set(Y[$ * 2 + gn], Y[$ * 2 + pn]),
                P.get(Tt + Ct * 2 + rr + gn) && nt.set(Y[$ * 2 + pn], Y[U - 1 - $ * 2 - gn]),
                P.get(Tt + Ct * 4 + rr + gn) &&
                  nt.set(Y[U - 1 - $ * 2 - gn], Y[U - 1 - $ * 2 - pn]),
                P.get(Tt + Ct * 6 + rr + gn) && nt.set(Y[U - 1 - $ * 2 - pn], Y[$ * 2 + gn]))
          Tt += Ct * 8
        if ((Pt.drawModeMessage(nt, m, K, j), m)) Pt.drawBullsEye(nt, M.truncDivision(K, 2), 5)
          Pt.drawBullsEye(nt, M.truncDivision(K, 2), 7)
          for (let $ = 0, Tt = 0; $ < M.truncDivision(U, 2) - 1; $ += 15, Tt += 16)
            for (let Ct = M.truncDivision(K, 2) & 1; Ct < K; Ct += 2)
              (nt.set(M.truncDivision(K, 2) - Tt, Ct),
                nt.set(M.truncDivision(K, 2) + Tt, Ct),
                nt.set(Ct, M.truncDivision(K, 2) - Tt),
                nt.set(Ct, M.truncDivision(K, 2) + Tt))
        }
        let et = new Pp()
          et.setCompact(m),
          et.setSize(K),
          et.setLayers(b),
          et.setCodeWords(B),
          et.setMatrix(nt),
          et
      static drawBullsEye(o, a, l) {
            (o.set(d, a - u), o.set(d, a + u), o.set(a - u, d), o.set(a + u, d))
        ;(o.set(a - l, a - l),
          o.set(a - l + 1, a - l),
          o.set(a - l, a - l + 1),
          o.set(a + l, a - l),
          o.set(a + l, a - l + 1),
          o.set(a + l, a + l - 1))
      }
      static generateModeMessage(o, a, l) {
          o
              (u = Pt.generateCheckWords(u, 28, 4)))
              (u = Pt.generateCheckWords(u, 40, 4))),
      static drawModeMessage(o, a, l, u) {
            ;(u.get(g) && o.set(m, d - 5),
              u.get(g + 7) && o.set(d + 5, m),
              u.get(20 - g) && o.set(m, d + 5),
              u.get(27 - g) && o.set(d - 5, m))
            ;(u.get(g) && o.set(m, d - 7),
              u.get(g + 10) && o.set(d + 7, m),
              u.get(29 - g) && o.set(m, d + 7),
              u.get(39 - g) && o.set(d - 7, m))
      static generateCheckWords(o, a, l) {
        let u = o.getSize() / l,
          d = new Wh(Pt.getGF(l)),
          m = Pt.bitsToWords(o, l, g)
      static bitsToWords(o, a, l) {
        for (d = 0, g = o.getSize() / a; d < g; d++) {
          for (let b = 0; b < a; b++) m |= o.get(d * a + b) ? 1 << (a - b - 1) : 0
      static getGF(o) {
        switch (o) {
            return Ft.AZTEC_PARAM
            return Ft.AZTEC_DATA_6
            return Ft.AZTEC_DATA_8
            return Ft.AZTEC_DATA_10
            return Ft.AZTEC_DATA_12
            throw new w('Unsupported word size ' + o)
      static stuffBits(o, a) {
          u = o.getSize(),
          for (let b = 0; b < a; b++) (g + b >= u || o.get(g + b)) && (m |= 1 << (a - 1 - b))
      static totalBitsInLayer(o, a) {
        return ((a ? 88 : 112) + 16 * o) * o
    ;((Pt.DEFAULT_EC_PERCENT = 33),
      (Pt.DEFAULT_AZTEC_LAYERS = 0),
      (Pt.MAX_NB_BITS = 32),
      (Pt.MAX_NB_BITS_COMPACT = 4),
      (Pt.WORD_SIZE = Int32Array.from([
    class ec {
      encode(o, a, l, u) {
        return this.encodeWithHints(o, a, l, u, null)
      encodeWithHints(o, a, l, u, d) {
          m = Pt.DEFAULT_EC_PERCENT,
          b = Pt.DEFAULT_AZTEC_LAYERS
            (d.has(Ie.CHARACTER_SET) && (g = Dp.forName(d.get(Ie.CHARACTER_SET).toString())),
            d.has(Ie.ERROR_CORRECTION) && (m = M.parseInt(d.get(Ie.ERROR_CORRECTION).toString())),
            d.has(Ie.AZTEC_LAYERS) && (b = M.parseInt(d.get(Ie.AZTEC_LAYERS).toString()))),
          ec.encodeLayers(o, a, l, u, g, m, b)
      static encodeLayers(o, a, l, u, d, g, m) {
        if (a !== ut.AZTEC) throw new w('Can only encode AZTEC, but got ' + a)
        let b = Pt.encode(rt.getBytes(o, d), g, m)
        return ec.renderResult(b, l, u)
      static renderResult(o, a, l) {
        let u = o.getMatrix()
          P = new _t(m, b)
          for (let U = 0, Y = C; U < d; U++, Y += v) u.get(U, B) && P.setRegion(Y, j, v, v)
        return P
    ;((n.AbstractExpandedDecoder = Nh),
      (n.AztecCode = Pp),
      (n.AztecCodeWriter = ec),
      (n.AztecDecoder = qt),
      (n.AztecEncoder = Pt),
      (n.AztecPoint = en),
      (n.BarcodeFormat = ut),
      (n.BitMatrix = _t),
      (n.BrowserCodeReader = Te),
      (n.BrowserPDF417Reader = Ib),
      (n.BrowserQRCodeReader = _b),
      (n.Code128Reader = it),
      (n.Code39Reader = Ae),
      (n.DataMatrixDecodedBitStreamParser = ei),
      (n.DecoderResult = Js),
      (n.EncodeHintType = Ie),
      (n.GenericGF = Ft),
      (n.GlobalHistogramBinarizer = xt),
      (n.GridSampler = Ih),
      (n.HTMLCanvasElementLuminanceSource = pt),
      (n.HybridBinarizer = gt),
      (n.ITFReader = Gt),
      (n.InvertedLuminanceSource = ft),
      (n.LuminanceSource = ot),
      (n.MathUtils = Dt),
      (n.MultiFormatOneDReader = qo),
      (n.OneDReader = Ce),
      (n.PDF417DecodedBitStreamParser = q),
      (n.PDF417Reader = Ve),
      (n.PDF417ResultMetadata = _p),
      (n.PerspectiveTransform = er),
      (n.QRCodeDataMask = Wn),
      (n.QRCodeDecodedBitStreamParser = se),
      (n.QRCodeDecoderErrorCorrectionLevel = Kt),
      (n.QRCodeDecoderFormatInformation = Ze),
      (n.QRCodeEncoder = Jt),
      (n.QRCodeMaskUtil = ge),
      (n.QRCodeMatrixUtil = wt),
      (n.QRCodeMode = mt),
      (n.QRCodeVersion = dt),
      (n.QRCodeWriter = Qo),
      (n.RGBLuminanceSource = Uh),
      (n.RSS14Reader = pe),
      (n.ReedSolomonDecoder = ea),
      (n.ReedSolomonEncoder = Wh),
      (n.ReedSolomonException = Xo),
      (n.Result = Bt),
      (n.ResultMetadataType = Ne),
      (n.ResultPoint = ht),
      (n.StringUtils = rt),
      (n.VideoInputDevice = Ut),
      (n.WriterException = Yt),
      (n.ZXingArrays = N),
      (n.ZXingCharset = Dp),
      (n.ZXingStringBuilder = vt),
      (n.ZXingStringEncoding = st),
var ee = Ef.exports
const MT = qy(ee),
  DT = Zy({ __proto__: null, default: MT }, [ee])
    function t(e, n, r) {
          [lt.QR_CODE, ee.BarcodeFormat.QR_CODE],
          [lt.AZTEC, ee.BarcodeFormat.AZTEC],
          [lt.CODABAR, ee.BarcodeFormat.CODABAR],
          [lt.CODE_39, ee.BarcodeFormat.CODE_39],
          [lt.CODE_93, ee.BarcodeFormat.CODE_93],
          [lt.CODE_128, ee.BarcodeFormat.CODE_128],
          [lt.DATA_MATRIX, ee.BarcodeFormat.DATA_MATRIX],
          [lt.MAXICODE, ee.BarcodeFormat.MAXICODE],
          [lt.ITF, ee.BarcodeFormat.ITF],
          [lt.EAN_13, ee.BarcodeFormat.EAN_13],
          [lt.EAN_8, ee.BarcodeFormat.EAN_8],
          [lt.PDF_417, ee.BarcodeFormat.PDF_417],
          [lt.RSS_14, ee.BarcodeFormat.RSS_14],
          [lt.RSS_EXPANDED, ee.BarcodeFormat.RSS_EXPANDED],
          [lt.UPC_A, ee.BarcodeFormat.UPC_A],
          [lt.UPC_E, ee.BarcodeFormat.UPC_E],
          [lt.UPC_EAN_EXTENSION, ee.BarcodeFormat.UPC_EAN_EXTENSION],
        !DT)
      var i = this.createZXingFormats(e),
        s = new Map()
      ;(s.set(ee.DecodeHintType.POSSIBLE_FORMATS, i),
        s.set(ee.DecodeHintType.TRY_HARDER, !1),
        (this.hints = s))
      (t.prototype.decodeAsync = function (e) {
            r(n.decode(e))
          } catch (s) {
            i(s)
      (t.prototype.decode = function (e) {
        var n = new ee.MultiFormatReader(this.verbose, this.hints),
          r = new ee.HTMLCanvasElementLuminanceSource(e),
          i = new ee.BinaryBitmap(new ee.HybridBinarizer(r)),
          s = n.decode(i)
          text: s.text,
          format: ib.create(this.toHtml5QrcodeSupportedFormats(s.format)),
      (t.prototype.createReverseFormatMap = function () {
        var e = new Map()
            e.set(n, r)
          e
      (t.prototype.toHtml5QrcodeSupportedFormats = function (e) {
        if (!this.reverseFormatMap.has(e)) throw "reverseFormatMap doesn't have ".concat(e)
        return this.reverseFormatMap.get(e)
      (t.prototype.createZXingFormats = function (e) {
        for (var n = [], r = 0, i = e; r < i.length; r++) {
          var s = i[r]
          this.formatMap.has(s)
            ? n.push(this.formatMap.get(s))
            : this.logger.logError(''.concat(s, ' is not supported by') + 'ZXingHtml5QrcodeShim')
      (t.prototype.createDebugData = function () {
      t
  PT = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
            c(s)
    return new (n || (n = Promise))(function (s, c) {
        y.done ? s(y.value) : i(y.value).then(h, f)
      p((r = r.apply(t, [])).next())
  LT = function (t, e) {
          if (s[0] & 1) throw s[1]
          return s[1]
      s,
              (s =
                    ? i.throw || ((s = i.return) && s.call(i), 0)
              !(s = s.call(i, p[1])).done)
            return s
          switch (((i = 0), s && (p = [p[0] & 2, s.value]), p[0])) {
              s = p
                ((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (p[0] === 6 || p[0] === 2))
              if (p[0] === 3 && (!s || (p[1] > s[0] && p[1] < s[3]))) {
              if (p[0] === 6 && n.label < s[1]) {
                ;((n.label = s[1]), (s = p))
              if (s && n.label < s[2]) {
                ;((n.label = s[2]), n.ops.push(p))
              ;(s[2] && n.ops.pop(), n.trys.pop())
          p = e.call(t, n)
          r = s = 0
  Wy = (function () {
    function t(e, n, r) {
          [lt.QR_CODE, 'qr_code'],
          [lt.AZTEC, 'aztec'],
          [lt.CODABAR, 'codabar'],
          [lt.CODE_39, 'code_39'],
          [lt.CODE_93, 'code_93'],
          [lt.CODE_128, 'code_128'],
          [lt.DATA_MATRIX, 'data_matrix'],
          [lt.ITF, 'itf'],
          [lt.EAN_13, 'ean_13'],
          [lt.EAN_8, 'ean_8'],
          [lt.PDF_417, 'pdf417'],
          [lt.UPC_A, 'upc_a'],
          [lt.UPC_E, 'upc_e'],
        !t.isSupported())
      var i = this.createBarcodeDetectorFormats(e)
      (t.isSupported = function () {
        var e = new BarcodeDetector({ formats: ['qr_code'] })
        return typeof e < 'u'
      (t.prototype.decodeAsync = function (e) {
        return PT(this, void 0, void 0, function () {
                return [4, this.detector.detect(e)]
      (t.prototype.selectLargestBarcode = function (e) {
        for (var n = null, r = 0, i = 0, s = e; i < s.length; i++) {
          var c = s[i],
      (t.prototype.createBarcodeDetectorFormats = function (e) {
        for (var n = [], r = 0, i = e; r < i.length; r++) {
          var s = i[r]
          this.formatMap.has(s)
            ? n.push(this.formatMap.get(s))
            : this.logger.warn(''.concat(s, ' is not supported by') + 'BarcodeDetectorDelegate')
      (t.prototype.toHtml5QrcodeSupportedFormats = function (e) {
        if (!this.reverseFormatMap.has(e)) throw "reverseFormatMap doesn't have ".concat(e)
        return this.reverseFormatMap.get(e)
      (t.prototype.createReverseFormatMap = function () {
        var e = new Map()
            e.set(n, r)
          e
      (t.prototype.createDebugData = function () {
      t
  Uy = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
            c(s)
    return new (n || (n = Promise))(function (s, c) {
        y.done ? s(y.value) : i(y.value).then(h, f)
      p((r = r.apply(t, [])).next())
  zy = function (t, e) {
          if (s[0] & 1) throw s[1]
          return s[1]
      s,
              (s =
                    ? i.throw || ((s = i.return) && s.call(i), 0)
              !(s = s.call(i, p[1])).done)
            return s
          switch (((i = 0), s && (p = [p[0] & 2, s.value]), p[0])) {
              s = p
                ((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (p[0] === 6 || p[0] === 2))
              if (p[0] === 3 && (!s || (p[1] > s[0] && p[1] < s[3]))) {
              if (p[0] === 6 && n.label < s[1]) {
                ;((n.label = s[1]), (s = p))
              if (s && n.label < s[2]) {
                ;((n.label = s[2]), n.ops.push(p))
              ;(s[2] && n.ops.pop(), n.trys.pop())
          p = e.call(t, n)
          r = s = 0
    function t(e, n, r, i) {
        n && Wy.isSupported()
          ? ((this.primaryDecoder = new Wy(e, r, i)), (this.secondaryDecoder = new Vy(e, r, i)))
          : (this.primaryDecoder = new Vy(e, r, i)))
      (t.prototype.decodeAsync = function (e) {
        return Uy(this, void 0, void 0, function () {
                return (r.trys.push([1, , 3, 4]), [4, this.getDecoder().decodeAsync(e)])
      (t.prototype.decodeRobustlyAsync = function (e) {
        return Uy(this, void 0, void 0, function () {
                return (i.trys.push([1, 3, 4, 5]), [4, this.primaryDecoder.decodeAsync(e)])
                  return [2, this.secondaryDecoder.decodeAsync(e)]
      (t.prototype.getDecoder = function () {
      (t.prototype.possiblyLogPerformance = function (e) {
          var n = performance.now() - e
      (t.prototype.possiblyFlushPerformanceReport = function () {
          for (var e = 0, n = 0, r = this.executionResults; n < r.length; n++) {
            e += i
          var s = e / this.executionResults.length
            ''.concat(s, ' ms for ').concat(this.executionResults.length, ' last runs.')
      t
    var t = function (e, n) {
        (t =
            for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s])
        t(e, n)
    return function (e, n) {
      t(e, n)
        this.constructor = e
      e.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r())
  Gu = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
            c(s)
    return new (n || (n = Promise))(function (s, c) {
        y.done ? s(y.value) : i(y.value).then(h, f)
      p((r = r.apply(t, [])).next())
  Yu = function (t, e) {
          if (s[0] & 1) throw s[1]
          return s[1]
      s,
              (s =
                    ? i.throw || ((s = i.return) && s.call(i), 0)
              !(s = s.call(i, p[1])).done)
            return s
          switch (((i = 0), s && (p = [p[0] & 2, s.value]), p[0])) {
              s = p
              break
                ((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (p[0] === 6 || p[0] === 2))
              if (p[0] === 3 && (!s || (p[1] > s[0] && p[1] < s[3]))) {
              if (p[0] === 6 && n.label < s[1]) {
                ;((n.label = s[1]), (s = p))
              if (s && n.label < s[2]) {
                ;((n.label = s[2]), n.ops.push(p))
              ;(s[2] && n.ops.pop(), n.trys.pop())
          p = e.call(t, n)
          r = s = 0
  sb = (function () {
    function t(e, n) {
      ;((this.name = e), (this.track = n))
      (t.prototype.isSupported = function () {
      (t.prototype.apply = function (e) {
        n[this.name] = e
      (t.prototype.value = function () {
        var e = this.track.getSettings()
        if (this.name in e) {
          var n = e[this.name]
      t
  BT = (function (t) {
    yp(e, t)
    function e(n, r) {
      return t.call(this, n, r) || this
      (e.prototype.min = function () {
      (e.prototype.max = function () {
      (e.prototype.step = function () {
      (e.prototype.apply = function (n) {
      (e.prototype.getCapabilities = function () {
      (e.prototype.failIfNotSupported = function () {
      e
  })(sb),
  FT = (function (t) {
    yp(e, t)
    function e(n) {
      return t.call(this, 'zoom', n) || this
    return e
  jT = (function (t) {
    yp(e, t)
    function e(n) {
      return t.call(this, 'torch', n) || this
    return e
  })(sb),
    function t(e) {
      this.track = e
      (t.prototype.zoomFeature = function () {
      (t.prototype.torchFeature = function () {
      t
  WT = (function () {
    function t(e, n, r) {
        (this.parentElement = e),
        e.append(this.surface))
      (t.prototype.createVideoElement = function (e) {
          (n.style.width = ''.concat(e, 'px')),
      (t.prototype.setupSurface = function () {
        var e = this
          var r = e.surface.clientWidth,
            i = e.surface.clientHeight
          ;(e.callbacks.onRenderSurfaceReady(r, i), e.surface.removeEventListener('playing', n))
      (t.create = function (e, n, r, i) {
          var s, c
                  (s = new t(e, n, i)),
                      [4, s.getFirstTrackOrFail().applyConstraints(c)])
                return (s.setupSurface(), [2, s])
      (t.prototype.failIfClosed = function () {
      (t.prototype.getFirstTrackOrFail = function () {
      (t.prototype.pause = function () {
      (t.prototype.resume = function (e) {
            ;(setTimeout(e, 200), n.surface.removeEventListener('playing', r))
      (t.prototype.isPaused = function () {
      (t.prototype.getSurface = function () {
      (t.prototype.getRunningTrackCapabilities = function () {
      (t.prototype.getRunningTrackSettings = function () {
      (t.prototype.applyVideoConstraints = function (e) {
            if ('aspectRatio' in e) throw "Changing 'aspectRatio' in run-time is not yet supported."
            return [2, this.getFirstTrackOrFail().applyConstraints(e)]
      (t.prototype.close = function () {
        var e = this
          var i = e.mediaStream.getVideoTracks(),
            s = i.length,
          e.mediaStream.getVideoTracks().forEach(function (h) {
            ;(e.mediaStream.removeTrack(h),
              c >= s && ((e.isClosed = !0), e.parentElement.removeChild(e.surface), n()))
      (t.prototype.getCapabilities = function () {
      t
  UT = (function () {
    function t(e) {
      this.mediaStream = e
      (t.prototype.render = function (e, n, r) {
            return [2, WT.create(e, this.mediaStream, n, r)]
      (t.create = function (e) {
                return ((n = { audio: !1, video: e }), [4, navigator.mediaDevices.getUserMedia(n)])
                return ((r = i.sent()), [2, new t(r)])
      t
  Hy = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
            c(s)
    return new (n || (n = Promise))(function (s, c) {
        y.done ? s(y.value) : i(y.value).then(h, f)
      p((r = r.apply(t, [])).next())
  Xy = function (t, e) {
          if (s[0] & 1) throw s[1]
          return s[1]
      s,
              (s =
                    ? i.throw || ((s = i.return) && s.call(i), 0)
              !(s = s.call(i, p[1])).done)
            return s
          switch (((i = 0), s && (p = [p[0] & 2, s.value]), p[0])) {
              s = p
                ((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (p[0] === 6 || p[0] === 2))
              if (p[0] === 3 && (!s || (p[1] > s[0] && p[1] < s[3]))) {
              if (p[0] === 6 && n.label < s[1]) {
                ;((n.label = s[1]), (s = p))
              if (s && n.label < s[2]) {
                ;((n.label = s[2]), n.ops.push(p))
              ;(s[2] && n.ops.pop(), n.trys.pop())
          p = e.call(t, n)
          r = s = 0
    function t() {}
      (t.failIfNotSupported = function () {
          return Xy(this, function (e) {
            return [2, new t()]
      (t.prototype.create = function (e) {
            return [2, UT.create(e)]
      t
  HT = function (t, e, n, r) {
    function i(s) {
      return s instanceof n
        ? s
            c(s)
    return new (n || (n = Promise))(function (s, c) {
        y.done ? s(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(t, [])).next())
  XT = function (t, e) {
          if (s[0] & 1) throw s[1]
          return s[1]
      s,
      }
              (s =
                    ? i.throw || ((s = i.return) && s.call(i), 0)
              !(s = s.call(i, p[1])).done)
            return s
          switch (((i = 0), s && (p = [p[0] & 2, s.value]), p[0])) {
              s = p
                ((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (p[0] === 6 || p[0] === 2))
              if (p[0] === 3 && (!s || (p[1] > s[0] && p[1] < s[3]))) {
              if (p[0] === 6 && n.label < s[1]) {
                ;((n.label = s[1]), (s = p))
              if (s && n.label < s[2]) {
                ;((n.label = s[2]), n.ops.push(p))
              ;(s[2] && n.ops.pop(), n.trys.pop())
          p = e.call(t, n)
          r = s = 0
    function t() {}
      (t.retrieve = function () {
        if (navigator.mediaDevices) return t.getCamerasFromMediaDevices()
        var e = MediaStreamTrack
        return MediaStreamTrack && e.getSources
          ? t.getCamerasFromMediaStreamTrack()
          : t.rejectWithError()
      (t.rejectWithError = function () {
        var e = Es.unableToQuerySupportedDevices()
          t.isHttpsOrLocalhost() || (e = Es.insecureContextCameraQueryError()),
          Promise.reject(e)
      (t.isHttpsOrLocalhost = function () {
        var e = location.host.split(':')[0]
        return e === '127.0.0.1' || e === 'localhost'
      (t.getCamerasFromMediaDevices = function () {
          var e, n, r, i, s, c, h
                  (e = function (p) {
                for (r = f.sent(), i = [], s = 0, c = r; s < c.length; s++)
                  ((h = c[s]),
                return (e(n), [2, i])
      (t.getCamerasFromMediaStreamTrack = function () {
        return new Promise(function (e, n) {
          var r = function (s) {
              for (var c = [], h = 0, f = s; h < f.length; h++) {
              e(c)
      t
  me
;(function (t) {
  ;((t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
    (t[(t.NOT_STARTED = 1)] = 'NOT_STARTED'),
    (t[(t.SCANNING = 2)] = 'SCANNING'),
    (t[(t.PAUSED = 3)] = 'PAUSED'))
})(me || (me = {}))
    function t() {
      ;((this.state = me.NOT_STARTED), (this.onGoingTransactionNewState = me.UNKNOWN))
      (t.prototype.directTransition = function (e) {
        ;(this.failIfTransitionOngoing(), this.validateTransition(e), (this.state = e))
      (t.prototype.startTransition = function (e) {
          this.validateTransition(e),
          (this.onGoingTransactionNewState = e),
      (t.prototype.execute = function () {
        if (this.onGoingTransactionNewState === me.UNKNOWN)
        var e = this.onGoingTransactionNewState
        ;((this.onGoingTransactionNewState = me.UNKNOWN), this.directTransition(e))
      (t.prototype.cancel = function () {
        if (this.onGoingTransactionNewState === me.UNKNOWN)
        this.onGoingTransactionNewState = me.UNKNOWN
      (t.prototype.getState = function () {
      (t.prototype.failIfTransitionOngoing = function () {
        if (this.onGoingTransactionNewState !== me.UNKNOWN)
      (t.prototype.validateTransition = function (e) {
          case me.UNKNOWN:
          case me.NOT_STARTED:
            this.failIfNewStateIs(e, [me.PAUSED])
          case me.SCANNING:
          case me.PAUSED:
      (t.prototype.failIfNewStateIs = function (e, n) {
          var s = i[r]
          if (e === s) throw 'Cannot transition from '.concat(this.state, ' to ').concat(e)
      t
    function t(e) {
      this.stateManager = e
      (t.prototype.startTransition = function (e) {
        return this.stateManager.startTransition(e)
      (t.prototype.directTransition = function (e) {
        this.stateManager.directTransition(e)
      (t.prototype.getState = function () {
      (t.prototype.canScanFile = function () {
        return this.stateManager.getState() === me.NOT_STARTED
      (t.prototype.isScanning = function () {
        return this.stateManager.getState() !== me.NOT_STARTED
      (t.prototype.isStrictlyScanning = function () {
        return this.stateManager.getState() === me.SCANNING
      (t.prototype.isPaused = function () {
        return this.stateManager.getState() === me.PAUSED
      t
  qT = (function () {
    function t() {}
      (t.create = function () {
      t
  KT = (function () {
    var t = function (e, n) {
        (t =
            for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s])
        t(e, n)
    return function (e, n) {
      t(e, n)
        this.constructor = e
      e.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r())
  In = (function (t) {
    KT(e, t)
    function e() {
      return (t !== null && t.apply(this, arguments)) || this
      (e.DEFAULT_WIDTH = 300),
      (e.DEFAULT_WIDTH_OFFSET = 2),
      (e.FILE_SCAN_MIN_HEIGHT = 300),
      (e.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100),
      (e.MIN_QR_BOX_SIZE = 50),
      (e.SHADED_LEFT = 1),
      (e.SHADED_RIGHT = 2),
      (e.SHADED_TOP = 3),
      (e.SHADED_BOTTOM = 4),
      (e.SHADED_REGION_ELEMENT_ID = 'qr-shaded-region'),
      (e.VERBOSE = !1),
      (e.BORDER_SHADER_DEFAULT_COLOR = '#ffffff'),
      (e.BORDER_SHADER_MATCH_COLOR = 'rgb(90, 193, 56)'),
      e
  })(RT),
    function t(e, n) {
        (this.fps = In.SCAN_DEFAULT_FPS),
        e
          ? (e.fps && (this.fps = e.fps),
            (this.disableFlip = e.disableFlip === !0),
            (this.qrbox = e.qrbox),
            (this.aspectRatio = e.aspectRatio),
            (this.videoConstraints = e.videoConstraints))
          : (this.disableFlip = In.DEFAULT_DISABLE_FLIP))
      (t.prototype.isMediaStreamConstraintsValid = function () {
          ? ob.isMediaStreamConstraintsValid(this.videoConstraints, this.logger)
      (t.prototype.isShadedBoxEnabled = function () {
        return !Pr(this.qrbox)
      (t.create = function (e, n) {
        return new t(e, n)
      t
    function t(e, n) {
        !document.getElementById(e))
        throw 'HTML Element with id='.concat(e, ' not found')
      ;((this.elementId = e), (this.verbose = !1))
        (this.logger = new NT(this.verbose)),
        (this.stateManagerProxy = qT.create()))
      (t.prototype.start = function (e, n, r, i) {
        var s = this
        if (!e) throw 'cameraIdOrConfig is required'
        ;(y.clientWidth ? y.clientWidth : In.DEFAULT_WIDTH,
          x = this.stateManagerProxy.startTransition(me.SCANNING)
          var k = p ? h.videoConstraints : w.createVideoConstraints(e)
          var D = {}
          ;(!p || h.aspectRatio) && (D.aspectRatio = h.aspectRatio)
          var _ = {
            onRenderSurfaceReady: function (N, M) {
              ;(w.setupUi(N, M, h), (w.isScanning = !0), w.foreverScan(h, r, c))
            .then(function (N) {
              N.create(k)
                  return M.render(s.element, D, _)
                  ;(x.cancel(), S(Es.errorGettingUserMedia(M)))
            .catch(function (N) {
              ;(x.cancel(), S(Es.cameraStreamingNotSupported()))
      (t.prototype.pause = function (e) {
        ;(this.stateManagerProxy.directTransition(me.PAUSED),
          (Pr(e) || e !== !0) && (e = !1),
          e && this.renderedCamera && this.renderedCamera.pause())
      (t.prototype.resume = function () {
        var e = this,
            ;(e.stateManagerProxy.directTransition(me.SCANNING), e.hidePausedState())
      (t.prototype.getState = function () {
      (t.prototype.stop = function () {
        var e = this
        var n = this.stateManagerProxy.startTransition(me.NOT_STARTED)
            if (e.element) {
              var s = document.getElementById(In.SHADED_REGION_ELEMENT_ID)
              s && e.element.removeChild(s)
      (t.prototype.scanFile = function (e, n) {
        return this.scanFileV2(e, n).then(function (r) {
      (t.prototype.scanFileV2 = function (e, n) {
        if (!e || !(e instanceof File))
        if ((Pr(n) && (n = !0), !this.stateManagerProxy.canScanFile()))
        return new Promise(function (i, s) {
            (r.lastScanImageFile = URL.createObjectURL(e)))
              y = p.clientWidth ? p.clientWidth : In.DEFAULT_WIDTH,
              w = Math.max(p.clientHeight ? p.clientHeight : f, In.FILE_SCAN_MIN_HEIGHT),
            var k = In.FILE_SCAN_HIDDEN_CANVAS_PADDING,
              D = Math.max(c.width, x.width),
              _ = Math.max(c.height, x.height),
              N = D + 2 * k,
              M = _ + 2 * k,
              O = r.createCanvasElement(N, M)
            ;((F.canvas.width = N), (F.canvas.height = M), F.drawImage(c, 0, 0, h, f, k, k, D, _))
                .catch(s)
              s('QR code parse error, error = '.concat(z))
            (c.onerror = s),
            (c.onabort = s),
            (c.onstalled = s),
            (c.onsuspend = s),
            (c.src = URL.createObjectURL(e)))
      (t.prototype.clear = function () {
      (t.getCameras = function () {
      (t.prototype.getRunningTrackCapabilities = function () {
      (t.prototype.getRunningTrackSettings = function () {
      (t.prototype.getRunningTrackCameraCapabilities = function () {
      (t.prototype.applyVideoConstraints = function (e) {
        if (e) {
          if (!ob.isMediaStreamConstraintsValid(e, this.logger))
        return this.getRenderedCameraOrFail().applyVideoConstraints(e)
      (t.prototype.getRenderedCameraOrFail = function () {
      (t.prototype.getSupportedFormats = function (e) {
          lt.QR_CODE,
          lt.AZTEC,
          lt.CODABAR,
          lt.CODE_39,
          lt.CODE_93,
          lt.CODE_128,
          lt.DATA_MATRIX,
          lt.MAXICODE,
          lt.ITF,
          lt.EAN_13,
          lt.EAN_8,
          lt.PDF_417,
          lt.RSS_14,
          lt.RSS_EXPANDED,
          lt.UPC_A,
          lt.UPC_E,
          lt.UPC_EAN_EXTENSION,
        if (!e || typeof e == 'boolean' || !e.formatsToSupport) return n
        if (!Array.isArray(e.formatsToSupport))
        if (e.formatsToSupport.length === 0) throw 'Atleast 1 formatsToSupport is needed.'
        for (var r = [], i = 0, s = e.formatsToSupport; i < s.length; i++) {
          var c = s[i]
          _T(c)
      (t.prototype.getUseBarCodeDetectorIfSupported = function (e) {
        if (Pr(e)) return !0
        if (!Pr(e.useBarCodeDetectorIfSupported)) return e.useBarCodeDetectorIfSupported !== !1
        if (Pr(e.experimentalFeatures)) return !0
        var n = e.experimentalFeatures
        return Pr(n.useBarCodeDetectorIfSupported) ? !0 : n.useBarCodeDetectorIfSupported !== !1
      (t.prototype.validateQrboxSize = function (e, n, r) {
          s = r.qrbox
        this.validateQrboxConfig(s)
        var c = this.toQrdimensions(e, n, s),
            if (p < In.MIN_QR_BOX_SIZE)
                ' '.concat(In.MIN_QR_BOX_SIZE, 'px.')
              p > e &&
                (p = e)),
      (t.prototype.validateQrboxConfig = function (e) {
          typeof e != 'number' &&
          typeof e != 'function' &&
          (e.width === void 0 || e.height === void 0)
      (t.prototype.toQrdimensions = function (e, n, r) {
            return r(e, n)
      (t.prototype.setupUi = function (e, n, r) {
        r.isShadedBoxEnabled() && this.validateQrboxSize(e, n, r)
        var i = Pr(r.qrbox) ? { width: e, height: n } : r.qrbox
        var s = this.toQrdimensions(e, n, i)
        s.height > n &&
        var c = r.isShadedBoxEnabled() && s.height <= n,
          h = { x: 0, y: 0, width: e, height: n },
          f = c ? this.getShadedRegionBounds(e, n, s) : h,
          c && this.possiblyInsertShadingElement(this.element, e, n, s),
      (t.prototype.createScannerPausedUiElement = function (e) {
        ;((n.innerText = Es.scannerPaused()),
          e.appendChild(n),
      (t.prototype.scanContext = function (e, n) {
                return (e(i.text, jy.createFromQrcodeResult(i)), r.possiblyUpdateShaders(!0), !0)
                var s = Es.codeParseError(i)
                return (n(s, TT.createFrom(s)), !1)
      (t.prototype.foreverScan = function (e, n, r) {
          var s = this.renderedCamera.getSurface(),
            c = s.videoWidth / s.clientWidth,
            h = s.videoHeight / s.clientHeight
          this.context.drawImage(s, y, w, f, p, 0, 0, this.qrRegion.width, this.qrRegion.height)
              i.foreverScan(e, n, r)
            }, i.getTimeoutFps(e.fps))
              !E && e.disableFlip !== !0
      (t.prototype.createVideoConstraints = function (e) {
        if (typeof e == 'string') return { deviceId: { exact: e } }
        if (typeof e == 'object') {
            s = 'exact',
            h = Object.keys(e)
          var f = Object.keys(e)[0]
            var p = e.facingMode
              if (s in p) {
                if (c(p[''.concat(s)])) return { facingMode: { exact: p[''.concat(s)] } }
                throw "'facingMode' should be string or object with" + ' '.concat(s, ' as key.')
            var w = e.deviceId
              if (s in w) return { deviceId: { exact: w[''.concat(s)] } }
              throw "'deviceId' should be string or object with" + ' '.concat(s, ' as key.')
        }
        var E = typeof e
      (t.prototype.computeCanvasDrawConfig = function (e, n, r, i) {
        if (e <= r && n <= i) {
          var s = (r - e) / 2,
          return { x: s, y: c, width: e, height: n }
          var h = e,
            e > r && ((n = (r / e) * n), (e = r)),
            n > i && ((e = (i / n) * e), (n = i)),
                ' to '.concat(e, 'X').concat(n, '.')
            this.computeCanvasDrawConfig(e, n, r, i)
      (t.prototype.clearElement = function () {
        var e = document.getElementById(this.elementId)
        e && (e.innerHTML = '')
      (t.prototype.possiblyUpdateShaders = function (e) {
        this.qrMatch !== e &&
              n.style.backgroundColor = e
                ? In.BORDER_SHADER_MATCH_COLOR
                : In.BORDER_SHADER_DEFAULT_COLOR
          (this.qrMatch = e))
      (t.prototype.possiblyCloseLastScanImageFile = function () {
      (t.prototype.createCanvasElement = function (e, n, r) {
        var i = e,
          s = n,
          (c.style.height = ''.concat(s, 'px')),
          (c.id = Pr(r) ? 'qr-canvas' : r),
      (t.prototype.getShadedRegionBounds = function (e, n, r) {
        if (r.width > e || r.height > n)
        return { x: (e - r.width) / 2, y: (n - r.height) / 2, width: r.width, height: r.height }
      (t.prototype.possiblyInsertShadingElement = function (e, n, r, i) {
          var s = document.createElement('div')
          s.style.position = 'absolute'
            ((s.style.borderLeft = ''.concat(c, 'px solid rgba(0, 0, 0, 0.48)')),
            (s.style.borderRight = ''.concat(c, 'px solid rgba(0, 0, 0, 0.48)')),
            (s.style.borderTop = ''.concat(h, 'px solid rgba(0, 0, 0, 0.48)')),
            (s.style.borderBottom = ''.concat(h, 'px solid rgba(0, 0, 0, 0.48)')),
            (s.style.boxSizing = 'border-box'),
            (s.style.top = '0px'),
            (s.style.bottom = '0px'),
            (s.style.left = '0px'),
            (s.style.right = '0px'),
            (s.id = ''.concat(In.SHADED_REGION_ELEMENT_ID)),
            ;(this.insertShaderBorders(s, p, f, -f, null, 0, !0),
              this.insertShaderBorders(s, p, f, -f, null, 0, !1),
              this.insertShaderBorders(s, p, f, null, -f, 0, !0),
              this.insertShaderBorders(s, p, f, null, -f, 0, !1),
              this.insertShaderBorders(s, f, p + f, -f, null, -f, !0),
              this.insertShaderBorders(s, f, p + f, null, -f, -f, !0),
              this.insertShaderBorders(s, f, p + f, -f, null, -f, !1),
              this.insertShaderBorders(s, f, p + f, null, -f, -f, !1),
          e.append(s)
      (t.prototype.insertShaderBorders = function (e, n, r, i, s, c, h) {
          (f.style.backgroundColor = In.BORDER_SHADER_DEFAULT_COLOR),
          s !== null && (f.style.bottom = ''.concat(s, 'px')),
          e.appendChild(f))
      (t.prototype.showPausedState = function () {
      (t.prototype.hidePausedState = function () {
      (t.prototype.getTimeoutFps = function (e) {
        return 1e3 / e
      t
;(function (t) {
  ;((t[(t.STATUS_DEFAULT = 0)] = 'STATUS_DEFAULT'),
    (t[(t.STATUS_SUCCESS = 1)] = 'STATUS_SUCCESS'),
    (t[(t.STATUS_WARNING = 2)] = 'STATUS_WARNING'),
    (t[(t.STATUS_REQUESTING_PERMISSION = 3)] = 'STATUS_REQUESTING_PERMISSION'))
const JT = ({ onScan: t }) => {
  const e = X.useRef(null),
    [i, s] = X.useState(null),
        (e.current = h),
              ;(t(f), h.stop().catch(() => {}), r(!1))
                s('Camera scan is active. Align the QR token.')
            ;(s(String(f)), r(!1))
    }, [n, t]),
    R.jsxs('div', {
        R.jsxs('div', {
            R.jsx(Vl, { size: 24, className: 'text-emerald-300' }),
            R.jsxs('div', {
                R.jsx('h3', { className: 'text-lg font-semibold', children: 'Scan Token' }),
                R.jsx('p', {
        R.jsx('div', {
          children: R.jsx('button', {
        n && R.jsx('div', { id: c, className: 'mt-4 overflow-hidden rounded-xl' }),
        i && R.jsx('p', { className: 'mt-3 text-xs text-rose-300', children: i }),
Ul.register(xs, Ja, Wr, X3, Z3, ru, yf, bf, _R)
  tN = {
  eN = () => {
    const [t, e] = X.useState(sessionStorage.getItem('VP_DECODE_UNLOCK') === '1'),
      [n, r] = X.useState(e3() ?? ''),
      [i, s] = X.useState(null),
          const S = t3(E.trim()).split('|'),
            D = S.join('|')
          if ((await ep(D)).slice(0, 8) !== k) throw new Error('Checksum mismatch')
          const _ = S[14],
            N = JSON.parse(_),
          ;(s({
            answers: N,
          ;(h(String(S)), s(null))
          k = i.answers.map((_) => _.rtMs),
          D = {
            labels: i.answers.map((_) => `Q${_.questionId}`),
                pointBackgroundColor: k.map((_) =>
                  _ < 450 ? 'rgba(248, 113, 113, 0.9)' : 'rgba(148, 163, 184, 0.9)'
        return { radarData: E, barData: S, lineData: D }
    return t
      ? R.jsxs('div', {
            R.jsxs('div', {
                R.jsxs('div', {
                    R.jsx('p', {
                    R.jsx('h1', {
                    R.jsx('p', {
                R.jsxs('button', {
                  children: [R.jsx(q6, { size: 18 }), 'Download Report'],
            R.jsxs('section', {
                R.jsxs('div', {
                    R.jsxs('div', {
                        R.jsx(Eo, { size: 22, className: 'text-emerald-300' }),
                        R.jsxs('div', {
                            R.jsx('h3', {
                            R.jsx('p', {
                    R.jsxs('div', {
                        R.jsxs('div', {
                            R.jsx('span', { children: 'Session' }),
                            R.jsx('span', { className: 'text-emerald-200', children: 'Unlocked' }),
                        R.jsxs('div', {
                            R.jsx('span', { children: 'Storage' }),
                            R.jsx('span', { className: 'text-slate-300', children: 'Local only' }),
                        R.jsxs('div', {
                            R.jsx('span', { children: 'Report' }),
                            R.jsx('span', {
                R.jsxs('div', {
                    R.jsx('h3', {
                    R.jsx('ul', {
                      ].map((E) => R.jsx('li', { className: 'list-item', children: E }, E)),
            R.jsxs('div', {
                R.jsxs('div', {
                    R.jsxs('div', {
                        R.jsx(Eo, { size: 22, className: 'text-emerald-300' }),
                        R.jsxs('div', {
                            R.jsx('h3', {
                            R.jsx('p', {
                    R.jsx('textarea', {
                    c && R.jsx('p', { className: 'mt-2 text-xs text-rose-300', children: c }),
                    R.jsx('button', {
                R.jsx(JT, {
              R.jsxs(Kn.div, {
                  R.jsxs('section', {
                      R.jsxs('div', {
                          R.jsxs('div', {
                              R.jsx('p', {
                              R.jsx('h2', {
                          R.jsx('span', {
                      R.jsxs('div', {
                          R.jsxs('div', {
                              R.jsx('p', {
                              R.jsxs('p', {
                          R.jsxs('div', {
                              R.jsx('p', {
                              R.jsx('p', {
                          R.jsxs('div', {
                              R.jsxs('div', {
                                children: [R.jsx($0, { size: 18 }), 'Integrity Score'],
                              R.jsx('p', {
                  R.jsxs('section', {
                      R.jsxs('div', {
                          R.jsx(Qc, { size: 22, className: 'text-rose-300' }),
                          R.jsxs('div', {
                              R.jsx('h2', {
                              R.jsx('p', {
                      R.jsxs('div', {
                            R.jsx('p', {
                            R.jsxs(
                              Kn.div,
                                  R.jsx(Qc, { size: 18, className: 'text-rose-300' }),
                                  R.jsx('span', {
                      R.jsx('p', {
                        R.jsx('p', {
                  R.jsxs('section', {
                      R.jsxs('div', {
                          R.jsx(bh, { size: 22, className: 'text-emerald-300' }),
                          R.jsxs('div', {
                              R.jsx('h2', {
                              R.jsx('p', {
                      R.jsxs('div', {
                          R.jsx('div', {
                            children: R.jsx(tb, {
                          R.jsx('div', {
                            children: R.jsx(aT, {
                      R.jsx('div', {
                          R.jsxs(
                                R.jsx('p', {
                                R.jsx('p', {
                  R.jsxs('section', {
                      R.jsxs('div', {
                            ? R.jsx(sf, { size: 22, className: 'text-amber-300' })
                            : R.jsx(K6, { size: 22, className: 'text-emerald-300' }),
                          R.jsxs('div', {
                              R.jsx('h2', {
                              R.jsx('p', {
                      R.jsxs('div', {
                            R.jsx('p', {
                            R.jsxs(
                                  R.jsx('p', {
                                  R.jsx('p', {
                                    children: tN[E] ?? 'Integrity signal observed.',
                  R.jsxs('section', {
                      R.jsxs('div', {
                          R.jsx(Vl, { size: 20, className: 'text-slate-300' }),
                          R.jsxs('div', {
                              R.jsx('h2', {
                              R.jsx('p', {
                      R.jsx('div', {
                        children: R.jsx(sT, {
                  R.jsxs('section', {
                      R.jsx('h2', {
                      R.jsx('p', {
                      R.jsx('div', {
                            D = `${E.trait} +${k}`,
                            _ = S.rtMs < 450
                          return R.jsxs(
                                R.jsxs('div', {
                                    R.jsxs('div', {
                                        R.jsxs('p', {
                                        R.jsx('h3', {
                                    R.jsxs('div', {
                                          R.jsxs('span', {
                                            children: [R.jsx(sf, { size: 12 }), 'Lie Trap'],
                                          R.jsxs('span', {
                                            children: [R.jsx(Qc, { size: 12 }), 'Safety Trigger'],
                                R.jsxs('div', {
                                    R.jsxs('span', { children: ['Answer: ', S.answer] }),
                                    R.jsxs('span', { children: ['RT: ', S.rtMs, 'ms'] }),
                                    R.jsxs('span', { children: ['Impact: ', D] }),
                                    _ &&
                                      R.jsx('span', {
                                R.jsxs('p', {
                                    _ ? 'defensive' : 'deliberate',
      : R.jsxs('div', {
            R.jsx(IT, { onUnlock: () => e(!0) }),
            R.jsx('p', {
  nN = () =>
    R.jsx('footer', {
      children: R.jsxs('div', {
          R.jsxs('div', {
              R.jsxs('div', {
                  R.jsxs('div', {
                      R.jsx('span', {
                        children: R.jsx(Qs, { size: 18 }),
                      R.jsxs('div', {
                          R.jsx('p', {
                          R.jsx('p', {
                  R.jsx('p', {
              R.jsxs('div', {
                  R.jsx('p', {
                  R.jsxs('ul', {
                      R.jsxs('li', {
                          R.jsx(tp, { size: 16, className: 'text-emerald-300' }),
                      R.jsxs('li', {
                          R.jsx(J0, { size: 16, className: 'text-emerald-300' }),
                      R.jsxs('li', {
                          R.jsx(Q6, { size: 16, className: 'text-emerald-300' }),
              R.jsxs('div', {
                  R.jsx('p', {
                  R.jsx('p', {
                  R.jsxs('div', {
                      R.jsx(tr, {
                      R.jsx(tr, {
          R.jsxs('div', {
              R.jsx('span', {
              R.jsx('span', {
  rN = [
  iN = () =>
    R.jsx('header', {
      children: R.jsxs('div', {
          R.jsxs(tr, {
              R.jsx('span', {
                children: R.jsx(Qs, { size: 18 }),
              R.jsxs('div', {
                  R.jsx('p', {
                  R.jsx('p', {
          R.jsx('nav', {
            children: rN.map((t) =>
              R.jsx(
                  to: t.to,
                  className: ({ isActive: e }) => `nav-link ${e ? 'nav-link-active' : ''}`,
                  children: t.label,
                t.to
          R.jsx('div', {
            children: R.jsx(tr, {
  oN = {
  sN = () =>
    R.jsxs('div', {
        R.jsx(iN, {}),
        R.jsx(Kn.main, {
          variants: oN,
          children: R.jsxs(iC, {
              R.jsx(rs, { path: '/', element: R.jsx(ok, {}) }),
              R.jsx(rs, { path: '/quiz', element: R.jsx(yk, {}) }),
              R.jsx(rs, { path: '/result', element: R.jsx(CT, {}) }),
              R.jsx(rs, { path: '/restore', element: R.jsx(eN, {}) }),
              R.jsx(rs, { path: '*', element: R.jsx(nC, { to: '/', replace: !0 }) }),
        R.jsx(nN, {}),
cw(ab).render(R.jsx(A.StrictMode, { children: R.jsx(dC, { children: R.jsx(sN, {}) }) }))
          l.setNumber(s, a + u, 0)
        }
      }
      static embedPositionAdjustmentPattern(s, a, l) {
        for (let u = 0; u < 5; ++u) {
          const d = we.POSITION_ADJUSTMENT_PATTERN[u]
          for (let g = 0; g < 5; ++g) l.setNumber(s + g, a + u, d[g])
        }
      }
      static embedPositionDetectionPattern(s, a, l) {
        for (let u = 0; u < 7; ++u) {
          const d = we.POSITION_DETECTION_PATTERN[u]
          for (let g = 0; g < 7; ++g) l.setNumber(s + g, a + u, d[g])
        }
      }
      static embedPositionDetectionPatternsAndSeparators(s) {
        const a = we.POSITION_DETECTION_PATTERN[0].length
        ;(we.embedPositionDetectionPattern(0, 0, s),
          we.embedPositionDetectionPattern(s.getWidth() - a, 0, s),
          we.embedPositionDetectionPattern(0, s.getWidth() - a, s))
        const l = 8
        ;(we.embedHorizontalSeparationPattern(0, l - 1, s),
          we.embedHorizontalSeparationPattern(s.getWidth() - l, l - 1, s),
          we.embedHorizontalSeparationPattern(0, s.getWidth() - l, s))
        const u = 7
        ;(we.embedVerticalSeparationPattern(u, 0, s),
          we.embedVerticalSeparationPattern(s.getHeight() - u - 1, 0, s),
          we.embedVerticalSeparationPattern(u, s.getHeight() - u, s))
      }
      static maybeEmbedPositionAdjustmentPatterns(s, a) {
        if (s.getVersionNumber() < 2) return
        const l = s.getVersionNumber() - 1,
          u = we.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[l]
        for (let d = 0, g = u.length; d !== g; d++) {
          const m = u[d]
          if (m >= 0)
            for (let b = 0; b !== g; b++) {
              const v = u[b]
              v >= 0 &&
                we.isEmpty(a.get(v, m)) &&
                we.embedPositionAdjustmentPattern(v - 2, m - 2, a)
            }
        }
      }
    }
    ;((we.POSITION_DETECTION_PATTERN = Array.from([
      Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
    ])),
      (we.POSITION_ADJUSTMENT_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1]),
      ])),
      (we.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
        Int32Array.from([6, 30, 58, 86, 114, 142, 170]),
      ])),
      (we.TYPE_INFO_COORDINATES = Array.from([
        Int32Array.from([8, 0]),
        Int32Array.from([8, 1]),
        Int32Array.from([8, 2]),
        Int32Array.from([8, 3]),
        Int32Array.from([8, 4]),
        Int32Array.from([8, 5]),
        Int32Array.from([8, 7]),
        Int32Array.from([8, 8]),
        Int32Array.from([7, 8]),
        Int32Array.from([5, 8]),
        Int32Array.from([4, 8]),
        Int32Array.from([3, 8]),
        Int32Array.from([2, 8]),
        Int32Array.from([1, 8]),
        Int32Array.from([0, 8]),
      ])),
      (we.VERSION_INFO_POLY = 7973),
      (we.TYPE_INFO_POLY = 1335),
      (we.TYPE_INFO_MASK_PATTERN = 21522))
    class Nb {
      constructor(s, a) {
        ;((this.dataBytes = s), (this.errorCorrectionBytes = a))
      }
      getDataBytes() {
        return this.dataBytes
      }
      getErrorCorrectionBytes() {
        return this.errorCorrectionBytes
      }
    }
    class Je {
      constructor() {}
      static calculateMaskPenalty(s) {
        return (
          gt.applyMaskPenaltyRule1(s) +
          gt.applyMaskPenaltyRule2(s) +
          gt.applyMaskPenaltyRule3(s) +
          gt.applyMaskPenaltyRule4(s)
        )
      }
      static encode(s, a, l = null) {
        let u = Je.DEFAULT_BYTE_MODE_ENCODING
        const d = l !== null && l.get(_t.CHARACTER_SET) !== void 0
        d && (u = l.get(_t.CHARACTER_SET).toString())
        const g = this.chooseMode(s, u),
          m = new O()
        if (g === me.BYTE && (d || Je.DEFAULT_BYTE_MODE_ENCODING !== u)) {
          const te = Z.getCharacterSetECIByName(u)
          te !== void 0 && this.appendECI(te, m)
        }
        this.appendModeInfo(g, m)
        const b = new O()
        this.appendBytes(s, g, b, u)
        let v
        if (l !== null && l.get(_t.QR_VERSION) !== void 0) {
          const te = Number.parseInt(l.get(_t.QR_VERSION).toString(), 10)
          v = de.getVersionForNumber(te)
          const $ = this.calculateBitsNeeded(g, m, b, v)
          if (!this.willFit($, v, a)) throw new Ye('Data too big for requested version')
        } else v = this.recommendVersion(a, g, m, b)
        const C = new O()
        C.appendBitArray(m)
        const T = g === me.BYTE ? b.getSizeInBytes() : s.length
        ;(this.appendLengthInfo(T, v, g, C), C.appendBitArray(b))
        const D = v.getECBlocksForLevel(a),
          B = v.getTotalCodewords() - D.getTotalECCodewords()
        this.terminateBits(B, C)
        const j = this.interleaveWithECBytes(C, v.getTotalCodewords(), B, D.getNumBlocks()),
          W = new Yi()
        ;(W.setECLevel(a), W.setMode(g), W.setVersion(v))
        const Y = v.getDimensionForVersion(),
          q = new Jl(Y, Y),
          ne = this.chooseMaskPattern(j, a, v, q)
        return (W.setMaskPattern(ne), we.buildMatrix(j, a, v, ne, q), W.setMatrix(q), W)
      }
      static recommendVersion(s, a, l, u) {
        const d = this.calculateBitsNeeded(a, l, u, de.getVersionForNumber(1)),
          g = this.chooseVersion(d, s),
          m = this.calculateBitsNeeded(a, l, u, g)
        return this.chooseVersion(m, s)
      }
      static calculateBitsNeeded(s, a, l, u) {
        return a.getSize() + s.getCharacterCountBits(u) + l.getSize()
      }
      static getAlphanumericCode(s) {
        return s < Je.ALPHANUMERIC_TABLE.length ? Je.ALPHANUMERIC_TABLE[s] : -1
      }
      static chooseMode(s, a = null) {
        if (Z.SJIS.getName() === a && this.isOnlyDoubleByteKanji(s)) return me.KANJI
        let l = !1,
          u = !1
        for (let d = 0, g = s.length; d < g; ++d) {
          const m = s.charAt(d)
          if (Je.isDigit(m)) l = !0
          else if (this.getAlphanumericCode(m.charCodeAt(0)) !== -1) u = !0
          else return me.BYTE
        }
        return u ? me.ALPHANUMERIC : l ? me.NUMERIC : me.BYTE
      }
      static isOnlyDoubleByteKanji(s) {
        let a
        try {
          a = oe.encode(s, Z.SJIS)
        } catch {
          return !1
        }
        const l = a.length
        if (l % 2 !== 0) return !1
        for (let u = 0; u < l; u += 2) {
          const d = a[u] & 255
          if ((d < 129 || d > 159) && (d < 224 || d > 235)) return !1
        }
        return !0
      }
      static chooseMaskPattern(s, a, l, u) {
        let d = Number.MAX_SAFE_INTEGER,
          g = -1
        for (let m = 0; m < Yi.NUM_MASK_PATTERNS; m++) {
          we.buildMatrix(s, a, l, m, u)
          let b = this.calculateMaskPenalty(u)
          b < d && ((d = b), (g = m))
        }
        return g
      }
      static chooseVersion(s, a) {
        for (let l = 1; l <= 40; l++) {
          const u = de.getVersionForNumber(l)
          if (Je.willFit(s, u, a)) return u
        }
        throw new Ye('Data too big')
      }
      static willFit(s, a, l) {
        const u = a.getTotalCodewords(),
          d = a.getECBlocksForLevel(l).getTotalECCodewords(),
          g = u - d,
          m = (s + 7) / 8
        return g >= m
      }
      static terminateBits(s, a) {
        const l = s * 8
        if (a.getSize() > l)
          throw new Ye('data bits cannot fit in the QR Code' + a.getSize() + ' > ' + l)
        for (let g = 0; g < 4 && a.getSize() < l; ++g) a.appendBit(!1)
        const u = a.getSize() & 7
        if (u > 0) for (let g = u; g < 8; g++) a.appendBit(!1)
        const d = s - a.getSizeInBytes()
        for (let g = 0; g < d; ++g) a.appendBits(g & 1 ? 17 : 236, 8)
        if (a.getSize() !== l) throw new Ye('Bits size does not equal capacity')
      }
      static getNumDataBytesAndNumECBytesForBlockID(s, a, l, u, d, g) {
        if (u >= l) throw new Ye('Block ID too large')
        const m = s % l,
          b = l - m,
          v = Math.floor(s / l),
          C = v + 1,
          T = Math.floor(a / l),
          D = T + 1,
          B = v - T,
          j = C - D
        if (B !== j) throw new Ye('EC bytes mismatch')
        if (l !== b + m) throw new Ye('RS blocks mismatch')
        if (s !== (T + B) * b + (D + j) * m) throw new Ye('Total bytes mismatch')
        u < b ? ((d[0] = T), (g[0] = B)) : ((d[0] = D), (g[0] = j))
      }
      static interleaveWithECBytes(s, a, l, u) {
        if (s.getSizeInBytes() !== l) throw new Ye('Number of bits and data bytes does not match')
        let d = 0,
          g = 0,
          m = 0
        const b = new Array()
        for (let C = 0; C < u; ++C) {
          const T = new Int32Array(1),
            D = new Int32Array(1)
          Je.getNumDataBytesAndNumECBytesForBlockID(a, l, u, C, T, D)
          const B = T[0],
            j = new Uint8Array(B)
          s.toBytes(8 * d, j, 0, B)
          const W = Je.generateECBytes(j, D[0])
          ;(b.push(new Nb(j, W)), (g = Math.max(g, B)), (m = Math.max(m, W.length)), (d += T[0]))
        }
        if (l !== d) throw new Ye('Data bytes does not match offset')
        const v = new O()
        for (let C = 0; C < g; ++C)
          for (const T of b) {
            const D = T.getDataBytes()
            C < D.length && v.appendBits(D[C], 8)
          }
        for (let C = 0; C < m; ++C)
          for (const T of b) {
            const D = T.getErrorCorrectionBytes()
            C < D.length && v.appendBits(D[C], 8)
          }
        if (a !== v.getSizeInBytes())
          throw new Ye('Interleaving error: ' + a + ' and ' + v.getSizeInBytes() + ' differ.')
        return v
      }
      static generateECBytes(s, a) {
        const l = s.length,
          u = new Int32Array(l + a)
        for (let g = 0; g < l; g++) u[g] = s[g] & 255
        new Uh(Fe.QR_CODE_FIELD_256).encode(u, a)
        const d = new Uint8Array(a)
        for (let g = 0; g < a; g++) d[g] = u[l + g]
        return d
      }
      static appendModeInfo(s, a) {
        a.appendBits(s.getBits(), 4)
      }
      static appendLengthInfo(s, a, l, u) {
        const d = l.getCharacterCountBits(a)
        if (s >= 1 << d) throw new Ye(s + ' is bigger than ' + ((1 << d) - 1))
        u.appendBits(s, d)
      }
      static appendBytes(s, a, l, u) {
        switch (a) {
          case me.NUMERIC:
            Je.appendNumericBytes(s, l)
            break
          case me.ALPHANUMERIC:
            Je.appendAlphanumericBytes(s, l)
            break
          case me.BYTE:
            Je.append8BitBytes(s, l, u)
            break
          case me.KANJI:
            Je.appendKanjiBytes(s, l)
            break
          default:
            throw new Ye('Invalid mode: ' + a)
        }
      }
      static getDigit(s) {
        return s.charCodeAt(0) - 48
      }
      static isDigit(s) {
        const a = Je.getDigit(s)
        return a >= 0 && a <= 9
      }
      static appendNumericBytes(s, a) {
        const l = s.length
        let u = 0
        for (; u < l; ) {
          const d = Je.getDigit(s.charAt(u))
          if (u + 2 < l) {
            const g = Je.getDigit(s.charAt(u + 1)),
              m = Je.getDigit(s.charAt(u + 2))
            ;(a.appendBits(d * 100 + g * 10 + m, 10), (u += 3))
          } else if (u + 1 < l) {
            const g = Je.getDigit(s.charAt(u + 1))
            ;(a.appendBits(d * 10 + g, 7), (u += 2))
          } else (a.appendBits(d, 4), u++)
        }
      }
      static appendAlphanumericBytes(s, a) {
        const l = s.length
        let u = 0
        for (; u < l; ) {
          const d = Je.getAlphanumericCode(s.charCodeAt(u))
          if (d === -1) throw new Ye()
          if (u + 1 < l) {
            const g = Je.getAlphanumericCode(s.charCodeAt(u + 1))
            if (g === -1) throw new Ye()
            ;(a.appendBits(d * 45 + g, 11), (u += 2))
          } else (a.appendBits(d, 6), u++)
        }
      }
      static append8BitBytes(s, a, l) {
        let u
        try {
          u = oe.encode(s, l)
        } catch (d) {
          throw new Ye(d)
        }
        for (let d = 0, g = u.length; d !== g; d++) {
          const m = u[d]
          a.appendBits(m, 8)
        }
      }
      static appendKanjiBytes(s, a) {
        let l
        try {
          l = oe.encode(s, Z.SJIS)
        } catch (d) {
          throw new Ye(d)
        }
        const u = l.length
        for (let d = 0; d < u; d += 2) {
          const g = l[d] & 255,
            m = l[d + 1] & 255,
            b = ((g << 8) & 4294967295) | m
          let v = -1
          if (
            (b >= 33088 && b <= 40956
              ? (v = b - 33088)
              : b >= 57408 && b <= 60351 && (v = b - 49472),
            v === -1)
          )
            throw new Ye('Invalid byte sequence')
          const C = (v >> 8) * 192 + (v & 255)
          a.appendBits(C, 13)
        }
      }
      static appendECI(s, a) {
        ;(a.appendBits(me.ECI.getBits(), 4), a.appendBits(s.getValue(), 8))
      }
    }
    ;((Je.ALPHANUMERIC_TABLE = Int32Array.from([
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41,
      42, 43, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16,
      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1,
      -1,
    ])),
      (Je.DEFAULT_BYTE_MODE_ENCODING = Z.UTF8.getName()))
    class Zi {
      write(s, a, l, u = null) {
        if (s.length === 0) throw new w('Found empty contents')
        if (a < 0 || l < 0) throw new w('Requested dimensions are too small: ' + a + 'x' + l)
        let d = qe.L,
          g = Zi.QUIET_ZONE_SIZE
        u !== null &&
          (u.get(_t.ERROR_CORRECTION) !== void 0 &&
            (d = qe.fromString(u.get(_t.ERROR_CORRECTION).toString())),
          u.get(_t.MARGIN) !== void 0 && (g = Number.parseInt(u.get(_t.MARGIN).toString(), 10)))
        const m = Je.encode(s, d, u)
        return this.renderResult(m, a, l, g)
      }
      writeToDom(s, a, l, u, d = null) {
        typeof s == 'string' && (s = document.querySelector(s))
        const g = this.write(a, l, u, d)
        s && s.appendChild(g)
      }
      renderResult(s, a, l, u) {
        const d = s.getMatrix()
        if (d === null) throw new dr()
        const g = d.getWidth(),
          m = d.getHeight(),
          b = g + u * 2,
          v = m + u * 2,
          C = Math.max(a, b),
          T = Math.max(l, v),
          D = Math.min(Math.floor(C / b), Math.floor(T / v)),
          B = Math.floor((C - g * D) / 2),
          j = Math.floor((T - m * D) / 2),
          W = this.createSVGElement(C, T)
        for (let Y = 0, q = j; Y < m; Y++, q += D)
          for (let ne = 0, te = B; ne < g; ne++, te += D)
            if (d.get(ne, Y) === 1) {
              const $ = this.createSvgRectElement(te, q, D, D)
              W.appendChild($)
            }
        return W
      }
      createSVGElement(s, a) {
        const l = document.createElementNS(Zi.SVG_NS, 'svg')
        return (
          l.setAttributeNS(null, 'height', s.toString()),
          l.setAttributeNS(null, 'width', a.toString()),
          l
        )
      }
      createSvgRectElement(s, a, l, u) {
        const d = document.createElementNS(Zi.SVG_NS, 'rect')
        return (
          d.setAttributeNS(null, 'x', s.toString()),
          d.setAttributeNS(null, 'y', a.toString()),
          d.setAttributeNS(null, 'height', l.toString()),
          d.setAttributeNS(null, 'width', u.toString()),
          d.setAttributeNS(null, 'fill', '#000000'),
          d
        )
      }
    }
    ;((Zi.QUIET_ZONE_SIZE = 4), (Zi.SVG_NS = 'http://www.w3.org/2000/svg'))
    class qs {
      encode(s, a, l, u, d) {
        if (s.length === 0) throw new w('Found empty contents')
        if (a !== ue.QR_CODE) throw new w('Can only encode QR_CODE, but got ' + a)
        if (l < 0 || u < 0) throw new w(`Requested dimensions are too small: ${l}x${u}`)
        let g = qe.L,
          m = qs.QUIET_ZONE_SIZE
        d !== null &&
          (d.get(_t.ERROR_CORRECTION) !== void 0 &&
            (g = qe.fromString(d.get(_t.ERROR_CORRECTION).toString())),
          d.get(_t.MARGIN) !== void 0 && (m = Number.parseInt(d.get(_t.MARGIN).toString(), 10)))
        const b = Je.encode(s, g, d)
        return qs.renderResult(b, l, u, m)
      }
      static renderResult(s, a, l, u) {
        const d = s.getMatrix()
        if (d === null) throw new dr()
        const g = d.getWidth(),
          m = d.getHeight(),
          b = g + u * 2,
          v = m + u * 2,
          C = Math.max(a, b),
          T = Math.max(l, v),
          D = Math.min(Math.floor(C / b), Math.floor(T / v)),
          B = Math.floor((C - g * D) / 2),
          j = Math.floor((T - m * D) / 2),
          W = new Ie(C, T)
        for (let Y = 0, q = j; Y < m; Y++, q += D)
          for (let ne = 0, te = B; ne < g; ne++, te += D)
            d.get(ne, Y) === 1 && W.setRegion(te, q, D, D)
        return W
      }
    }
    qs.QUIET_ZONE_SIZE = 4
    class Tb {
      encode(s, a, l, u, d) {
        let g
        switch (a) {
          case ue.QR_CODE:
            g = new qs()
            break
          default:
            throw new w('No encoder available for format ' + a)
        }
        return g.encode(s, a, l, u, d)
      }
    }
    class mr extends se {
      constructor(s, a, l, u, d, g, m, b) {
        if (
          (super(g, m),
          (this.yuvData = s),
          (this.dataWidth = a),
          (this.dataHeight = l),
          (this.left = u),
          (this.top = d),
          u + g > a || d + m > l)
        )
          throw new w('Crop rectangle does not fit within image data.')
        b && this.reverseHorizontal(g, m)
      }
      getRow(s, a) {
        if (s < 0 || s >= this.getHeight()) throw new w('Requested row is outside the image: ' + s)
        const l = this.getWidth()
        ;(a == null || a.length < l) && (a = new Uint8ClampedArray(l))
        const u = (s + this.top) * this.dataWidth + this.left
        return (k.arraycopy(this.yuvData, u, a, 0, l), a)
      }
      getMatrix() {
        const s = this.getWidth(),
          a = this.getHeight()
        if (s === this.dataWidth && a === this.dataHeight) return this.yuvData
        const l = s * a,
          u = new Uint8ClampedArray(l)
        let d = this.top * this.dataWidth + this.left
        if (s === this.dataWidth) return (k.arraycopy(this.yuvData, d, u, 0, l), u)
        for (let g = 0; g < a; g++) {
          const m = g * s
          ;(k.arraycopy(this.yuvData, d, u, m, s), (d += this.dataWidth))
        }
        return u
      }
      isCropSupported() {
        return !0
      }
      crop(s, a, l, u) {
        return new mr(
          this.yuvData,
          this.dataWidth,
          this.dataHeight,
          this.left + s,
          this.top + a,
          l,
          u,
          !1
        )
      }
      renderThumbnail() {
        const s = this.getWidth() / mr.THUMBNAIL_SCALE_FACTOR,
          a = this.getHeight() / mr.THUMBNAIL_SCALE_FACTOR,
          l = new Int32Array(s * a),
          u = this.yuvData
        let d = this.top * this.dataWidth + this.left
        for (let g = 0; g < a; g++) {
          const m = g * s
          for (let b = 0; b < s; b++) {
            const v = u[d + b * mr.THUMBNAIL_SCALE_FACTOR] & 255
            l[m + b] = 4278190080 | (v * 65793)
          }
          d += this.dataWidth * mr.THUMBNAIL_SCALE_FACTOR
        }
        return l
      }
      getThumbnailWidth() {
        return this.getWidth() / mr.THUMBNAIL_SCALE_FACTOR
      }
      getThumbnailHeight() {
        return this.getHeight() / mr.THUMBNAIL_SCALE_FACTOR
      }
      reverseHorizontal(s, a) {
        const l = this.yuvData
        for (
          let u = 0, d = this.top * this.dataWidth + this.left;
          u < a;
          u++, d += this.dataWidth
        ) {
          const g = d + s / 2
          for (let m = d, b = d + s - 1; m < g; m++, b--) {
            const v = l[m]
            ;((l[m] = l[b]), (l[b] = v))
          }
        }
      }
      invert() {
        return new fe(this)
      }
    }
    mr.THUMBNAIL_SCALE_FACTOR = 2
    class Wh extends se {
      constructor(s, a, l, u, d, g, m) {
        if (
          (super(a, l),
          (this.dataWidth = u),
          (this.dataHeight = d),
          (this.left = g),
          (this.top = m),
          s.BYTES_PER_ELEMENT === 4)
        ) {
          const b = a * l,
            v = new Uint8ClampedArray(b)
          for (let C = 0; C < b; C++) {
            const T = s[C],
              D = (T >> 16) & 255,
              B = (T >> 7) & 510,
              j = T & 255
            v[C] = ((D + B + j) / 4) & 255
          }
          this.luminances = v
        } else this.luminances = s
        if (
          (u === void 0 && (this.dataWidth = a),
          d === void 0 && (this.dataHeight = l),
          g === void 0 && (this.left = 0),
          m === void 0 && (this.top = 0),
          this.left + a > this.dataWidth || this.top + l > this.dataHeight)
        )
          throw new w('Crop rectangle does not fit within image data.')
      }
      getRow(s, a) {
        if (s < 0 || s >= this.getHeight()) throw new w('Requested row is outside the image: ' + s)
        const l = this.getWidth()
        ;(a == null || a.length < l) && (a = new Uint8ClampedArray(l))
        const u = (s + this.top) * this.dataWidth + this.left
        return (k.arraycopy(this.luminances, u, a, 0, l), a)
      }
      getMatrix() {
        const s = this.getWidth(),
          a = this.getHeight()
        if (s === this.dataWidth && a === this.dataHeight) return this.luminances
        const l = s * a,
          u = new Uint8ClampedArray(l)
        let d = this.top * this.dataWidth + this.left
        if (s === this.dataWidth) return (k.arraycopy(this.luminances, d, u, 0, l), u)
        for (let g = 0; g < a; g++) {
          const m = g * s
          ;(k.arraycopy(this.luminances, d, u, m, s), (d += this.dataWidth))
        }
        return u
      }
      isCropSupported() {
        return !0
      }
      crop(s, a, l, u) {
        return new Wh(
          this.luminances,
          l,
          u,
          this.dataWidth,
          this.dataHeight,
          this.left + s,
          this.top + a
        )
      }
      invert() {
        return new fe(this)
      }
    }
    class Pp extends Z {
      static forName(s) {
        return this.getCharacterSetECIByName(s)
      }
    }
    class zh {}
    zh.ISO_8859_1 = Z.ISO8859_1
    class Dp {
      isCompact() {
        return this.compact
      }
      setCompact(s) {
        this.compact = s
      }
      getSize() {
        return this.size
      }
      setSize(s) {
        this.size = s
      }
      getLayers() {
        return this.layers
      }
      setLayers(s) {
        this.layers = s
      }
      getCodeWords() {
        return this.codeWords
      }
      setCodeWords(s) {
        this.codeWords = s
      }
      getMatrix() {
        return this.matrix
      }
      setMatrix(s) {
        this.matrix = s
      }
    }
    class Lp {
      static singletonList(s) {
        return [s]
      }
      static min(s, a) {
        return s.sort(a)[0]
      }
    }
    class Rb {
      constructor(s) {
        this.previous = s
      }
      getPrevious() {
        return this.previous
      }
    }
    class Qs extends Rb {
      constructor(s, a, l) {
        ;(super(s), (this.value = a), (this.bitCount = l))
      }
      appendTo(s, a) {
        s.appendBits(this.value, this.bitCount)
      }
      add(s, a) {
        return new Qs(this, s, a)
      }
      addBinaryShift(s, a) {
        return (
          console.warn('addBinaryShift on SimpleToken, this simply returns a copy of this token'),
          new Qs(this, s, a)
        )
      }
      toString() {
        let s = this.value & ((1 << this.bitCount) - 1)
        return (
          (s |= 1 << this.bitCount),
          '<' + M.toBinaryString(s | (1 << this.bitCount)).substring(1) + '>'
        )
      }
    }
    class Hh extends Qs {
      constructor(s, a, l) {
        ;(super(s, 0, 0), (this.binaryShiftStart = a), (this.binaryShiftByteCount = l))
      }
      appendTo(s, a) {
        for (let l = 0; l < this.binaryShiftByteCount; l++)
          ((l === 0 || (l === 31 && this.binaryShiftByteCount <= 62)) &&
            (s.appendBits(31, 5),
            this.binaryShiftByteCount > 62
              ? s.appendBits(this.binaryShiftByteCount - 31, 16)
              : l === 0
                ? s.appendBits(Math.min(this.binaryShiftByteCount, 31), 5)
                : s.appendBits(this.binaryShiftByteCount - 31, 5)),
            s.appendBits(a[this.binaryShiftStart + l], 8))
      }
      addBinaryShift(s, a) {
        return new Hh(this, s, a)
      }
      toString() {
        return (
          '<' +
          this.binaryShiftStart +
          '::' +
          (this.binaryShiftStart + this.binaryShiftByteCount - 1) +
          '>'
        )
      }
    }
    function Mb(_, s, a) {
      return new Hh(_, s, a)
    }
    function ca(_, s, a) {
      return new Qs(_, s, a)
    }
    const Pb = ['UPPER', 'LOWER', 'DIGIT', 'MIXED', 'PUNCT'],
      si = 0,
      ec = 1,
      zn = 2,
      Op = 3,
      yr = 4,
      Db = new Qs(null, 0, 0),
      Xh = [
        Int32Array.from([0, (5 << 16) + 28, (5 << 16) + 30, (5 << 16) + 29, 656318]),
        Int32Array.from([(9 << 16) + 480 + 14, 0, (5 << 16) + 30, (5 << 16) + 29, 656318]),
        Int32Array.from([(4 << 16) + 14, (9 << 16) + 448 + 28, 0, (9 << 16) + 448 + 29, 932798]),
        Int32Array.from([(5 << 16) + 29, (5 << 16) + 28, 656318, 0, (5 << 16) + 30]),
        Int32Array.from([(5 << 16) + 31, 656380, 656382, 656381, 0]),
      ]
    function Lb(_) {
      for (let s of _) R.fill(s, -1)
      return (
        (_[si][yr] = 0),
        (_[ec][yr] = 0),
        (_[ec][si] = 28),
        (_[Op][yr] = 0),
        (_[zn][yr] = 0),
        (_[zn][si] = 15),
        _
      )
    }
    const Bp = Lb(R.createInt32Array(6, 6))
    class wr {
      constructor(s, a, l, u) {
        ;((this.token = s), (this.mode = a), (this.binaryShiftByteCount = l), (this.bitCount = u))
      }
      getMode() {
        return this.mode
      }
      getToken() {
        return this.token
      }
      getBinaryShiftByteCount() {
        return this.binaryShiftByteCount
      }
      getBitCount() {
        return this.bitCount
      }
      latchAndAppend(s, a) {
        let l = this.bitCount,
          u = this.token
        if (s !== this.mode) {
          let g = Xh[this.mode][s]
          ;((u = ca(u, g & 65535, g >> 16)), (l += g >> 16))
        }
        let d = s === zn ? 4 : 5
        return ((u = ca(u, a, d)), new wr(u, s, 0, l + d))
      }
      shiftAndAppend(s, a) {
        let l = this.token,
          u = this.mode === zn ? 4 : 5
        return (
          (l = ca(l, Bp[this.mode][s], u)),
          (l = ca(l, a, 5)),
          new wr(l, this.mode, 0, this.bitCount + u + 5)
        )
      }
      addBinaryShiftChar(s) {
        let a = this.token,
          l = this.mode,
          u = this.bitCount
        if (this.mode === yr || this.mode === zn) {
          let m = Xh[l][si]
          ;((a = ca(a, m & 65535, m >> 16)), (u += m >> 16), (l = si))
        }
        let d =
            this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31
              ? 18
              : this.binaryShiftByteCount === 62
                ? 9
                : 8,
          g = new wr(a, l, this.binaryShiftByteCount + 1, u + d)
        return (g.binaryShiftByteCount === 2078 && (g = g.endBinaryShift(s + 1)), g)
      }
      endBinaryShift(s) {
        if (this.binaryShiftByteCount === 0) return this
        let a = this.token
        return (
          (a = Mb(a, s - this.binaryShiftByteCount, this.binaryShiftByteCount)),
          new wr(a, this.mode, 0, this.bitCount)
        )
      }
      isBetterThanOrEqualTo(s) {
        let a = this.bitCount + (Xh[this.mode][s.mode] >> 16)
        return (
          this.binaryShiftByteCount < s.binaryShiftByteCount
            ? (a += wr.calculateBinaryShiftCost(s) - wr.calculateBinaryShiftCost(this))
            : this.binaryShiftByteCount > s.binaryShiftByteCount &&
              s.binaryShiftByteCount > 0 &&
              (a += 10),
          a <= s.bitCount
        )
      }
      toBitArray(s) {
        let a = []
        for (let u = this.endBinaryShift(s.length).token; u !== null; u = u.getPrevious())
          a.unshift(u)
        let l = new O()
        for (const u of a) u.appendTo(l, s)
        return l
      }
      toString() {
        return re.format(
          '%s bits=%d bytes=%d',
          Pb[this.mode],
          this.bitCount,
          this.binaryShiftByteCount
        )
      }
      static calculateBinaryShiftCost(s) {
        return s.binaryShiftByteCount > 62
          ? 21
          : s.binaryShiftByteCount > 31
            ? 20
            : s.binaryShiftByteCount > 0
              ? 10
              : 0
      }
    }
    wr.INITIAL_STATE = new wr(Db, si, 0, 0)
    function Ob(_) {
      const s = re.getCharCode(' '),
        a = re.getCharCode('.'),
        l = re.getCharCode(',')
      _[si][s] = 1
      const u = re.getCharCode('Z'),
        d = re.getCharCode('A')
      for (let D = d; D <= u; D++) _[si][D] = D - d + 2
      _[ec][s] = 1
      const g = re.getCharCode('z'),
        m = re.getCharCode('a')
      for (let D = m; D <= g; D++) _[ec][D] = D - m + 2
      _[zn][s] = 1
      const b = re.getCharCode('9'),
        v = re.getCharCode('0')
      for (let D = v; D <= b; D++) _[zn][D] = D - v + 2
      ;((_[zn][l] = 12), (_[zn][a] = 13))
      const C = [
        '\0',
        ' ',
        '',
        '',
        '',
        '',
        '',
        '',
        '\x07',
        '\b',
        '	',
        `
`,
        '\v',
        '\f',
        '\r',
        '\x1B',
        '',
        '',
        '',
        '',
        '@',
        '\\',
        '^',
        '_',
        '`',
        '|',
        '~',
        '',
      ]
      for (let D = 0; D < C.length; D++) _[Op][re.getCharCode(C[D])] = D
      const T = [
        '\0',
        '\r',
        '\0',
        '\0',
        '\0',
        '\0',
        '!',
        "'",
        '#',
        '$',
        '%',
        '&',
        "'",
        '(',
        ')',
        '*',
        '+',
        ',',
        '-',
        '.',
        '/',
        ':',
        ';',
        '<',
        '=',
        '>',
        '?',
        '[',
        ']',
        '{',
        '}',
      ]
      for (let D = 0; D < T.length; D++)
        re.getCharCode(T[D]) > 0 && (_[yr][re.getCharCode(T[D])] = D)
      return _
    }
    const Gh = Ob(R.createInt32Array(5, 256))
    class ua {
      constructor(s) {
        this.text = s
      }
      encode() {
        const s = re.getCharCode(' '),
          a = re.getCharCode(`
`)
        let l = Lp.singletonList(wr.INITIAL_STATE)
        for (let u = 0; u < this.text.length; u++) {
          let d,
            g = u + 1 < this.text.length ? this.text[u + 1] : 0
          switch (this.text[u]) {
            case re.getCharCode('\r'):
              d = g === a ? 2 : 0
              break
            case re.getCharCode('.'):
              d = g === s ? 3 : 0
              break
            case re.getCharCode(','):
              d = g === s ? 4 : 0
              break
            case re.getCharCode(':'):
              d = g === s ? 5 : 0
              break
            default:
              d = 0
          }
          d > 0
            ? ((l = ua.updateStateListForPair(l, u, d)), u++)
            : (l = this.updateStateListForChar(l, u))
        }
        return Lp.min(l, (u, d) => u.getBitCount() - d.getBitCount()).toBitArray(this.text)
      }
      updateStateListForChar(s, a) {
        const l = []
        for (let u of s) this.updateStateForChar(u, a, l)
        return ua.simplifyStates(l)
      }
      updateStateForChar(s, a, l) {
        let u = this.text[a] & 255,
          d = Gh[s.getMode()][u] > 0,
          g = null
        for (let m = 0; m <= yr; m++) {
          let b = Gh[m][u]
          if (b > 0) {
            if ((g == null && (g = s.endBinaryShift(a)), !d || m === s.getMode() || m === zn)) {
              const v = g.latchAndAppend(m, b)
              l.push(v)
            }
            if (!d && Bp[s.getMode()][m] >= 0) {
              const v = g.shiftAndAppend(m, b)
              l.push(v)
            }
          }
        }
        if (s.getBinaryShiftByteCount() > 0 || Gh[s.getMode()][u] === 0) {
          let m = s.addBinaryShiftChar(a)
          l.push(m)
        }
      }
      static updateStateListForPair(s, a, l) {
        const u = []
        for (let d of s) this.updateStateForPair(d, a, l, u)
        return this.simplifyStates(u)
      }
      static updateStateForPair(s, a, l, u) {
        let d = s.endBinaryShift(a)
        if (
          (u.push(d.latchAndAppend(yr, l)),
          s.getMode() !== yr && u.push(d.shiftAndAppend(yr, l)),
          l === 3 || l === 4)
        ) {
          let g = d.latchAndAppend(zn, 16 - l).latchAndAppend(zn, 1)
          u.push(g)
        }
        if (s.getBinaryShiftByteCount() > 0) {
          let g = s.addBinaryShiftChar(a).addBinaryShiftChar(a + 1)
          u.push(g)
        }
      }
      static simplifyStates(s) {
        let a = []
        for (const l of s) {
          let u = !0
          for (const d of a) {
            if (d.isBetterThanOrEqualTo(l)) {
              u = !1
              break
            }
            l.isBetterThanOrEqualTo(d) && (a = a.filter((g) => g !== d))
          }
          u && a.push(l)
        }
        return a
      }
    }
    class De {
      constructor() {}
      static encodeBytes(s) {
        return De.encode(s, De.DEFAULT_EC_PERCENT, De.DEFAULT_AZTEC_LAYERS)
      }
      static encode(s, a, l) {
        let u = new ua(s).encode(),
          d = M.truncDivision(u.getSize() * a, 100) + 11,
          g = u.getSize() + d,
          m,
          b,
          v,
          C,
          T
        if (l !== De.DEFAULT_AZTEC_LAYERS) {
          if (((m = l < 0), (b = Math.abs(l)), b > (m ? De.MAX_NB_BITS_COMPACT : De.MAX_NB_BITS)))
            throw new w(re.format('Illegal value %s for layers', l))
          ;((v = De.totalBitsInLayer(b, m)), (C = De.WORD_SIZE[b]))
          let $ = v - (v % C)
          if (((T = De.stuffBits(u, C)), T.getSize() + d > $))
            throw new w('Data to large for user specified layer')
          if (m && T.getSize() > C * 64) throw new w('Data to large for user specified layer')
        } else {
          ;((C = 0), (T = null))
          for (let $ = 0; ; $++) {
            if ($ > De.MAX_NB_BITS) throw new w('Data too large for an Aztec code')
            if (((m = $ <= 3), (b = m ? $ + 1 : $), (v = De.totalBitsInLayer(b, m)), g > v))
              continue
            ;(T == null || C !== De.WORD_SIZE[b]) &&
              ((C = De.WORD_SIZE[b]), (T = De.stuffBits(u, C)))
            let Te = v - (v % C)
            if (!(m && T.getSize() > C * 64) && T.getSize() + d <= Te) break
          }
        }
        let D = De.generateCheckWords(T, v, C),
          B = T.getSize() / C,
          j = De.generateModeMessage(m, b, B),
          W = (m ? 11 : 14) + b * 4,
          Y = new Int32Array(W),
          q
        if (m) {
          q = W
          for (let $ = 0; $ < Y.length; $++) Y[$] = $
        } else {
          q = W + 1 + 2 * M.truncDivision(M.truncDivision(W, 2) - 1, 15)
          let $ = M.truncDivision(W, 2),
            Te = M.truncDivision(q, 2)
          for (let Ce = 0; Ce < $; Ce++) {
            let pn = Ce + M.truncDivision(Ce, 15)
            ;((Y[$ - Ce - 1] = Te - pn - 1), (Y[$ + Ce] = Te + pn + 1))
          }
        }
        let ne = new Ie(q)
        for (let $ = 0, Te = 0; $ < b; $++) {
          let Ce = (b - $) * 4 + (m ? 9 : 12)
          for (let pn = 0; pn < Ce; pn++) {
            let rr = pn * 2
            for (let gn = 0; gn < 2; gn++)
              (D.get(Te + rr + gn) && ne.set(Y[$ * 2 + gn], Y[$ * 2 + pn]),
                D.get(Te + Ce * 2 + rr + gn) && ne.set(Y[$ * 2 + pn], Y[W - 1 - $ * 2 - gn]),
                D.get(Te + Ce * 4 + rr + gn) &&
                  ne.set(Y[W - 1 - $ * 2 - gn], Y[W - 1 - $ * 2 - pn]),
                D.get(Te + Ce * 6 + rr + gn) && ne.set(Y[W - 1 - $ * 2 - pn], Y[$ * 2 + gn]))
          }
          Te += Ce * 8
        }
        if ((De.drawModeMessage(ne, m, q, j), m)) De.drawBullsEye(ne, M.truncDivision(q, 2), 5)
        else {
          De.drawBullsEye(ne, M.truncDivision(q, 2), 7)
          for (let $ = 0, Te = 0; $ < M.truncDivision(W, 2) - 1; $ += 15, Te += 16)
            for (let Ce = M.truncDivision(q, 2) & 1; Ce < q; Ce += 2)
              (ne.set(M.truncDivision(q, 2) - Te, Ce),
                ne.set(M.truncDivision(q, 2) + Te, Ce),
                ne.set(Ce, M.truncDivision(q, 2) - Te),
                ne.set(Ce, M.truncDivision(q, 2) + Te))
        }
        let te = new Dp()
        return (
          te.setCompact(m),
          te.setSize(q),
          te.setLayers(b),
          te.setCodeWords(B),
          te.setMatrix(ne),
          te
        )
      }
      static drawBullsEye(s, a, l) {
        for (let u = 0; u < l; u += 2)
          for (let d = a - u; d <= a + u; d++)
            (s.set(d, a - u), s.set(d, a + u), s.set(a - u, d), s.set(a + u, d))
        ;(s.set(a - l, a - l),
          s.set(a - l + 1, a - l),
          s.set(a - l, a - l + 1),
          s.set(a + l, a - l),
          s.set(a + l, a - l + 1),
          s.set(a + l, a + l - 1))
      }
      static generateModeMessage(s, a, l) {
        let u = new O()
        return (
          s
            ? (u.appendBits(a - 1, 2),
              u.appendBits(l - 1, 6),
              (u = De.generateCheckWords(u, 28, 4)))
            : (u.appendBits(a - 1, 5),
              u.appendBits(l - 1, 11),
              (u = De.generateCheckWords(u, 40, 4))),
          u
        )
      }
      static drawModeMessage(s, a, l, u) {
        let d = M.truncDivision(l, 2)
        if (a)
          for (let g = 0; g < 7; g++) {
            let m = d - 3 + g
            ;(u.get(g) && s.set(m, d - 5),
              u.get(g + 7) && s.set(d + 5, m),
              u.get(20 - g) && s.set(m, d + 5),
              u.get(27 - g) && s.set(d - 5, m))
          }
        else
          for (let g = 0; g < 10; g++) {
            let m = d - 5 + g + M.truncDivision(g, 5)
            ;(u.get(g) && s.set(m, d - 7),
              u.get(g + 10) && s.set(d + 7, m),
              u.get(29 - g) && s.set(m, d + 7),
              u.get(39 - g) && s.set(d - 7, m))
          }
      }
      static generateCheckWords(s, a, l) {
        let u = s.getSize() / l,
          d = new Uh(De.getGF(l)),
          g = M.truncDivision(a, l),
          m = De.bitsToWords(s, l, g)
        d.encode(m, g - u)
        let b = a % l,
          v = new O()
        v.appendBits(0, b)
        for (const C of Array.from(m)) v.appendBits(C, l)
        return v
      }
      static bitsToWords(s, a, l) {
        let u = new Int32Array(l),
          d,
          g
        for (d = 0, g = s.getSize() / a; d < g; d++) {
          let m = 0
          for (let b = 0; b < a; b++) m |= s.get(d * a + b) ? 1 << (a - b - 1) : 0
          u[d] = m
        }
        return u
      }
      static getGF(s) {
        switch (s) {
          case 4:
            return Fe.AZTEC_PARAM
          case 6:
            return Fe.AZTEC_DATA_6
          case 8:
            return Fe.AZTEC_DATA_8
          case 10:
            return Fe.AZTEC_DATA_10
          case 12:
            return Fe.AZTEC_DATA_12
          default:
            throw new w('Unsupported word size ' + s)
        }
      }
      static stuffBits(s, a) {
        let l = new O(),
          u = s.getSize(),
          d = (1 << a) - 2
        for (let g = 0; g < u; g += a) {
          let m = 0
          for (let b = 0; b < a; b++) (g + b >= u || s.get(g + b)) && (m |= 1 << (a - 1 - b))
          ;(m & d) === d
            ? (l.appendBits(m & d, a), g--)
            : m & d
              ? l.appendBits(m, a)
              : (l.appendBits(m | 1, a), g--)
        }
        return l
      }
      static totalBitsInLayer(s, a) {
        return ((a ? 88 : 112) + 16 * s) * s
      }
    }
    ;((De.DEFAULT_EC_PERCENT = 33),
      (De.DEFAULT_AZTEC_LAYERS = 0),
      (De.MAX_NB_BITS = 32),
      (De.MAX_NB_BITS_COMPACT = 4),
      (De.WORD_SIZE = Int32Array.from([
        4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 12,
        12, 12, 12, 12, 12, 12, 12, 12,
      ])))
    class tc {
      encode(s, a, l, u) {
        return this.encodeWithHints(s, a, l, u, null)
      }
      encodeWithHints(s, a, l, u, d) {
        let g = zh.ISO_8859_1,
          m = De.DEFAULT_EC_PERCENT,
          b = De.DEFAULT_AZTEC_LAYERS
        return (
          d != null &&
            (d.has(_t.CHARACTER_SET) && (g = Pp.forName(d.get(_t.CHARACTER_SET).toString())),
            d.has(_t.ERROR_CORRECTION) && (m = M.parseInt(d.get(_t.ERROR_CORRECTION).toString())),
            d.has(_t.AZTEC_LAYERS) && (b = M.parseInt(d.get(_t.AZTEC_LAYERS).toString()))),
          tc.encodeLayers(s, a, l, u, g, m, b)
        )
      }
      static encodeLayers(s, a, l, u, d, g, m) {
        if (a !== ue.AZTEC) throw new w('Can only encode AZTEC, but got ' + a)
        let b = De.encode(re.getBytes(s, d), g, m)
        return tc.renderResult(b, l, u)
      }
      static renderResult(s, a, l) {
        let u = s.getMatrix()
        if (u == null) throw new dr()
        let d = u.getWidth(),
          g = u.getHeight(),
          m = Math.max(a, d),
          b = Math.max(l, g),
          v = Math.min(m / d, b / g),
          C = (m - d * v) / 2,
          T = (b - g * v) / 2,
          D = new Ie(m, b)
        for (let B = 0, j = T; B < g; B++, j += v)
          for (let W = 0, Y = C; W < d; W++, Y += v) u.get(W, B) && D.setRegion(Y, j, v, v)
        return D
      }
    }
    ;((n.AbstractExpandedDecoder = Rh),
      (n.ArgumentException = y),
      (n.ArithmeticException = zl),
      (n.AztecCode = Dp),
      (n.AztecCodeReader = Gl),
      (n.AztecCodeWriter = tc),
      (n.AztecDecoder = Ke),
      (n.AztecDetector = vp),
      (n.AztecDetectorResult = wp),
      (n.AztecEncoder = De),
      (n.AztecHighLevelEncoder = ua),
      (n.AztecPoint = tn),
      (n.BarcodeFormat = ue),
      (n.Binarizer = S),
      (n.BinaryBitmap = x),
      (n.BitArray = O),
      (n.BitMatrix = Ie),
      (n.BitSource = Lh),
      (n.BrowserAztecCodeReader = lb),
      (n.BrowserBarcodeReader = fb),
      (n.BrowserCodeReader = Tt),
      (n.BrowserDatamatrixCodeReader = gb),
      (n.BrowserMultiFormatReader = kb),
      (n.BrowserPDF417Reader = _b),
      (n.BrowserQRCodeReader = Ib),
      (n.BrowserQRCodeSvgWriter = Zi),
      (n.CharacterSetECI = Z),
      (n.ChecksumException = E),
      (n.Code128Reader = ie),
      (n.Code39Reader = At),
      (n.DataMatrixDecodedBitStreamParser = ti),
      (n.DataMatrixReader = ni),
      (n.DecodeHintType = z),
      (n.DecoderResult = Jo),
      (n.DefaultGridSampler = bp),
      (n.DetectorResult = Xl),
      (n.EAN13Reader = zi),
      (n.EncodeHintType = _t),
      (n.Exception = p),
      (n.FormatException = V),
      (n.GenericGF = Fe),
      (n.GenericGFPoly = un),
      (n.GlobalHistogramBinarizer = xe),
      (n.GridSampler = _h),
      (n.GridSamplerInstance = Jr),
      (n.HTMLCanvasElementLuminanceSource = pe),
      (n.HybridBinarizer = ge),
      (n.ITFReader = Ge),
      (n.IllegalArgumentException = w),
      (n.IllegalStateException = dr),
      (n.InvertedLuminanceSource = fe),
      (n.LuminanceSource = se),
      (n.MathUtils = Pe),
      (n.MultiFormatOneDReader = Zs),
      (n.MultiFormatReader = Mp),
      (n.MultiFormatWriter = Tb),
      (n.NotFoundException = H),
      (n.OneDReader = Ct),
      (n.PDF417DecodedBitStreamParser = K),
      (n.PDF417DecoderErrorCorrection = kp),
      (n.PDF417Reader = Vt),
      (n.PDF417ResultMetadata = Ip),
      (n.PerspectiveTransform = tr),
      (n.PlanarYUVLuminanceSource = mr),
      (n.QRCodeByteMatrix = Jl),
      (n.QRCodeDataMask = Un),
      (n.QRCodeDecodedBitStreamParser = ot),
      (n.QRCodeDecoderErrorCorrectionLevel = qe),
      (n.QRCodeDecoderFormatInformation = Zt),
      (n.QRCodeEncoder = Je),
      (n.QRCodeEncoderQRCode = Yi),
      (n.QRCodeMaskUtil = gt),
      (n.QRCodeMatrixUtil = we),
      (n.QRCodeMode = me),
      (n.QRCodeReader = ri),
      (n.QRCodeVersion = de),
      (n.QRCodeWriter = qs),
      (n.RGBLuminanceSource = Wh),
      (n.RSS14Reader = pt),
      (n.RSSExpandedReader = Q),
      (n.ReaderException = $l),
      (n.ReedSolomonDecoder = ta),
      (n.ReedSolomonEncoder = Uh),
      (n.ReedSolomonException = Hs),
      (n.Result = Be),
      (n.ResultMetadataType = Rt),
      (n.ResultPoint = he),
      (n.StringUtils = re),
      (n.UnsupportedOperationException = J),
      (n.VideoInputDevice = We),
      (n.WhiteRectangleDetector = Tr),
      (n.WriterException = Ye),
      (n.ZXingArrays = R),
      (n.ZXingCharset = Pp),
      (n.ZXingInteger = M),
      (n.ZXingStandardCharsets = zh),
      (n.ZXingStringBuilder = ve),
      (n.ZXingStringEncoding = oe),
      (n.ZXingSystem = k),
      (n.createAbstractExpandedDecoder = Sp),
      Object.defineProperty(n, '__esModule', { value: !0 }))
  })
})(Ef, Ef.exports)
var tt = Ef.exports
const MT = Ky(tt),
  PT = Zy({ __proto__: null, default: MT }, [tt])
var Vy = (function () {
    function e(t, n, r) {
      if (
        ((this.formatMap = new Map([
          [le.QR_CODE, tt.BarcodeFormat.QR_CODE],
          [le.AZTEC, tt.BarcodeFormat.AZTEC],
          [le.CODABAR, tt.BarcodeFormat.CODABAR],
          [le.CODE_39, tt.BarcodeFormat.CODE_39],
          [le.CODE_93, tt.BarcodeFormat.CODE_93],
          [le.CODE_128, tt.BarcodeFormat.CODE_128],
          [le.DATA_MATRIX, tt.BarcodeFormat.DATA_MATRIX],
          [le.MAXICODE, tt.BarcodeFormat.MAXICODE],
          [le.ITF, tt.BarcodeFormat.ITF],
          [le.EAN_13, tt.BarcodeFormat.EAN_13],
          [le.EAN_8, tt.BarcodeFormat.EAN_8],
          [le.PDF_417, tt.BarcodeFormat.PDF_417],
          [le.RSS_14, tt.BarcodeFormat.RSS_14],
          [le.RSS_EXPANDED, tt.BarcodeFormat.RSS_EXPANDED],
          [le.UPC_A, tt.BarcodeFormat.UPC_A],
          [le.UPC_E, tt.BarcodeFormat.UPC_E],
          [le.UPC_EAN_EXTENSION, tt.BarcodeFormat.UPC_EAN_EXTENSION],
        ])),
        (this.reverseFormatMap = this.createReverseFormatMap()),
        !PT)
      )
        throw 'Use html5qrcode.min.js without edit, ZXing not found.'
      ;((this.verbose = n), (this.logger = r))
      var i = this.createZXingFormats(t),
        o = new Map()
      ;(o.set(tt.DecodeHintType.POSSIBLE_FORMATS, i),
        o.set(tt.DecodeHintType.TRY_HARDER, !1),
        (this.hints = o))
    }
    return (
      (e.prototype.decodeAsync = function (t) {
        var n = this
        return new Promise(function (r, i) {
          try {
            r(n.decode(t))
          } catch (o) {
            i(o)
          }
        })
      }),
      (e.prototype.decode = function (t) {
        var n = new tt.MultiFormatReader(this.verbose, this.hints),
          r = new tt.HTMLCanvasElementLuminanceSource(t),
          i = new tt.BinaryBitmap(new tt.HybridBinarizer(r)),
          o = n.decode(i)
        return {
          text: o.text,
          format: ib.create(this.toHtml5QrcodeSupportedFormats(o.format)),
          debugData: this.createDebugData(),
        }
      }),
      (e.prototype.createReverseFormatMap = function () {
        var t = new Map()
        return (
          this.formatMap.forEach(function (n, r, i) {
            t.set(n, r)
          }),
          t
        )
      }),
      (e.prototype.toHtml5QrcodeSupportedFormats = function (t) {
        if (!this.reverseFormatMap.has(t)) throw "reverseFormatMap doesn't have ".concat(t)
        return this.reverseFormatMap.get(t)
      }),
      (e.prototype.createZXingFormats = function (t) {
        for (var n = [], r = 0, i = t; r < i.length; r++) {
          var o = i[r]
          this.formatMap.has(o)
            ? n.push(this.formatMap.get(o))
            : this.logger.logError(''.concat(o, ' is not supported by') + 'ZXingHtml5QrcodeShim')
        }
        return n
      }),
      (e.prototype.createDebugData = function () {
        return { decoderName: 'zxing-js' }
      }),
      e
    )
  })(),
  DT = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  LT = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  Uy = (function () {
    function e(t, n, r) {
      if (
        ((this.formatMap = new Map([
          [le.QR_CODE, 'qr_code'],
          [le.AZTEC, 'aztec'],
          [le.CODABAR, 'codabar'],
          [le.CODE_39, 'code_39'],
          [le.CODE_93, 'code_93'],
          [le.CODE_128, 'code_128'],
          [le.DATA_MATRIX, 'data_matrix'],
          [le.ITF, 'itf'],
          [le.EAN_13, 'ean_13'],
          [le.EAN_8, 'ean_8'],
          [le.PDF_417, 'pdf417'],
          [le.UPC_A, 'upc_a'],
          [le.UPC_E, 'upc_e'],
        ])),
        (this.reverseFormatMap = this.createReverseFormatMap()),
        !e.isSupported())
      )
        throw 'Use html5qrcode.min.js without edit, Use BarcodeDetectorDelegate only if it isSupported();'
      ;((this.verbose = n), (this.logger = r))
      var i = this.createBarcodeDetectorFormats(t)
      if (((this.detector = new BarcodeDetector(i)), !this.detector))
        throw 'BarcodeDetector detector not supported'
    }
    return (
      (e.isSupported = function () {
        if (!('BarcodeDetector' in window)) return !1
        var t = new BarcodeDetector({ formats: ['qr_code'] })
        return typeof t < 'u'
      }),
      (e.prototype.decodeAsync = function (t) {
        return DT(this, void 0, void 0, function () {
          var n, r
          return LT(this, function (i) {
            switch (i.label) {
              case 0:
                return [4, this.detector.detect(t)]
              case 1:
                if (((n = i.sent()), !n || n.length === 0)) throw 'No barcode or QR code detected.'
                return (
                  (r = this.selectLargestBarcode(n)),
                  [
                    2,
                    {
                      text: r.rawValue,
                      format: ib.create(this.toHtml5QrcodeSupportedFormats(r.format)),
                      debugData: this.createDebugData(),
                    },
                  ]
                )
            }
          })
        })
      }),
      (e.prototype.selectLargestBarcode = function (t) {
        for (var n = null, r = 0, i = 0, o = t; i < o.length; i++) {
          var c = o[i],
            h = c.boundingBox.width * c.boundingBox.height
          h > r && ((r = h), (n = c))
        }
        if (!n) throw 'No largest barcode found'
        return n
      }),
      (e.prototype.createBarcodeDetectorFormats = function (t) {
        for (var n = [], r = 0, i = t; r < i.length; r++) {
          var o = i[r]
          this.formatMap.has(o)
            ? n.push(this.formatMap.get(o))
            : this.logger.warn(''.concat(o, ' is not supported by') + 'BarcodeDetectorDelegate')
        }
        return { formats: n }
      }),
      (e.prototype.toHtml5QrcodeSupportedFormats = function (t) {
        if (!this.reverseFormatMap.has(t)) throw "reverseFormatMap doesn't have ".concat(t)
        return this.reverseFormatMap.get(t)
      }),
      (e.prototype.createReverseFormatMap = function () {
        var t = new Map()
        return (
          this.formatMap.forEach(function (n, r, i) {
            t.set(n, r)
          }),
          t
        )
      }),
      (e.prototype.createDebugData = function () {
        return { decoderName: 'BarcodeDetector' }
      }),
      e
    )
  })(),
  Wy = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  zy = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  OT = (function () {
    function e(t, n, r, i) {
      ;((this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100),
        (this.executions = 0),
        (this.executionResults = []),
        (this.wasPrimaryDecoderUsedInLastDecode = !1),
        (this.verbose = r),
        n && Uy.isSupported()
          ? ((this.primaryDecoder = new Uy(t, r, i)), (this.secondaryDecoder = new Vy(t, r, i)))
          : (this.primaryDecoder = new Vy(t, r, i)))
    }
    return (
      (e.prototype.decodeAsync = function (t) {
        return Wy(this, void 0, void 0, function () {
          var n
          return zy(this, function (r) {
            switch (r.label) {
              case 0:
                ;((n = performance.now()), (r.label = 1))
              case 1:
                return (r.trys.push([1, , 3, 4]), [4, this.getDecoder().decodeAsync(t)])
              case 2:
                return [2, r.sent()]
              case 3:
                return (this.possiblyLogPerformance(n), [7])
              case 4:
                return [2]
            }
          })
        })
      }),
      (e.prototype.decodeRobustlyAsync = function (t) {
        return Wy(this, void 0, void 0, function () {
          var n, r
          return zy(this, function (i) {
            switch (i.label) {
              case 0:
                ;((n = performance.now()), (i.label = 1))
              case 1:
                return (i.trys.push([1, 3, 4, 5]), [4, this.primaryDecoder.decodeAsync(t)])
              case 2:
                return [2, i.sent()]
              case 3:
                if (((r = i.sent()), this.secondaryDecoder))
                  return [2, this.secondaryDecoder.decodeAsync(t)]
                throw r
              case 4:
                return (this.possiblyLogPerformance(n), [7])
              case 5:
                return [2]
            }
          })
        })
      }),
      (e.prototype.getDecoder = function () {
        return this.secondaryDecoder
          ? this.wasPrimaryDecoderUsedInLastDecode === !1
            ? ((this.wasPrimaryDecoderUsedInLastDecode = !0), this.primaryDecoder)
            : ((this.wasPrimaryDecoderUsedInLastDecode = !1), this.secondaryDecoder)
          : this.primaryDecoder
      }),
      (e.prototype.possiblyLogPerformance = function (t) {
        if (this.verbose) {
          var n = performance.now() - t
          ;(this.executionResults.push(n), this.executions++, this.possiblyFlushPerformanceReport())
        }
      }),
      (e.prototype.possiblyFlushPerformanceReport = function () {
        if (!(this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE)) {
          for (var t = 0, n = 0, r = this.executionResults; n < r.length; n++) {
            var i = r[n]
            t += i
          }
          var o = t / this.executionResults.length
          ;(console.log(
            ''.concat(o, ' ms for ').concat(this.executionResults.length, ' last runs.')
          ),
            (this.executions = 0),
            (this.executionResults = []))
        }
      }),
      e
    )
  })(),
  yp = (function () {
    var e = function (t, n) {
      return (
        (e =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i
            }) ||
          function (r, i) {
            for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o])
          }),
        e(t, n)
      )
    }
    return function (t, n) {
      if (typeof n != 'function' && n !== null)
        throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null')
      e(t, n)
      function r() {
        this.constructor = t
      }
      t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r())
    }
  })(),
  Gu = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  Yu = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  ob = (function () {
    function e(t, n) {
      ;((this.name = t), (this.track = n))
    }
    return (
      (e.prototype.isSupported = function () {
        return this.track.getCapabilities ? this.name in this.track.getCapabilities() : !1
      }),
      (e.prototype.apply = function (t) {
        var n = {}
        n[this.name] = t
        var r = { advanced: [n] }
        return this.track.applyConstraints(r)
      }),
      (e.prototype.value = function () {
        var t = this.track.getSettings()
        if (this.name in t) {
          var n = t[this.name]
          return n
        }
        return null
      }),
      e
    )
  })(),
  BT = (function (e) {
    yp(t, e)
    function t(n, r) {
      return e.call(this, n, r) || this
    }
    return (
      (t.prototype.min = function () {
        return this.getCapabilities().min
      }),
      (t.prototype.max = function () {
        return this.getCapabilities().max
      }),
      (t.prototype.step = function () {
        return this.getCapabilities().step
      }),
      (t.prototype.apply = function (n) {
        var r = {}
        r[this.name] = n
        var i = { advanced: [r] }
        return this.track.applyConstraints(i)
      }),
      (t.prototype.getCapabilities = function () {
        this.failIfNotSupported()
        var n = this.track.getCapabilities(),
          r = n[this.name]
        return { min: r.min, max: r.max, step: r.step }
      }),
      (t.prototype.failIfNotSupported = function () {
        if (!this.isSupported()) throw new Error(''.concat(this.name, ' capability not supported'))
      }),
      t
    )
  })(ob),
  FT = (function (e) {
    yp(t, e)
    function t(n) {
      return e.call(this, 'zoom', n) || this
    }
    return t
  })(BT),
  jT = (function (e) {
    yp(t, e)
    function t(n) {
      return e.call(this, 'torch', n) || this
    }
    return t
  })(ob),
  VT = (function () {
    function e(t) {
      this.track = t
    }
    return (
      (e.prototype.zoomFeature = function () {
        return new FT(this.track)
      }),
      (e.prototype.torchFeature = function () {
        return new jT(this.track)
      }),
      e
    )
  })(),
  UT = (function () {
    function e(t, n, r) {
      ;((this.isClosed = !1),
        (this.parentElement = t),
        (this.mediaStream = n),
        (this.callbacks = r),
        (this.surface = this.createVideoElement(this.parentElement.clientWidth)),
        t.append(this.surface))
    }
    return (
      (e.prototype.createVideoElement = function (t) {
        var n = document.createElement('video')
        return (
          (n.style.width = ''.concat(t, 'px')),
          (n.style.display = 'block'),
          (n.muted = !0),
          n.setAttribute('muted', 'true'),
          (n.playsInline = !0),
          n
        )
      }),
      (e.prototype.setupSurface = function () {
        var t = this
        ;((this.surface.onabort = function () {
          throw 'RenderedCameraImpl video surface onabort() called'
        }),
          (this.surface.onerror = function () {
            throw 'RenderedCameraImpl video surface onerror() called'
          }))
        var n = function () {
          var r = t.surface.clientWidth,
            i = t.surface.clientHeight
          ;(t.callbacks.onRenderSurfaceReady(r, i), t.surface.removeEventListener('playing', n))
        }
        ;(this.surface.addEventListener('playing', n),
          (this.surface.srcObject = this.mediaStream),
          this.surface.play())
      }),
      (e.create = function (t, n, r, i) {
        return Gu(this, void 0, void 0, function () {
          var o, c
          return Yu(this, function (h) {
            switch (h.label) {
              case 0:
                return (
                  (o = new e(t, n, i)),
                  r.aspectRatio
                    ? ((c = { aspectRatio: r.aspectRatio }),
                      [4, o.getFirstTrackOrFail().applyConstraints(c)])
                    : [3, 2]
                )
              case 1:
                ;(h.sent(), (h.label = 2))
              case 2:
                return (o.setupSurface(), [2, o])
            }
          })
        })
      }),
      (e.prototype.failIfClosed = function () {
        if (this.isClosed) throw 'The RenderedCamera has already been closed.'
      }),
      (e.prototype.getFirstTrackOrFail = function () {
        if ((this.failIfClosed(), this.mediaStream.getVideoTracks().length === 0))
          throw 'No video tracks found'
        return this.mediaStream.getVideoTracks()[0]
      }),
      (e.prototype.pause = function () {
        ;(this.failIfClosed(), this.surface.pause())
      }),
      (e.prototype.resume = function (t) {
        this.failIfClosed()
        var n = this,
          r = function () {
            ;(setTimeout(t, 200), n.surface.removeEventListener('playing', r))
          }
        ;(this.surface.addEventListener('playing', r), this.surface.play())
      }),
      (e.prototype.isPaused = function () {
        return (this.failIfClosed(), this.surface.paused)
      }),
      (e.prototype.getSurface = function () {
        return (this.failIfClosed(), this.surface)
      }),
      (e.prototype.getRunningTrackCapabilities = function () {
        return this.getFirstTrackOrFail().getCapabilities()
      }),
      (e.prototype.getRunningTrackSettings = function () {
        return this.getFirstTrackOrFail().getSettings()
      }),
      (e.prototype.applyVideoConstraints = function (t) {
        return Gu(this, void 0, void 0, function () {
          return Yu(this, function (n) {
            if ('aspectRatio' in t) throw "Changing 'aspectRatio' in run-time is not yet supported."
            return [2, this.getFirstTrackOrFail().applyConstraints(t)]
          })
        })
      }),
      (e.prototype.close = function () {
        if (this.isClosed) return Promise.resolve()
        var t = this
        return new Promise(function (n, r) {
          var i = t.mediaStream.getVideoTracks(),
            o = i.length,
            c = 0
          t.mediaStream.getVideoTracks().forEach(function (h) {
            ;(t.mediaStream.removeTrack(h),
              h.stop(),
              ++c,
              c >= o && ((t.isClosed = !0), t.parentElement.removeChild(t.surface), n()))
          })
        })
      }),
      (e.prototype.getCapabilities = function () {
        return new VT(this.getFirstTrackOrFail())
      }),
      e
    )
  })(),
  WT = (function () {
    function e(t) {
      this.mediaStream = t
    }
    return (
      (e.prototype.render = function (t, n, r) {
        return Gu(this, void 0, void 0, function () {
          return Yu(this, function (i) {
            return [2, UT.create(t, this.mediaStream, n, r)]
          })
        })
      }),
      (e.create = function (t) {
        return Gu(this, void 0, void 0, function () {
          var n, r
          return Yu(this, function (i) {
            switch (i.label) {
              case 0:
                if (!navigator.mediaDevices) throw 'navigator.mediaDevices not supported'
                return ((n = { audio: !1, video: t }), [4, navigator.mediaDevices.getUserMedia(n)])
              case 1:
                return ((r = i.sent()), [2, new e(r)])
            }
          })
        })
      }),
      e
    )
  })(),
  Hy = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  Xy = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  zT = (function () {
    function e() {}
    return (
      (e.failIfNotSupported = function () {
        return Hy(this, void 0, void 0, function () {
          return Xy(this, function (t) {
            if (!navigator.mediaDevices) throw 'navigator.mediaDevices not supported'
            return [2, new e()]
          })
        })
      }),
      (e.prototype.create = function (t) {
        return Hy(this, void 0, void 0, function () {
          return Xy(this, function (n) {
            return [2, WT.create(t)]
          })
        })
      }),
      e
    )
  })(),
  HT = function (e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (c) {
            c(o)
          })
    }
    return new (n || (n = Promise))(function (o, c) {
      function h(y) {
        try {
          p(r.next(y))
        } catch (w) {
          c(w)
        }
      }
      function f(y) {
        try {
          p(r.throw(y))
        } catch (w) {
          c(w)
        }
      }
      function p(y) {
        y.done ? o(y.value) : i(y.value).then(h, f)
      }
      p((r = r.apply(e, [])).next())
    })
  },
  XT = function (e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1]
          return o[1]
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      c
    return (
      (c = { next: h(0), throw: h(1), return: h(2) }),
      typeof Symbol == 'function' &&
        (c[Symbol.iterator] = function () {
          return this
        }),
      c
    )
    function h(p) {
      return function (y) {
        return f([p, y])
      }
    }
    function f(p) {
      if (r) throw new TypeError('Generator is already executing.')
      for (; c && ((c = 0), p[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                p[0] & 2
                  ? i.return
                  : p[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, p[1])).done)
          )
            return o
          switch (((i = 0), o && (p = [p[0] & 2, o.value]), p[0])) {
            case 0:
            case 1:
              o = p
              break
            case 4:
              return (n.label++, { value: p[1], done: !1 })
            case 5:
              ;(n.label++, (i = p[1]), (p = [0]))
              continue
            case 7:
              ;((p = n.ops.pop()), n.trys.pop())
              continue
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2))
              ) {
                n = 0
                continue
              }
              if (p[0] === 3 && (!o || (p[1] > o[0] && p[1] < o[3]))) {
                n.label = p[1]
                break
              }
              if (p[0] === 6 && n.label < o[1]) {
                ;((n.label = o[1]), (o = p))
                break
              }
              if (o && n.label < o[2]) {
                ;((n.label = o[2]), n.ops.push(p))
                break
              }
              ;(o[2] && n.ops.pop(), n.trys.pop())
              continue
          }
          p = t.call(e, n)
        } catch (y) {
          ;((p = [6, y]), (i = 0))
        } finally {
          r = o = 0
        }
      if (p[0] & 5) throw p[1]
      return { value: p[0] ? p[1] : void 0, done: !0 }
    }
  },
  GT = (function () {
    function e() {}
    return (
      (e.retrieve = function () {
        if (navigator.mediaDevices) return e.getCamerasFromMediaDevices()
        var t = MediaStreamTrack
        return MediaStreamTrack && t.getSources
          ? e.getCamerasFromMediaStreamTrack()
          : e.rejectWithError()
      }),
      (e.rejectWithError = function () {
        var t = Eo.unableToQuerySupportedDevices()
        return (
          e.isHttpsOrLocalhost() || (t = Eo.insecureContextCameraQueryError()),
          Promise.reject(t)
        )
      }),
      (e.isHttpsOrLocalhost = function () {
        if (location.protocol === 'https:') return !0
        var t = location.host.split(':')[0]
        return t === '127.0.0.1' || t === 'localhost'
      }),
      (e.getCamerasFromMediaDevices = function () {
        return HT(this, void 0, void 0, function () {
          var t, n, r, i, o, c, h
          return XT(this, function (f) {
            switch (f.label) {
              case 0:
                return (
                  (t = function (p) {
                    for (var y = p.getVideoTracks(), w = 0, x = y; w < x.length; w++) {
                      var E = x[w]
                      ;((E.enabled = !1), E.stop(), p.removeTrack(E))
                    }
                  }),
                  [4, navigator.mediaDevices.getUserMedia({ audio: !1, video: !0 })]
                )
              case 1:
                return ((n = f.sent()), [4, navigator.mediaDevices.enumerateDevices()])
              case 2:
                for (r = f.sent(), i = [], o = 0, c = r; o < c.length; o++)
                  ((h = c[o]),
                    h.kind === 'videoinput' && i.push({ id: h.deviceId, label: h.label }))
                return (t(n), [2, i])
            }
          })
        })
      }),
      (e.getCamerasFromMediaStreamTrack = function () {
        return new Promise(function (t, n) {
          var r = function (o) {
              for (var c = [], h = 0, f = o; h < f.length; h++) {
                var p = f[h]
                p.kind === 'video' && c.push({ id: p.id, label: p.label })
              }
              t(c)
            },
            i = MediaStreamTrack
          i.getSources(r)
        })
      }),
      e
    )
  })(),
  mt
;(function (e) {
  ;((e[(e.UNKNOWN = 0)] = 'UNKNOWN'),
    (e[(e.NOT_STARTED = 1)] = 'NOT_STARTED'),
    (e[(e.SCANNING = 2)] = 'SCANNING'),
    (e[(e.PAUSED = 3)] = 'PAUSED'))
})(mt || (mt = {}))
var YT = (function () {
    function e() {
      ;((this.state = mt.NOT_STARTED), (this.onGoingTransactionNewState = mt.UNKNOWN))
    }
    return (
      (e.prototype.directTransition = function (t) {
        ;(this.failIfTransitionOngoing(), this.validateTransition(t), (this.state = t))
      }),
      (e.prototype.startTransition = function (t) {
        return (
          this.failIfTransitionOngoing(),
          this.validateTransition(t),
          (this.onGoingTransactionNewState = t),
          this
        )
      }),
      (e.prototype.execute = function () {
        if (this.onGoingTransactionNewState === mt.UNKNOWN)
          throw 'Transaction is already cancelled, cannot execute().'
        var t = this.onGoingTransactionNewState
        ;((this.onGoingTransactionNewState = mt.UNKNOWN), this.directTransition(t))
      }),
      (e.prototype.cancel = function () {
        if (this.onGoingTransactionNewState === mt.UNKNOWN)
          throw 'Transaction is already cancelled, cannot cancel().'
        this.onGoingTransactionNewState = mt.UNKNOWN
      }),
      (e.prototype.getState = function () {
        return this.state
      }),
      (e.prototype.failIfTransitionOngoing = function () {
        if (this.onGoingTransactionNewState !== mt.UNKNOWN)
          throw 'Cannot transition to a new state, already under transition'
      }),
      (e.prototype.validateTransition = function (t) {
        switch (this.state) {
          case mt.UNKNOWN:
            throw 'Transition from unknown is not allowed'
          case mt.NOT_STARTED:
            this.failIfNewStateIs(t, [mt.PAUSED])
            break
          case mt.SCANNING:
            break
          case mt.PAUSED:
            break
        }
      }),
      (e.prototype.failIfNewStateIs = function (t, n) {
        for (var r = 0, i = n; r < i.length; r++) {
          var o = i[r]
          if (t === o) throw 'Cannot transition from '.concat(this.state, ' to ').concat(t)
        }
      }),
      e
    )
  })(),
  ZT = (function () {
    function e(t) {
      this.stateManager = t
    }
    return (
      (e.prototype.startTransition = function (t) {
        return this.stateManager.startTransition(t)
      }),
      (e.prototype.directTransition = function (t) {
        this.stateManager.directTransition(t)
      }),
      (e.prototype.getState = function () {
        return this.stateManager.getState()
      }),
      (e.prototype.canScanFile = function () {
        return this.stateManager.getState() === mt.NOT_STARTED
      }),
      (e.prototype.isScanning = function () {
        return this.stateManager.getState() !== mt.NOT_STARTED
      }),
      (e.prototype.isStrictlyScanning = function () {
        return this.stateManager.getState() === mt.SCANNING
      }),
      (e.prototype.isPaused = function () {
        return this.stateManager.getState() === mt.PAUSED
      }),
      e
    )
  })(),
  KT = (function () {
    function e() {}
    return (
      (e.create = function () {
        return new ZT(new YT())
      }),
      e
    )
  })(),
  qT = (function () {
    var e = function (t, n) {
      return (
        (e =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i
            }) ||
          function (r, i) {
            for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o])
          }),
        e(t, n)
      )
    }
    return function (t, n) {
      if (typeof n != 'function' && n !== null)
        throw new TypeError('Class extends value ' + String(n) + ' is not a constructor or null')
      e(t, n)
      function r() {
        this.constructor = t
      }
      t.prototype = n === null ? Object.create(n) : ((r.prototype = n.prototype), new r())
    }
  })(),
  _n = (function (e) {
    qT(t, e)
    function t() {
      return (e !== null && e.apply(this, arguments)) || this
    }
    return (
      (t.DEFAULT_WIDTH = 300),
      (t.DEFAULT_WIDTH_OFFSET = 2),
      (t.FILE_SCAN_MIN_HEIGHT = 300),
      (t.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100),
      (t.MIN_QR_BOX_SIZE = 50),
      (t.SHADED_LEFT = 1),
      (t.SHADED_RIGHT = 2),
      (t.SHADED_TOP = 3),
      (t.SHADED_BOTTOM = 4),
      (t.SHADED_REGION_ELEMENT_ID = 'qr-shaded-region'),
      (t.VERBOSE = !1),
      (t.BORDER_SHADER_DEFAULT_COLOR = '#ffffff'),
      (t.BORDER_SHADER_MATCH_COLOR = 'rgb(90, 193, 56)'),
      t
    )
  })(NT),
  QT = (function () {
    function e(t, n) {
      ;((this.logger = n),
        (this.fps = _n.SCAN_DEFAULT_FPS),
        t
          ? (t.fps && (this.fps = t.fps),
            (this.disableFlip = t.disableFlip === !0),
            (this.qrbox = t.qrbox),
            (this.aspectRatio = t.aspectRatio),
            (this.videoConstraints = t.videoConstraints))
          : (this.disableFlip = _n.DEFAULT_DISABLE_FLIP))
    }
    return (
      (e.prototype.isMediaStreamConstraintsValid = function () {
        return this.videoConstraints
          ? sb.isMediaStreamConstraintsValid(this.videoConstraints, this.logger)
          : (this.logger.logError('Empty videoConstraints', !0), !1)
      }),
      (e.prototype.isShadedBoxEnabled = function () {
        return !Dr(this.qrbox)
      }),
      (e.create = function (t, n) {
        return new e(t, n)
      }),
      e
    )
  })(),
  $T = (function () {
    function e(t, n) {
      if (
        ((this.element = null),
        (this.canvasElement = null),
        (this.scannerPausedUiElement = null),
        (this.hasBorderShaders = null),
        (this.borderShaders = null),
        (this.qrMatch = null),
        (this.renderedCamera = null),
        (this.qrRegion = null),
        (this.context = null),
        (this.lastScanImageFile = null),
        (this.isScanning = !1),
        !document.getElementById(t))
      )
        throw 'HTML Element with id='.concat(t, ' not found')
      ;((this.elementId = t), (this.verbose = !1))
      var r
      ;(typeof n == 'boolean'
        ? (this.verbose = n === !0)
        : n && ((r = n), (this.verbose = r.verbose === !0), r.experimentalFeatures),
        (this.logger = new RT(this.verbose)),
        (this.qrcode = new OT(
          this.getSupportedFormats(n),
          this.getUseBarCodeDetectorIfSupported(r),
          this.verbose,
          this.logger
        )),
        this.foreverScanTimeout,
        (this.shouldScan = !0),
        (this.stateManagerProxy = KT.create()))
    }
    return (
      (e.prototype.start = function (t, n, r, i) {
        var o = this
        if (!t) throw 'cameraIdOrConfig is required'
        if (!r || typeof r != 'function')
          throw 'qrCodeSuccessCallback is required and should be a function.'
        var c
        i ? (c = i) : (c = this.verbose ? this.logger.log : function () {})
        var h = QT.create(n, this.logger)
        this.clearElement()
        var f = !1
        h.videoConstraints &&
          (h.isMediaStreamConstraintsValid()
            ? (f = !0)
            : this.logger.logError(
                "'videoConstraints' is not valid 'MediaStreamConstraints, it will be ignored.'",
                !0
              ))
        var p = f,
          y = document.getElementById(this.elementId)
        ;(y.clientWidth ? y.clientWidth : _n.DEFAULT_WIDTH,
          (y.style.position = 'relative'),
          (this.shouldScan = !0),
          (this.element = y))
        var w = this,
          x = this.stateManagerProxy.startTransition(mt.SCANNING)
        return new Promise(function (E, S) {
          var k = p ? h.videoConstraints : w.createVideoConstraints(t)
          if (!k) {
            ;(x.cancel(), S('videoConstraints should be defined'))
            return
          }
          var P = {}
          ;(!p || h.aspectRatio) && (P.aspectRatio = h.aspectRatio)
          var I = {
            onRenderSurfaceReady: function (R, M) {
              ;(w.setupUi(R, M, h), (w.isScanning = !0), w.foreverScan(h, r, c))
            },
          }
          zT.failIfNotSupported()
            .then(function (R) {
              R.create(k)
                .then(function (M) {
                  return M.render(o.element, P, I)
                    .then(function (O) {
                      ;((w.renderedCamera = O), x.execute(), E(null))
                    })
                    .catch(function (O) {
                      ;(x.cancel(), S(O))
                    })
                })
                .catch(function (M) {
                  ;(x.cancel(), S(Eo.errorGettingUserMedia(M)))
                })
            })
            .catch(function (R) {
              ;(x.cancel(), S(Eo.cameraStreamingNotSupported()))
            })
        })
      }),
      (e.prototype.pause = function (t) {
        if (!this.stateManagerProxy.isStrictlyScanning())
          throw 'Cannot pause, scanner is not scanning.'
        ;(this.stateManagerProxy.directTransition(mt.PAUSED),
          this.showPausedState(),
          (Dr(t) || t !== !0) && (t = !1),
          t && this.renderedCamera && this.renderedCamera.pause())
      }),
      (e.prototype.resume = function () {
        if (!this.stateManagerProxy.isPaused()) throw 'Cannot result, scanner is not paused.'
        if (!this.renderedCamera) throw "renderedCamera doesn't exist while trying resume()"
        var t = this,
          n = function () {
            ;(t.stateManagerProxy.directTransition(mt.SCANNING), t.hidePausedState())
          }
        if (!this.renderedCamera.isPaused()) {
          n()
          return
        }
        this.renderedCamera.resume(function () {
          n()
        })
      }),
      (e.prototype.getState = function () {
        return this.stateManagerProxy.getState()
      }),
      (e.prototype.stop = function () {
        var t = this
        if (!this.stateManagerProxy.isScanning())
          throw 'Cannot stop, scanner is not running or paused.'
        var n = this.stateManagerProxy.startTransition(mt.NOT_STARTED)
        ;((this.shouldScan = !1), this.foreverScanTimeout && clearTimeout(this.foreverScanTimeout))
        var r = function () {
            if (t.element) {
              var o = document.getElementById(_n.SHADED_REGION_ELEMENT_ID)
              o && t.element.removeChild(o)
            }
          },
          i = this
        return this.renderedCamera.close().then(function () {
          return (
            (i.renderedCamera = null),
            i.element && (i.element.removeChild(i.canvasElement), (i.canvasElement = null)),
            r(),
            i.qrRegion && (i.qrRegion = null),
            i.context && (i.context = null),
            n.execute(),
            i.hidePausedState(),
            (i.isScanning = !1),
            Promise.resolve()
          )
        })
      }),
      (e.prototype.scanFile = function (t, n) {
        return this.scanFileV2(t, n).then(function (r) {
          return r.decodedText
        })
      }),
      (e.prototype.scanFileV2 = function (t, n) {
        var r = this
        if (!t || !(t instanceof File))
          throw "imageFile argument is mandatory and should be instance of File. Use 'event.target.files[0]'."
        if ((Dr(n) && (n = !0), !this.stateManagerProxy.canScanFile()))
          throw 'Cannot start file scan - ongoing camera scan'
        return new Promise(function (i, o) {
          ;(r.possiblyCloseLastScanImageFile(),
            r.clearElement(),
            (r.lastScanImageFile = URL.createObjectURL(t)))
          var c = new Image()
          ;((c.onload = function () {
            var h = c.width,
              f = c.height,
              p = document.getElementById(r.elementId),
              y = p.clientWidth ? p.clientWidth : _n.DEFAULT_WIDTH,
              w = Math.max(p.clientHeight ? p.clientHeight : f, _n.FILE_SCAN_MIN_HEIGHT),
              x = r.computeCanvasDrawConfig(h, f, y, w)
            if (n) {
              var E = r.createCanvasElement(y, w, 'qr-canvas-visible')
              ;((E.style.display = 'inline-block'), p.appendChild(E))
              var S = E.getContext('2d')
              if (!S) throw 'Unable to get 2d context from canvas'
              ;((S.canvas.width = y),
                (S.canvas.height = w),
                S.drawImage(c, 0, 0, h, f, x.x, x.y, x.width, x.height))
            }
            var k = _n.FILE_SCAN_HIDDEN_CANVAS_PADDING,
              P = Math.max(c.width, x.width),
              I = Math.max(c.height, x.height),
              R = P + 2 * k,
              M = I + 2 * k,
              O = r.createCanvasElement(R, M)
            p.appendChild(O)
            var F = O.getContext('2d')
            if (!F) throw 'Unable to get 2d context from canvas'
            ;((F.canvas.width = R), (F.canvas.height = M), F.drawImage(c, 0, 0, h, f, k, k, P, I))
            try {
              r.qrcode
                .decodeRobustlyAsync(O)
                .then(function (z) {
                  i(jy.createFromQrcodeResult(z))
                })
                .catch(o)
            } catch (z) {
              o('QR code parse error, error = '.concat(z))
            }
          }),
            (c.onerror = o),
            (c.onabort = o),
            (c.onstalled = o),
            (c.onsuspend = o),
            (c.src = URL.createObjectURL(t)))
        })
      }),
      (e.prototype.clear = function () {
        this.clearElement()
      }),
      (e.getCameras = function () {
        return GT.retrieve()
      }),
      (e.prototype.getRunningTrackCapabilities = function () {
        return this.getRenderedCameraOrFail().getRunningTrackCapabilities()
      }),
      (e.prototype.getRunningTrackSettings = function () {
        return this.getRenderedCameraOrFail().getRunningTrackSettings()
      }),
      (e.prototype.getRunningTrackCameraCapabilities = function () {
        return this.getRenderedCameraOrFail().getCapabilities()
      }),
      (e.prototype.applyVideoConstraints = function (t) {
        if (t) {
          if (!sb.isMediaStreamConstraintsValid(t, this.logger))
            throw 'invalid videoConstaints passed, check logs for more details'
        } else throw 'videoConstaints is required argument.'
        return this.getRenderedCameraOrFail().applyVideoConstraints(t)
      }),
      (e.prototype.getRenderedCameraOrFail = function () {
        if (this.renderedCamera == null)
          throw 'Scanning is not in running state, call this API only when QR code scanning using camera is in running state.'
        return this.renderedCamera
      }),
      (e.prototype.getSupportedFormats = function (t) {
        var n = [
          le.QR_CODE,
          le.AZTEC,
          le.CODABAR,
          le.CODE_39,
          le.CODE_93,
          le.CODE_128,
          le.DATA_MATRIX,
          le.MAXICODE,
          le.ITF,
          le.EAN_13,
          le.EAN_8,
          le.PDF_417,
          le.RSS_14,
          le.RSS_EXPANDED,
          le.UPC_A,
          le.UPC_E,
          le.UPC_EAN_EXTENSION,
        ]
        if (!t || typeof t == 'boolean' || !t.formatsToSupport) return n
        if (!Array.isArray(t.formatsToSupport))
          throw 'configOrVerbosityFlag.formatsToSupport should be undefined or an array.'
        if (t.formatsToSupport.length === 0) throw 'Atleast 1 formatsToSupport is needed.'
        for (var r = [], i = 0, o = t.formatsToSupport; i < o.length; i++) {
          var c = o[i]
          IT(c)
            ? r.push(c)
            : this.logger.warn('Invalid format: '.concat(c, ' passed in config, ignoring.'))
        }
        if (r.length === 0) throw 'None of formatsToSupport match supported values.'
        return r
      }),
      (e.prototype.getUseBarCodeDetectorIfSupported = function (t) {
        if (Dr(t)) return !0
        if (!Dr(t.useBarCodeDetectorIfSupported)) return t.useBarCodeDetectorIfSupported !== !1
        if (Dr(t.experimentalFeatures)) return !0
        var n = t.experimentalFeatures
        return Dr(n.useBarCodeDetectorIfSupported) ? !0 : n.useBarCodeDetectorIfSupported !== !1
      }),
      (e.prototype.validateQrboxSize = function (t, n, r) {
        var i = this,
          o = r.qrbox
        this.validateQrboxConfig(o)
        var c = this.toQrdimensions(t, n, o),
          h = function (p) {
            if (p < _n.MIN_QR_BOX_SIZE)
              throw (
                "minimum size of 'config.qrbox' dimension value is" +
                ' '.concat(_n.MIN_QR_BOX_SIZE, 'px.')
              )
          },
          f = function (p) {
            return (
              p > t &&
                (i.logger.warn(
                  '`qrbox.width` or `qrbox` is larger than the width of the root element. The width will be truncated to the width of root element.'
                ),
                (p = t)),
              p
            )
          }
        ;(h(c.width), h(c.height), (c.width = f(c.width)))
      }),
      (e.prototype.validateQrboxConfig = function (t) {
        if (
          typeof t != 'number' &&
          typeof t != 'function' &&
          (t.width === void 0 || t.height === void 0)
        )
          throw "Invalid instance of QrDimensions passed for 'config.qrbox'. Both 'width' and 'height' should be set."
      }),
      (e.prototype.toQrdimensions = function (t, n, r) {
        if (typeof r == 'number') return { width: r, height: r }
        if (typeof r == 'function')
          try {
            return r(t, n)
          } catch (i) {
            throw new Error(
              'qrbox config was passed as a function but it failed with unknown error' + i
            )
          }
        return r
      }),
      (e.prototype.setupUi = function (t, n, r) {
        r.isShadedBoxEnabled() && this.validateQrboxSize(t, n, r)
        var i = Dr(r.qrbox) ? { width: t, height: n } : r.qrbox
        this.validateQrboxConfig(i)
        var o = this.toQrdimensions(t, n, i)
        o.height > n &&
          this.logger.warn(
            '[Html5Qrcode] config.qrbox has height that isgreater than the height of the video stream. Shading will be ignored'
          )
        var c = r.isShadedBoxEnabled() && o.height <= n,
          h = { x: 0, y: 0, width: t, height: n },
          f = c ? this.getShadedRegionBounds(t, n, o) : h,
          p = this.createCanvasElement(f.width, f.height),
          y = { willReadFrequently: !0 },
          w = p.getContext('2d', y)
        ;((w.canvas.width = f.width),
          (w.canvas.height = f.height),
          this.element.append(p),
          c && this.possiblyInsertShadingElement(this.element, t, n, o),
          this.createScannerPausedUiElement(this.element),
          (this.qrRegion = f),
          (this.context = w),
          (this.canvasElement = p))
      }),
      (e.prototype.createScannerPausedUiElement = function (t) {
        var n = document.createElement('div')
        ;((n.innerText = Eo.scannerPaused()),
          (n.style.display = 'none'),
          (n.style.position = 'absolute'),
          (n.style.top = '0px'),
          (n.style.zIndex = '1'),
          (n.style.background = 'rgba(9, 9, 9, 0.46)'),
          (n.style.color = '#FFECEC'),
          (n.style.textAlign = 'center'),
          (n.style.width = '100%'),
          t.appendChild(n),
          (this.scannerPausedUiElement = n))
      }),
      (e.prototype.scanContext = function (t, n) {
        var r = this
        return this.stateManagerProxy.isPaused()
          ? Promise.resolve(!1)
          : this.qrcode
              .decodeAsync(this.canvasElement)
              .then(function (i) {
                return (t(i.text, jy.createFromQrcodeResult(i)), r.possiblyUpdateShaders(!0), !0)
              })
              .catch(function (i) {
                r.possiblyUpdateShaders(!1)
                var o = Eo.codeParseError(i)
                return (n(o, TT.createFrom(o)), !1)
              })
      }),
      (e.prototype.foreverScan = function (t, n, r) {
        var i = this
        if (this.shouldScan && this.renderedCamera) {
          var o = this.renderedCamera.getSurface(),
            c = o.videoWidth / o.clientWidth,
            h = o.videoHeight / o.clientHeight
          if (!this.qrRegion) throw 'qrRegion undefined when localMediaStream is ready.'
          var f = this.qrRegion.width * c,
            p = this.qrRegion.height * h,
            y = this.qrRegion.x * c,
            w = this.qrRegion.y * h
          this.context.drawImage(o, y, w, f, p, 0, 0, this.qrRegion.width, this.qrRegion.height)
          var x = function () {
            i.foreverScanTimeout = setTimeout(function () {
              i.foreverScan(t, n, r)
            }, i.getTimeoutFps(t.fps))
          }
          this.scanContext(n, r)
            .then(function (E) {
              !E && t.disableFlip !== !0
                ? (i.context.translate(i.context.canvas.width, 0),
                  i.context.scale(-1, 1),
                  i.scanContext(n, r).finally(function () {
                    x()
                  }))
                : x()
            })
            .catch(function (E) {
              ;(i.logger.logError('Error happend while scanning context', E), x())
            })
        }
      }),
      (e.prototype.createVideoConstraints = function (t) {
        if (typeof t == 'string') return { deviceId: { exact: t } }
        if (typeof t == 'object') {
          var n = 'facingMode',
            r = 'deviceId',
            i = { user: !0, environment: !0 },
            o = 'exact',
            c = function (S) {
              if (S in i) return !0
              throw "config has invalid 'facingMode' value = " + "'".concat(S, "'")
            },
            h = Object.keys(t)
          if (h.length !== 1)
            throw (
              "'cameraIdOrConfig' object should have exactly 1 key," +
              ' if passed as an object, found '.concat(h.length, ' keys')
            )
          var f = Object.keys(t)[0]
          if (f !== n && f !== r)
            throw (
              "Only '".concat(n, "' and '").concat(r, "' ") +
              " are supported for 'cameraIdOrConfig'"
            )
          if (f === n) {
            var p = t.facingMode
            if (typeof p == 'string') {
              if (c(p)) return { facingMode: p }
            } else if (typeof p == 'object')
              if (o in p) {
                if (c(p[''.concat(o)])) return { facingMode: { exact: p[''.concat(o)] } }
              } else
                throw "'facingMode' should be string or object with" + ' '.concat(o, ' as key.')
            else {
              var y = typeof p
              throw "Invalid type of 'facingMode' = ".concat(y)
            }
          } else {
            var w = t.deviceId
            if (typeof w == 'string') return { deviceId: w }
            if (typeof w == 'object') {
              if (o in w) return { deviceId: { exact: w[''.concat(o)] } }
              throw "'deviceId' should be string or object with" + ' '.concat(o, ' as key.')
            } else {
              var x = typeof w
              throw "Invalid type of 'deviceId' = ".concat(x)
            }
          }
        }
        var E = typeof t
        throw "Invalid type of 'cameraIdOrConfig' = ".concat(E)
      }),
      (e.prototype.computeCanvasDrawConfig = function (t, n, r, i) {
        if (t <= r && n <= i) {
          var o = (r - t) / 2,
            c = (i - n) / 2
          return { x: o, y: c, width: t, height: n }
        } else {
          var h = t,
            f = n
          return (
            t > r && ((n = (r / t) * n), (t = r)),
            n > i && ((t = (i / n) * t), (n = i)),
            this.logger.log(
              'Image downsampled from ' +
                ''.concat(h, 'X').concat(f) +
                ' to '.concat(t, 'X').concat(n, '.')
            ),
            this.computeCanvasDrawConfig(t, n, r, i)
          )
        }
      }),
      (e.prototype.clearElement = function () {
        if (this.stateManagerProxy.isScanning())
          throw 'Cannot clear while scan is ongoing, close it first.'
        var t = document.getElementById(this.elementId)
        t && (t.innerHTML = '')
      }),
      (e.prototype.possiblyUpdateShaders = function (t) {
        this.qrMatch !== t &&
          (this.hasBorderShaders &&
            this.borderShaders &&
            this.borderShaders.length &&
            this.borderShaders.forEach(function (n) {
              n.style.backgroundColor = t
                ? _n.BORDER_SHADER_MATCH_COLOR
                : _n.BORDER_SHADER_DEFAULT_COLOR
            }),
          (this.qrMatch = t))
      }),
      (e.prototype.possiblyCloseLastScanImageFile = function () {
        this.lastScanImageFile &&
          (URL.revokeObjectURL(this.lastScanImageFile), (this.lastScanImageFile = null))
      }),
      (e.prototype.createCanvasElement = function (t, n, r) {
        var i = t,
          o = n,
          c = document.createElement('canvas')
        return (
          (c.style.width = ''.concat(i, 'px')),
          (c.style.height = ''.concat(o, 'px')),
          (c.style.display = 'none'),
          (c.id = Dr(r) ? 'qr-canvas' : r),
          c
        )
      }),
      (e.prototype.getShadedRegionBounds = function (t, n, r) {
        if (r.width > t || r.height > n)
          throw "'config.qrbox' dimensions should not be greater than the dimensions of the root HTML element."
        return { x: (t - r.width) / 2, y: (n - r.height) / 2, width: r.width, height: r.height }
      }),
      (e.prototype.possiblyInsertShadingElement = function (t, n, r, i) {
        if (!(n - i.width < 1 || r - i.height < 1)) {
          var o = document.createElement('div')
          o.style.position = 'absolute'
          var c = (n - i.width) / 2,
            h = (r - i.height) / 2
          if (
            ((o.style.borderLeft = ''.concat(c, 'px solid rgba(0, 0, 0, 0.48)')),
            (o.style.borderRight = ''.concat(c, 'px solid rgba(0, 0, 0, 0.48)')),
            (o.style.borderTop = ''.concat(h, 'px solid rgba(0, 0, 0, 0.48)')),
            (o.style.borderBottom = ''.concat(h, 'px solid rgba(0, 0, 0, 0.48)')),
            (o.style.boxSizing = 'border-box'),
            (o.style.top = '0px'),
            (o.style.bottom = '0px'),
            (o.style.left = '0px'),
            (o.style.right = '0px'),
            (o.id = ''.concat(_n.SHADED_REGION_ELEMENT_ID)),
            n - i.width < 11 || r - i.height < 11)
          )
            this.hasBorderShaders = !1
          else {
            var f = 5,
              p = 40
            ;(this.insertShaderBorders(o, p, f, -f, null, 0, !0),
              this.insertShaderBorders(o, p, f, -f, null, 0, !1),
              this.insertShaderBorders(o, p, f, null, -f, 0, !0),
              this.insertShaderBorders(o, p, f, null, -f, 0, !1),
              this.insertShaderBorders(o, f, p + f, -f, null, -f, !0),
              this.insertShaderBorders(o, f, p + f, null, -f, -f, !0),
              this.insertShaderBorders(o, f, p + f, -f, null, -f, !1),
              this.insertShaderBorders(o, f, p + f, null, -f, -f, !1),
              (this.hasBorderShaders = !0))
          }
          t.append(o)
        }
      }),
      (e.prototype.insertShaderBorders = function (t, n, r, i, o, c, h) {
        var f = document.createElement('div')
        ;((f.style.position = 'absolute'),
          (f.style.backgroundColor = _n.BORDER_SHADER_DEFAULT_COLOR),
          (f.style.width = ''.concat(n, 'px')),
          (f.style.height = ''.concat(r, 'px')),
          i !== null && (f.style.top = ''.concat(i, 'px')),
          o !== null && (f.style.bottom = ''.concat(o, 'px')),
          h ? (f.style.left = ''.concat(c, 'px')) : (f.style.right = ''.concat(c, 'px')),
          this.borderShaders || (this.borderShaders = []),
          this.borderShaders.push(f),
          t.appendChild(f))
      }),
      (e.prototype.showPausedState = function () {
        if (!this.scannerPausedUiElement)
          throw '[internal error] scanner paused UI element not found'
        this.scannerPausedUiElement.style.display = 'block'
      }),
      (e.prototype.hidePausedState = function () {
        if (!this.scannerPausedUiElement)
          throw '[internal error] scanner paused UI element not found'
        this.scannerPausedUiElement.style.display = 'none'
      }),
      (e.prototype.getTimeoutFps = function (t) {
        return 1e3 / t
      }),
      e
    )
  })(),
  Gy
;(function (e) {
  ;((e[(e.STATUS_DEFAULT = 0)] = 'STATUS_DEFAULT'),
    (e[(e.STATUS_SUCCESS = 1)] = 'STATUS_SUCCESS'),
    (e[(e.STATUS_WARNING = 2)] = 'STATUS_WARNING'),
    (e[(e.STATUS_REQUESTING_PERMISSION = 3)] = 'STATUS_REQUESTING_PERMISSION'))
})(Gy || (Gy = {}))
const JT = ({ onScan: e }) => {
  const t = X.useRef(null),
    [n, r] = X.useState(!1),
    [i, o] = X.useState(null),
    c = 'vibe-prism-scanner'
  return (
    X.useEffect(() => {
      if (!n) return
      const h = new $T(c)
      return (
        (t.current = h),
        h
          .start(
            { facingMode: 'environment' },
            { fps: 10, qrbox: { width: 220, height: 220 } },
            (f) => {
              ;(e(f), h.stop().catch(() => {}), r(!1))
            },
            (f) => {
              ;(typeof f == 'string' && f.includes('NotFound')) ||
                o('Camera scan is active. Align the QR token.')
            }
          )
          .catch((f) => {
            ;(o(String(f)), r(!1))
          }),
        () => {
          h.stop()
            .then(() => h.clear())
            .catch(() => {})
        }
      )
    }, [n, e]),
    N.jsxs('div', {
      className: 'glass-panel p-6',
      children: [
        N.jsxs('div', {
          className: 'flex items-center gap-3',
          children: [
            N.jsx(Vl, { size: 24, className: 'text-emerald-300' }),
            N.jsxs('div', {
              children: [
                N.jsx('h3', { className: 'text-lg font-semibold', children: 'Scan Token' }),
                N.jsx('p', {
                  className: 'text-sm text-slate-400',
                  children: 'Use your camera to restore a Nexus Who payload.',
                }),
              ],
            }),
          ],
        }),
        N.jsx('div', {
          className: 'mt-4',
          children: N.jsx('button', {
            type: 'button',
            onClick: () => r((h) => !h),
            className: 'button-secondary',
            children: n ? 'Stop Scanner' : 'Start Scanner',
          }),
        }),
        n && N.jsx('div', { id: c, className: 'mt-4 overflow-hidden rounded-xl' }),
        i && N.jsx('p', { className: 'mt-3 text-xs text-rose-300', children: i }),
      ],
    })
  )
}
Wl.register(xo, Ja, Ur, X3, Z3, ru, yf, bf, IN)
const Yy = {
    GREEN: 'bg-emerald-500/10 text-emerald-200 border-emerald-400/30',
    YELLOW: 'bg-amber-500/10 text-amber-200 border-amber-400/30',
    RED: 'bg-rose-500/10 text-rose-200 border-rose-400/30',
  },
  eR = {
    masking: 'Rapid defensive responses detected under 450ms.',
    contradictions: 'Lie-trap items returned high agreement.',
    halo: 'Response pattern suggests overly idealized self-presentation.',
  },
  tR = () => {
    const [e, t] = X.useState(sessionStorage.getItem('VP_DECODE_UNLOCK') === '1'),
      [n, r] = X.useState(t3() ?? ''),
      [i, o] = X.useState(null),
      [c, h] = X.useState(null),
      f = X.useCallback(async (E) => {
        try {
          const S = e3(E.trim()).split('|'),
            k = S.pop(),
            P = S.join('|')
          if (!k) throw new Error('Checksum missing')
          if ((await tp(P)).slice(0, 8) !== k) throw new Error('Checksum mismatch')
          if (S[0] !== 'VP1') throw new Error('Unsupported payload')
          const I = S[14],
            R = JSON.parse(I),
            M = S[12]
              .split(';')
              .map((F) => F.split(':'))
              .filter((F) => F[1] === 'true')
              .map((F) => F[0]),
            O = S[13] === 'none' ? [] : S[13].split('~')
          ;(o({
            band: S[3],
            dtiBase: Number(S[4]),
            dtiFinal: Number(S[5]),
            scores: { N: Number(S[6]), M: Number(S[7]), P: Number(S[8]), MD: Number(S[9]) },
            integrity: Number(S[10]),
            archetype: S[11],
            maskFlags: M,
            overrideFlags: O,
            answers: R,
          }),
            h(null))
        } catch (S) {
          ;(h(String(S)), o(null))
        }
      }, []),
      p = () => {
        if (!n.trim()) {
          h('Paste a token or scan a QR code.')
          return
        }
        f(n.trim())
      },
      y = X.useMemo(() => (i ? new Map(i.answers.map((E) => [E.questionId, E])) : new Map()), [i]),
      w = X.useMemo(() => {
        if (!i) return null
        const E = {
            labels: ['N', 'M', 'P', 'MD'],
            datasets: [
              {
                label: 'Trait Strength',
                data: [i.scores.N, i.scores.M, i.scores.P, i.scores.MD],
                backgroundColor: 'rgba(56, 189, 248, 0.15)',
                borderColor: 'rgba(56, 189, 248, 0.6)',
                borderWidth: 2,
                pointBackgroundColor: 'rgba(56, 189, 248, 0.9)',
              },
            ],
          },
          S = {
            labels: ['N', 'M', 'P', 'MD'],
            datasets: [
              {
                label: 'Intensity',
                data: [i.scores.N, i.scores.M, i.scores.P, i.scores.MD],
                backgroundColor: [
                  'rgba(16, 185, 129, 0.4)',
                  'rgba(59, 130, 246, 0.4)',
                  'rgba(239, 68, 68, 0.4)',
                  'rgba(251, 191, 36, 0.4)',
                ],
                borderRadius: 8,
              },
            ],
          },
          k = i.answers.map((I) => I.rtMs),
          P = {
            labels: i.answers.map((I) => `Q${I.questionId}`),
            datasets: [
              {
                label: 'Response Time (ms)',
                data: k,
                borderColor: 'rgba(148, 163, 184, 0.8)',
                backgroundColor: 'rgba(148, 163, 184, 0.2)',
                pointBackgroundColor: k.map((I) =>
                  I < 450 ? 'rgba(248, 113, 113, 0.9)' : 'rgba(148, 163, 184, 0.9)'
                ),
                tension: 0.3,
              },
            ],
          }
        return { radarData: E, barData: S, lineData: P }
      }, [i]),
      x = () => {
        if (!i) return
        const E = window.open('', '_blank')
        E &&
          (E.document.write(`
      <html>
        <head>
          <title>Nexus Who Report</title>
          <style>
            body { font-family: Inter, sans-serif; padding: 32px; background: #0f172a; color: #e2e8f0; }
            h1, h2 { color: #f8fafc; }
            .badge { display: inline-block; padding: 6px 12px; border-radius: 999px; background: #1e293b; margin-right: 8px; }
            .section { margin-bottom: 24px; }
          </style>
        </head>
        <body>
          <h1>Nexus Who Forensic Report</h1>
          <div class="section">
            <h2>Summary</h2>
            <p><span class="badge">Band: ${i.band}</span><span class="badge">Archetype: ${i.archetype}</span></p>
            <p>DTI Base: ${i.dtiBase} | DTI Final: ${i.dtiFinal}</p>
            <p>Integrity: ${i.integrity}</p>
          </div>
          <div class="section">
            <h2>Overrides</h2>
            <p>${i.overrideFlags.join('; ') || 'None'}</p>
          </div>
          <div class="section">
            <h2>Masking & Integrity Flags</h2>
            <p>${i.maskFlags.join(', ') || 'None'}</p>
          </div>
        </body>
      </html>
    `),
          E.document.close(),
          E.focus(),
          E.print())
      }
    return e
      ? N.jsxs('div', {
          className: 'mx-auto flex w-full max-w-6xl flex-col gap-8 px-6 py-16',
          children: [
            N.jsxs('div', {
              className: 'flex flex-wrap items-center justify-between gap-4',
              children: [
                N.jsxs('div', {
                  children: [
                    N.jsx('p', {
                      className: 'text-xs uppercase tracking-[0.4em] text-slate-400',
                      children: 'Nexus Who  forensic decoder',
                    }),
                    N.jsx('h1', {
                      className: 'mt-3 text-3xl font-semibold',
                      children: 'Restore & Decode',
                    }),
                    N.jsx('p', {
                      className: 'mt-2 text-sm text-slate-400',
                      children:
                        'Paste a token or scan your QR to rebuild the full report in seconds.',
                    }),
                  ],
                }),
                N.jsxs('button', {
                  type: 'button',
                  onClick: x,
                  className: 'button-secondary',
                  children: [N.jsx(K6, { size: 18 }), 'Download Report'],
                }),
              ],
            }),
            N.jsxs('section', {
              className: 'grid gap-6 lg:grid-cols-[1.1fr_0.9fr]',
              children: [
                N.jsxs('div', {
                  className: 'glass-panel p-6',
                  children: [
                    N.jsxs('div', {
                      className: 'flex items-center gap-3',
                      children: [
                        N.jsx(xs, { size: 22, className: 'text-emerald-300' }),
                        N.jsxs('div', {
                          children: [
                            N.jsx('h3', {
                              className: 'text-lg font-semibold',
                              children: 'Decoder Status',
                            }),
                            N.jsx('p', {
                              className: 'text-sm text-slate-400',
                              children:
                                'Your session is authenticated for secure profile restoration.',
                            }),
                          ],
                        }),
                      ],
                    }),
                    N.jsxs('div', {
                      className: 'mt-4 grid gap-3 text-sm text-slate-300',
                      children: [
                        N.jsxs('div', {
                          className:
                            'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                          children: [
                            N.jsx('span', { children: 'Session' }),
                            N.jsx('span', { className: 'text-emerald-200', children: 'Unlocked' }),
                          ],
                        }),
                        N.jsxs('div', {
                          className:
                            'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                          children: [
                            N.jsx('span', { children: 'Storage' }),
                            N.jsx('span', { className: 'text-slate-300', children: 'Local only' }),
                          ],
                        }),
                        N.jsxs('div', {
                          className:
                            'flex items-center justify-between rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2',
                          children: [
                            N.jsx('span', { children: 'Report' }),
                            N.jsx('span', {
                              className: 'text-slate-300',
                              children: 'Full forensic',
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
                N.jsxs('div', {
                  className: 'glass-panel p-6',
                  children: [
                    N.jsx('h3', {
                      className: 'text-lg font-semibold',
                      children: 'Decode checklist',
                    }),
                    N.jsx('ul', {
                      className: 'mt-4 space-y-2 text-sm text-slate-300',
                      children: [
                        'Use the most recent token for accurate scores.',
                        'Scan in a well-lit space for best QR results.',
                        'Export a PDF if you need to share the report.',
                      ].map((E) => N.jsx('li', { className: 'list-item', children: E }, E)),
                    }),
                  ],
                }),
              ],
            }),
            N.jsxs('div', {
              className: 'grid gap-6 lg:grid-cols-[1.1fr_0.9fr]',
              children: [
                N.jsxs('div', {
                  className: 'glass-panel p-6',
                  children: [
                    N.jsxs('div', {
                      className: 'flex items-center gap-3',
                      children: [
                        N.jsx(xs, { size: 22, className: 'text-emerald-300' }),
                        N.jsxs('div', {
                          children: [
                            N.jsx('h3', {
                              className: 'text-lg font-semibold',
                              children: 'Paste Token',
                            }),
                            N.jsx('p', {
                              className: 'text-sm text-slate-400',
                              children:
                                'Paste the Base64 URL-safe token to decode the full report.',
                            }),
                          ],
                        }),
                      ],
                    }),
                    N.jsx('textarea', {
                      value: n,
                      onChange: (E) => r(E.target.value),
                      className:
                        'mt-4 h-28 w-full rounded-xl border border-white/10 bg-slate-900/60 p-3 text-xs text-slate-200',
                    }),
                    c && N.jsx('p', { className: 'mt-2 text-xs text-rose-300', children: c }),
                    N.jsx('button', {
                      type: 'button',
                      onClick: p,
                      className: 'button-primary mt-4',
                      children: 'Decode Token',
                    }),
                  ],
                }),
                N.jsx(JT, {
                  onScan: (E) => {
                    ;(r(E), f(E))
                  },
                }),
              ],
            }),
            i &&
              w &&
              N.jsxs(qn.div, {
                initial: { opacity: 0 },
                animate: { opacity: 1 },
                transition: { duration: 0.4 },
                className: 'flex flex-col gap-8',
                children: [
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex flex-wrap items-center justify-between gap-4',
                        children: [
                          N.jsxs('div', {
                            children: [
                              N.jsx('p', {
                                className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                                children: 'Summary',
                              }),
                              N.jsx('h2', {
                                className: 'text-2xl font-semibold',
                                children: 'Forensic Snapshot',
                              }),
                            ],
                          }),
                          N.jsx('span', {
                            className: `badge border ${Yy[i.band] ?? Yy.GREEN}`,
                            children: i.band,
                          }),
                        ],
                      }),
                      N.jsxs('div', {
                        className: 'mt-4 grid gap-4 md:grid-cols-2',
                        children: [
                          N.jsxs('div', {
                            className: 'rounded-xl border border-white/10 bg-slate-900/60 p-4',
                            children: [
                              N.jsx('p', {
                                className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                                children: 'DTI',
                              }),
                              N.jsxs('p', {
                                className: 'mt-2 text-lg font-semibold',
                                children: ['Base ', i.dtiBase, '  Final ', i.dtiFinal],
                              }),
                            ],
                          }),
                          N.jsxs('div', {
                            className: 'rounded-xl border border-white/10 bg-slate-900/60 p-4',
                            children: [
                              N.jsx('p', {
                                className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                                children: 'Archetype',
                              }),
                              N.jsx('p', {
                                className: 'mt-2 text-lg font-semibold',
                                children: i.archetype,
                              }),
                            ],
                          }),
                          N.jsxs('div', {
                            className: 'rounded-xl border border-white/10 bg-slate-900/60 p-4',
                            children: [
                              N.jsxs('div', {
                                className: 'flex items-center gap-2 text-sm text-slate-400',
                                children: [N.jsx($0, { size: 18 }), 'Integrity Score'],
                              }),
                              N.jsx('p', {
                                className: 'mt-2 text-lg font-semibold',
                                children: i.integrity,
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex items-center gap-3',
                        children: [
                          N.jsx(Qc, { size: 22, className: 'text-rose-300' }),
                          N.jsxs('div', {
                            children: [
                              N.jsx('h2', {
                                className: 'text-xl font-semibold',
                                children: 'Overrides & Safety Triggers',
                              }),
                              N.jsx('p', {
                                className: 'text-sm text-slate-400',
                                children: 'Immediate escalations based on safety thresholds.',
                              }),
                            ],
                          }),
                        ],
                      }),
                      N.jsxs('div', {
                        className: 'mt-4 space-y-2',
                        children: [
                          i.overrideFlags.length === 0 &&
                            N.jsx('p', {
                              className: 'text-sm text-slate-400',
                              children: 'No overrides triggered.',
                            }),
                          i.overrideFlags.map((E) =>
                            N.jsxs(
                              qn.div,
                              {
                                initial: { opacity: 0 },
                                animate: { opacity: [0.7, 1, 0.7] },
                                transition: { duration: 2.4, repeat: 1 / 0, ease: 'easeInOut' },
                                className:
                                  'flex items-center gap-3 rounded-xl border border-rose-500/30 bg-rose-500/10 p-3',
                                children: [
                                  N.jsx(Qc, { size: 18, className: 'text-rose-300' }),
                                  N.jsx('span', {
                                    className: 'text-sm text-rose-100',
                                    children: E,
                                  }),
                                ],
                              },
                              E
                            )
                          ),
                        ],
                      }),
                      N.jsx('p', {
                        className: 'mt-3 text-xs text-slate-400',
                        children:
                          'Overrides trigger when Q11, Q15, or Q18 score  2, or when trait levels cross the P > 75 and MD > 60 threshold.',
                      }),
                      i.overrideFlags.length > 0 &&
                        N.jsx('p', {
                          className: 'mt-3 text-xs text-rose-200',
                          children: 'Band escalated to RED due to active overrides.',
                        }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex items-center gap-3',
                        children: [
                          N.jsx(bh, { size: 22, className: 'text-emerald-300' }),
                          N.jsxs('div', {
                            children: [
                              N.jsx('h2', {
                                className: 'text-xl font-semibold',
                                children: 'Trait Analysis',
                              }),
                              N.jsx('p', {
                                className: 'text-sm text-slate-400',
                                children: 'Weighted trait intensities.',
                              }),
                            ],
                          }),
                        ],
                      }),
                      N.jsxs('div', {
                        className: 'mt-6 grid gap-6 lg:grid-cols-2',
                        children: [
                          N.jsx('div', {
                            className: 'h-64',
                            children: N.jsx(eb, {
                              data: w.radarData,
                              options: {
                                scales: {
                                  r: {
                                    ticks: { display: !1 },
                                    grid: { color: 'rgba(148, 163, 184, 0.2)' },
                                    pointLabels: { color: 'rgba(226, 232, 240, 0.8)' },
                                    suggestedMin: 0,
                                    suggestedMax: 100,
                                  },
                                },
                                plugins: { legend: { display: !1 } },
                                animation: { duration: 900 },
                              },
                            }),
                          }),
                          N.jsx('div', {
                            className: 'h-64',
                            children: N.jsx(aT, {
                              data: w.barData,
                              options: {
                                scales: {
                                  y: {
                                    grid: { color: 'rgba(148, 163, 184, 0.2)' },
                                    ticks: { color: 'rgba(226, 232, 240, 0.7)' },
                                    suggestedMin: 0,
                                    suggestedMax: 100,
                                  },
                                  x: { ticks: { color: 'rgba(226, 232, 240, 0.7)' } },
                                },
                                plugins: { legend: { display: !1 } },
                                animation: { duration: 900 },
                              },
                            }),
                          }),
                        ],
                      }),
                      N.jsx('div', {
                        className: 'mt-6 grid gap-4 md:grid-cols-2',
                        children: [
                          {
                            key: 'N',
                            label: 'Narcissism (N)',
                            copy: 'Elevated focus on visibility, status control, and perceived centrality in group dynamics.',
                          },
                          {
                            key: 'M',
                            label: 'Machiavellianism (M)',
                            copy: 'Strategic, long-horizon planning with emphasis on leverage, timing, and advantage.',
                          },
                          {
                            key: 'P',
                            label: 'Psychopathy (P)',
                            copy: 'Emotional detachment, intensity, and willingness to prioritize outcomes over social cost.',
                          },
                          {
                            key: 'MD',
                            label: 'Manipulation Doctrine (MD)',
                            copy: 'Preferred influence tactics, persuasion confidence, and group-shaping behaviors.',
                          },
                        ].map((E) =>
                          N.jsxs(
                            'div',
                            {
                              className: 'rounded-xl border border-white/10 bg-slate-900/60 p-4',
                              children: [
                                N.jsx('p', {
                                  className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                                  children: E.label,
                                }),
                                N.jsx('p', {
                                  className: 'mt-2 text-sm text-slate-300',
                                  children: E.copy,
                                }),
                              ],
                            },
                            E.key
                          )
                        ),
                      }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex items-center gap-3',
                        children: [
                          i.maskFlags.length > 0
                            ? N.jsx(of, { size: 22, className: 'text-amber-300' })
                            : N.jsx(q6, { size: 22, className: 'text-emerald-300' }),
                          N.jsxs('div', {
                            children: [
                              N.jsx('h2', {
                                className: 'text-xl font-semibold',
                                children: 'Integrity & Masking',
                              }),
                              N.jsx('p', {
                                className: 'text-sm text-slate-400',
                                children:
                                  'Flags highlight defensive responding, contradictions, and halo effects.',
                              }),
                            ],
                          }),
                        ],
                      }),
                      N.jsxs('div', {
                        className: 'mt-4 space-y-2',
                        children: [
                          i.maskFlags.length === 0 &&
                            N.jsx('p', {
                              className: 'text-sm text-slate-400',
                              children: 'No integrity flags detected.',
                            }),
                          i.maskFlags.map((E) =>
                            N.jsxs(
                              'div',
                              {
                                className:
                                  'rounded-xl border border-amber-400/30 bg-amber-500/10 p-3 text-sm text-amber-100',
                                children: [
                                  N.jsx('p', {
                                    className: 'text-sm font-semibold uppercase tracking-[0.2em]',
                                    children: E,
                                  }),
                                  N.jsx('p', {
                                    className: 'mt-1 text-xs text-amber-200',
                                    children: eR[E] ?? 'Integrity signal observed.',
                                  }),
                                ],
                              },
                              E
                            )
                          ),
                        ],
                      }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsxs('div', {
                        className: 'flex items-center gap-3',
                        children: [
                          N.jsx(Vl, { size: 20, className: 'text-slate-300' }),
                          N.jsxs('div', {
                            children: [
                              N.jsx('h2', {
                                className: 'text-xl font-semibold',
                                children: 'Response Time Analysis',
                              }),
                              N.jsx('p', {
                                className: 'text-sm text-slate-400',
                                children: 'Highlights rapid responses under 450ms.',
                              }),
                            ],
                          }),
                        ],
                      }),
                      N.jsx('div', {
                        className: 'mt-6 h-64',
                        children: N.jsx(oT, {
                          data: w.lineData,
                          options: {
                            scales: {
                              y: {
                                ticks: { color: 'rgba(226, 232, 240, 0.7)' },
                                grid: { color: 'rgba(148, 163, 184, 0.2)' },
                              },
                              x: { ticks: { color: 'rgba(226, 232, 240, 0.7)' } },
                            },
                            plugins: { legend: { display: !1 } },
                            animation: { duration: 900 },
                          },
                        }),
                      }),
                    ],
                  }),
                  N.jsxs('section', {
                    className: 'glass-panel p-6',
                    children: [
                      N.jsx('h2', {
                        className: 'text-xl font-semibold',
                        children: 'Full Answer Breakdown',
                      }),
                      N.jsx('p', {
                        className: 'text-sm text-slate-400',
                        children: 'Detailed view of each response, timing, and trait impact.',
                      }),
                      N.jsx('div', {
                        className: 'mt-6 space-y-4',
                        children: af.map((E) => {
                          const S = y.get(E.id)
                          if (!S) return null
                          const k = E.reverse ? 3 - S.answer : S.answer,
                            P = `${E.trait} +${k}`,
                            I = S.rtMs < 450
                          return N.jsxs(
                            'div',
                            {
                              className: 'rounded-2xl border border-white/10 bg-slate-900/60 p-4',
                              children: [
                                N.jsxs('div', {
                                  className: 'flex flex-wrap items-start justify-between gap-3',
                                  children: [
                                    N.jsxs('div', {
                                      children: [
                                        N.jsxs('p', {
                                          className:
                                            'text-xs uppercase tracking-[0.3em] text-slate-400',
                                          children: ['Q', E.id],
                                        }),
                                        N.jsx('h3', {
                                          className: 'mt-1 text-lg font-semibold text-slate-50',
                                          children: E.text,
                                        }),
                                      ],
                                    }),
                                    N.jsxs('div', {
                                      className: 'flex gap-2',
                                      children: [
                                        E.lieTrap &&
                                          N.jsxs('span', {
                                            className:
                                              'badge gap-2 border border-amber-400/40 bg-amber-500/10 text-amber-200',
                                            children: [N.jsx(of, { size: 12 }), 'Lie Trap'],
                                          }),
                                        E.safetyTrigger &&
                                          N.jsxs('span', {
                                            className:
                                              'badge gap-2 border border-rose-400/40 bg-rose-500/10 text-rose-200',
                                            children: [N.jsx(Qc, { size: 12 }), 'Safety Trigger'],
                                          }),
                                      ],
                                    }),
                                  ],
                                }),
                                N.jsxs('div', {
                                  className: 'mt-3 flex flex-wrap gap-3 text-xs text-slate-400',
                                  children: [
                                    N.jsxs('span', { children: ['Answer: ', S.answer] }),
                                    N.jsxs('span', { children: ['RT: ', S.rtMs, 'ms'] }),
                                    N.jsxs('span', { children: ['Impact: ', P] }),
                                    I &&
                                      N.jsx('span', {
                                        className: 'text-rose-300',
                                        children: 'Fast response',
                                      }),
                                  ],
                                }),
                                N.jsxs('p', {
                                  className: 'mt-3 text-sm text-slate-300',
                                  children: [
                                    'This response suggests a ',
                                    E.trait,
                                    '-aligned behavior with a measured intensity of ',
                                    k,
                                    ' on the internal scale. The pacing indicates',
                                    ' ',
                                    I ? 'defensive' : 'deliberate',
                                    ' engagement.',
                                  ],
                                }),
                              ],
                            },
                            E.id
                          )
                        }),
                      }),
                    ],
                  }),
                ],
              }),
          ],
        })
      : N.jsxs('div', {
          className: 'mx-auto w-full max-w-3xl px-6 py-16',
          children: [
            N.jsx(_T, { onUnlock: () => t(!0) }),
            N.jsx('p', {
              className: 'mt-4 text-xs text-slate-500',
              children:
                'Decoder access is restricted. Unlocking stores a session flag in the browser only.',
            }),
          ],
        })
  },
  nR = () =>
    N.jsx('footer', {
      className: 'mt-16 border-t border-white/5 bg-slate-950/70',
      children: N.jsxs('div', {
        className: 'mx-auto flex w-full max-w-6xl flex-col gap-10 px-6 py-12',
        children: [
          N.jsxs('div', {
            className: 'grid gap-8 lg:grid-cols-[1.2fr_0.9fr_0.9fr]',
            children: [
              N.jsxs('div', {
                className: 'space-y-4',
                children: [
                  N.jsxs('div', {
                    className: 'flex items-center gap-3',
                    children: [
                      N.jsx('span', {
                        className:
                          'flex h-10 w-10 items-center justify-center rounded-2xl border border-emerald-400/30 bg-emerald-500/10 text-emerald-200',
                        children: N.jsx(Qo, { size: 18 }),
                      }),
                      N.jsxs('div', {
                        children: [
                          N.jsx('p', {
                            className: 'text-xs uppercase tracking-[0.3em] text-emerald-200',
                            children: 'Vibe Prism',
                          }),
                          N.jsx('p', {
                            className: 'text-sm font-semibold text-slate-50',
                            children: 'Nexus Who Intelligence Lab',
                          }),
                        ],
                      }),
                    ],
                  }),
                  N.jsx('p', {
                    className: 'text-sm text-slate-400',
                    children:
                      'Built for insight-forward teams and creators who want to understand the energy they bring into every room. Private by design, calm by default.',
                  }),
                ],
              }),
              N.jsxs('div', {
                className: 'space-y-3',
                children: [
                  N.jsx('p', {
                    className: 'text-xs uppercase tracking-[0.3em] text-slate-400',
                    children: 'Core Pillars',
                  }),
                  N.jsxs('ul', {
                    className: 'space-y-2 text-sm text-slate-300',
                    children: [
                      N.jsxs('li', {
                        className: 'flex items-center gap-2',
                        children: [
                          N.jsx(ep, { size: 16, className: 'text-emerald-300' }),
                          'Momentum-aware personality mapping',
                        ],
                      }),
                      N.jsxs('li', {
                        className: 'flex items-center gap-2',
                        children: [
                          N.jsx(J0, { size: 16, className: 'text-emerald-300' }),
                          'Precision archetypes with clear next steps',
                        ],
                      }),
                      N.jsxs('li', {
                        className: 'flex items-center gap-2',
                        children: [
                          N.jsx(Q6, { size: 16, className: 'text-emerald-300' }),
                          'Integrity signals baked into every score',
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              N.jsxs('div', {
                className: 'glass-panel p-5',
                children: [
                  N.jsx('p', {
                    className: 'text-sm font-semibold text-slate-100',
                    children: 'Ready to capture your profile?',
                  }),
                  N.jsx('p', {
                    className: 'mt-2 text-xs text-slate-400',
                    children: 'Launch the quiz, lock in your token, and decode whenever you want.',
                  }),
                  N.jsxs('div', {
                    className: 'mt-4 flex flex-wrap gap-3',
                    children: [
                      N.jsx(er, {
                        to: '/quiz',
                        className: 'button-primary',
                        children: 'Start the quiz',
                      }),
                      N.jsx(er, {
                        to: '/restore',
                        className: 'button-secondary',
                        children: 'Decode token',
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
          N.jsxs('div', {
            className: 'flex flex-wrap items-center justify-between gap-3 text-xs text-slate-500',
            children: [
              N.jsx('span', {
                children: ' 2026 Vibe Prism  Nexus Who Minisite. All rights reserved.',
              }),
              N.jsx('span', {
                children: 'Encrypted locally. Nothing leaves your device without permission.',
              }),
            ],
          }),
        ],
      }),
    }),
  rR = [
    { label: 'Overview', to: '/' },
    { label: 'Quiz', to: '/quiz' },
    { label: 'Results', to: '/result' },
    { label: 'Restore', to: '/restore' },
  ],
  iR = () =>
    N.jsx('header', {
      className: 'sticky top-0 z-40 border-b border-white/5 bg-slate-950/70 backdrop-blur',
      children: N.jsxs('div', {
        className: 'mx-auto flex w-full max-w-6xl items-center justify-between px-6 py-4',
        children: [
          N.jsxs(er, {
            to: '/',
            className: 'flex items-center gap-3',
            children: [
              N.jsx('span', {
                className:
                  'flex h-10 w-10 items-center justify-center rounded-2xl border border-emerald-400/30 bg-emerald-500/10 text-emerald-200',
                children: N.jsx(Qo, { size: 18 }),
              }),
              N.jsxs('div', {
                children: [
                  N.jsx('p', {
                    className: 'text-xs uppercase tracking-[0.3em] text-emerald-200',
                    children: 'Vibe Prism',
                  }),
                  N.jsx('p', {
                    className: 'text-sm font-semibold text-slate-50',
                    children: 'Nexus Who Minisite',
                  }),
                ],
              }),
            ],
          }),
          N.jsx('nav', {
            className: 'hidden items-center gap-6 text-sm text-slate-300 md:flex',
            children: rR.map((e) =>
              N.jsx(
                gC,
                {
                  to: e.to,
                  className: ({ isActive: t }) => `nav-link ${t ? 'nav-link-active' : ''}`,
                  children: e.label,
                },
                e.to
              )
            ),
          }),
          N.jsx('div', {
            className: 'flex items-center gap-3',
            children: N.jsx(er, {
              to: '/quiz',
              className: 'button-primary hidden sm:inline-flex',
              children: 'Start the quiz',
            }),
          }),
        ],
      }),
    }),
  sR = {
    initial: { opacity: 0, y: 16 },
    animate: { opacity: 1, y: 0, transition: { duration: 0.4 } },
    exit: { opacity: 0, y: -12, transition: { duration: 0.2 } },
  },
  oR = () =>
    N.jsxs('div', {
      className:
        'flex min-h-screen flex-col bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 text-slate-100',
      children: [
        N.jsx(iR, {}),
        N.jsx(qn.main, {
          variants: sR,
          initial: 'initial',
          animate: 'animate',
          exit: 'exit',
          className: 'flex-1',
          children: N.jsxs(iC, {
            children: [
              N.jsx(no, { path: '/', element: N.jsx(sk, {}) }),
              N.jsx(no, { path: '/quiz', element: N.jsx(yk, {}) }),
              N.jsx(no, { path: '/result', element: N.jsx(CT, {}) }),
              N.jsx(no, { path: '/restore', element: N.jsx(tR, {}) }),
              N.jsx(no, { path: '*', element: N.jsx(nC, { to: '/', replace: !0 }) }),
            ],
          }),
        }),
        N.jsx(nR, {}),
      ],
    }),
  ab = document.getElementById('root')
if (!ab) throw new Error('Root container missing')
cw(ab).render(N.jsx(A.StrictMode, { children: N.jsx(dC, { children: N.jsx(oR, {}) }) }))
